// Generated code!
#![allow(unused_comparisons, unreachable_patterns)]
#![allow(clippy::let_and_return, clippy::eq_op)]
#![allow(clippy::excessive_precision, clippy::manual_range_contains, clippy::absurd_extreme_comparisons)]
#![deny(clippy::arithmetic_side_effects)]

//! Message definitions from file `"hyundai_kia_generic.dbc"`
//!
//! - Version: `Version("")`

use core::ops::BitOr;
use bitvec::prelude::*;
#[cfg(feature = "arb")]
use arbitrary::{Arbitrary, Unstructured};

/// All messages
#[derive(Clone)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Messages {
    /// ODS13
    Ods13(Ods13),
    /// ODS12
    Ods12(Ods12),
    /// ODS11
    Ods11(Ods11),
    /// ECS12
    Ecs12(Ecs12),
    /// SPAS12
    Spas12(Spas12),
    /// CLU11
    Clu11(Clu11),
    /// Sign_Detection
    SignDetection(SignDetection),
    /// TMU_GW_PE_01
    TmuGwPe01(TmuGwPe01),
    /// HU_DATC_PE_00
    HuDatcPe00(HuDatcPe00),
    /// HU_DATC_E_02
    HuDatcE02(HuDatcE02),
    /// EMS21
    Ems21(Ems21),
    /// GW_Warning_PE
    GwWarningPe(GwWarningPe),
    /// CAL_SAS11
    CalSas11(CalSas11),
    /// CLU12
    Clu12(Clu12),
    /// SAS11
    Sas11(Sas11),
    /// ACU12
    Acu12(Acu12),
    /// ACU11
    Acu11(Acu11),
    /// AHLS11
    Ahls11(Ahls11),
    /// PSB11
    Psb11(Psb11),
    /// TCS13
    Tcs13(Tcs13),
    /// TPMS11
    Tpms11(Tpms11),
    /// TCS12
    Tcs12(Tcs12),
    /// EMS19
    Ems19(Ems19),
    /// AFLS11
    Afls11(Afls11),
    /// SPAS11
    Spas11(Spas11),
    /// EPB11
    Epb11(Epb11),
    /// EMS_H12
    EmsH12(EmsH12),
    /// LCA11
    Lca11(Lca11),
    /// ABS11
    Abs11(Abs11),
    /// WHL_PUL11
    WhlPul11(WhlPul11),
    /// TMU11
    Tmu11(Tmu11),
    /// WHL_SPD11
    WhlSpd11(WhlSpd11),
    /// EVP11
    Evp11(Evp11),
    /// AAF11
    Aaf11(Aaf11),
    /// EMS17
    Ems17(Ems17),
    /// REA11
    Rea11(Rea11),
    /// CUBIS11
    Cubis11(Cubis11),
    /// FATC11
    Fatc11(Fatc11),
    /// EMS_DCT12
    EmsDct12(EmsDct12),
    /// MDPS11
    Mdps11(Mdps11),
    /// DI_BOX13
    DiBox13(DiBox13),
    /// EMS13
    Ems13(Ems13),
    /// EMS_DCT11
    EmsDct11(EmsDct11),
    /// HU_MON_PE_01
    HuMonPe01(HuMonPe01),
    /// CGW5
    Cgw5(Cgw5),
    /// ESP11
    Esp11(Esp11),
    /// HU_AVM_E_00
    HuAvmE00(HuAvmE00),
    /// HU_AVM_E_01
    HuAvmE01(HuAvmE01),
    /// OPI11
    Opi11(Opi11),
    /// LPI11
    Lpi11(Lpi11),
    /// VSM11
    Vsm11(Vsm11),
    /// PGS_HU_PE_01
    PgsHuPe01(PgsHuPe01),
    /// TCU_DCT13
    TcuDct13(TcuDct13),
    /// HUD11
    Hud11(Hud11),
    /// EMS16
    Ems16(Ems16),
    /// AVM_HU_PE_00
    AvmHuPe00(AvmHuPe00),
    /// HU_AVM_PE_00
    HuAvmPe00(HuAvmPe00),
    /// CGW4
    Cgw4(Cgw4),
    /// EngFrzFrm12
    EngFrzFrm12(EngFrzFrm12),
    /// EngFrzFrm11
    EngFrzFrm11(EngFrzFrm11),
    /// FPCM11
    Fpcm11(Fpcm11),
    /// LVR12
    Lvr12(Lvr12),
    /// LVR11
    Lvr11(Lvr11),
    /// CGW2
    Cgw2(Cgw2),
    /// TCS11
    Tcs11(Tcs11),
    /// SNV11
    Snv11(Snv11),
    /// MDPS12
    Mdps12(Mdps12),
    /// IAP11
    Iap11(Iap11),
    /// TCU_DCT14
    TcuDct14(TcuDct14),
    /// BAT11
    Bat11(Bat11),
    /// EMS15
    Ems15(Ems15),
    /// DI_BOX12
    DiBox12(DiBox12),
    /// EMS14
    Ems14(Ems14),
    /// DATC11
    Datc11(Datc11),
    /// DATC13
    Datc13(Datc13),
    /// DATC12
    Datc12(Datc12),
    /// CGW1
    Cgw1(Cgw1),
    /// DATC14
    Datc14(Datc14),
    /// LKAS11
    Lkas11(Lkas11),
    /// LKAS12
    Lkas12(Lkas12),
    /// TMU_GW_E_01
    TmuGwE01(TmuGwE01),
    /// PAS11
    Pas11(Pas11),
    /// EMS18
    Ems18(Ems18),
    /// CLU15
    Clu15(Clu15),
    /// _4WD13
    X4wd13(X4wd13),
    /// _4WD12
    X4wd12(X4wd12),
    /// EMS12
    Ems12(Ems12),
    /// _4WD11
    X4wd11(X4wd11),
    /// HU_GW_E_01
    HuGwE01(HuGwE01),
    /// HU_GW_E_00
    HuGwE00(HuGwE00),
    /// GW_HU_E_01
    GwHuE01(GwHuE01),
    /// GW_HU_E_00
    GwHuE00(GwHuE00),
    /// GW_SWRC_PE
    GwSwrcPe(GwSwrcPe),
    /// GW_IPM_PE_1
    GwIpmPe1(GwIpmPe1),
    /// SCC12
    Scc12(Scc12),
    /// GW_DDM_PE
    GwDdmPe(GwDdmPe),
    /// SCC11
    Scc11(Scc11),
    /// CGW3
    Cgw3(Cgw3),
    /// ESP12
    Esp12(Esp12),
    /// CLU16
    Clu16(Clu16),
    /// EMS11
    Ems11(Ems11),
    /// CLU14
    Clu14(Clu14),
    /// TCU13
    Tcu13(Tcu13),
    /// TCU12
    Tcu12(Tcu12),
    /// TCU11
    Tcu11(Tcu11),
    /// ACU13
    Acu13(Acu13),
    /// CGW_USM1
    CgwUsm1(CgwUsm1),
    /// CLU13
    Clu13(Clu13),
    /// SCC13
    Scc13(Scc13),
    /// TCS15
    Tcs15(Tcs15),
    /// TCU14
    Tcu14(Tcu14),
    /// ECS11
    Ecs11(Ecs11),
    /// CLU_CFG11
    CluCfg11(CluCfg11),
    /// ACU14
    Acu14(Acu14),
    /// EMS20
    Ems20(Ems20),
    /// FCA11
    Fca11(Fca11),
    /// HDA11_MFC
    Hda11Mfc(Hda11Mfc),
    /// FCA12
    Fca12(Fca12),
    /// FRT_RADAR11
    FrtRadar11(FrtRadar11),
    /// SCC14
    Scc14(Scc14),
    /// LFAHDA_MFC
    LfahdaMfc(LfahdaMfc),
    /// BCM_PO_11
    BcmPo11(BcmPo11),
    /// LABEL11
    Label11(Label11),
    /// WHL_SPD12_FS
    WhlSpd12Fs(WhlSpd12Fs),
    /// WHL_SPD13_FS
    WhlSpd13Fs(WhlSpd13Fs),
    /// ADAS_PRK_11
    AdasPrk11(AdasPrk11),
    /// ELECT_GEAR
    ElectGear(ElectGear),
    /// E_EMS11
    EEms11(EEms11),
    /// EV_PC6
    EvPc6(EvPc6),
    /// EV_PC2
    EvPc2(EvPc2),
    /// EV_PC10
    EvPc10(EvPc10),
    /// RSPA11
    Rspa11(Rspa11),
    /// S_MDPS11
    SMdps11(SMdps11),
    /// S_MDPS12
    SMdps12(SMdps12),
    /// AHB1
    Ahb1(Ahb1),
    /// MFC_4a7
    Mfc4a7(Mfc4a7),
    /// BCA11
    Bca11(Bca11),
    /// P_STS
    PSts(PSts),
    /// YRS11
    Yrs11(Yrs11),
    /// YRS12
    Yrs12(Yrs12),
    /// YRS13
    Yrs13(Yrs13),
    /// EMS_366
    Ems366(Ems366),
    /// M_356
    M356(M356),
    /// ICM_412h
    Icm412h(Icm412h),
    /// Navi_HU
    NaviHu(NaviHu),
}

impl Messages {
    /// Read message from CAN frame
    #[inline(never)]
    pub fn from_can_message(id: u32, payload: &[u8]) -> Result<Self, CanError> {
        
        let res = match id {
            1532 => Messages::Ods13(Ods13::try_from(payload)?),
            1531 => Messages::Ods12(Ods12::try_from(payload)?),
            1530 => Messages::Ods11(Ods11::try_from(payload)?),
            1017 => Messages::Ecs12(Ecs12::try_from(payload)?),
            1268 => Messages::Spas12(Spas12::try_from(payload)?),
            1265 => Messages::Clu11(Clu11::try_from(payload)?),
            1260 => Messages::SignDetection(SignDetection::try_from(payload)?),
            1492 => Messages::TmuGwPe01(TmuGwPe01::try_from(payload)?),
            1491 => Messages::HuDatcPe00(HuDatcPe00::try_from(payload)?),
            1490 => Messages::HuDatcE02(HuDatcE02::try_from(payload)?),
            1479 => Messages::Ems21(Ems21::try_from(payload)?),
            1472 => Messages::GwWarningPe(GwWarningPe::try_from(payload)?),
            1984 => Messages::CalSas11(CalSas11::try_from(payload)?),
            1456 => Messages::Clu12(Clu12::try_from(payload)?),
            688 => Messages::Sas11(Sas11::try_from(payload)?),
            1441 => Messages::Acu12(Acu12::try_from(payload)?),
            1440 => Messages::Acu11(Acu11::try_from(payload)?),
            1437 => Messages::Ahls11(Ahls11::try_from(payload)?),
            1434 => Messages::Psb11(Psb11::try_from(payload)?),
            916 => Messages::Tcs13(Tcs13::try_from(payload)?),
            1427 => Messages::Tpms11(Tpms11::try_from(payload)?),
            915 => Messages::Tcs12(Tcs12::try_from(payload)?),
            1170 => Messages::Ems19(Ems19::try_from(payload)?),
            1425 => Messages::Afls11(Afls11::try_from(payload)?),
            912 => Messages::Spas11(Spas11::try_from(payload)?),
            1168 => Messages::Epb11(Epb11::try_from(payload)?),
            399 => Messages::EmsH12(EmsH12::try_from(payload)?),
            1419 => Messages::Lca11(Lca11::try_from(payload)?),
            906 => Messages::Abs11(Abs11::try_from(payload)?),
            903 => Messages::WhlPul11(WhlPul11::try_from(payload)?),
            1415 => Messages::Tmu11(Tmu11::try_from(payload)?),
            902 => Messages::WhlSpd11(WhlSpd11::try_from(payload)?),
            1414 => Messages::Evp11(Evp11::try_from(payload)?),
            1412 => Messages::Aaf11(Aaf11::try_from(payload)?),
            900 => Messages::Ems17(Ems17::try_from(payload)?),
            387 => Messages::Rea11(Rea11::try_from(payload)?),
            1411 => Messages::Cubis11(Cubis11::try_from(payload)?),
            899 => Messages::Fatc11(Fatc11::try_from(payload)?),
            129 => Messages::EmsDct12(EmsDct12::try_from(payload)?),
            897 => Messages::Mdps11(Mdps11::try_from(payload)?),
            896 => Messages::DiBox13(DiBox13::try_from(payload)?),
            640 => Messages::Ems13(Ems13::try_from(payload)?),
            128 => Messages::EmsDct11(EmsDct11::try_from(payload)?),
            1407 => Messages::HuMonPe01(HuMonPe01::try_from(payload)?),
            127 => Messages::Cgw5(Cgw5::try_from(payload)?),
            1151 => Messages::Esp11(Esp11::try_from(payload)?),
            1397 => Messages::HuAvmE00(HuAvmE00::try_from(payload)?),
            1395 => Messages::HuAvmE01(HuAvmE01::try_from(payload)?),
            1393 => Messages::Opi11(Opi11::try_from(payload)?),
            625 => Messages::Lpi11(Lpi11::try_from(payload)?),
            356 => Messages::Vsm11(Vsm11::try_from(payload)?),
            1379 => Messages::PgsHuPe01(PgsHuPe01::try_from(payload)?),
            354 => Messages::TcuDct13(TcuDct13::try_from(payload)?),
            1378 => Messages::Hud11(Hud11::try_from(payload)?),
            608 => Messages::Ems16(Ems16::try_from(payload)?),
            1371 => Messages::AvmHuPe00(AvmHuPe00::try_from(payload)?),
            1370 => Messages::HuAvmPe00(HuAvmPe00::try_from(payload)?),
            1369 => Messages::Cgw4(Cgw4::try_from(payload)?),
            1367 => Messages::EngFrzFrm12(EngFrzFrm12::try_from(payload)?),
            1366 => Messages::EngFrzFrm11(EngFrzFrm11::try_from(payload)?),
            1365 => Messages::Fpcm11(Fpcm11::try_from(payload)?),
            871 => Messages::Lvr12(Lvr12::try_from(payload)?),
            872 => Messages::Lvr11(Lvr11::try_from(payload)?),
            1363 => Messages::Cgw2(Cgw2::try_from(payload)?),
            339 => Messages::Tcs11(Tcs11::try_from(payload)?),
            1362 => Messages::Snv11(Snv11::try_from(payload)?),
            593 => Messages::Mdps12(Mdps12::try_from(payload)?),
            1360 => Messages::Iap11(Iap11::try_from(payload)?),
            1356 => Messages::TcuDct14(TcuDct14::try_from(payload)?),
            1353 => Messages::Bat11(Bat11::try_from(payload)?),
            1351 => Messages::Ems15(Ems15::try_from(payload)?),
            1350 => Messages::DiBox12(DiBox12::try_from(payload)?),
            1349 => Messages::Ems14(Ems14::try_from(payload)?),
            68 => Messages::Datc11(Datc11::try_from(payload)?),
            67 => Messages::Datc13(Datc13::try_from(payload)?),
            66 => Messages::Datc12(Datc12::try_from(payload)?),
            1345 => Messages::Cgw1(Cgw1::try_from(payload)?),
            64 => Messages::Datc14(Datc14::try_from(payload)?),
            832 => Messages::Lkas11(Lkas11::try_from(payload)?),
            1342 => Messages::Lkas12(Lkas12::try_from(payload)?),
            1338 => Messages::TmuGwE01(TmuGwE01::try_from(payload)?),
            1078 => Messages::Pas11(Pas11::try_from(payload)?),
            48 => Messages::Ems18(Ems18::try_from(payload)?),
            1322 => Messages::Clu15(Clu15::try_from(payload)?),
            1066 => Messages::X4wd13(X4wd13::try_from(payload)?),
            1065 => Messages::X4wd12(X4wd12::try_from(payload)?),
            809 => Messages::Ems12(Ems12::try_from(payload)?),
            1064 => Messages::X4wd11(X4wd11::try_from(payload)?),
            1319 => Messages::HuGwE01(HuGwE01::try_from(payload)?),
            1318 => Messages::HuGwE00(HuGwE00::try_from(payload)?),
            1317 => Messages::GwHuE01(GwHuE01::try_from(payload)?),
            1316 => Messages::GwHuE00(GwHuE00::try_from(payload)?),
            1315 => Messages::GwSwrcPe(GwSwrcPe::try_from(payload)?),
            1314 => Messages::GwIpmPe1(GwIpmPe1::try_from(payload)?),
            1057 => Messages::Scc12(Scc12::try_from(payload)?),
            1313 => Messages::GwDdmPe(GwDdmPe::try_from(payload)?),
            1056 => Messages::Scc11(Scc11::try_from(payload)?),
            1312 => Messages::Cgw3(Cgw3::try_from(payload)?),
            544 => Messages::Esp12(Esp12::try_from(payload)?),
            1307 => Messages::Clu16(Clu16::try_from(payload)?),
            790 => Messages::Ems11(Ems11::try_from(payload)?),
            1301 => Messages::Clu14(Clu14::try_from(payload)?),
            275 => Messages::Tcu13(Tcu13::try_from(payload)?),
            274 => Messages::Tcu12(Tcu12::try_from(payload)?),
            273 => Messages::Tcu11(Tcu11::try_from(payload)?),
            16 => Messages::Acu13(Acu13::try_from(payload)?),
            1040 => Messages::CgwUsm1(CgwUsm1::try_from(payload)?),
            1292 => Messages::Clu13(Clu13::try_from(payload)?),
            1290 => Messages::Scc13(Scc13::try_from(payload)?),
            1287 => Messages::Tcs15(Tcs15::try_from(payload)?),
            1282 => Messages::Tcu14(Tcu14::try_from(payload)?),
            1281 => Messages::Ecs11(Ecs11::try_from(payload)?),
            1024 => Messages::CluCfg11(CluCfg11::try_from(payload)?),
            1280 => Messages::Acu14(Acu14::try_from(payload)?),
            512 => Messages::Ems20(Ems20::try_from(payload)?),
            909 => Messages::Fca11(Fca11::try_from(payload)?),
            1156 => Messages::Hda11Mfc(Hda11Mfc::try_from(payload)?),
            1155 => Messages::Fca12(Fca12::try_from(payload)?),
            1186 => Messages::FrtRadar11(FrtRadar11::try_from(payload)?),
            905 => Messages::Scc14(Scc14::try_from(payload)?),
            1157 => Messages::LfahdaMfc(LfahdaMfc::try_from(payload)?),
            913 => Messages::BcmPo11(BcmPo11::try_from(payload)?),
            1426 => Messages::Label11(Label11::try_from(payload)?),
            910 => Messages::WhlSpd12Fs(WhlSpd12Fs::try_from(payload)?),
            911 => Messages::WhlSpd13Fs(WhlSpd13Fs::try_from(payload)?),
            865 => Messages::AdasPrk11(AdasPrk11::try_from(payload)?),
            882 => Messages::ElectGear(ElectGear::try_from(payload)?),
            881 => Messages::EEms11(EEms11::try_from(payload)?),
            1355 => Messages::EvPc6(EvPc6::try_from(payload)?),
            1430 => Messages::EvPc2(EvPc2::try_from(payload)?),
            1535 => Messages::EvPc10(EvPc10::try_from(payload)?),
            908 => Messages::Rspa11(Rspa11::try_from(payload)?),
            914 => Messages::SMdps11(SMdps11::try_from(payload)?),
            357 => Messages::SMdps12(SMdps12::try_from(payload)?),
            352 => Messages::Ahb1(Ahb1::try_from(payload)?),
            1191 => Messages::Mfc4a7(Mfc4a7::try_from(payload)?),
            1162 => Messages::Bca11(Bca11::try_from(payload)?),
            1136 => Messages::PSts(PSts::try_from(payload)?),
            304 => Messages::Yrs11(Yrs11::try_from(payload)?),
            320 => Messages::Yrs12(Yrs12::try_from(payload)?),
            1173 => Messages::Yrs13(Yrs13::try_from(payload)?),
            870 => Messages::Ems366(Ems366::try_from(payload)?),
            854 => Messages::M356(M356::try_from(payload)?),
            1042 => Messages::Icm412h(Icm412h::try_from(payload)?),
            1348 => Messages::NaviHu(NaviHu::try_from(payload)?),
            n => return Err(CanError::UnknownMessageId(n)),
        };
        Ok(res)
    }
}

/// ODS13
///
/// - ID: 1532 (0x5fc)
/// - Size: 5 bytes
/// - Transmitter: ODS
#[derive(Clone, Copy)]
pub struct Ods13 {
    raw: [u8; 5],
}

impl Ods13 {
    pub const MESSAGE_ID: u32 = 1532;
    
    pub const CR_ODS_ID_MIN: u8 = 0_u8;
    pub const CR_ODS_ID_MAX: u8 = 255_u8;
    pub const CR_ODS_CHKSUM_H_MIN: u8 = 0_u8;
    pub const CR_ODS_CHKSUM_H_MAX: u8 = 255_u8;
    pub const CR_ODS_CHKSUM_L_MIN: u8 = 0_u8;
    pub const CR_ODS_CHKSUM_L_MAX: u8 = 255_u8;
    pub const CR_ODS_ROM_ID_H_MIN: u8 = 0_u8;
    pub const CR_ODS_ROM_ID_H_MAX: u8 = 255_u8;
    pub const CR_ODS_ROM_ID_L_MIN: u8 = 0_u8;
    pub const CR_ODS_ROM_ID_L_MAX: u8 = 255_u8;
    
    /// Construct new ODS13 from values
    pub fn new(cr_ods_id: u8, cr_ods_chksum_h: u8, cr_ods_chksum_l: u8, cr_ods_rom_id_h: u8, cr_ods_rom_id_l: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 5] };
        res.set_cr_ods_id(cr_ods_id)?;
        res.set_cr_ods_chksum_h(cr_ods_chksum_h)?;
        res.set_cr_ods_chksum_l(cr_ods_chksum_l)?;
        res.set_cr_ods_rom_id_h(cr_ods_rom_id_h)?;
        res.set_cr_ods_rom_id_l(cr_ods_rom_id_l)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 5] {
        &self.raw
    }
    
    /// CR_Ods_ID
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cr_ods_id(&self) -> u8 {
        self.cr_ods_id_raw()
    }
    
    /// Get raw value of CR_Ods_ID
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ods_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Ods_ID
    #[inline(always)]
    pub fn set_cr_ods_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1532 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CR_Ods_Chksum_H
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Dummy
    #[inline(always)]
    pub fn cr_ods_chksum_h(&self) -> u8 {
        self.cr_ods_chksum_h_raw()
    }
    
    /// Get raw value of CR_Ods_Chksum_H
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ods_chksum_h_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Ods_Chksum_H
    #[inline(always)]
    pub fn set_cr_ods_chksum_h(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1532 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CR_Ods_Chksum_L
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Dummy
    #[inline(always)]
    pub fn cr_ods_chksum_l(&self) -> u8 {
        self.cr_ods_chksum_l_raw()
    }
    
    /// Get raw value of CR_Ods_Chksum_L
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ods_chksum_l_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Ods_Chksum_L
    #[inline(always)]
    pub fn set_cr_ods_chksum_l(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1532 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// CR_Ods_RomID_H
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Dummy
    #[inline(always)]
    pub fn cr_ods_rom_id_h(&self) -> u8 {
        self.cr_ods_rom_id_h_raw()
    }
    
    /// Get raw value of CR_Ods_RomID_H
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ods_rom_id_h_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Ods_RomID_H
    #[inline(always)]
    pub fn set_cr_ods_rom_id_h(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1532 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CR_Ods_RomID_L
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Dummy
    #[inline(always)]
    pub fn cr_ods_rom_id_l(&self) -> u8 {
        self.cr_ods_rom_id_l_raw()
    }
    
    /// Get raw value of CR_Ods_RomID_L
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ods_rom_id_l_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Ods_RomID_L
    #[inline(always)]
    pub fn set_cr_ods_rom_id_l(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1532 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ods13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 5 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 5];
        raw.copy_from_slice(&payload[..5]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ods13 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ods13")
                .field("cr_ods_id", &self.cr_ods_id())
                .field("cr_ods_chksum_h", &self.cr_ods_chksum_h())
                .field("cr_ods_chksum_l", &self.cr_ods_chksum_l())
                .field("cr_ods_rom_id_h", &self.cr_ods_rom_id_h())
                .field("cr_ods_rom_id_l", &self.cr_ods_rom_id_l())
            .finish()
        } else {
            f.debug_tuple("Ods13").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ods13 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cr_ods_id = u.int_in_range(0..=255)?;
        let cr_ods_chksum_h = u.int_in_range(0..=255)?;
        let cr_ods_chksum_l = u.int_in_range(0..=255)?;
        let cr_ods_rom_id_h = u.int_in_range(0..=255)?;
        let cr_ods_rom_id_l = u.int_in_range(0..=255)?;
        Ods13::new(cr_ods_id,cr_ods_chksum_h,cr_ods_chksum_l,cr_ods_rom_id_h,cr_ods_rom_id_l).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ODS12
///
/// - ID: 1531 (0x5fb)
/// - Size: 8 bytes
/// - Transmitter: ODS
#[derive(Clone, Copy)]
pub struct Ods12 {
    raw: [u8; 8],
}

impl Ods12 {
    pub const MESSAGE_ID: u32 = 1531;
    
    pub const CR_ODS_SER_NUM0_MIN: u8 = 0_u8;
    pub const CR_ODS_SER_NUM0_MAX: u8 = 255_u8;
    pub const CR_ODS_SER_NUM1_MIN: u8 = 0_u8;
    pub const CR_ODS_SER_NUM1_MAX: u8 = 255_u8;
    pub const CR_ODS_SER_NUM2_MIN: u8 = 0_u8;
    pub const CR_ODS_SER_NUM2_MAX: u8 = 255_u8;
    pub const CR_ODS_SER_NUM3_MIN: u8 = 0_u8;
    pub const CR_ODS_SER_NUM3_MAX: u8 = 255_u8;
    pub const CR_ODS_SER_NUM4_MIN: u8 = 0_u8;
    pub const CR_ODS_SER_NUM4_MAX: u8 = 255_u8;
    pub const CR_ODS_SER_NUM5_MIN: u8 = 0_u8;
    pub const CR_ODS_SER_NUM5_MAX: u8 = 255_u8;
    pub const CR_ODS_SER_NUM6_MIN: u8 = 0_u8;
    pub const CR_ODS_SER_NUM6_MAX: u8 = 255_u8;
    pub const CR_ODS_SER_NUM7_MIN: u8 = 0_u8;
    pub const CR_ODS_SER_NUM7_MAX: u8 = 255_u8;
    
    /// Construct new ODS12 from values
    pub fn new(cr_ods_ser_num0: u8, cr_ods_ser_num1: u8, cr_ods_ser_num2: u8, cr_ods_ser_num3: u8, cr_ods_ser_num4: u8, cr_ods_ser_num5: u8, cr_ods_ser_num6: u8, cr_ods_ser_num7: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cr_ods_ser_num0(cr_ods_ser_num0)?;
        res.set_cr_ods_ser_num1(cr_ods_ser_num1)?;
        res.set_cr_ods_ser_num2(cr_ods_ser_num2)?;
        res.set_cr_ods_ser_num3(cr_ods_ser_num3)?;
        res.set_cr_ods_ser_num4(cr_ods_ser_num4)?;
        res.set_cr_ods_ser_num5(cr_ods_ser_num5)?;
        res.set_cr_ods_ser_num6(cr_ods_ser_num6)?;
        res.set_cr_ods_ser_num7(cr_ods_ser_num7)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CR_Ods_SerNum0
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cr_ods_ser_num0(&self) -> u8 {
        self.cr_ods_ser_num0_raw()
    }
    
    /// Get raw value of CR_Ods_SerNum0
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ods_ser_num0_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Ods_SerNum0
    #[inline(always)]
    pub fn set_cr_ods_ser_num0(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1531 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CR_Ods_SerNum1
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cr_ods_ser_num1(&self) -> u8 {
        self.cr_ods_ser_num1_raw()
    }
    
    /// Get raw value of CR_Ods_SerNum1
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ods_ser_num1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Ods_SerNum1
    #[inline(always)]
    pub fn set_cr_ods_ser_num1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1531 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CR_Ods_SerNum2
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cr_ods_ser_num2(&self) -> u8 {
        self.cr_ods_ser_num2_raw()
    }
    
    /// Get raw value of CR_Ods_SerNum2
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ods_ser_num2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Ods_SerNum2
    #[inline(always)]
    pub fn set_cr_ods_ser_num2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1531 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// CR_Ods_SerNum3
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cr_ods_ser_num3(&self) -> u8 {
        self.cr_ods_ser_num3_raw()
    }
    
    /// Get raw value of CR_Ods_SerNum3
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ods_ser_num3_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Ods_SerNum3
    #[inline(always)]
    pub fn set_cr_ods_ser_num3(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1531 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CR_Ods_SerNum4
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cr_ods_ser_num4(&self) -> u8 {
        self.cr_ods_ser_num4_raw()
    }
    
    /// Get raw value of CR_Ods_SerNum4
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ods_ser_num4_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Ods_SerNum4
    #[inline(always)]
    pub fn set_cr_ods_ser_num4(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1531 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CR_Ods_SerNum5
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cr_ods_ser_num5(&self) -> u8 {
        self.cr_ods_ser_num5_raw()
    }
    
    /// Get raw value of CR_Ods_SerNum5
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ods_ser_num5_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Ods_SerNum5
    #[inline(always)]
    pub fn set_cr_ods_ser_num5(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1531 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// CR_Ods_SerNum6
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cr_ods_ser_num6(&self) -> u8 {
        self.cr_ods_ser_num6_raw()
    }
    
    /// Get raw value of CR_Ods_SerNum6
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ods_ser_num6_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Ods_SerNum6
    #[inline(always)]
    pub fn set_cr_ods_ser_num6(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1531 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// CR_Ods_SerNum7
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cr_ods_ser_num7(&self) -> u8 {
        self.cr_ods_ser_num7_raw()
    }
    
    /// Get raw value of CR_Ods_SerNum7
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ods_ser_num7_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Ods_SerNum7
    #[inline(always)]
    pub fn set_cr_ods_ser_num7(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1531 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ods12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ods12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ods12")
                .field("cr_ods_ser_num0", &self.cr_ods_ser_num0())
                .field("cr_ods_ser_num1", &self.cr_ods_ser_num1())
                .field("cr_ods_ser_num2", &self.cr_ods_ser_num2())
                .field("cr_ods_ser_num3", &self.cr_ods_ser_num3())
                .field("cr_ods_ser_num4", &self.cr_ods_ser_num4())
                .field("cr_ods_ser_num5", &self.cr_ods_ser_num5())
                .field("cr_ods_ser_num6", &self.cr_ods_ser_num6())
                .field("cr_ods_ser_num7", &self.cr_ods_ser_num7())
            .finish()
        } else {
            f.debug_tuple("Ods12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ods12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cr_ods_ser_num0 = u.int_in_range(0..=255)?;
        let cr_ods_ser_num1 = u.int_in_range(0..=255)?;
        let cr_ods_ser_num2 = u.int_in_range(0..=255)?;
        let cr_ods_ser_num3 = u.int_in_range(0..=255)?;
        let cr_ods_ser_num4 = u.int_in_range(0..=255)?;
        let cr_ods_ser_num5 = u.int_in_range(0..=255)?;
        let cr_ods_ser_num6 = u.int_in_range(0..=255)?;
        let cr_ods_ser_num7 = u.int_in_range(0..=255)?;
        Ods12::new(cr_ods_ser_num0,cr_ods_ser_num1,cr_ods_ser_num2,cr_ods_ser_num3,cr_ods_ser_num4,cr_ods_ser_num5,cr_ods_ser_num6,cr_ods_ser_num7).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ODS11
///
/// - ID: 1530 (0x5fa)
/// - Size: 8 bytes
/// - Transmitter: ODS
#[derive(Clone, Copy)]
pub struct Ods11 {
    raw: [u8; 8],
}

impl Ods11 {
    pub const MESSAGE_ID: u32 = 1530;
    
    pub const CR_WCS_ERR_STAT_MIN: u8 = 0_u8;
    pub const CR_WCS_ERR_STAT_MAX: u8 = 63_u8;
    pub const CR_WCS_CLASS_STAT_MIN: u8 = 0_u8;
    pub const CR_WCS_CLASS_STAT_MAX: u8 = 4_u8;
    
    /// Construct new ODS11 from values
    pub fn new(cf_ods_prc_cmd: bool, cf_ods_bts_fail: bool, cf_ods_acu_rcv_sn: bool, cf_ods_eol_cal: bool, cf_ods_ps_fail: bool, cf_ods_ecu_fail: bool, cf_ods_wgt_stat: bool, cf_ods_occ_stat: bool, cr_wcs_err_stat: u8, cr_wcs_class_stat: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_ods_prc_cmd(cf_ods_prc_cmd)?;
        res.set_cf_ods_bts_fail(cf_ods_bts_fail)?;
        res.set_cf_ods_acu_rcv_sn(cf_ods_acu_rcv_sn)?;
        res.set_cf_ods_eol_cal(cf_ods_eol_cal)?;
        res.set_cf_ods_ps_fail(cf_ods_ps_fail)?;
        res.set_cf_ods_ecu_fail(cf_ods_ecu_fail)?;
        res.set_cf_ods_wgt_stat(cf_ods_wgt_stat)?;
        res.set_cf_ods_occ_stat(cf_ods_occ_stat)?;
        res.set_cr_wcs_err_stat(cr_wcs_err_stat)?;
        res.set_cr_wcs_class_stat(cr_wcs_class_stat)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Ods_PrcCmd
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Dummy
    #[inline(always)]
    pub fn cf_ods_prc_cmd(&self) -> bool {
        self.cf_ods_prc_cmd_raw()
    }
    
    /// Get raw value of CF_Ods_PrcCmd
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ods_prc_cmd_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ods_PrcCmd
    #[inline(always)]
    pub fn set_cf_ods_prc_cmd(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// CF_Ods_BtsFail
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Dummy
    #[inline(always)]
    pub fn cf_ods_bts_fail(&self) -> bool {
        self.cf_ods_bts_fail_raw()
    }
    
    /// Get raw value of CF_Ods_BtsFail
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ods_bts_fail_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ods_BtsFail
    #[inline(always)]
    pub fn set_cf_ods_bts_fail(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// CF_Ods_AcuRcvSN
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cf_ods_acu_rcv_sn(&self) -> bool {
        self.cf_ods_acu_rcv_sn_raw()
    }
    
    /// Get raw value of CF_Ods_AcuRcvSN
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ods_acu_rcv_sn_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ods_AcuRcvSN
    #[inline(always)]
    pub fn set_cf_ods_acu_rcv_sn(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// CF_Ods_EolCal
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cf_ods_eol_cal(&self) -> bool {
        self.cf_ods_eol_cal_raw()
    }
    
    /// Get raw value of CF_Ods_EolCal
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ods_eol_cal_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ods_EolCal
    #[inline(always)]
    pub fn set_cf_ods_eol_cal(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// CF_Ods_PsFail
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cf_ods_ps_fail(&self) -> bool {
        self.cf_ods_ps_fail_raw()
    }
    
    /// Get raw value of CF_Ods_PsFail
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ods_ps_fail_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ods_PsFail
    #[inline(always)]
    pub fn set_cf_ods_ps_fail(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[6..7].store_le(value);
        Ok(())
    }
    
    /// CF_Ods_EcuFail
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cf_ods_ecu_fail(&self) -> bool {
        self.cf_ods_ecu_fail_raw()
    }
    
    /// Get raw value of CF_Ods_EcuFail
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ods_ecu_fail_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ods_EcuFail
    #[inline(always)]
    pub fn set_cf_ods_ecu_fail(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// CF_Ods_WgtStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cf_ods_wgt_stat(&self) -> bool {
        self.cf_ods_wgt_stat_raw()
    }
    
    /// Get raw value of CF_Ods_WgtStat
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ods_wgt_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ods_WgtStat
    #[inline(always)]
    pub fn set_cf_ods_wgt_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[8..9].store_le(value);
        Ok(())
    }
    
    /// CF_Ods_OccStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cf_ods_occ_stat(&self) -> bool {
        self.cf_ods_occ_stat_raw()
    }
    
    /// Get raw value of CF_Ods_OccStat
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ods_occ_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ods_OccStat
    #[inline(always)]
    pub fn set_cf_ods_occ_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[16..17].store_le(value);
        Ok(())
    }
    
    /// CR_Wcs_ErrStat
    ///
    /// - Min: 0
    /// - Max: 63
    /// - Unit: ""
    /// - Receivers: ACU
    #[inline(always)]
    pub fn cr_wcs_err_stat(&self) -> u8 {
        self.cr_wcs_err_stat_raw()
    }
    
    /// Get raw value of CR_Wcs_ErrStat
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_wcs_err_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Wcs_ErrStat
    #[inline(always)]
    pub fn set_cr_wcs_err_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 63_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1530 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CR_Wcs_ClassStat
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: ACU, BCM
    #[inline(always)]
    pub fn cr_wcs_class_stat(&self) -> u8 {
        self.cr_wcs_class_stat_raw()
    }
    
    /// Get raw value of CR_Wcs_ClassStat
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_wcs_class_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Wcs_ClassStat
    #[inline(always)]
    pub fn set_cr_wcs_class_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1530 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ods11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ods11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ods11")
                .field("cf_ods_prc_cmd", &self.cf_ods_prc_cmd())
                .field("cf_ods_bts_fail", &self.cf_ods_bts_fail())
                .field("cf_ods_acu_rcv_sn", &self.cf_ods_acu_rcv_sn())
                .field("cf_ods_eol_cal", &self.cf_ods_eol_cal())
                .field("cf_ods_ps_fail", &self.cf_ods_ps_fail())
                .field("cf_ods_ecu_fail", &self.cf_ods_ecu_fail())
                .field("cf_ods_wgt_stat", &self.cf_ods_wgt_stat())
                .field("cf_ods_occ_stat", &self.cf_ods_occ_stat())
                .field("cr_wcs_err_stat", &self.cr_wcs_err_stat())
                .field("cr_wcs_class_stat", &self.cr_wcs_class_stat())
            .finish()
        } else {
            f.debug_tuple("Ods11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ods11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_ods_prc_cmd = u.int_in_range(0..=1)? == 1;
        let cf_ods_bts_fail = u.int_in_range(0..=1)? == 1;
        let cf_ods_acu_rcv_sn = u.int_in_range(0..=1)? == 1;
        let cf_ods_eol_cal = u.int_in_range(0..=1)? == 1;
        let cf_ods_ps_fail = u.int_in_range(0..=1)? == 1;
        let cf_ods_ecu_fail = u.int_in_range(0..=1)? == 1;
        let cf_ods_wgt_stat = u.int_in_range(0..=1)? == 1;
        let cf_ods_occ_stat = u.int_in_range(0..=1)? == 1;
        let cr_wcs_err_stat = u.int_in_range(0..=63)?;
        let cr_wcs_class_stat = u.int_in_range(0..=4)?;
        Ods11::new(cf_ods_prc_cmd,cf_ods_bts_fail,cf_ods_acu_rcv_sn,cf_ods_eol_cal,cf_ods_ps_fail,cf_ods_ecu_fail,cf_ods_wgt_stat,cf_ods_occ_stat,cr_wcs_err_stat,cr_wcs_class_stat).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ECS12
///
/// - ID: 1017 (0x3f9)
/// - Size: 4 bytes
/// - Transmitter: ECS
#[derive(Clone, Copy)]
pub struct Ecs12 {
    raw: [u8; 4],
}

impl Ecs12 {
    pub const MESSAGE_ID: u32 = 1017;
    
    pub const HEIGHT_FL_MIN: f32 = -128_f32;
    pub const HEIGHT_FL_MAX: f32 = 127_f32;
    pub const HEIGHT_FR_MIN: f32 = -128_f32;
    pub const HEIGHT_FR_MAX: f32 = 127_f32;
    pub const HEIGHT_RL_MIN: f32 = -128_f32;
    pub const HEIGHT_RL_MAX: f32 = 127_f32;
    pub const HEIGHT_RR_MIN: f32 = -128_f32;
    pub const HEIGHT_RR_MAX: f32 = 127_f32;
    
    /// Construct new ECS12 from values
    pub fn new(height_fl: f32, height_fr: f32, height_rl: f32, height_rr: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_height_fl(height_fl)?;
        res.set_height_fr(height_fr)?;
        res.set_height_rl(height_rl)?;
        res.set_height_rr(height_rr)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 4] {
        &self.raw
    }
    
    /// Height_FL
    ///
    /// - Min: -128
    /// - Max: 127
    /// - Unit: "mm"
    /// - Receivers: AFLS
    #[inline(always)]
    pub fn height_fl(&self) -> f32 {
        self.height_fl_raw()
    }
    
    /// Get raw value of Height_FL
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -128
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn height_fl_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -128_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Height_FL
    #[inline(always)]
    pub fn set_height_fl(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -128_f32 || 127_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1017 });
        }
        let factor = 1_f32;
        let offset = -128_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// Height_FR
    ///
    /// - Min: -128
    /// - Max: 127
    /// - Unit: "mm"
    /// - Receivers: AFLS
    #[inline(always)]
    pub fn height_fr(&self) -> f32 {
        self.height_fr_raw()
    }
    
    /// Get raw value of Height_FR
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -128
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn height_fr_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -128_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Height_FR
    #[inline(always)]
    pub fn set_height_fr(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -128_f32 || 127_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1017 });
        }
        let factor = 1_f32;
        let offset = -128_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Height_RL
    ///
    /// - Min: -128
    /// - Max: 127
    /// - Unit: "mm"
    /// - Receivers: AFLS
    #[inline(always)]
    pub fn height_rl(&self) -> f32 {
        self.height_rl_raw()
    }
    
    /// Get raw value of Height_RL
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -128
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn height_rl_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -128_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Height_RL
    #[inline(always)]
    pub fn set_height_rl(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -128_f32 || 127_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1017 });
        }
        let factor = 1_f32;
        let offset = -128_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// Height_RR
    ///
    /// - Min: -128
    /// - Max: 127
    /// - Unit: "mm"
    /// - Receivers: AFLS
    #[inline(always)]
    pub fn height_rr(&self) -> f32 {
        self.height_rr_raw()
    }
    
    /// Get raw value of Height_RR
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -128
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn height_rr_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -128_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Height_RR
    #[inline(always)]
    pub fn set_height_rr(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -128_f32 || 127_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1017 });
        }
        let factor = 1_f32;
        let offset = -128_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ecs12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ecs12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ecs12")
                .field("height_fl", &self.height_fl())
                .field("height_fr", &self.height_fr())
                .field("height_rl", &self.height_rl())
                .field("height_rr", &self.height_rr())
            .finish()
        } else {
            f.debug_tuple("Ecs12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ecs12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let height_fl = u.float_in_range(-128_f32..=127_f32)?;
        let height_fr = u.float_in_range(-128_f32..=127_f32)?;
        let height_rl = u.float_in_range(-128_f32..=127_f32)?;
        let height_rr = u.float_in_range(-128_f32..=127_f32)?;
        Ecs12::new(height_fl,height_fr,height_rl,height_rr).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// SPAS12
///
/// - ID: 1268 (0x4f4)
/// - Size: 8 bytes
/// - Transmitter: SPAS
#[derive(Clone, Copy)]
pub struct Spas12 {
    raw: [u8; 8],
}

impl Spas12 {
    pub const MESSAGE_ID: u32 = 1268;
    
    pub const CF_SPAS_HMI_STAT_MIN: u8 = 0_u8;
    pub const CF_SPAS_HMI_STAT_MAX: u8 = 255_u8;
    pub const CF_SPAS_DISP_MIN: u8 = 0_u8;
    pub const CF_SPAS_DISP_MAX: u8 = 3_u8;
    pub const CF_SPAS_FIL_IND_MIN: u8 = 0_u8;
    pub const CF_SPAS_FIL_IND_MAX: u8 = 7_u8;
    pub const CF_SPAS_FIR_IND_MIN: u8 = 0_u8;
    pub const CF_SPAS_FIR_IND_MAX: u8 = 7_u8;
    pub const CF_SPAS_FOL_IND_MIN: u8 = 0_u8;
    pub const CF_SPAS_FOL_IND_MAX: u8 = 7_u8;
    pub const CF_SPAS_FOR_IND_MIN: u8 = 0_u8;
    pub const CF_SPAS_FOR_IND_MAX: u8 = 7_u8;
    pub const CF_SPAS_VOL_DOWN_MIN: u8 = 0_u8;
    pub const CF_SPAS_VOL_DOWN_MAX: u8 = 3_u8;
    pub const CF_SPAS_RIL_IND_MIN: u8 = 0_u8;
    pub const CF_SPAS_RIL_IND_MAX: u8 = 7_u8;
    pub const CF_SPAS_RIR_IND_MIN: u8 = 0_u8;
    pub const CF_SPAS_RIR_IND_MAX: u8 = 7_u8;
    pub const CF_SPAS_FLS_ALARM_MIN: u8 = 0_u8;
    pub const CF_SPAS_FLS_ALARM_MAX: u8 = 3_u8;
    pub const CF_SPAS_ROL_IND_MIN: u8 = 0_u8;
    pub const CF_SPAS_ROL_IND_MAX: u8 = 7_u8;
    pub const CF_SPAS_ROR_IND_MIN: u8 = 0_u8;
    pub const CF_SPAS_ROR_IND_MAX: u8 = 7_u8;
    pub const CF_SPAS_FCS_ALARM_MIN: u8 = 0_u8;
    pub const CF_SPAS_FCS_ALARM_MAX: u8 = 3_u8;
    pub const CF_SPAS_FI_IND_MIN: u8 = 0_u8;
    pub const CF_SPAS_FI_IND_MAX: u8 = 7_u8;
    pub const CF_SPAS_RI_IND_MIN: u8 = 0_u8;
    pub const CF_SPAS_RI_IND_MAX: u8 = 7_u8;
    pub const CF_SPAS_FRS_ALARM_MIN: u8 = 0_u8;
    pub const CF_SPAS_FRS_ALARM_MAX: u8 = 3_u8;
    pub const CF_SPAS_FR_ALARM_MIN: u8 = 0_u8;
    pub const CF_SPAS_FR_ALARM_MAX: u8 = 3_u8;
    pub const CF_SPAS_RR_ALARM_MIN: u8 = 0_u8;
    pub const CF_SPAS_RR_ALARM_MAX: u8 = 3_u8;
    pub const CF_SPAS_BEEP_ALARM_MIN: u8 = 0_u8;
    pub const CF_SPAS_BEEP_ALARM_MAX: u8 = 15_u8;
    pub const CF_SPAS_RLS_ALARM_MIN: u8 = 0_u8;
    pub const CF_SPAS_RLS_ALARM_MAX: u8 = 3_u8;
    pub const CF_SPAS_RCS_ALARM_MIN: u8 = 0_u8;
    pub const CF_SPAS_RCS_ALARM_MAX: u8 = 3_u8;
    pub const CF_SPAS_RRS_ALARM_MIN: u8 = 0_u8;
    pub const CF_SPAS_RRS_ALARM_MAX: u8 = 3_u8;
    
    /// Construct new SPAS12 from values
    pub fn new(cf_spas_hmi_stat: u8, cf_spas_disp: u8, cf_spas_fil_ind: u8, cf_spas_fir_ind: u8, cf_spas_fol_ind: u8, cf_spas_for_ind: u8, cf_spas_vol_down: u8, cf_spas_ril_ind: u8, cf_spas_rir_ind: u8, cf_spas_fls_alarm: u8, cf_spas_rol_ind: u8, cf_spas_ror_ind: u8, cf_spas_fcs_alarm: u8, cf_spas_fi_ind: u8, cf_spas_ri_ind: u8, cf_spas_frs_alarm: u8, cf_spas_fr_alarm: u8, cf_spas_rr_alarm: u8, cf_spas_beep_alarm: u8, cf_spas_stat_alarm: bool, cf_spas_rls_alarm: u8, cf_spas_rcs_alarm: u8, cf_spas_rrs_alarm: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_spas_hmi_stat(cf_spas_hmi_stat)?;
        res.set_cf_spas_disp(cf_spas_disp)?;
        res.set_cf_spas_fil_ind(cf_spas_fil_ind)?;
        res.set_cf_spas_fir_ind(cf_spas_fir_ind)?;
        res.set_cf_spas_fol_ind(cf_spas_fol_ind)?;
        res.set_cf_spas_for_ind(cf_spas_for_ind)?;
        res.set_cf_spas_vol_down(cf_spas_vol_down)?;
        res.set_cf_spas_ril_ind(cf_spas_ril_ind)?;
        res.set_cf_spas_rir_ind(cf_spas_rir_ind)?;
        res.set_cf_spas_fls_alarm(cf_spas_fls_alarm)?;
        res.set_cf_spas_rol_ind(cf_spas_rol_ind)?;
        res.set_cf_spas_ror_ind(cf_spas_ror_ind)?;
        res.set_cf_spas_fcs_alarm(cf_spas_fcs_alarm)?;
        res.set_cf_spas_fi_ind(cf_spas_fi_ind)?;
        res.set_cf_spas_ri_ind(cf_spas_ri_ind)?;
        res.set_cf_spas_frs_alarm(cf_spas_frs_alarm)?;
        res.set_cf_spas_fr_alarm(cf_spas_fr_alarm)?;
        res.set_cf_spas_rr_alarm(cf_spas_rr_alarm)?;
        res.set_cf_spas_beep_alarm(cf_spas_beep_alarm)?;
        res.set_cf_spas_stat_alarm(cf_spas_stat_alarm)?;
        res.set_cf_spas_rls_alarm(cf_spas_rls_alarm)?;
        res.set_cf_spas_rcs_alarm(cf_spas_rcs_alarm)?;
        res.set_cf_spas_rrs_alarm(cf_spas_rrs_alarm)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Spas_HMI_Stat
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_spas_hmi_stat(&self) -> u8 {
        self.cf_spas_hmi_stat_raw()
    }
    
    /// Get raw value of CF_Spas_HMI_Stat
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_hmi_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_HMI_Stat
    #[inline(always)]
    pub fn set_cf_spas_hmi_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_Disp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, EMS
    #[inline(always)]
    pub fn cf_spas_disp(&self) -> u8 {
        self.cf_spas_disp_raw()
    }
    
    /// Get raw value of CF_Spas_Disp
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_Disp
    #[inline(always)]
    pub fn set_cf_spas_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_FIL_Ind
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU
    #[inline(always)]
    pub fn cf_spas_fil_ind(&self) -> u8 {
        self.cf_spas_fil_ind_raw()
    }
    
    /// Get raw value of CF_Spas_FIL_Ind
    ///
    /// - Start bit: 10
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_fil_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_FIL_Ind
    #[inline(always)]
    pub fn set_cf_spas_fil_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..13].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_FIR_Ind
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU
    #[inline(always)]
    pub fn cf_spas_fir_ind(&self) -> u8 {
        self.cf_spas_fir_ind_raw()
    }
    
    /// Get raw value of CF_Spas_FIR_Ind
    ///
    /// - Start bit: 13
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_fir_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[13..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_FIR_Ind
    #[inline(always)]
    pub fn set_cf_spas_fir_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[13..16].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_FOL_Ind
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU
    #[inline(always)]
    pub fn cf_spas_fol_ind(&self) -> u8 {
        self.cf_spas_fol_ind_raw()
    }
    
    /// Get raw value of CF_Spas_FOL_Ind
    ///
    /// - Start bit: 16
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_fol_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..19].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_FOL_Ind
    #[inline(always)]
    pub fn set_cf_spas_fol_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..19].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_FOR_Ind
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU
    #[inline(always)]
    pub fn cf_spas_for_ind(&self) -> u8 {
        self.cf_spas_for_ind_raw()
    }
    
    /// Get raw value of CF_Spas_FOR_Ind
    ///
    /// - Start bit: 19
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_for_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[19..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_FOR_Ind
    #[inline(always)]
    pub fn set_cf_spas_for_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[19..22].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_VolDown
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_spas_vol_down(&self) -> u8 {
        self.cf_spas_vol_down_raw()
    }
    
    /// Get raw value of CF_Spas_VolDown
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_vol_down_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_VolDown
    #[inline(always)]
    pub fn set_cf_spas_vol_down(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_RIL_Ind
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU
    #[inline(always)]
    pub fn cf_spas_ril_ind(&self) -> u8 {
        self.cf_spas_ril_ind_raw()
    }
    
    /// Get raw value of CF_Spas_RIL_Ind
    ///
    /// - Start bit: 24
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_ril_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..27].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_RIL_Ind
    #[inline(always)]
    pub fn set_cf_spas_ril_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..27].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_RIR_Ind
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU
    #[inline(always)]
    pub fn cf_spas_rir_ind(&self) -> u8 {
        self.cf_spas_rir_ind_raw()
    }
    
    /// Get raw value of CF_Spas_RIR_Ind
    ///
    /// - Start bit: 27
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_rir_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[27..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_RIR_Ind
    #[inline(always)]
    pub fn set_cf_spas_rir_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[27..30].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_FLS_Alarm
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_spas_fls_alarm(&self) -> u8 {
        self.cf_spas_fls_alarm_raw()
    }
    
    /// Get raw value of CF_Spas_FLS_Alarm
    ///
    /// - Start bit: 30
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_fls_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[30..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_FLS_Alarm
    #[inline(always)]
    pub fn set_cf_spas_fls_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[30..32].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_ROL_Ind
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU
    #[inline(always)]
    pub fn cf_spas_rol_ind(&self) -> u8 {
        self.cf_spas_rol_ind_raw()
    }
    
    /// Get raw value of CF_Spas_ROL_Ind
    ///
    /// - Start bit: 32
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_rol_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..35].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_ROL_Ind
    #[inline(always)]
    pub fn set_cf_spas_rol_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..35].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_ROR_Ind
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU
    #[inline(always)]
    pub fn cf_spas_ror_ind(&self) -> u8 {
        self.cf_spas_ror_ind_raw()
    }
    
    /// Get raw value of CF_Spas_ROR_Ind
    ///
    /// - Start bit: 35
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_ror_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[35..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_ROR_Ind
    #[inline(always)]
    pub fn set_cf_spas_ror_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[35..38].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_FCS_Alarm
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_spas_fcs_alarm(&self) -> u8 {
        self.cf_spas_fcs_alarm_raw()
    }
    
    /// Get raw value of CF_Spas_FCS_Alarm
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_fcs_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_FCS_Alarm
    #[inline(always)]
    pub fn set_cf_spas_fcs_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[38..40].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_FI_Ind
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU
    #[inline(always)]
    pub fn cf_spas_fi_ind(&self) -> u8 {
        self.cf_spas_fi_ind_raw()
    }
    
    /// Get raw value of CF_Spas_FI_Ind
    ///
    /// - Start bit: 40
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_fi_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..43].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_FI_Ind
    #[inline(always)]
    pub fn set_cf_spas_fi_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..43].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_RI_Ind
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU
    #[inline(always)]
    pub fn cf_spas_ri_ind(&self) -> u8 {
        self.cf_spas_ri_ind_raw()
    }
    
    /// Get raw value of CF_Spas_RI_Ind
    ///
    /// - Start bit: 43
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_ri_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[43..46].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_RI_Ind
    #[inline(always)]
    pub fn set_cf_spas_ri_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[43..46].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_FRS_Alarm
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_spas_frs_alarm(&self) -> u8 {
        self.cf_spas_frs_alarm_raw()
    }
    
    /// Get raw value of CF_Spas_FRS_Alarm
    ///
    /// - Start bit: 46
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_frs_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[46..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_FRS_Alarm
    #[inline(always)]
    pub fn set_cf_spas_frs_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[46..48].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_FR_Alarm
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_spas_fr_alarm(&self) -> u8 {
        self.cf_spas_fr_alarm_raw()
    }
    
    /// Get raw value of CF_Spas_FR_Alarm
    ///
    /// - Start bit: 48
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_fr_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..50].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_FR_Alarm
    #[inline(always)]
    pub fn set_cf_spas_fr_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..50].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_RR_Alarm
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_spas_rr_alarm(&self) -> u8 {
        self.cf_spas_rr_alarm_raw()
    }
    
    /// Get raw value of CF_Spas_RR_Alarm
    ///
    /// - Start bit: 50
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_rr_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[50..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_RR_Alarm
    #[inline(always)]
    pub fn set_cf_spas_rr_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[50..52].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_BEEP_Alarm
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_spas_beep_alarm(&self) -> u8 {
        self.cf_spas_beep_alarm_raw()
    }
    
    /// Get raw value of CF_Spas_BEEP_Alarm
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_beep_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_BEEP_Alarm
    #[inline(always)]
    pub fn set_cf_spas_beep_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[52..56].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_StatAlarm
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_spas_stat_alarm(&self) -> bool {
        self.cf_spas_stat_alarm_raw()
    }
    
    /// Get raw value of CF_Spas_StatAlarm
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_stat_alarm_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Spas_StatAlarm
    #[inline(always)]
    pub fn set_cf_spas_stat_alarm(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[56..57].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_RLS_Alarm
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_spas_rls_alarm(&self) -> u8 {
        self.cf_spas_rls_alarm_raw()
    }
    
    /// Get raw value of CF_Spas_RLS_Alarm
    ///
    /// - Start bit: 57
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_rls_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[57..59].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_RLS_Alarm
    #[inline(always)]
    pub fn set_cf_spas_rls_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[57..59].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_RCS_Alarm
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_spas_rcs_alarm(&self) -> u8 {
        self.cf_spas_rcs_alarm_raw()
    }
    
    /// Get raw value of CF_Spas_RCS_Alarm
    ///
    /// - Start bit: 59
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_rcs_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[59..61].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_RCS_Alarm
    #[inline(always)]
    pub fn set_cf_spas_rcs_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[59..61].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_RRS_Alarm
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_spas_rrs_alarm(&self) -> u8 {
        self.cf_spas_rrs_alarm_raw()
    }
    
    /// Get raw value of CF_Spas_RRS_Alarm
    ///
    /// - Start bit: 61
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_rrs_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[61..63].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_RRS_Alarm
    #[inline(always)]
    pub fn set_cf_spas_rrs_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1268 });
        }
        self.raw.view_bits_mut::<Lsb0>()[61..63].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Spas12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Spas12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Spas12")
                .field("cf_spas_hmi_stat", &self.cf_spas_hmi_stat())
                .field("cf_spas_disp", &self.cf_spas_disp())
                .field("cf_spas_fil_ind", &self.cf_spas_fil_ind())
                .field("cf_spas_fir_ind", &self.cf_spas_fir_ind())
                .field("cf_spas_fol_ind", &self.cf_spas_fol_ind())
                .field("cf_spas_for_ind", &self.cf_spas_for_ind())
                .field("cf_spas_vol_down", &self.cf_spas_vol_down())
                .field("cf_spas_ril_ind", &self.cf_spas_ril_ind())
                .field("cf_spas_rir_ind", &self.cf_spas_rir_ind())
                .field("cf_spas_fls_alarm", &self.cf_spas_fls_alarm())
                .field("cf_spas_rol_ind", &self.cf_spas_rol_ind())
                .field("cf_spas_ror_ind", &self.cf_spas_ror_ind())
                .field("cf_spas_fcs_alarm", &self.cf_spas_fcs_alarm())
                .field("cf_spas_fi_ind", &self.cf_spas_fi_ind())
                .field("cf_spas_ri_ind", &self.cf_spas_ri_ind())
                .field("cf_spas_frs_alarm", &self.cf_spas_frs_alarm())
                .field("cf_spas_fr_alarm", &self.cf_spas_fr_alarm())
                .field("cf_spas_rr_alarm", &self.cf_spas_rr_alarm())
                .field("cf_spas_beep_alarm", &self.cf_spas_beep_alarm())
                .field("cf_spas_stat_alarm", &self.cf_spas_stat_alarm())
                .field("cf_spas_rls_alarm", &self.cf_spas_rls_alarm())
                .field("cf_spas_rcs_alarm", &self.cf_spas_rcs_alarm())
                .field("cf_spas_rrs_alarm", &self.cf_spas_rrs_alarm())
            .finish()
        } else {
            f.debug_tuple("Spas12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Spas12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_spas_hmi_stat = u.int_in_range(0..=255)?;
        let cf_spas_disp = u.int_in_range(0..=3)?;
        let cf_spas_fil_ind = u.int_in_range(0..=7)?;
        let cf_spas_fir_ind = u.int_in_range(0..=7)?;
        let cf_spas_fol_ind = u.int_in_range(0..=7)?;
        let cf_spas_for_ind = u.int_in_range(0..=7)?;
        let cf_spas_vol_down = u.int_in_range(0..=3)?;
        let cf_spas_ril_ind = u.int_in_range(0..=7)?;
        let cf_spas_rir_ind = u.int_in_range(0..=7)?;
        let cf_spas_fls_alarm = u.int_in_range(0..=3)?;
        let cf_spas_rol_ind = u.int_in_range(0..=7)?;
        let cf_spas_ror_ind = u.int_in_range(0..=7)?;
        let cf_spas_fcs_alarm = u.int_in_range(0..=3)?;
        let cf_spas_fi_ind = u.int_in_range(0..=7)?;
        let cf_spas_ri_ind = u.int_in_range(0..=7)?;
        let cf_spas_frs_alarm = u.int_in_range(0..=3)?;
        let cf_spas_fr_alarm = u.int_in_range(0..=3)?;
        let cf_spas_rr_alarm = u.int_in_range(0..=3)?;
        let cf_spas_beep_alarm = u.int_in_range(0..=15)?;
        let cf_spas_stat_alarm = u.int_in_range(0..=1)? == 1;
        let cf_spas_rls_alarm = u.int_in_range(0..=3)?;
        let cf_spas_rcs_alarm = u.int_in_range(0..=3)?;
        let cf_spas_rrs_alarm = u.int_in_range(0..=3)?;
        Spas12::new(cf_spas_hmi_stat,cf_spas_disp,cf_spas_fil_ind,cf_spas_fir_ind,cf_spas_fol_ind,cf_spas_for_ind,cf_spas_vol_down,cf_spas_ril_ind,cf_spas_rir_ind,cf_spas_fls_alarm,cf_spas_rol_ind,cf_spas_ror_ind,cf_spas_fcs_alarm,cf_spas_fi_ind,cf_spas_ri_ind,cf_spas_frs_alarm,cf_spas_fr_alarm,cf_spas_rr_alarm,cf_spas_beep_alarm,cf_spas_stat_alarm,cf_spas_rls_alarm,cf_spas_rcs_alarm,cf_spas_rrs_alarm).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// CLU11
///
/// - ID: 1265 (0x4f1)
/// - Size: 4 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct Clu11 {
    raw: [u8; 4],
}

impl Clu11 {
    pub const MESSAGE_ID: u32 = 1265;
    
    pub const CF_CLU_CRUISE_SW_STATE_MIN: u8 = 0_u8;
    pub const CF_CLU_CRUISE_SW_STATE_MAX: u8 = 7_u8;
    pub const CF_CLU_VANZ_DECIMAL_MIN: f32 = 0_f32;
    pub const CF_CLU_VANZ_DECIMAL_MAX: f32 = 0.375_f32;
    pub const CF_CLU_VANZ_MIN: f32 = 0_f32;
    pub const CF_CLU_VANZ_MAX: f32 = 255.5_f32;
    pub const CF_CLU_RHEOSTAT_LEVEL_MIN: u8 = 0_u8;
    pub const CF_CLU_RHEOSTAT_LEVEL_MAX: u8 = 31_u8;
    pub const CF_CLU_ALIVE_CNT1_MIN: u8 = 0_u8;
    pub const CF_CLU_ALIVE_CNT1_MAX: u8 = 15_u8;
    
    /// Construct new CLU11 from values
    pub fn new(cf_clu_cruise_sw_state: u8, cf_clu_cruise_sw_main: bool, cf_clu_sld_main_sw: bool, cf_clu_parity_bit1: bool, cf_clu_vanz_decimal: f32, cf_clu_vanz: f32, cf_clu_speed_unit: bool, cf_clu_detent_out: bool, cf_clu_rheostat_level: u8, cf_clu_clu_info: bool, cf_clu_amp_info: bool, cf_clu_alive_cnt1: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_cf_clu_cruise_sw_state(cf_clu_cruise_sw_state)?;
        res.set_cf_clu_cruise_sw_main(cf_clu_cruise_sw_main)?;
        res.set_cf_clu_sld_main_sw(cf_clu_sld_main_sw)?;
        res.set_cf_clu_parity_bit1(cf_clu_parity_bit1)?;
        res.set_cf_clu_vanz_decimal(cf_clu_vanz_decimal)?;
        res.set_cf_clu_vanz(cf_clu_vanz)?;
        res.set_cf_clu_speed_unit(cf_clu_speed_unit)?;
        res.set_cf_clu_detent_out(cf_clu_detent_out)?;
        res.set_cf_clu_rheostat_level(cf_clu_rheostat_level)?;
        res.set_cf_clu_clu_info(cf_clu_clu_info)?;
        res.set_cf_clu_amp_info(cf_clu_amp_info)?;
        res.set_cf_clu_alive_cnt1(cf_clu_alive_cnt1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 4] {
        &self.raw
    }
    
    /// CF_Clu_CruiseSwState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: EMS, LDWS_LKAS, SCC
    #[inline(always)]
    pub fn cf_clu_cruise_sw_state(&self) -> u8 {
        self.cf_clu_cruise_sw_state_raw()
    }
    
    /// Get raw value of CF_Clu_CruiseSwState
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_cruise_sw_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_CruiseSwState
    #[inline(always)]
    pub fn set_cf_clu_cruise_sw_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1265 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..3].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_CruiseSwMain
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, LDWS_LKAS, SCC
    #[inline(always)]
    pub fn cf_clu_cruise_sw_main(&self) -> bool {
        self.cf_clu_cruise_sw_main_raw()
    }
    
    /// Get raw value of CF_Clu_CruiseSwMain
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_cruise_sw_main_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_CruiseSwMain
    #[inline(always)]
    pub fn set_cf_clu_cruise_sw_main(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_SldMainSW
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_clu_sld_main_sw(&self) -> bool {
        self.cf_clu_sld_main_sw_raw()
    }
    
    /// Get raw value of CF_Clu_SldMainSW
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_sld_main_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_SldMainSW
    #[inline(always)]
    pub fn set_cf_clu_sld_main_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_ParityBit1
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: "pulse count"
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_clu_parity_bit1(&self) -> bool {
        self.cf_clu_parity_bit1_raw()
    }
    
    /// Get raw value of CF_Clu_ParityBit1
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_parity_bit1_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_ParityBit1
    #[inline(always)]
    pub fn set_cf_clu_parity_bit1(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_VanzDecimal
    ///
    /// - Min: 0
    /// - Max: 0.375
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_clu_vanz_decimal(&self) -> f32 {
        self.cf_clu_vanz_decimal_raw()
    }
    
    /// Get raw value of CF_Clu_VanzDecimal
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 0.125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_vanz_decimal_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        let factor = 0.125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CF_Clu_VanzDecimal
    #[inline(always)]
    pub fn set_cf_clu_vanz_decimal(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 0.375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1265 });
        }
        let factor = 0.125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_Vanz
    ///
    /// - Min: 0
    /// - Max: 255.5
    /// - Unit: "km/h or MPH"
    /// - Receivers: BCM, CUBIS, EMS, IBOX, LDWS_LKAS, MDPS, SCC
    #[inline(always)]
    pub fn cf_clu_vanz(&self) -> f32 {
        self.cf_clu_vanz_raw()
    }
    
    /// Get raw value of CF_Clu_Vanz
    ///
    /// - Start bit: 8
    /// - Signal size: 9 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_vanz_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..17].load_le::<u16>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CF_Clu_Vanz
    #[inline(always)]
    pub fn set_cf_clu_vanz(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 255.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1265 });
        }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[8..17].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_SPEED_UNIT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM, CUBIS, EMS, IBOX, LDWS_LKAS, MDPS, SCC
    #[inline(always)]
    pub fn cf_clu_speed_unit(&self) -> bool {
        self.cf_clu_speed_unit_raw()
    }
    
    /// Get raw value of CF_Clu_SPEED_UNIT
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_speed_unit_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_SPEED_UNIT
    #[inline(always)]
    pub fn set_cf_clu_speed_unit(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[17..18].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_DetentOut
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: AVM, BCM, LCA, PGS, SPAS
    #[inline(always)]
    pub fn cf_clu_detent_out(&self) -> bool {
        self.cf_clu_detent_out_raw()
    }
    
    /// Get raw value of CF_Clu_DetentOut
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_detent_out_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_DetentOut
    #[inline(always)]
    pub fn set_cf_clu_detent_out(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[18..19].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_RheostatLevel
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: ""
    /// - Receivers: AVM, BCM, LCA, PGS, SPAS
    #[inline(always)]
    pub fn cf_clu_rheostat_level(&self) -> u8 {
        self.cf_clu_rheostat_level_raw()
    }
    
    /// Get raw value of CF_Clu_RheostatLevel
    ///
    /// - Start bit: 19
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_rheostat_level_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[19..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_RheostatLevel
    #[inline(always)]
    pub fn set_cf_clu_rheostat_level(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 31_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1265 });
        }
        self.raw.view_bits_mut::<Lsb0>()[19..24].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_CluInfo
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_clu_info(&self) -> bool {
        self.cf_clu_clu_info_raw()
    }
    
    /// Get raw value of CF_Clu_CluInfo
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_clu_info_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_CluInfo
    #[inline(always)]
    pub fn set_cf_clu_clu_info(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[24..25].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_AmpInfo
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_amp_info(&self) -> bool {
        self.cf_clu_amp_info_raw()
    }
    
    /// Get raw value of CF_Clu_AmpInfo
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_amp_info_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_AmpInfo
    #[inline(always)]
    pub fn set_cf_clu_amp_info(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[25..26].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_AliveCnt1
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: AHLS, EMS, EPB, LDWS_LKAS, MDPS, SCC
    #[inline(always)]
    pub fn cf_clu_alive_cnt1(&self) -> u8 {
        self.cf_clu_alive_cnt1_raw()
    }
    
    /// Get raw value of CF_Clu_AliveCnt1
    ///
    /// - Start bit: 28
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_alive_cnt1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[28..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_AliveCnt1
    #[inline(always)]
    pub fn set_cf_clu_alive_cnt1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1265 });
        }
        self.raw.view_bits_mut::<Lsb0>()[28..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Clu11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Clu11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Clu11")
                .field("cf_clu_cruise_sw_state", &self.cf_clu_cruise_sw_state())
                .field("cf_clu_cruise_sw_main", &self.cf_clu_cruise_sw_main())
                .field("cf_clu_sld_main_sw", &self.cf_clu_sld_main_sw())
                .field("cf_clu_parity_bit1", &self.cf_clu_parity_bit1())
                .field("cf_clu_vanz_decimal", &self.cf_clu_vanz_decimal())
                .field("cf_clu_vanz", &self.cf_clu_vanz())
                .field("cf_clu_speed_unit", &self.cf_clu_speed_unit())
                .field("cf_clu_detent_out", &self.cf_clu_detent_out())
                .field("cf_clu_rheostat_level", &self.cf_clu_rheostat_level())
                .field("cf_clu_clu_info", &self.cf_clu_clu_info())
                .field("cf_clu_amp_info", &self.cf_clu_amp_info())
                .field("cf_clu_alive_cnt1", &self.cf_clu_alive_cnt1())
            .finish()
        } else {
            f.debug_tuple("Clu11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Clu11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_clu_cruise_sw_state = u.int_in_range(0..=7)?;
        let cf_clu_cruise_sw_main = u.int_in_range(0..=1)? == 1;
        let cf_clu_sld_main_sw = u.int_in_range(0..=1)? == 1;
        let cf_clu_parity_bit1 = u.int_in_range(0..=1)? == 1;
        let cf_clu_vanz_decimal = u.float_in_range(0_f32..=0.375_f32)?;
        let cf_clu_vanz = u.float_in_range(0_f32..=255.5_f32)?;
        let cf_clu_speed_unit = u.int_in_range(0..=1)? == 1;
        let cf_clu_detent_out = u.int_in_range(0..=1)? == 1;
        let cf_clu_rheostat_level = u.int_in_range(0..=31)?;
        let cf_clu_clu_info = u.int_in_range(0..=1)? == 1;
        let cf_clu_amp_info = u.int_in_range(0..=1)? == 1;
        let cf_clu_alive_cnt1 = u.int_in_range(0..=15)?;
        Clu11::new(cf_clu_cruise_sw_state,cf_clu_cruise_sw_main,cf_clu_sld_main_sw,cf_clu_parity_bit1,cf_clu_vanz_decimal,cf_clu_vanz,cf_clu_speed_unit,cf_clu_detent_out,cf_clu_rheostat_level,cf_clu_clu_info,cf_clu_amp_info,cf_clu_alive_cnt1).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// Sign_Detection
///
/// - ID: 1260 (0x4ec)
/// - Size: 8 bytes
/// - Transmitter: XXX
#[derive(Clone, Copy)]
pub struct SignDetection {
    raw: [u8; 8],
}

impl SignDetection {
    pub const MESSAGE_ID: u32 = 1260;
    
    pub const SPEED_LIM_NAV_CAM_MIN: u8 = 0_u8;
    pub const SPEED_LIM_NAV_CAM_MAX: u8 = 255_u8;
    pub const SPEED_LIM_NAV_CAM2_MIN: u8 = 0_u8;
    pub const SPEED_LIM_NAV_CAM2_MAX: u8 = 255_u8;
    
    /// Construct new Sign_Detection from values
    pub fn new(speed_lim_nav_cam: u8, speed_lim_nav_cam2: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_speed_lim_nav_cam(speed_lim_nav_cam)?;
        res.set_speed_lim_nav_cam2(speed_lim_nav_cam2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// SpeedLim_Nav_Cam
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: "km/h / mph"
    /// - Receivers: XXX
    #[inline(always)]
    pub fn speed_lim_nav_cam(&self) -> u8 {
        self.speed_lim_nav_cam_raw()
    }
    
    /// Get raw value of SpeedLim_Nav_Cam
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn speed_lim_nav_cam_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of SpeedLim_Nav_Cam
    #[inline(always)]
    pub fn set_speed_lim_nav_cam(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1260 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// SpeedLim_Nav_Cam2
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: "km/h / mph"
    /// - Receivers: XXX
    #[inline(always)]
    pub fn speed_lim_nav_cam2(&self) -> u8 {
        self.speed_lim_nav_cam2_raw()
    }
    
    /// Get raw value of SpeedLim_Nav_Cam2
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn speed_lim_nav_cam2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of SpeedLim_Nav_Cam2
    #[inline(always)]
    pub fn set_speed_lim_nav_cam2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1260 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for SignDetection {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for SignDetection {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("SignDetection")
                .field("speed_lim_nav_cam", &self.speed_lim_nav_cam())
                .field("speed_lim_nav_cam2", &self.speed_lim_nav_cam2())
            .finish()
        } else {
            f.debug_tuple("SignDetection").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for SignDetection {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let speed_lim_nav_cam = u.int_in_range(0..=255)?;
        let speed_lim_nav_cam2 = u.int_in_range(0..=255)?;
        SignDetection::new(speed_lim_nav_cam,speed_lim_nav_cam2).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// TMU_GW_PE_01
///
/// - ID: 1492 (0x5d4)
/// - Size: 8 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct TmuGwPe01 {
    raw: [u8; 8],
}

impl TmuGwPe01 {
    pub const MESSAGE_ID: u32 = 1492;
    
    pub const TMU_IVR_ACTIVITY_MIN: u8 = 0_u8;
    pub const TMU_IVR_ACTIVITY_MAX: u8 = 3_u8;
    pub const TMU_PHONE_ACTIVITY_MIN: u8 = 0_u8;
    pub const TMU_PHONE_ACTIVITY_MAX: u8 = 3_u8;
    
    /// Construct new TMU_GW_PE_01 from values
    pub fn new(tmu_ivr_activity: u8, tmu_phone_activity: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_tmu_ivr_activity(tmu_ivr_activity)?;
        res.set_tmu_phone_activity(tmu_phone_activity)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// TMU_IVRActivity
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: DATC
    #[inline(always)]
    pub fn tmu_ivr_activity(&self) -> u8 {
        self.tmu_ivr_activity_raw()
    }
    
    /// Get raw value of TMU_IVRActivity
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tmu_ivr_activity_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of TMU_IVRActivity
    #[inline(always)]
    pub fn set_tmu_ivr_activity(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1492 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// TMU_PhoneActivity
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: DATC
    #[inline(always)]
    pub fn tmu_phone_activity(&self) -> u8 {
        self.tmu_phone_activity_raw()
    }
    
    /// Get raw value of TMU_PhoneActivity
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tmu_phone_activity_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of TMU_PhoneActivity
    #[inline(always)]
    pub fn set_tmu_phone_activity(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1492 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for TmuGwPe01 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for TmuGwPe01 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("TmuGwPe01")
                .field("tmu_ivr_activity", &self.tmu_ivr_activity())
                .field("tmu_phone_activity", &self.tmu_phone_activity())
            .finish()
        } else {
            f.debug_tuple("TmuGwPe01").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for TmuGwPe01 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let tmu_ivr_activity = u.int_in_range(0..=3)?;
        let tmu_phone_activity = u.int_in_range(0..=3)?;
        TmuGwPe01::new(tmu_ivr_activity,tmu_phone_activity).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// HU_DATC_PE_00
///
/// - ID: 1491 (0x5d3)
/// - Size: 8 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct HuDatcPe00 {
    raw: [u8; 8],
}

impl HuDatcPe00 {
    pub const MESSAGE_ID: u32 = 1491;
    
    pub const HU_VR_ACTIVITY_MIN: u8 = 0_u8;
    pub const HU_VR_ACTIVITY_MAX: u8 = 3_u8;
    pub const HU_PHONE_ACTIVITY_MIN: u8 = 0_u8;
    pub const HU_PHONE_ACTIVITY_MAX: u8 = 3_u8;
    pub const BLOWER_NOISE_CONTROL_MIN: u8 = 0_u8;
    pub const BLOWER_NOISE_CONTROL_MAX: u8 = 3_u8;
    
    /// Construct new HU_DATC_PE_00 from values
    pub fn new(hu_vr_activity: u8, hu_phone_activity: u8, blower_noise_control: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_hu_vr_activity(hu_vr_activity)?;
        res.set_hu_phone_activity(hu_phone_activity)?;
        res.set_blower_noise_control(blower_noise_control)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// HU_VRActivity
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: DATC
    #[inline(always)]
    pub fn hu_vr_activity(&self) -> u8 {
        self.hu_vr_activity_raw()
    }
    
    /// Get raw value of HU_VRActivity
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_vr_activity_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_VRActivity
    #[inline(always)]
    pub fn set_hu_vr_activity(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1491 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// HU_PhoneActivity
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: DATC
    #[inline(always)]
    pub fn hu_phone_activity(&self) -> u8 {
        self.hu_phone_activity_raw()
    }
    
    /// Get raw value of HU_PhoneActivity
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_phone_activity_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_PhoneActivity
    #[inline(always)]
    pub fn set_hu_phone_activity(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1491 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// BlowerNoiseControl
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: DATC
    #[inline(always)]
    pub fn blower_noise_control(&self) -> u8 {
        self.blower_noise_control_raw()
    }
    
    /// Get raw value of BlowerNoiseControl
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn blower_noise_control_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BlowerNoiseControl
    #[inline(always)]
    pub fn set_blower_noise_control(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1491 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for HuDatcPe00 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for HuDatcPe00 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("HuDatcPe00")
                .field("hu_vr_activity", &self.hu_vr_activity())
                .field("hu_phone_activity", &self.hu_phone_activity())
                .field("blower_noise_control", &self.blower_noise_control())
            .finish()
        } else {
            f.debug_tuple("HuDatcPe00").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for HuDatcPe00 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let hu_vr_activity = u.int_in_range(0..=3)?;
        let hu_phone_activity = u.int_in_range(0..=3)?;
        let blower_noise_control = u.int_in_range(0..=3)?;
        HuDatcPe00::new(hu_vr_activity,hu_phone_activity,blower_noise_control).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// HU_DATC_E_02
///
/// - ID: 1490 (0x5d2)
/// - Size: 8 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct HuDatcE02 {
    raw: [u8; 8],
}

impl HuDatcE02 {
    pub const MESSAGE_ID: u32 = 1490;
    
    pub const HU_DATC_REAR_ON_OFF_SET_MIN: u8 = 0_u8;
    pub const HU_DATC_REAR_ON_OFF_SET_MAX: u8 = 3_u8;
    pub const HU_DATC_ADS_ON_OFF_SET_MIN: u8 = 0_u8;
    pub const HU_DATC_ADS_ON_OFF_SET_MAX: u8 = 3_u8;
    
    /// Construct new HU_DATC_E_02 from values
    pub fn new(hu_datc_rear_on_off_set: u8, hu_datc_ads_on_off_set: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_hu_datc_rear_on_off_set(hu_datc_rear_on_off_set)?;
        res.set_hu_datc_ads_on_off_set(hu_datc_ads_on_off_set)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// HU_DATC_RearOnOffSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: DATC
    #[inline(always)]
    pub fn hu_datc_rear_on_off_set(&self) -> u8 {
        self.hu_datc_rear_on_off_set_raw()
    }
    
    /// Get raw value of HU_DATC_RearOnOffSet
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_datc_rear_on_off_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_DATC_RearOnOffSet
    #[inline(always)]
    pub fn set_hu_datc_rear_on_off_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1490 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// HU_DATC_ADSOnOffSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: DATC
    #[inline(always)]
    pub fn hu_datc_ads_on_off_set(&self) -> u8 {
        self.hu_datc_ads_on_off_set_raw()
    }
    
    /// Get raw value of HU_DATC_ADSOnOffSet
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_datc_ads_on_off_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_DATC_ADSOnOffSet
    #[inline(always)]
    pub fn set_hu_datc_ads_on_off_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1490 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for HuDatcE02 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for HuDatcE02 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("HuDatcE02")
                .field("hu_datc_rear_on_off_set", &self.hu_datc_rear_on_off_set())
                .field("hu_datc_ads_on_off_set", &self.hu_datc_ads_on_off_set())
            .finish()
        } else {
            f.debug_tuple("HuDatcE02").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for HuDatcE02 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let hu_datc_rear_on_off_set = u.int_in_range(0..=3)?;
        let hu_datc_ads_on_off_set = u.int_in_range(0..=3)?;
        HuDatcE02::new(hu_datc_rear_on_off_set,hu_datc_ads_on_off_set).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EMS21
///
/// - ID: 1479 (0x5c7)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct Ems21 {
    raw: [u8; 8],
}

impl Ems21 {
    pub const MESSAGE_ID: u32 = 1479;
    
    pub const SCR_LEVEL_WARN_MIN: u8 = 0_u8;
    pub const SCR_LEVEL_WARN_MAX: u8 = 4_u8;
    pub const SCR_SYS_ERROR_WARN_MIN: u8 = 0_u8;
    pub const SCR_SYS_ERROR_WARN_MAX: u8 = 7_u8;
    pub const SCR_INDUCEMENT_EXIT_COND_MIN: u8 = 0_u8;
    pub const SCR_INDUCEMENT_EXIT_COND_MAX: u8 = 3_u8;
    pub const SCR_UREA_LEVEL_MIN: f32 = 0_f32;
    pub const SCR_UREA_LEVEL_MAX: f32 = 100_f32;
    pub const SCR_NO_REMAINING_RESTARTS_MIN: u8 = 0_u8;
    pub const SCR_NO_REMAINING_RESTARTS_MAX: u8 = 255_u8;
    pub const SCR_REMAINING_DISTANCE_MIN: u16 = 0_u16;
    pub const SCR_REMAINING_DISTANCE_MAX: u16 = 25000_u16;
    
    /// Construct new EMS21 from values
    pub fn new(scr_level_warn_lamp: bool, scr_level_warn: u8, scr_sys_error_warn: u8, scr_system_warn_lamp: bool, scr_inducement_exit_cond: u8, scr_urea_level: f32, scr_no_remaining_restarts: u8, scr_remaining_distance: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_scr_level_warn_lamp(scr_level_warn_lamp)?;
        res.set_scr_level_warn(scr_level_warn)?;
        res.set_scr_sys_error_warn(scr_sys_error_warn)?;
        res.set_scr_system_warn_lamp(scr_system_warn_lamp)?;
        res.set_scr_inducement_exit_cond(scr_inducement_exit_cond)?;
        res.set_scr_urea_level(scr_urea_level)?;
        res.set_scr_no_remaining_restarts(scr_no_remaining_restarts)?;
        res.set_scr_remaining_distance(scr_remaining_distance)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// SCR_LEVEL_WARN_LAMP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn scr_level_warn_lamp(&self) -> bool {
        self.scr_level_warn_lamp_raw()
    }
    
    /// Get raw value of SCR_LEVEL_WARN_LAMP
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn scr_level_warn_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of SCR_LEVEL_WARN_LAMP
    #[inline(always)]
    pub fn set_scr_level_warn_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// SCR_LEVEL_WARN
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn scr_level_warn(&self) -> u8 {
        self.scr_level_warn_raw()
    }
    
    /// Get raw value of SCR_LEVEL_WARN
    ///
    /// - Start bit: 1
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn scr_level_warn_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[1..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of SCR_LEVEL_WARN
    #[inline(always)]
    pub fn set_scr_level_warn(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1479 });
        }
        self.raw.view_bits_mut::<Lsb0>()[1..4].store_le(value);
        Ok(())
    }
    
    /// SCR_SYS_ERROR_WARN
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn scr_sys_error_warn(&self) -> u8 {
        self.scr_sys_error_warn_raw()
    }
    
    /// Get raw value of SCR_SYS_ERROR_WARN
    ///
    /// - Start bit: 4
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn scr_sys_error_warn_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of SCR_SYS_ERROR_WARN
    #[inline(always)]
    pub fn set_scr_sys_error_warn(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1479 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..7].store_le(value);
        Ok(())
    }
    
    /// SCR_SYSTEM_WARN_LAMP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn scr_system_warn_lamp(&self) -> bool {
        self.scr_system_warn_lamp_raw()
    }
    
    /// Get raw value of SCR_SYSTEM_WARN_LAMP
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn scr_system_warn_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of SCR_SYSTEM_WARN_LAMP
    #[inline(always)]
    pub fn set_scr_system_warn_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// SCR_INDUCEMENT_EXIT_COND
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn scr_inducement_exit_cond(&self) -> u8 {
        self.scr_inducement_exit_cond_raw()
    }
    
    /// Get raw value of SCR_INDUCEMENT_EXIT_COND
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn scr_inducement_exit_cond_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of SCR_INDUCEMENT_EXIT_COND
    #[inline(always)]
    pub fn set_scr_inducement_exit_cond(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1479 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// SCR_UREA_LEVEL
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: CLU
    #[inline(always)]
    pub fn scr_urea_level(&self) -> f32 {
        self.scr_urea_level_raw()
    }
    
    /// Get raw value of SCR_UREA_LEVEL
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn scr_urea_level_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of SCR_UREA_LEVEL
    #[inline(always)]
    pub fn set_scr_urea_level(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1479 });
        }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// SCR_NO_REMAINING_RESTARTS
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn scr_no_remaining_restarts(&self) -> u8 {
        self.scr_no_remaining_restarts_raw()
    }
    
    /// Get raw value of SCR_NO_REMAINING_RESTARTS
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn scr_no_remaining_restarts_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of SCR_NO_REMAINING_RESTARTS
    #[inline(always)]
    pub fn set_scr_no_remaining_restarts(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1479 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// SCR_REMAINING_DISTANCE
    ///
    /// - Min: 0
    /// - Max: 25000
    /// - Unit: "km"
    /// - Receivers: CLU
    #[inline(always)]
    pub fn scr_remaining_distance(&self) -> u16 {
        self.scr_remaining_distance_raw()
    }
    
    /// Get raw value of SCR_REMAINING_DISTANCE
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn scr_remaining_distance_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<u16>();
        
        signal
    }
    
    /// Set value of SCR_REMAINING_DISTANCE
    #[inline(always)]
    pub fn set_scr_remaining_distance(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 25000_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1479 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ems21 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ems21 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ems21")
                .field("scr_level_warn_lamp", &self.scr_level_warn_lamp())
                .field("scr_level_warn", &self.scr_level_warn())
                .field("scr_sys_error_warn", &self.scr_sys_error_warn())
                .field("scr_system_warn_lamp", &self.scr_system_warn_lamp())
                .field("scr_inducement_exit_cond", &self.scr_inducement_exit_cond())
                .field("scr_urea_level", &self.scr_urea_level())
                .field("scr_no_remaining_restarts", &self.scr_no_remaining_restarts())
                .field("scr_remaining_distance", &self.scr_remaining_distance())
            .finish()
        } else {
            f.debug_tuple("Ems21").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ems21 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let scr_level_warn_lamp = u.int_in_range(0..=1)? == 1;
        let scr_level_warn = u.int_in_range(0..=4)?;
        let scr_sys_error_warn = u.int_in_range(0..=7)?;
        let scr_system_warn_lamp = u.int_in_range(0..=1)? == 1;
        let scr_inducement_exit_cond = u.int_in_range(0..=3)?;
        let scr_urea_level = u.float_in_range(0_f32..=100_f32)?;
        let scr_no_remaining_restarts = u.int_in_range(0..=255)?;
        let scr_remaining_distance = u.int_in_range(0..=25000)?;
        Ems21::new(scr_level_warn_lamp,scr_level_warn,scr_sys_error_warn,scr_system_warn_lamp,scr_inducement_exit_cond,scr_urea_level,scr_no_remaining_restarts,scr_remaining_distance).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// GW_Warning_PE
///
/// - ID: 1472 (0x5c0)
/// - Size: 8 bytes
/// - Transmitter: BCM
#[derive(Clone, Copy)]
pub struct GwWarningPe {
    raw: [u8; 8],
}

impl GwWarningPe {
    pub const MESSAGE_ID: u32 = 1472;
    
    pub const AUDIO_VOLUME_DOWN_MIN: u8 = 0_u8;
    pub const AUDIO_VOLUME_DOWN_MAX: u8 = 3_u8;
    pub const PAS_SPKR_FLH_ALARM_MIN: u8 = 0_u8;
    pub const PAS_SPKR_FLH_ALARM_MAX: u8 = 3_u8;
    pub const PAS_SPKR_FCNT_ALARM_MIN: u8 = 0_u8;
    pub const PAS_SPKR_FCNT_ALARM_MAX: u8 = 3_u8;
    pub const PAS_SPKR_FRH_ALARM_MIN: u8 = 0_u8;
    pub const PAS_SPKR_FRH_ALARM_MAX: u8 = 3_u8;
    pub const PAS_SPKR_RLH_ALARM_MIN: u8 = 0_u8;
    pub const PAS_SPKR_RLH_ALARM_MAX: u8 = 3_u8;
    pub const PAS_SPKR_RCNT_ALARM_MIN: u8 = 0_u8;
    pub const PAS_SPKR_RCNT_ALARM_MAX: u8 = 3_u8;
    pub const PAS_SPKR_RRH_ALARM_MIN: u8 = 0_u8;
    pub const PAS_SPKR_RRH_ALARM_MAX: u8 = 3_u8;
    
    /// Construct new GW_Warning_PE from values
    pub fn new(audio_volume_down: u8, pas_spkr_flh_alarm: u8, pas_spkr_fcnt_alarm: u8, pas_spkr_frh_alarm: u8, pas_spkr_rlh_alarm: u8, pas_spkr_rcnt_alarm: u8, pas_spkr_rrh_alarm: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_audio_volume_down(audio_volume_down)?;
        res.set_pas_spkr_flh_alarm(pas_spkr_flh_alarm)?;
        res.set_pas_spkr_fcnt_alarm(pas_spkr_fcnt_alarm)?;
        res.set_pas_spkr_frh_alarm(pas_spkr_frh_alarm)?;
        res.set_pas_spkr_rlh_alarm(pas_spkr_rlh_alarm)?;
        res.set_pas_spkr_rcnt_alarm(pas_spkr_rcnt_alarm)?;
        res.set_pas_spkr_rrh_alarm(pas_spkr_rrh_alarm)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Audio_VolumeDown
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn audio_volume_down(&self) -> u8 {
        self.audio_volume_down_raw()
    }
    
    /// Get raw value of Audio_VolumeDown
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn audio_volume_down_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Audio_VolumeDown
    #[inline(always)]
    pub fn set_audio_volume_down(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1472 });
        }
        self.raw.view_bits_mut::<Lsb0>()[38..40].store_le(value);
        Ok(())
    }
    
    /// Pas_Spkr_Flh_Alarm
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn pas_spkr_flh_alarm(&self) -> u8 {
        self.pas_spkr_flh_alarm_raw()
    }
    
    /// Get raw value of Pas_Spkr_Flh_Alarm
    ///
    /// - Start bit: 48
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pas_spkr_flh_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..50].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Pas_Spkr_Flh_Alarm
    #[inline(always)]
    pub fn set_pas_spkr_flh_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1472 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..50].store_le(value);
        Ok(())
    }
    
    /// Pas_Spkr_Fcnt_Alarm
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn pas_spkr_fcnt_alarm(&self) -> u8 {
        self.pas_spkr_fcnt_alarm_raw()
    }
    
    /// Get raw value of Pas_Spkr_Fcnt_Alarm
    ///
    /// - Start bit: 50
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pas_spkr_fcnt_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[50..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Pas_Spkr_Fcnt_Alarm
    #[inline(always)]
    pub fn set_pas_spkr_fcnt_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1472 });
        }
        self.raw.view_bits_mut::<Lsb0>()[50..52].store_le(value);
        Ok(())
    }
    
    /// Pas_Spkr_Frh_Alarm
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn pas_spkr_frh_alarm(&self) -> u8 {
        self.pas_spkr_frh_alarm_raw()
    }
    
    /// Get raw value of Pas_Spkr_Frh_Alarm
    ///
    /// - Start bit: 52
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pas_spkr_frh_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[52..54].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Pas_Spkr_Frh_Alarm
    #[inline(always)]
    pub fn set_pas_spkr_frh_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1472 });
        }
        self.raw.view_bits_mut::<Lsb0>()[52..54].store_le(value);
        Ok(())
    }
    
    /// Pas_Spkr_Rlh_Alarm
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, PGS
    #[inline(always)]
    pub fn pas_spkr_rlh_alarm(&self) -> u8 {
        self.pas_spkr_rlh_alarm_raw()
    }
    
    /// Get raw value of Pas_Spkr_Rlh_Alarm
    ///
    /// - Start bit: 56
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pas_spkr_rlh_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..58].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Pas_Spkr_Rlh_Alarm
    #[inline(always)]
    pub fn set_pas_spkr_rlh_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1472 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..58].store_le(value);
        Ok(())
    }
    
    /// Pas_Spkr_Rcnt_Alarm
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn pas_spkr_rcnt_alarm(&self) -> u8 {
        self.pas_spkr_rcnt_alarm_raw()
    }
    
    /// Get raw value of Pas_Spkr_Rcnt_Alarm
    ///
    /// - Start bit: 58
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pas_spkr_rcnt_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[58..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Pas_Spkr_Rcnt_Alarm
    #[inline(always)]
    pub fn set_pas_spkr_rcnt_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1472 });
        }
        self.raw.view_bits_mut::<Lsb0>()[58..60].store_le(value);
        Ok(())
    }
    
    /// Pas_Spkr_Rrh_Alarm
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, PGS
    #[inline(always)]
    pub fn pas_spkr_rrh_alarm(&self) -> u8 {
        self.pas_spkr_rrh_alarm_raw()
    }
    
    /// Get raw value of Pas_Spkr_Rrh_Alarm
    ///
    /// - Start bit: 60
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pas_spkr_rrh_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..62].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Pas_Spkr_Rrh_Alarm
    #[inline(always)]
    pub fn set_pas_spkr_rrh_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1472 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..62].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for GwWarningPe {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for GwWarningPe {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("GwWarningPe")
                .field("audio_volume_down", &self.audio_volume_down())
                .field("pas_spkr_flh_alarm", &self.pas_spkr_flh_alarm())
                .field("pas_spkr_fcnt_alarm", &self.pas_spkr_fcnt_alarm())
                .field("pas_spkr_frh_alarm", &self.pas_spkr_frh_alarm())
                .field("pas_spkr_rlh_alarm", &self.pas_spkr_rlh_alarm())
                .field("pas_spkr_rcnt_alarm", &self.pas_spkr_rcnt_alarm())
                .field("pas_spkr_rrh_alarm", &self.pas_spkr_rrh_alarm())
            .finish()
        } else {
            f.debug_tuple("GwWarningPe").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for GwWarningPe {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let audio_volume_down = u.int_in_range(0..=3)?;
        let pas_spkr_flh_alarm = u.int_in_range(0..=3)?;
        let pas_spkr_fcnt_alarm = u.int_in_range(0..=3)?;
        let pas_spkr_frh_alarm = u.int_in_range(0..=3)?;
        let pas_spkr_rlh_alarm = u.int_in_range(0..=3)?;
        let pas_spkr_rcnt_alarm = u.int_in_range(0..=3)?;
        let pas_spkr_rrh_alarm = u.int_in_range(0..=3)?;
        GwWarningPe::new(audio_volume_down,pas_spkr_flh_alarm,pas_spkr_fcnt_alarm,pas_spkr_frh_alarm,pas_spkr_rlh_alarm,pas_spkr_rcnt_alarm,pas_spkr_rrh_alarm).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// CAL_SAS11
///
/// - ID: 1984 (0x7c0)
/// - Size: 2 bytes
/// - Transmitter: ESC
#[derive(Clone, Copy)]
pub struct CalSas11 {
    raw: [u8; 2],
}

impl CalSas11 {
    pub const MESSAGE_ID: u32 = 1984;
    
    pub const CCW_MIN: u8 = 0_u8;
    pub const CCW_MAX: u8 = 15_u8;
    pub const SAS_CID_MIN: u16 = 0_u16;
    pub const SAS_CID_MAX: u16 = 2047_u16;
    
    /// Construct new CAL_SAS11 from values
    pub fn new(ccw: u8, sas_cid: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ccw(ccw)?;
        res.set_sas_cid(sas_cid)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// CCW
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: SAS
    #[inline(always)]
    pub fn ccw(&self) -> u8 {
        self.ccw_raw()
    }
    
    /// Get raw value of CCW
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ccw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CCW
    #[inline(always)]
    pub fn set_ccw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1984 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..4].store_le(value);
        Ok(())
    }
    
    /// SAS_CID
    ///
    /// - Min: 0
    /// - Max: 2047
    /// - Unit: ""
    /// - Receivers: SAS
    #[inline(always)]
    pub fn sas_cid(&self) -> u16 {
        self.sas_cid_raw()
    }
    
    /// Get raw value of SAS_CID
    ///
    /// - Start bit: 4
    /// - Signal size: 11 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn sas_cid_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[4..15].load_le::<u16>();
        
        signal
    }
    
    /// Set value of SAS_CID
    #[inline(always)]
    pub fn set_sas_cid(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 2047_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1984 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..15].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for CalSas11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for CalSas11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("CalSas11")
                .field("ccw", &self.ccw())
                .field("sas_cid", &self.sas_cid())
            .finish()
        } else {
            f.debug_tuple("CalSas11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for CalSas11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ccw = u.int_in_range(0..=15)?;
        let sas_cid = u.int_in_range(0..=2047)?;
        CalSas11::new(ccw,sas_cid).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// CLU12
///
/// - ID: 1456 (0x5b0)
/// - Size: 4 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct Clu12 {
    raw: [u8; 4],
}

impl Clu12 {
    pub const MESSAGE_ID: u32 = 1456;
    
    pub const CF_CLU_ODOMETER_MIN: f32 = 0_f32;
    pub const CF_CLU_ODOMETER_MAX: f32 = 1677721.4_f32;
    
    /// Construct new CLU12 from values
    pub fn new(cf_clu_odometer: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_cf_clu_odometer(cf_clu_odometer)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 4] {
        &self.raw
    }
    
    /// CF_Clu_Odometer
    ///
    /// - Min: 0
    /// - Max: 1677721.4
    /// - Unit: "km"
    /// - Receivers: _4WD, AAF, BCM, CUBIS, EMS, EPB, IBOX, LDWS_LKAS, SCC, TPMS
    #[inline(always)]
    pub fn cf_clu_odometer(&self) -> f32 {
        self.cf_clu_odometer_raw()
    }
    
    /// Get raw value of CF_Clu_Odometer
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_odometer_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CF_Clu_Odometer
    #[inline(always)]
    pub fn set_cf_clu_odometer(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1677721.4_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1456 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Clu12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Clu12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Clu12")
                .field("cf_clu_odometer", &self.cf_clu_odometer())
            .finish()
        } else {
            f.debug_tuple("Clu12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Clu12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_clu_odometer = u.float_in_range(0_f32..=1677721.4_f32)?;
        Clu12::new(cf_clu_odometer).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// SAS11
///
/// - ID: 688 (0x2b0)
/// - Size: 5 bytes
/// - Transmitter: MDPS
#[derive(Clone, Copy)]
pub struct Sas11 {
    raw: [u8; 5],
}

impl Sas11 {
    pub const MESSAGE_ID: u32 = 688;
    
    pub const SAS_ANGLE_MIN: f32 = -3276.8_f32;
    pub const SAS_ANGLE_MAX: f32 = 3276.7_f32;
    pub const SAS_SPEED_MIN: f32 = 0_f32;
    pub const SAS_SPEED_MAX: f32 = 1016_f32;
    pub const SAS_STAT_MIN: u8 = 0_u8;
    pub const SAS_STAT_MAX: u8 = 255_u8;
    pub const MSG_COUNT_MIN: u8 = 0_u8;
    pub const MSG_COUNT_MAX: u8 = 15_u8;
    pub const CHECK_SUM_MIN: u8 = 0_u8;
    pub const CHECK_SUM_MAX: u8 = 15_u8;
    
    /// Construct new SAS11 from values
    pub fn new(sas_angle: f32, sas_speed: f32, sas_stat: u8, msg_count: u8, check_sum: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 5] };
        res.set_sas_angle(sas_angle)?;
        res.set_sas_speed(sas_speed)?;
        res.set_sas_stat(sas_stat)?;
        res.set_msg_count(msg_count)?;
        res.set_check_sum(check_sum)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 5] {
        &self.raw
    }
    
    /// SAS_Angle
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "Deg"
    /// - Receivers: _4WD, ACU, AFLS, AVM, CLU, ECS, EMS, ESC, IBOX, LCA, LDWS_LKAS, PGS, PSB, SCC, SPAS, TCU, _4WD, ACU, AFLS, AVM, BCM, CLU, ECS, EMS, ESC, IBOX, LCA, LDWS_LKAS, PGS, PSB, SCC, SPAS, TCU
    #[inline(always)]
    pub fn sas_angle(&self) -> f32 {
        self.sas_angle_raw()
    }
    
    /// Get raw value of SAS_Angle
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn sas_angle_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of SAS_Angle
    #[inline(always)]
    pub fn set_sas_angle(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 688 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
    /// SAS_Speed
    ///
    /// - Min: 0
    /// - Max: 1016
    /// - Unit: ""
    /// - Receivers: AFLS, ECS, ESC, IBOX, LDWS_LKAS, SCC, SPAS, TCU, AFLS, ECS, ESC, IBOX, LDWS_LKAS, SCC, SPAS, TCU
    #[inline(always)]
    pub fn sas_speed(&self) -> f32 {
        self.sas_speed_raw()
    }
    
    /// Get raw value of SAS_Speed
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn sas_speed_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of SAS_Speed
    #[inline(always)]
    pub fn set_sas_speed(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1016_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 688 });
        }
        let factor = 4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// SAS_Stat
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: ECS, ESC, IBOX, LDWS_LKAS, PSB, SCC, SPAS, TCU, ECS, ESC, IBOX, LDWS_LKAS, PSB, SCC, SPAS, TCU
    #[inline(always)]
    pub fn sas_stat(&self) -> u8 {
        self.sas_stat_raw()
    }
    
    /// Get raw value of SAS_Stat
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn sas_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of SAS_Stat
    #[inline(always)]
    pub fn set_sas_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 688 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// MsgCount
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: ECS, ESC, IBOX, LDWS_LKAS, PSB, SCC, SPAS, ECS, ESC, IBOX, LDWS_LKAS, PSB, SCC, SPAS
    #[inline(always)]
    pub fn msg_count(&self) -> u8 {
        self.msg_count_raw()
    }
    
    /// Get raw value of MsgCount
    ///
    /// - Start bit: 32
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn msg_count_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of MsgCount
    #[inline(always)]
    pub fn set_msg_count(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 688 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..36].store_le(value);
        Ok(())
    }
    
    /// CheckSum
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: ECS, EMS, ESC, IBOX, LDWS_LKAS, PSB, SCC, SPAS, ECS, EMS, ESC, IBOX, LDWS_LKAS, PSB, SCC, SPAS
    #[inline(always)]
    pub fn check_sum(&self) -> u8 {
        self.check_sum_raw()
    }
    
    /// Get raw value of CheckSum
    ///
    /// - Start bit: 36
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn check_sum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[36..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CheckSum
    #[inline(always)]
    pub fn set_check_sum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 688 });
        }
        self.raw.view_bits_mut::<Lsb0>()[36..40].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Sas11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 5 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 5];
        raw.copy_from_slice(&payload[..5]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Sas11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Sas11")
                .field("sas_angle", &self.sas_angle())
                .field("sas_speed", &self.sas_speed())
                .field("sas_stat", &self.sas_stat())
                .field("msg_count", &self.msg_count())
                .field("check_sum", &self.check_sum())
            .finish()
        } else {
            f.debug_tuple("Sas11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Sas11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let sas_angle = u.float_in_range(-3276.8_f32..=3276.7_f32)?;
        let sas_speed = u.float_in_range(0_f32..=1016_f32)?;
        let sas_stat = u.int_in_range(0..=255)?;
        let msg_count = u.int_in_range(0..=15)?;
        let check_sum = u.int_in_range(0..=15)?;
        Sas11::new(sas_angle,sas_speed,sas_stat,msg_count,check_sum).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ACU12
///
/// - ID: 1441 (0x5a1)
/// - Size: 8 bytes
/// - Transmitter: ACU
#[derive(Clone, Copy)]
pub struct Acu12 {
    raw: [u8; 8],
}

impl Acu12 {
    pub const MESSAGE_ID: u32 = 1441;
    
    pub const CR_ACU_SN_MIN: u64 = 0_u64;
    pub const CR_ACU_SN_MAX: u64 = 0_u64;
    
    /// Construct new ACU12 from values
    pub fn new(cr_acu_sn: u64) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cr_acu_sn(cr_acu_sn)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CR_Acu_SN
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: ODS
    #[inline(always)]
    pub fn cr_acu_sn(&self) -> u64 {
        self.cr_acu_sn_raw()
    }
    
    /// Get raw value of CR_Acu_SN
    ///
    /// - Start bit: 0
    /// - Signal size: 64 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_acu_sn_raw(&self) -> u64 {
        let signal = self.raw.view_bits::<Lsb0>()[0..64].load_le::<u64>();
        
        signal
    }
    
    /// Set value of CR_Acu_SN
    #[inline(always)]
    pub fn set_cr_acu_sn(&mut self, value: u64) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u64 || 0_u64 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1441 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Acu12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Acu12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Acu12")
                .field("cr_acu_sn", &self.cr_acu_sn())
            .finish()
        } else {
            f.debug_tuple("Acu12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Acu12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cr_acu_sn = u.int_in_range(0..=0)?;
        Acu12::new(cr_acu_sn).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ACU11
///
/// - ID: 1440 (0x5a0)
/// - Size: 8 bytes
/// - Transmitter: ACU
#[derive(Clone, Copy)]
pub struct Acu11 {
    raw: [u8; 8],
}

impl Acu11 {
    pub const MESSAGE_ID: u32 = 1440;
    
    pub const CF_SWL_IND_MIN: u8 = 0_u8;
    pub const CF_SWL_IND_MAX: u8 = 3_u8;
    pub const CF_ACU_FLT_STAT_MIN: u8 = 0_u8;
    pub const CF_ACU_FLT_STAT_MAX: u8 = 3_u8;
    pub const CF_ACU_EXT_OF_SAB_MIN: u8 = 0_u8;
    pub const CF_ACU_EXT_OF_SAB_MAX: u8 = 3_u8;
    pub const CF_ACU_DTC_MIN: u16 = 0_u16;
    pub const CF_ACU_DTC_MAX: u16 = 65535_u16;
    pub const CF_ACU_NUM_OF_FLT_MIN: u8 = 0_u8;
    pub const CF_ACU_NUM_OF_FLT_MAX: u8 = 255_u8;
    
    /// Construct new ACU11 from values
    pub fn new(cf_ods_sn_rcv: bool, cf_ods_id_rcv: bool, cf_ods_rz_req: bool, cf_abg_dep_inh_ent: bool, cf_abg_dep_ent: bool, cf_pas_bkl_flt_stat: bool, cf_dri_bkl_flt_stat: bool, cf_pas_bkl_stat: bool, cf_dri_bkl_stat: bool, cf_swl_ind: u8, cf_acu_flt_stat: u8, cf_acu_ext_of_sab: u8, cf_acu_dtc: u16, cf_acu_num_of_flt: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_ods_sn_rcv(cf_ods_sn_rcv)?;
        res.set_cf_ods_id_rcv(cf_ods_id_rcv)?;
        res.set_cf_ods_rz_req(cf_ods_rz_req)?;
        res.set_cf_abg_dep_inh_ent(cf_abg_dep_inh_ent)?;
        res.set_cf_abg_dep_ent(cf_abg_dep_ent)?;
        res.set_cf_pas_bkl_flt_stat(cf_pas_bkl_flt_stat)?;
        res.set_cf_dri_bkl_flt_stat(cf_dri_bkl_flt_stat)?;
        res.set_cf_pas_bkl_stat(cf_pas_bkl_stat)?;
        res.set_cf_dri_bkl_stat(cf_dri_bkl_stat)?;
        res.set_cf_swl_ind(cf_swl_ind)?;
        res.set_cf_acu_flt_stat(cf_acu_flt_stat)?;
        res.set_cf_acu_ext_of_sab(cf_acu_ext_of_sab)?;
        res.set_cf_acu_dtc(cf_acu_dtc)?;
        res.set_cf_acu_num_of_flt(cf_acu_num_of_flt)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Ods_SNRcv
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ODS
    #[inline(always)]
    pub fn cf_ods_sn_rcv(&self) -> bool {
        self.cf_ods_sn_rcv_raw()
    }
    
    /// Get raw value of CF_Ods_SNRcv
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ods_sn_rcv_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ods_SNRcv
    #[inline(always)]
    pub fn set_cf_ods_sn_rcv(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// CF_Ods_IDRcv
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ODS
    #[inline(always)]
    pub fn cf_ods_id_rcv(&self) -> bool {
        self.cf_ods_id_rcv_raw()
    }
    
    /// Get raw value of CF_Ods_IDRcv
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ods_id_rcv_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ods_IDRcv
    #[inline(always)]
    pub fn set_cf_ods_id_rcv(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// CF_Ods_RZReq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ODS
    #[inline(always)]
    pub fn cf_ods_rz_req(&self) -> bool {
        self.cf_ods_rz_req_raw()
    }
    
    /// Get raw value of CF_Ods_RZReq
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ods_rz_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ods_RZReq
    #[inline(always)]
    pub fn set_cf_ods_rz_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// CF_Abg_DepInhEnt
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ODS
    #[inline(always)]
    pub fn cf_abg_dep_inh_ent(&self) -> bool {
        self.cf_abg_dep_inh_ent_raw()
    }
    
    /// Get raw value of CF_Abg_DepInhEnt
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_abg_dep_inh_ent_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Abg_DepInhEnt
    #[inline(always)]
    pub fn set_cf_abg_dep_inh_ent(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[6..7].store_le(value);
        Ok(())
    }
    
    /// CF_Abg_DepEnt
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ODS
    #[inline(always)]
    pub fn cf_abg_dep_ent(&self) -> bool {
        self.cf_abg_dep_ent_raw()
    }
    
    /// Get raw value of CF_Abg_DepEnt
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_abg_dep_ent_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Abg_DepEnt
    #[inline(always)]
    pub fn set_cf_abg_dep_ent(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// CF_PasBkl_FltStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ODS, PSB
    #[inline(always)]
    pub fn cf_pas_bkl_flt_stat(&self) -> bool {
        self.cf_pas_bkl_flt_stat_raw()
    }
    
    /// Get raw value of CF_PasBkl_FltStat
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_pas_bkl_flt_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_PasBkl_FltStat
    #[inline(always)]
    pub fn set_cf_pas_bkl_flt_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[28..29].store_le(value);
        Ok(())
    }
    
    /// CF_DriBkl_FltStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ODS, PSB
    #[inline(always)]
    pub fn cf_dri_bkl_flt_stat(&self) -> bool {
        self.cf_dri_bkl_flt_stat_raw()
    }
    
    /// Get raw value of CF_DriBkl_FltStat
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_dri_bkl_flt_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_DriBkl_FltStat
    #[inline(always)]
    pub fn set_cf_dri_bkl_flt_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[29..30].store_le(value);
        Ok(())
    }
    
    /// CF_PasBkl_Stat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: IBOX, ODS, PSB, TMU
    #[inline(always)]
    pub fn cf_pas_bkl_stat(&self) -> bool {
        self.cf_pas_bkl_stat_raw()
    }
    
    /// Get raw value of CF_PasBkl_Stat
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_pas_bkl_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_PasBkl_Stat
    #[inline(always)]
    pub fn set_cf_pas_bkl_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[30..31].store_le(value);
        Ok(())
    }
    
    /// CF_DriBkl_Stat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ODS, PSB
    #[inline(always)]
    pub fn cf_dri_bkl_stat(&self) -> bool {
        self.cf_dri_bkl_stat_raw()
    }
    
    /// Get raw value of CF_DriBkl_Stat
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_dri_bkl_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_DriBkl_Stat
    #[inline(always)]
    pub fn set_cf_dri_bkl_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[31..32].store_le(value);
        Ok(())
    }
    
    /// CF_SWL_Ind
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CUBIS, IBOX
    #[inline(always)]
    pub fn cf_swl_ind(&self) -> u8 {
        self.cf_swl_ind_raw()
    }
    
    /// Get raw value of CF_SWL_Ind
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_swl_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_SWL_Ind
    #[inline(always)]
    pub fn set_cf_swl_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1440 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..34].store_le(value);
        Ok(())
    }
    
    /// CF_Acu_FltStat
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CUBIS, IBOX
    #[inline(always)]
    pub fn cf_acu_flt_stat(&self) -> u8 {
        self.cf_acu_flt_stat_raw()
    }
    
    /// Get raw value of CF_Acu_FltStat
    ///
    /// - Start bit: 34
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_acu_flt_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[34..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Acu_FltStat
    #[inline(always)]
    pub fn set_cf_acu_flt_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1440 });
        }
        self.raw.view_bits_mut::<Lsb0>()[34..36].store_le(value);
        Ok(())
    }
    
    /// CF_Acu_ExtOfSab
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CLU, CUBIS, IBOX
    #[inline(always)]
    pub fn cf_acu_ext_of_sab(&self) -> u8 {
        self.cf_acu_ext_of_sab_raw()
    }
    
    /// Get raw value of CF_Acu_ExtOfSab
    ///
    /// - Start bit: 36
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_acu_ext_of_sab_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[36..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Acu_ExtOfSab
    #[inline(always)]
    pub fn set_cf_acu_ext_of_sab(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1440 });
        }
        self.raw.view_bits_mut::<Lsb0>()[36..38].store_le(value);
        Ok(())
    }
    
    /// CF_Acu_Dtc
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: CUBIS, IBOX
    #[inline(always)]
    pub fn cf_acu_dtc(&self) -> u16 {
        self.cf_acu_dtc_raw()
    }
    
    /// Get raw value of CF_Acu_Dtc
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_acu_dtc_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[40..56].load_le::<u16>();
        
        signal
    }
    
    /// Set value of CF_Acu_Dtc
    #[inline(always)]
    pub fn set_cf_acu_dtc(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1440 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..56].store_le(value);
        Ok(())
    }
    
    /// CF_Acu_NumOfFlt
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CUBIS, IBOX
    #[inline(always)]
    pub fn cf_acu_num_of_flt(&self) -> u8 {
        self.cf_acu_num_of_flt_raw()
    }
    
    /// Get raw value of CF_Acu_NumOfFlt
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_acu_num_of_flt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Acu_NumOfFlt
    #[inline(always)]
    pub fn set_cf_acu_num_of_flt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1440 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Acu11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Acu11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Acu11")
                .field("cf_ods_sn_rcv", &self.cf_ods_sn_rcv())
                .field("cf_ods_id_rcv", &self.cf_ods_id_rcv())
                .field("cf_ods_rz_req", &self.cf_ods_rz_req())
                .field("cf_abg_dep_inh_ent", &self.cf_abg_dep_inh_ent())
                .field("cf_abg_dep_ent", &self.cf_abg_dep_ent())
                .field("cf_pas_bkl_flt_stat", &self.cf_pas_bkl_flt_stat())
                .field("cf_dri_bkl_flt_stat", &self.cf_dri_bkl_flt_stat())
                .field("cf_pas_bkl_stat", &self.cf_pas_bkl_stat())
                .field("cf_dri_bkl_stat", &self.cf_dri_bkl_stat())
                .field("cf_swl_ind", &self.cf_swl_ind())
                .field("cf_acu_flt_stat", &self.cf_acu_flt_stat())
                .field("cf_acu_ext_of_sab", &self.cf_acu_ext_of_sab())
                .field("cf_acu_dtc", &self.cf_acu_dtc())
                .field("cf_acu_num_of_flt", &self.cf_acu_num_of_flt())
            .finish()
        } else {
            f.debug_tuple("Acu11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Acu11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_ods_sn_rcv = u.int_in_range(0..=1)? == 1;
        let cf_ods_id_rcv = u.int_in_range(0..=1)? == 1;
        let cf_ods_rz_req = u.int_in_range(0..=1)? == 1;
        let cf_abg_dep_inh_ent = u.int_in_range(0..=1)? == 1;
        let cf_abg_dep_ent = u.int_in_range(0..=1)? == 1;
        let cf_pas_bkl_flt_stat = u.int_in_range(0..=1)? == 1;
        let cf_dri_bkl_flt_stat = u.int_in_range(0..=1)? == 1;
        let cf_pas_bkl_stat = u.int_in_range(0..=1)? == 1;
        let cf_dri_bkl_stat = u.int_in_range(0..=1)? == 1;
        let cf_swl_ind = u.int_in_range(0..=3)?;
        let cf_acu_flt_stat = u.int_in_range(0..=3)?;
        let cf_acu_ext_of_sab = u.int_in_range(0..=3)?;
        let cf_acu_dtc = u.int_in_range(0..=65535)?;
        let cf_acu_num_of_flt = u.int_in_range(0..=255)?;
        Acu11::new(cf_ods_sn_rcv,cf_ods_id_rcv,cf_ods_rz_req,cf_abg_dep_inh_ent,cf_abg_dep_ent,cf_pas_bkl_flt_stat,cf_dri_bkl_flt_stat,cf_pas_bkl_stat,cf_dri_bkl_stat,cf_swl_ind,cf_acu_flt_stat,cf_acu_ext_of_sab,cf_acu_dtc,cf_acu_num_of_flt).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// AHLS11
///
/// - ID: 1437 (0x59d)
/// - Size: 8 bytes
/// - Transmitter: AHLS
#[derive(Clone, Copy)]
pub struct Ahls11 {
    raw: [u8; 8],
}

impl Ahls11 {
    pub const MESSAGE_ID: u32 = 1437;
    
    pub const CF_AHLS_WARN_LAMP_MIN: u8 = 0_u8;
    pub const CF_AHLS_WARN_LAMP_MAX: u8 = 3_u8;
    pub const CF_AHLS_WARN_MSG_MIN: u8 = 0_u8;
    pub const CF_AHLS_WARN_MSG_MAX: u8 = 3_u8;
    
    /// Construct new AHLS11 from values
    pub fn new(cf_ahls_warn_lamp: u8, cf_ahls_warn_msg: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_ahls_warn_lamp(cf_ahls_warn_lamp)?;
        res.set_cf_ahls_warn_msg(cf_ahls_warn_msg)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Ahls_WarnLamp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_ahls_warn_lamp(&self) -> u8 {
        self.cf_ahls_warn_lamp_raw()
    }
    
    /// Get raw value of CF_Ahls_WarnLamp
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ahls_warn_lamp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ahls_WarnLamp
    #[inline(always)]
    pub fn set_cf_ahls_warn_lamp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1437 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// CF_Ahls_WarnMsg
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_ahls_warn_msg(&self) -> u8 {
        self.cf_ahls_warn_msg_raw()
    }
    
    /// Get raw value of CF_Ahls_WarnMsg
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ahls_warn_msg_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ahls_WarnMsg
    #[inline(always)]
    pub fn set_cf_ahls_warn_msg(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1437 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ahls11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ahls11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ahls11")
                .field("cf_ahls_warn_lamp", &self.cf_ahls_warn_lamp())
                .field("cf_ahls_warn_msg", &self.cf_ahls_warn_msg())
            .finish()
        } else {
            f.debug_tuple("Ahls11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ahls11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_ahls_warn_lamp = u.int_in_range(0..=3)?;
        let cf_ahls_warn_msg = u.int_in_range(0..=3)?;
        Ahls11::new(cf_ahls_warn_lamp,cf_ahls_warn_msg).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// PSB11
///
/// - ID: 1434 (0x59a)
/// - Size: 2 bytes
/// - Transmitter: PSB
#[derive(Clone, Copy)]
pub struct Psb11 {
    raw: [u8; 2],
}

impl Psb11 {
    pub const MESSAGE_ID: u32 = 1434;
    
    pub const PSB_LH_FAIL_MIN: u8 = 0_u8;
    pub const PSB_LH_FAIL_MAX: u8 = 3_u8;
    pub const PSB_LH_ACT_MIN: u8 = 0_u8;
    pub const PSB_LH_ACT_MAX: u8 = 4_u8;
    pub const PSB_RH_FAIL_MIN: u8 = 0_u8;
    pub const PSB_RH_FAIL_MAX: u8 = 3_u8;
    pub const PSB_RH_ACT_MIN: u8 = 0_u8;
    pub const PSB_RH_ACT_MAX: u8 = 4_u8;
    
    /// Construct new PSB11 from values
    pub fn new(psb_lh_fail: u8, psb_lh_tgl: bool, psb_lh_act: u8, psb_rh_fail: u8, psb_rh_tgl: bool, psb_rh_act: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_psb_lh_fail(psb_lh_fail)?;
        res.set_psb_lh_tgl(psb_lh_tgl)?;
        res.set_psb_lh_act(psb_lh_act)?;
        res.set_psb_rh_fail(psb_rh_fail)?;
        res.set_psb_rh_tgl(psb_rh_tgl)?;
        res.set_psb_rh_act(psb_rh_act)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// PSB_LH_FAIL
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn psb_lh_fail(&self) -> u8 {
        self.psb_lh_fail_raw()
    }
    
    /// Get raw value of PSB_LH_FAIL
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn psb_lh_fail_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PSB_LH_FAIL
    #[inline(always)]
    pub fn set_psb_lh_fail(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1434 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// PSB_LH_TGL
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn psb_lh_tgl(&self) -> bool {
        self.psb_lh_tgl_raw()
    }
    
    /// Get raw value of PSB_LH_TGL
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn psb_lh_tgl_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of PSB_LH_TGL
    #[inline(always)]
    pub fn set_psb_lh_tgl(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// PSB_LH_ACT
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Dummy
    #[inline(always)]
    pub fn psb_lh_act(&self) -> u8 {
        self.psb_lh_act_raw()
    }
    
    /// Get raw value of PSB_LH_ACT
    ///
    /// - Start bit: 3
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn psb_lh_act_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[3..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PSB_LH_ACT
    #[inline(always)]
    pub fn set_psb_lh_act(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1434 });
        }
        self.raw.view_bits_mut::<Lsb0>()[3..7].store_le(value);
        Ok(())
    }
    
    /// PSB_RH_FAIL
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn psb_rh_fail(&self) -> u8 {
        self.psb_rh_fail_raw()
    }
    
    /// Get raw value of PSB_RH_FAIL
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn psb_rh_fail_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PSB_RH_FAIL
    #[inline(always)]
    pub fn set_psb_rh_fail(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1434 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// PSB_RH_TGL
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn psb_rh_tgl(&self) -> bool {
        self.psb_rh_tgl_raw()
    }
    
    /// Get raw value of PSB_RH_TGL
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn psb_rh_tgl_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of PSB_RH_TGL
    #[inline(always)]
    pub fn set_psb_rh_tgl(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[10..11].store_le(value);
        Ok(())
    }
    
    /// PSB_RH_ACT
    ///
    /// - Min: 0
    /// - Max: 4
    /// - Unit: ""
    /// - Receivers: Dummy
    #[inline(always)]
    pub fn psb_rh_act(&self) -> u8 {
        self.psb_rh_act_raw()
    }
    
    /// Get raw value of PSB_RH_ACT
    ///
    /// - Start bit: 11
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn psb_rh_act_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[11..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PSB_RH_ACT
    #[inline(always)]
    pub fn set_psb_rh_act(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 4_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1434 });
        }
        self.raw.view_bits_mut::<Lsb0>()[11..15].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Psb11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Psb11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Psb11")
                .field("psb_lh_fail", &self.psb_lh_fail())
                .field("psb_lh_tgl", &self.psb_lh_tgl())
                .field("psb_lh_act", &self.psb_lh_act())
                .field("psb_rh_fail", &self.psb_rh_fail())
                .field("psb_rh_tgl", &self.psb_rh_tgl())
                .field("psb_rh_act", &self.psb_rh_act())
            .finish()
        } else {
            f.debug_tuple("Psb11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Psb11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let psb_lh_fail = u.int_in_range(0..=3)?;
        let psb_lh_tgl = u.int_in_range(0..=1)? == 1;
        let psb_lh_act = u.int_in_range(0..=4)?;
        let psb_rh_fail = u.int_in_range(0..=3)?;
        let psb_rh_tgl = u.int_in_range(0..=1)? == 1;
        let psb_rh_act = u.int_in_range(0..=4)?;
        Psb11::new(psb_lh_fail,psb_lh_tgl,psb_lh_act,psb_rh_fail,psb_rh_tgl,psb_rh_act).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// TCS13
///
/// - ID: 916 (0x394)
/// - Size: 8 bytes
/// - Transmitter: ESC
#[derive(Clone, Copy)]
pub struct Tcs13 {
    raw: [u8; 8],
}

impl Tcs13 {
    pub const MESSAGE_ID: u32 = 916;
    
    pub const A_BASIS_MIN: f32 = -10.23_f32;
    pub const A_BASIS_MAX: f32 = 10.24_f32;
    pub const ALIVE_COUNTER_TCS_MIN: u8 = 0_u8;
    pub const ALIVE_COUNTER_TCS_MAX: u8 = 7_u8;
    pub const DF_BF_STAT_MIN: u8 = 0_u8;
    pub const DF_BF_STAT_MAX: u8 = 3_u8;
    pub const SCC_REQ_LIM_MIN: u8 = 0_u8;
    pub const SCC_REQ_LIM_MAX: u8 = 3_u8;
    pub const TQI_SCC_MIN: f32 = 0_f32;
    pub const TQI_SCC_MAX: f32 = 199.609375_f32;
    pub const ACCEL_REF_ACC_MIN: f32 = -10.23_f32;
    pub const ACCEL_REF_ACC_MAX: f32 = 10.24_f32;
    pub const ACC_ENABLE_MIN: u8 = 0_u8;
    pub const ACC_ENABLE_MAX: u8 = 3_u8;
    pub const DRIVER_OVERRIDE_MIN: u8 = 0_u8;
    pub const DRIVER_OVERRIDE_MAX: u8 = 3_u8;
    pub const CHECK_SUM_TCS3_MIN: u8 = 0_u8;
    pub const CHECK_SUM_TCS3_MAX: u8 = 15_u8;
    pub const CF_VSM_AVAIL_MIN: u8 = 0_u8;
    pub const CF_VSM_AVAIL_MAX: u8 = 3_u8;
    pub const CF_VSM_CONF_SWI_MIN: u8 = 0_u8;
    pub const CF_VSM_CONF_SWI_MAX: u8 = 3_u8;
    
    /// Construct new TCS13 from values
    pub fn new(a_basis: f32, brake_light: bool, dc_enable: bool, alive_counter_tcs: u8, pre_tcs_ctl: bool, eba_ack: bool, fca_ack: bool, df_bf_stat: u8, scc_req_lim: u8, tqi_scc: f32, accel_ref_acc: f32, acc_enable: u8, driver_override: u8, stand_still: bool, check_sum_tcs3: u8, acc_equip: bool, pbrake_act: bool, acc_req: bool, driver_braking: bool, cf_vsm_coded: bool, cf_vsm_avail: u8, cf_vsm_handshake: bool, cf_dri_bke_stat: bool, cf_vsm_conf_swi: u8, aeb_equip: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_a_basis(a_basis)?;
        res.set_brake_light(brake_light)?;
        res.set_dc_enable(dc_enable)?;
        res.set_alive_counter_tcs(alive_counter_tcs)?;
        res.set_pre_tcs_ctl(pre_tcs_ctl)?;
        res.set_eba_ack(eba_ack)?;
        res.set_fca_ack(fca_ack)?;
        res.set_df_bf_stat(df_bf_stat)?;
        res.set_scc_req_lim(scc_req_lim)?;
        res.set_tqi_scc(tqi_scc)?;
        res.set_accel_ref_acc(accel_ref_acc)?;
        res.set_acc_enable(acc_enable)?;
        res.set_driver_override(driver_override)?;
        res.set_stand_still(stand_still)?;
        res.set_check_sum_tcs3(check_sum_tcs3)?;
        res.set_acc_equip(acc_equip)?;
        res.set_pbrake_act(pbrake_act)?;
        res.set_acc_req(acc_req)?;
        res.set_driver_braking(driver_braking)?;
        res.set_cf_vsm_coded(cf_vsm_coded)?;
        res.set_cf_vsm_avail(cf_vsm_avail)?;
        res.set_cf_vsm_handshake(cf_vsm_handshake)?;
        res.set_cf_dri_bke_stat(cf_dri_bke_stat)?;
        res.set_cf_vsm_conf_swi(cf_vsm_conf_swi)?;
        res.set_aeb_equip(aeb_equip)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// aBasis
    ///
    /// - Min: -10.23
    /// - Max: 10.24
    /// - Unit: "m/s^2"
    /// - Receivers: EMS, SCC
    #[inline(always)]
    pub fn a_basis(&self) -> f32 {
        self.a_basis_raw()
    }
    
    /// Get raw value of aBasis
    ///
    /// - Start bit: 0
    /// - Signal size: 11 bits
    /// - Factor: 0.01
    /// - Offset: -10.23
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn a_basis_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..11].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = -10.23_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of aBasis
    #[inline(always)]
    pub fn set_a_basis(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -10.23_f32 || 10.24_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 916 });
        }
        let factor = 0.01_f32;
        let offset = -10.23_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..11].store_le(value);
        Ok(())
    }
    
    /// BrakeLight
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, EMS, SCC
    #[inline(always)]
    pub fn brake_light(&self) -> bool {
        self.brake_light_raw()
    }
    
    /// Get raw value of BrakeLight
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn brake_light_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BrakeLight
    #[inline(always)]
    pub fn set_brake_light(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[11..12].store_le(value);
        Ok(())
    }
    
    /// DCEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, SCC
    #[inline(always)]
    pub fn dc_enable(&self) -> bool {
        self.dc_enable_raw()
    }
    
    /// Get raw value of DCEnable
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dc_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DCEnable
    #[inline(always)]
    pub fn set_dc_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[12..13].store_le(value);
        Ok(())
    }
    
    /// AliveCounterTCS
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: EMS, SCC
    #[inline(always)]
    pub fn alive_counter_tcs(&self) -> u8 {
        self.alive_counter_tcs_raw()
    }
    
    /// Get raw value of AliveCounterTCS
    ///
    /// - Start bit: 13
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn alive_counter_tcs_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[13..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AliveCounterTCS
    #[inline(always)]
    pub fn set_alive_counter_tcs(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 916 });
        }
        self.raw.view_bits_mut::<Lsb0>()[13..16].store_le(value);
        Ok(())
    }
    
    /// Pre_TCS_CTL
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn pre_tcs_ctl(&self) -> bool {
        self.pre_tcs_ctl_raw()
    }
    
    /// Get raw value of Pre_TCS_CTL
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pre_tcs_ctl_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Pre_TCS_CTL
    #[inline(always)]
    pub fn set_pre_tcs_ctl(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[16..17].store_le(value);
        Ok(())
    }
    
    /// EBA_ACK
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn eba_ack(&self) -> bool {
        self.eba_ack_raw()
    }
    
    /// Get raw value of EBA_ACK
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn eba_ack_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of EBA_ACK
    #[inline(always)]
    pub fn set_eba_ack(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[17..18].store_le(value);
        Ok(())
    }
    
    /// FCA_ACK
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn fca_ack(&self) -> bool {
        self.fca_ack_raw()
    }
    
    /// Get raw value of FCA_ACK
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fca_ack_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of FCA_ACK
    #[inline(always)]
    pub fn set_fca_ack(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[18..19].store_le(value);
        Ok(())
    }
    
    /// DF_BF_STAT
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCW
    #[inline(always)]
    pub fn df_bf_stat(&self) -> u8 {
        self.df_bf_stat_raw()
    }
    
    /// Get raw value of DF_BF_STAT
    ///
    /// - Start bit: 19
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn df_bf_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[19..21].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DF_BF_STAT
    #[inline(always)]
    pub fn set_df_bf_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 916 });
        }
        self.raw.view_bits_mut::<Lsb0>()[19..21].store_le(value);
        Ok(())
    }
    
    /// SCCReqLim
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: SCC
    #[inline(always)]
    pub fn scc_req_lim(&self) -> u8 {
        self.scc_req_lim_raw()
    }
    
    /// Get raw value of SCCReqLim
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn scc_req_lim_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of SCCReqLim
    #[inline(always)]
    pub fn set_scc_req_lim(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 916 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
    /// TQI_SCC
    ///
    /// - Min: 0
    /// - Max: 199.609375
    /// - Unit: "%"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn tqi_scc(&self) -> f32 {
        self.tqi_scc_raw()
    }
    
    /// Get raw value of TQI_SCC
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_scc_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI_SCC
    #[inline(always)]
    pub fn set_tqi_scc(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 199.609375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 916 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// ACCEL_REF_ACC
    ///
    /// - Min: -10.23
    /// - Max: 10.24
    /// - Unit: "m/s^2"
    /// - Receivers: EMS, SCC
    #[inline(always)]
    pub fn accel_ref_acc(&self) -> f32 {
        self.accel_ref_acc_raw()
    }
    
    /// Get raw value of ACCEL_REF_ACC
    ///
    /// - Start bit: 32
    /// - Signal size: 11 bits
    /// - Factor: 0.01
    /// - Offset: -10.23
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accel_ref_acc_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..43].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = -10.23_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of ACCEL_REF_ACC
    #[inline(always)]
    pub fn set_accel_ref_acc(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -10.23_f32 || 10.24_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 916 });
        }
        let factor = 0.01_f32;
        let offset = -10.23_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[32..43].store_le(value);
        Ok(())
    }
    
    /// ACCEnable
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, SCC
    #[inline(always)]
    pub fn acc_enable(&self) -> Tcs13AccEnable {
        let signal = self.raw.view_bits::<Lsb0>()[43..45].load_le::<u8>();
        
        match signal {
            0 => Tcs13AccEnable::SccReady,
            1 => Tcs13AccEnable::SccTempFault,
            2 => Tcs13AccEnable::SccPermanentFault,
            3 => Tcs13AccEnable::SccPermanentFaultCommunicationIssue,
            _ => Tcs13AccEnable::_Other(self.acc_enable_raw()),
        }
    }
    
    /// Get raw value of ACCEnable
    ///
    /// - Start bit: 43
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn acc_enable_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[43..45].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ACCEnable
    #[inline(always)]
    pub fn set_acc_enable(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 916 });
        }
        self.raw.view_bits_mut::<Lsb0>()[43..45].store_le(value);
        Ok(())
    }
    
    /// DriverOverride
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, SCC
    #[inline(always)]
    pub fn driver_override(&self) -> u8 {
        self.driver_override_raw()
    }
    
    /// Get raw value of DriverOverride
    ///
    /// - Start bit: 45
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn driver_override_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[45..47].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DriverOverride
    #[inline(always)]
    pub fn set_driver_override(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 916 });
        }
        self.raw.view_bits_mut::<Lsb0>()[45..47].store_le(value);
        Ok(())
    }
    
    /// StandStill
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, SCC
    #[inline(always)]
    pub fn stand_still(&self) -> bool {
        self.stand_still_raw()
    }
    
    /// Get raw value of StandStill
    ///
    /// - Start bit: 47
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn stand_still_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[47..48].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of StandStill
    #[inline(always)]
    pub fn set_stand_still(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[47..48].store_le(value);
        Ok(())
    }
    
    /// CheckSum_TCS3
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: EMS, SCC
    #[inline(always)]
    pub fn check_sum_tcs3(&self) -> u8 {
        self.check_sum_tcs3_raw()
    }
    
    /// Get raw value of CheckSum_TCS3
    ///
    /// - Start bit: 48
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn check_sum_tcs3_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CheckSum_TCS3
    #[inline(always)]
    pub fn set_check_sum_tcs3(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 916 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..52].store_le(value);
        Ok(())
    }
    
    /// ACC_EQUIP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, SCC
    #[inline(always)]
    pub fn acc_equip(&self) -> bool {
        self.acc_equip_raw()
    }
    
    /// Get raw value of ACC_EQUIP
    ///
    /// - Start bit: 52
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn acc_equip_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[52..53].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ACC_EQUIP
    #[inline(always)]
    pub fn set_acc_equip(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[52..53].store_le(value);
        Ok(())
    }
    
    /// PBRAKE_ACT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, SCC
    #[inline(always)]
    pub fn pbrake_act(&self) -> bool {
        self.pbrake_act_raw()
    }
    
    /// Get raw value of PBRAKE_ACT
    ///
    /// - Start bit: 53
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pbrake_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[53..54].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of PBRAKE_ACT
    #[inline(always)]
    pub fn set_pbrake_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[53..54].store_le(value);
        Ok(())
    }
    
    /// ACC_REQ
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn acc_req(&self) -> bool {
        self.acc_req_raw()
    }
    
    /// Get raw value of ACC_REQ
    ///
    /// - Start bit: 54
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn acc_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[54..55].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ACC_REQ
    #[inline(always)]
    pub fn set_acc_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[54..55].store_le(value);
        Ok(())
    }
    
    /// DriverBraking
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, SCC
    #[inline(always)]
    pub fn driver_braking(&self) -> bool {
        self.driver_braking_raw()
    }
    
    /// Get raw value of DriverBraking
    ///
    /// - Start bit: 55
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn driver_braking_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[55..56].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DriverBraking
    #[inline(always)]
    pub fn set_driver_braking(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[55..56].store_le(value);
        Ok(())
    }
    
    /// CF_VSM_Coded
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: SCC
    #[inline(always)]
    pub fn cf_vsm_coded(&self) -> bool {
        self.cf_vsm_coded_raw()
    }
    
    /// Get raw value of CF_VSM_Coded
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_coded_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_VSM_Coded
    #[inline(always)]
    pub fn set_cf_vsm_coded(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[56..57].store_le(value);
        Ok(())
    }
    
    /// CF_VSM_Avail
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, SCC
    #[inline(always)]
    pub fn cf_vsm_avail(&self) -> u8 {
        self.cf_vsm_avail_raw()
    }
    
    /// Get raw value of CF_VSM_Avail
    ///
    /// - Start bit: 57
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_avail_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[57..59].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_VSM_Avail
    #[inline(always)]
    pub fn set_cf_vsm_avail(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 916 });
        }
        self.raw.view_bits_mut::<Lsb0>()[57..59].store_le(value);
        Ok(())
    }
    
    /// CF_VSM_Handshake
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: SCC
    #[inline(always)]
    pub fn cf_vsm_handshake(&self) -> bool {
        self.cf_vsm_handshake_raw()
    }
    
    /// Get raw value of CF_VSM_Handshake
    ///
    /// - Start bit: 59
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_handshake_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[59..60].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_VSM_Handshake
    #[inline(always)]
    pub fn set_cf_vsm_handshake(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[59..60].store_le(value);
        Ok(())
    }
    
    /// CF_DriBkeStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: SCC
    #[inline(always)]
    pub fn cf_dri_bke_stat(&self) -> bool {
        self.cf_dri_bke_stat_raw()
    }
    
    /// Get raw value of CF_DriBkeStat
    ///
    /// - Start bit: 60
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_dri_bke_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[60..61].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_DriBkeStat
    #[inline(always)]
    pub fn set_cf_dri_bke_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[60..61].store_le(value);
        Ok(())
    }
    
    /// CF_VSM_ConfSwi
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: SCC
    #[inline(always)]
    pub fn cf_vsm_conf_swi(&self) -> u8 {
        self.cf_vsm_conf_swi_raw()
    }
    
    /// Get raw value of CF_VSM_ConfSwi
    ///
    /// - Start bit: 61
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_conf_swi_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[61..63].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_VSM_ConfSwi
    #[inline(always)]
    pub fn set_cf_vsm_conf_swi(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 916 });
        }
        self.raw.view_bits_mut::<Lsb0>()[61..63].store_le(value);
        Ok(())
    }
    
    /// AEB_EQUIP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: SCC
    #[inline(always)]
    pub fn aeb_equip(&self) -> bool {
        self.aeb_equip_raw()
    }
    
    /// Get raw value of AEB_EQUIP
    ///
    /// - Start bit: 63
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aeb_equip_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[63..64].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of AEB_EQUIP
    #[inline(always)]
    pub fn set_aeb_equip(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[63..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Tcs13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Tcs13 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Tcs13")
                .field("a_basis", &self.a_basis())
                .field("brake_light", &self.brake_light())
                .field("dc_enable", &self.dc_enable())
                .field("alive_counter_tcs", &self.alive_counter_tcs())
                .field("pre_tcs_ctl", &self.pre_tcs_ctl())
                .field("eba_ack", &self.eba_ack())
                .field("fca_ack", &self.fca_ack())
                .field("df_bf_stat", &self.df_bf_stat())
                .field("scc_req_lim", &self.scc_req_lim())
                .field("tqi_scc", &self.tqi_scc())
                .field("accel_ref_acc", &self.accel_ref_acc())
                .field("acc_enable", &self.acc_enable())
                .field("driver_override", &self.driver_override())
                .field("stand_still", &self.stand_still())
                .field("check_sum_tcs3", &self.check_sum_tcs3())
                .field("acc_equip", &self.acc_equip())
                .field("pbrake_act", &self.pbrake_act())
                .field("acc_req", &self.acc_req())
                .field("driver_braking", &self.driver_braking())
                .field("cf_vsm_coded", &self.cf_vsm_coded())
                .field("cf_vsm_avail", &self.cf_vsm_avail())
                .field("cf_vsm_handshake", &self.cf_vsm_handshake())
                .field("cf_dri_bke_stat", &self.cf_dri_bke_stat())
                .field("cf_vsm_conf_swi", &self.cf_vsm_conf_swi())
                .field("aeb_equip", &self.aeb_equip())
            .finish()
        } else {
            f.debug_tuple("Tcs13").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Tcs13 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let a_basis = u.float_in_range(-10.23_f32..=10.24_f32)?;
        let brake_light = u.int_in_range(0..=1)? == 1;
        let dc_enable = u.int_in_range(0..=1)? == 1;
        let alive_counter_tcs = u.int_in_range(0..=7)?;
        let pre_tcs_ctl = u.int_in_range(0..=1)? == 1;
        let eba_ack = u.int_in_range(0..=1)? == 1;
        let fca_ack = u.int_in_range(0..=1)? == 1;
        let df_bf_stat = u.int_in_range(0..=3)?;
        let scc_req_lim = u.int_in_range(0..=3)?;
        let tqi_scc = u.float_in_range(0_f32..=199.609375_f32)?;
        let accel_ref_acc = u.float_in_range(-10.23_f32..=10.24_f32)?;
        let acc_enable = u.int_in_range(0..=3)?;
        let driver_override = u.int_in_range(0..=3)?;
        let stand_still = u.int_in_range(0..=1)? == 1;
        let check_sum_tcs3 = u.int_in_range(0..=15)?;
        let acc_equip = u.int_in_range(0..=1)? == 1;
        let pbrake_act = u.int_in_range(0..=1)? == 1;
        let acc_req = u.int_in_range(0..=1)? == 1;
        let driver_braking = u.int_in_range(0..=1)? == 1;
        let cf_vsm_coded = u.int_in_range(0..=1)? == 1;
        let cf_vsm_avail = u.int_in_range(0..=3)?;
        let cf_vsm_handshake = u.int_in_range(0..=1)? == 1;
        let cf_dri_bke_stat = u.int_in_range(0..=1)? == 1;
        let cf_vsm_conf_swi = u.int_in_range(0..=3)?;
        let aeb_equip = u.int_in_range(0..=1)? == 1;
        Tcs13::new(a_basis,brake_light,dc_enable,alive_counter_tcs,pre_tcs_ctl,eba_ack,fca_ack,df_bf_stat,scc_req_lim,tqi_scc,accel_ref_acc,acc_enable,driver_override,stand_still,check_sum_tcs3,acc_equip,pbrake_act,acc_req,driver_braking,cf_vsm_coded,cf_vsm_avail,cf_vsm_handshake,cf_dri_bke_stat,cf_vsm_conf_swi,aeb_equip).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for ACCEnable
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Tcs13AccEnable {
    SccReady,
    SccTempFault,
    SccPermanentFault,
    SccPermanentFaultCommunicationIssue,
    _Other(u8),
}

impl From<Tcs13AccEnable> for u8 {
    fn from(val: Tcs13AccEnable) -> u8 {
        match val {
            Tcs13AccEnable::SccReady => 0,
            Tcs13AccEnable::SccTempFault => 1,
            Tcs13AccEnable::SccPermanentFault => 2,
            Tcs13AccEnable::SccPermanentFaultCommunicationIssue => 3,
            Tcs13AccEnable::_Other(x) => x,
        }
    }
}


/// TPMS11
///
/// - ID: 1427 (0x593)
/// - Size: 6 bytes
/// - Transmitter: BCM
#[derive(Clone, Copy)]
pub struct Tpms11 {
    raw: [u8; 6],
}

impl Tpms11 {
    pub const MESSAGE_ID: u32 = 1427;
    
    pub const TPMS_W_LAMP_MIN: u8 = 0_u8;
    pub const TPMS_W_LAMP_MAX: u8 = 3_u8;
    pub const TREAD_W_LAMP_MIN: u8 = 0_u8;
    pub const TREAD_W_LAMP_MAX: u8 = 3_u8;
    pub const STATUS_TPMS_MIN: u8 = 0_u8;
    pub const STATUS_TPMS_MAX: u8 = 0_u8;
    pub const UNIT_MIN: u8 = 0_u8;
    pub const UNIT_MAX: u8 = 3_u8;
    pub const PRESSURE_FL_MIN: u8 = 0_u8;
    pub const PRESSURE_FL_MAX: u8 = 255_u8;
    pub const PRESSURE_FR_MIN: u8 = 0_u8;
    pub const PRESSURE_FR_MAX: u8 = 255_u8;
    pub const PRESSURE_RL_MIN: u8 = 0_u8;
    pub const PRESSURE_RL_MAX: u8 = 255_u8;
    pub const PRESSURE_RR_MIN: u8 = 0_u8;
    pub const PRESSURE_RR_MAX: u8 = 255_u8;
    
    /// Construct new TPMS11 from values
    pub fn new(tpms_w_lamp: u8, tread_w_lamp: u8, pos_fl_w_lamp: bool, pos_fr_w_lamp: bool, pos_rl_w_lamp: bool, pos_rr_w_lamp: bool, status_tpms: u8, unit: u8, pressure_fl: u8, pressure_fr: u8, pressure_rl: u8, pressure_rr: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 6] };
        res.set_tpms_w_lamp(tpms_w_lamp)?;
        res.set_tread_w_lamp(tread_w_lamp)?;
        res.set_pos_fl_w_lamp(pos_fl_w_lamp)?;
        res.set_pos_fr_w_lamp(pos_fr_w_lamp)?;
        res.set_pos_rl_w_lamp(pos_rl_w_lamp)?;
        res.set_pos_rr_w_lamp(pos_rr_w_lamp)?;
        res.set_status_tpms(status_tpms)?;
        res.set_unit(unit)?;
        res.set_pressure_fl(pressure_fl)?;
        res.set_pressure_fr(pressure_fr)?;
        res.set_pressure_rl(pressure_rl)?;
        res.set_pressure_rr(pressure_rr)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 6] {
        &self.raw
    }
    
    /// TPMS_W_LAMP
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, CUBIS, HUD, IBOX, CLU, CUBIS, HUD, IBOX
    #[inline(always)]
    pub fn tpms_w_lamp(&self) -> u8 {
        self.tpms_w_lamp_raw()
    }
    
    /// Get raw value of TPMS_W_LAMP
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tpms_w_lamp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of TPMS_W_LAMP
    #[inline(always)]
    pub fn set_tpms_w_lamp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1427 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// TREAD_W_LAMP
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, CUBIS, HUD, IBOX, CLU, CUBIS, HUD, IBOX
    #[inline(always)]
    pub fn tread_w_lamp(&self) -> u8 {
        self.tread_w_lamp_raw()
    }
    
    /// Get raw value of TREAD_W_LAMP
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tread_w_lamp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of TREAD_W_LAMP
    #[inline(always)]
    pub fn set_tread_w_lamp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1427 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// POS_FL_W_LAMP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, CUBIS, HUD, IBOX
    #[inline(always)]
    pub fn pos_fl_w_lamp(&self) -> bool {
        self.pos_fl_w_lamp_raw()
    }
    
    /// Get raw value of POS_FL_W_LAMP
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pos_fl_w_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of POS_FL_W_LAMP
    #[inline(always)]
    pub fn set_pos_fl_w_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// POS_FR_W_LAMP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, CUBIS, HUD, IBOX
    #[inline(always)]
    pub fn pos_fr_w_lamp(&self) -> bool {
        self.pos_fr_w_lamp_raw()
    }
    
    /// Get raw value of POS_FR_W_LAMP
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pos_fr_w_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of POS_FR_W_LAMP
    #[inline(always)]
    pub fn set_pos_fr_w_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// POS_RL_W_LAMP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, CUBIS, HUD, IBOX
    #[inline(always)]
    pub fn pos_rl_w_lamp(&self) -> bool {
        self.pos_rl_w_lamp_raw()
    }
    
    /// Get raw value of POS_RL_W_LAMP
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pos_rl_w_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of POS_RL_W_LAMP
    #[inline(always)]
    pub fn set_pos_rl_w_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[6..7].store_le(value);
        Ok(())
    }
    
    /// POS_RR_W_LAMP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, CUBIS, HUD, IBOX
    #[inline(always)]
    pub fn pos_rr_w_lamp(&self) -> bool {
        self.pos_rr_w_lamp_raw()
    }
    
    /// Get raw value of POS_RR_W_LAMP
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pos_rr_w_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of POS_RR_W_LAMP
    #[inline(always)]
    pub fn set_pos_rr_w_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// STATUS_TPMS
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn status_tpms(&self) -> u8 {
        self.status_tpms_raw()
    }
    
    /// Get raw value of STATUS_TPMS
    ///
    /// - Start bit: 8
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn status_tpms_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of STATUS_TPMS
    #[inline(always)]
    pub fn set_status_tpms(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1427 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..11].store_le(value);
        Ok(())
    }
    
    /// UNIT
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn unit(&self) -> u8 {
        self.unit_raw()
    }
    
    /// Get raw value of UNIT
    ///
    /// - Start bit: 11
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn unit_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[11..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of UNIT
    #[inline(always)]
    pub fn set_unit(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1427 });
        }
        self.raw.view_bits_mut::<Lsb0>()[11..13].store_le(value);
        Ok(())
    }
    
    /// PRESSURE_FL
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn pressure_fl(&self) -> u8 {
        self.pressure_fl_raw()
    }
    
    /// Get raw value of PRESSURE_FL
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pressure_fl_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PRESSURE_FL
    #[inline(always)]
    pub fn set_pressure_fl(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1427 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// PRESSURE_FR
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn pressure_fr(&self) -> u8 {
        self.pressure_fr_raw()
    }
    
    /// Get raw value of PRESSURE_FR
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pressure_fr_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PRESSURE_FR
    #[inline(always)]
    pub fn set_pressure_fr(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1427 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// PRESSURE_RL
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn pressure_rl(&self) -> u8 {
        self.pressure_rl_raw()
    }
    
    /// Get raw value of PRESSURE_RL
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pressure_rl_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PRESSURE_RL
    #[inline(always)]
    pub fn set_pressure_rl(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1427 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// PRESSURE_RR
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn pressure_rr(&self) -> u8 {
        self.pressure_rr_raw()
    }
    
    /// Get raw value of PRESSURE_RR
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pressure_rr_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PRESSURE_RR
    #[inline(always)]
    pub fn set_pressure_rr(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1427 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Tpms11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 6 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 6];
        raw.copy_from_slice(&payload[..6]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Tpms11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Tpms11")
                .field("tpms_w_lamp", &self.tpms_w_lamp())
                .field("tread_w_lamp", &self.tread_w_lamp())
                .field("pos_fl_w_lamp", &self.pos_fl_w_lamp())
                .field("pos_fr_w_lamp", &self.pos_fr_w_lamp())
                .field("pos_rl_w_lamp", &self.pos_rl_w_lamp())
                .field("pos_rr_w_lamp", &self.pos_rr_w_lamp())
                .field("status_tpms", &self.status_tpms())
                .field("unit", &self.unit())
                .field("pressure_fl", &self.pressure_fl())
                .field("pressure_fr", &self.pressure_fr())
                .field("pressure_rl", &self.pressure_rl())
                .field("pressure_rr", &self.pressure_rr())
            .finish()
        } else {
            f.debug_tuple("Tpms11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Tpms11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let tpms_w_lamp = u.int_in_range(0..=3)?;
        let tread_w_lamp = u.int_in_range(0..=3)?;
        let pos_fl_w_lamp = u.int_in_range(0..=1)? == 1;
        let pos_fr_w_lamp = u.int_in_range(0..=1)? == 1;
        let pos_rl_w_lamp = u.int_in_range(0..=1)? == 1;
        let pos_rr_w_lamp = u.int_in_range(0..=1)? == 1;
        let status_tpms = u.int_in_range(0..=0)?;
        let unit = u.int_in_range(0..=3)?;
        let pressure_fl = u.int_in_range(0..=255)?;
        let pressure_fr = u.int_in_range(0..=255)?;
        let pressure_rl = u.int_in_range(0..=255)?;
        let pressure_rr = u.int_in_range(0..=255)?;
        Tpms11::new(tpms_w_lamp,tread_w_lamp,pos_fl_w_lamp,pos_fr_w_lamp,pos_rl_w_lamp,pos_rr_w_lamp,status_tpms,unit,pressure_fl,pressure_fr,pressure_rl,pressure_rr).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// TCS12
///
/// - ID: 915 (0x393)
/// - Size: 4 bytes
/// - Transmitter: ESC
#[derive(Clone, Copy)]
pub struct Tcs12 {
    raw: [u8; 4],
}

impl Tcs12 {
    pub const MESSAGE_ID: u32 = 915;
    
    pub const SA_COUNT_MIN: f32 = -32768_f32;
    pub const SA_COUNT_MAX: f32 = 98302_f32;
    pub const SA_Z_COUNT_MIN: f32 = -32768_f32;
    pub const SA_Z_COUNT_MAX: f32 = 32766_f32;
    
    /// Construct new TCS12 from values
    pub fn new(sa_count: f32, sa_z_count: f32, sa_z_flag: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_sa_count(sa_count)?;
        res.set_sa_z_count(sa_z_count)?;
        res.set_sa_z_flag(sa_z_flag)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 4] {
        &self.raw
    }
    
    /// SA_COUNT
    ///
    /// - Min: -32768
    /// - Max: 98302
    /// - Unit: ""
    /// - Receivers: _4WD, ACU, MDPS
    #[inline(always)]
    pub fn sa_count(&self) -> f32 {
        self.sa_count_raw()
    }
    
    /// Get raw value of SA_COUNT
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 2
    /// - Offset: -32768
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn sa_count_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 2_f32;
        let offset = -32768_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of SA_COUNT
    #[inline(always)]
    pub fn set_sa_count(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -32768_f32 || 98302_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 915 });
        }
        let factor = 2_f32;
        let offset = -32768_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
    /// SA_Z_COUNT
    ///
    /// - Min: -32768
    /// - Max: 32766
    /// - Unit: ""
    /// - Receivers: _4WD, ACU, MDPS
    #[inline(always)]
    pub fn sa_z_count(&self) -> f32 {
        self.sa_z_count_raw()
    }
    
    /// Get raw value of SA_Z_COUNT
    ///
    /// - Start bit: 16
    /// - Signal size: 15 bits
    /// - Factor: 2
    /// - Offset: -32768
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn sa_z_count_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..31].load_le::<u16>();
        
        let factor = 2_f32;
        let offset = -32768_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of SA_Z_COUNT
    #[inline(always)]
    pub fn set_sa_z_count(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -32768_f32 || 32766_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 915 });
        }
        let factor = 2_f32;
        let offset = -32768_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[16..31].store_le(value);
        Ok(())
    }
    
    /// SA_Z_FLAG
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ACU, MDPS
    #[inline(always)]
    pub fn sa_z_flag(&self) -> bool {
        self.sa_z_flag_raw()
    }
    
    /// Get raw value of SA_Z_FLAG
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn sa_z_flag_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of SA_Z_FLAG
    #[inline(always)]
    pub fn set_sa_z_flag(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[31..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Tcs12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Tcs12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Tcs12")
                .field("sa_count", &self.sa_count())
                .field("sa_z_count", &self.sa_z_count())
                .field("sa_z_flag", &self.sa_z_flag())
            .finish()
        } else {
            f.debug_tuple("Tcs12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Tcs12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let sa_count = u.float_in_range(-32768_f32..=98302_f32)?;
        let sa_z_count = u.float_in_range(-32768_f32..=32766_f32)?;
        let sa_z_flag = u.int_in_range(0..=1)? == 1;
        Tcs12::new(sa_count,sa_z_count,sa_z_flag).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EMS19
///
/// - ID: 1170 (0x492)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct Ems19 {
    raw: [u8; 8],
}

impl Ems19 {
    pub const MESSAGE_ID: u32 = 1170;
    
    pub const CF_EMS_DN_SHFT_REQ_MIN: u8 = 0_u8;
    pub const CF_EMS_DN_SHFT_REQ_MAX: u8 = 14_u8;
    pub const CF_EMS_REP_MOD_CHK_MIN: u8 = 0_u8;
    pub const CF_EMS_REP_MOD_CHK_MAX: u8 = 3_u8;
    pub const CF_EMS_DECEL_REQ_MIN: f32 = -4.094_f32;
    pub const CF_EMS_DECEL_REQ_MAX: f32 = 0_f32;
    pub const CR_EMS_BST_PRE_MIN: f32 = 0_f32;
    pub const CR_EMS_BST_PRE_MAX: f32 = 4094_f32;
    pub const CR_EMS_ENG_OIL_TEMP_MIN: f32 = 0_f32;
    pub const CR_EMS_ENG_OIL_TEMP_MAX: f32 = 254_f32;
    pub const DPF_LAMP_STAT_MIN: u8 = 0_u8;
    pub const DPF_LAMP_STAT_MAX: u8 = 3_u8;
    pub const CF_EMS_MODELED_AMB_TEMP_MIN: f32 = -41_f32;
    pub const CF_EMS_MODELED_AMB_TEMP_MAX: f32 = 85.5_f32;
    pub const CF_EMS_ALIVE_COUNTER_EMS9_MIN: u8 = 0_u8;
    pub const CF_EMS_ALIVE_COUNTER_EMS9_MAX: u8 = 3_u8;
    pub const CF_EMS_CHECKSUM_EMS9_MIN: u8 = 0_u8;
    pub const CF_EMS_CHECKSUM_EMS9_MAX: u8 = 15_u8;
    
    /// Construct new EMS19 from values
    pub fn new(cf_ems_brk_req: bool, cf_ems_dn_shft_req: u8, cf_ems_rep_mod_chk: u8, cf_ems_aaf_open_req: bool, cf_ems_decel_req: f32, cr_ems_bst_pre: f32, cr_ems_eng_oil_temp: f32, dpf_lamp_stat: u8, bat_lamp_stat: bool, cf_ems_modeled_amb_temp: f32, cf_ems_ops_fail: bool, cf_ems_alive_counter_ems9: u8, cf_ems_checksum_ems9: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_ems_brk_req(cf_ems_brk_req)?;
        res.set_cf_ems_dn_shft_req(cf_ems_dn_shft_req)?;
        res.set_cf_ems_rep_mod_chk(cf_ems_rep_mod_chk)?;
        res.set_cf_ems_aaf_open_req(cf_ems_aaf_open_req)?;
        res.set_cf_ems_decel_req(cf_ems_decel_req)?;
        res.set_cr_ems_bst_pre(cr_ems_bst_pre)?;
        res.set_cr_ems_eng_oil_temp(cr_ems_eng_oil_temp)?;
        res.set_dpf_lamp_stat(dpf_lamp_stat)?;
        res.set_bat_lamp_stat(bat_lamp_stat)?;
        res.set_cf_ems_modeled_amb_temp(cf_ems_modeled_amb_temp)?;
        res.set_cf_ems_ops_fail(cf_ems_ops_fail)?;
        res.set_cf_ems_alive_counter_ems9(cf_ems_alive_counter_ems9)?;
        res.set_cf_ems_checksum_ems9(cf_ems_checksum_ems9)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Ems_BrkReq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC, IBOX, TCU
    #[inline(always)]
    pub fn cf_ems_brk_req(&self) -> bool {
        self.cf_ems_brk_req_raw()
    }
    
    /// Get raw value of CF_Ems_BrkReq
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_brk_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_BrkReq
    #[inline(always)]
    pub fn set_cf_ems_brk_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_DnShftReq
    ///
    /// - Min: 0
    /// - Max: 14
    /// - Unit: ""
    /// - Receivers: IBOX, TCU
    #[inline(always)]
    pub fn cf_ems_dn_shft_req(&self) -> u8 {
        self.cf_ems_dn_shft_req_raw()
    }
    
    /// Get raw value of CF_Ems_DnShftReq
    ///
    /// - Start bit: 1
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_dn_shft_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[1..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_DnShftReq
    #[inline(always)]
    pub fn set_cf_ems_dn_shft_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 14_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1170 });
        }
        self.raw.view_bits_mut::<Lsb0>()[1..5].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_RepModChk
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: IBOX
    #[inline(always)]
    pub fn cf_ems_rep_mod_chk(&self) -> u8 {
        self.cf_ems_rep_mod_chk_raw()
    }
    
    /// Get raw value of CF_Ems_RepModChk
    ///
    /// - Start bit: 5
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_rep_mod_chk_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[5..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_RepModChk
    #[inline(always)]
    pub fn set_cf_ems_rep_mod_chk(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1170 });
        }
        self.raw.view_bits_mut::<Lsb0>()[5..7].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_AAFOpenReq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: AAF, IBOX
    #[inline(always)]
    pub fn cf_ems_aaf_open_req(&self) -> bool {
        self.cf_ems_aaf_open_req_raw()
    }
    
    /// Get raw value of CF_Ems_AAFOpenReq
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_aaf_open_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_AAFOpenReq
    #[inline(always)]
    pub fn set_cf_ems_aaf_open_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_DecelReq
    ///
    /// - Min: -4.094
    /// - Max: 0
    /// - Unit: "m/s^2"
    /// - Receivers: ESC, IBOX, TCU
    #[inline(always)]
    pub fn cf_ems_decel_req(&self) -> f32 {
        self.cf_ems_decel_req_raw()
    }
    
    /// Get raw value of CF_Ems_DecelReq
    ///
    /// - Start bit: 8
    /// - Signal size: 12 bits
    /// - Factor: 0.001
    /// - Offset: -4.094
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_decel_req_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..20].load_le::<u16>();
        
        let factor = 0.001_f32;
        let offset = -4.094_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CF_Ems_DecelReq
    #[inline(always)]
    pub fn set_cf_ems_decel_req(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -4.094_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1170 });
        }
        let factor = 0.001_f32;
        let offset = -4.094_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[8..20].store_le(value);
        Ok(())
    }
    
    /// CR_Ems_BstPre
    ///
    /// - Min: 0
    /// - Max: 4094
    /// - Unit: "hPa"
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cr_ems_bst_pre(&self) -> f32 {
        self.cr_ems_bst_pre_raw()
    }
    
    /// Get raw value of CR_Ems_BstPre
    ///
    /// - Start bit: 20
    /// - Signal size: 12 bits
    /// - Factor: 1.322
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ems_bst_pre_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[20..32].load_le::<u16>();
        
        let factor = 1.322_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Ems_BstPre
    #[inline(always)]
    pub fn set_cr_ems_bst_pre(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 4094_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1170 });
        }
        let factor = 1.322_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[20..32].store_le(value);
        Ok(())
    }
    
    /// CR_Ems_EngOilTemp
    ///
    /// - Min: 0
    /// - Max: 254
    /// - Unit: "deg"
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cr_ems_eng_oil_temp(&self) -> f32 {
        self.cr_ems_eng_oil_temp_raw()
    }
    
    /// Get raw value of CR_Ems_EngOilTemp
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.75
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ems_eng_oil_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 0.75_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Ems_EngOilTemp
    #[inline(always)]
    pub fn set_cr_ems_eng_oil_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 254_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1170 });
        }
        let factor = 0.75_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// DPF_LAMP_STAT
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn dpf_lamp_stat(&self) -> u8 {
        self.dpf_lamp_stat_raw()
    }
    
    /// Get raw value of DPF_LAMP_STAT
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dpf_lamp_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DPF_LAMP_STAT
    #[inline(always)]
    pub fn set_dpf_lamp_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1170 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..42].store_le(value);
        Ok(())
    }
    
    /// BAT_LAMP_STAT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn bat_lamp_stat(&self) -> bool {
        self.bat_lamp_stat_raw()
    }
    
    /// Get raw value of BAT_LAMP_STAT
    ///
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bat_lamp_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[42..43].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BAT_LAMP_STAT
    #[inline(always)]
    pub fn set_bat_lamp_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[42..43].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_ModeledAmbTemp
    ///
    /// - Min: -41
    /// - Max: 85.5
    /// - Unit: "deg"
    /// - Receivers: AAF, IBOX
    #[inline(always)]
    pub fn cf_ems_modeled_amb_temp(&self) -> f32 {
        self.cf_ems_modeled_amb_temp_raw()
    }
    
    /// Get raw value of CF_Ems_ModeledAmbTemp
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -41
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_modeled_amb_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -41_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CF_Ems_ModeledAmbTemp
    #[inline(always)]
    pub fn set_cf_ems_modeled_amb_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -41_f32 || 85.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1170 });
        }
        let factor = 0.5_f32;
        let offset = -41_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_OPSFail
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_ems_ops_fail(&self) -> bool {
        self.cf_ems_ops_fail_raw()
    }
    
    /// Get raw value of CF_Ems_OPSFail
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_ops_fail_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_OPSFail
    #[inline(always)]
    pub fn set_cf_ems_ops_fail(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[56..57].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_AliveCounterEMS9
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: AAF, ABS, CUBIS, ECS, EPB, IBOX, MDPS, REA, SCC, SMK, TCU
    #[inline(always)]
    pub fn cf_ems_alive_counter_ems9(&self) -> u8 {
        self.cf_ems_alive_counter_ems9_raw()
    }
    
    /// Get raw value of CF_Ems_AliveCounterEMS9
    ///
    /// - Start bit: 58
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_alive_counter_ems9_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[58..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_AliveCounterEMS9
    #[inline(always)]
    pub fn set_cf_ems_alive_counter_ems9(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1170 });
        }
        self.raw.view_bits_mut::<Lsb0>()[58..60].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_ChecksumEMS9
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: AAF, ABS, CUBIS, ECS, EPB, IBOX, MDPS, REA, SCC, SMK, TCU
    #[inline(always)]
    pub fn cf_ems_checksum_ems9(&self) -> u8 {
        self.cf_ems_checksum_ems9_raw()
    }
    
    /// Get raw value of CF_Ems_ChecksumEMS9
    ///
    /// - Start bit: 60
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_checksum_ems9_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_ChecksumEMS9
    #[inline(always)]
    pub fn set_cf_ems_checksum_ems9(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1170 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ems19 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ems19 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ems19")
                .field("cf_ems_brk_req", &self.cf_ems_brk_req())
                .field("cf_ems_dn_shft_req", &self.cf_ems_dn_shft_req())
                .field("cf_ems_rep_mod_chk", &self.cf_ems_rep_mod_chk())
                .field("cf_ems_aaf_open_req", &self.cf_ems_aaf_open_req())
                .field("cf_ems_decel_req", &self.cf_ems_decel_req())
                .field("cr_ems_bst_pre", &self.cr_ems_bst_pre())
                .field("cr_ems_eng_oil_temp", &self.cr_ems_eng_oil_temp())
                .field("dpf_lamp_stat", &self.dpf_lamp_stat())
                .field("bat_lamp_stat", &self.bat_lamp_stat())
                .field("cf_ems_modeled_amb_temp", &self.cf_ems_modeled_amb_temp())
                .field("cf_ems_ops_fail", &self.cf_ems_ops_fail())
                .field("cf_ems_alive_counter_ems9", &self.cf_ems_alive_counter_ems9())
                .field("cf_ems_checksum_ems9", &self.cf_ems_checksum_ems9())
            .finish()
        } else {
            f.debug_tuple("Ems19").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ems19 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_ems_brk_req = u.int_in_range(0..=1)? == 1;
        let cf_ems_dn_shft_req = u.int_in_range(0..=14)?;
        let cf_ems_rep_mod_chk = u.int_in_range(0..=3)?;
        let cf_ems_aaf_open_req = u.int_in_range(0..=1)? == 1;
        let cf_ems_decel_req = u.float_in_range(-4.094_f32..=0_f32)?;
        let cr_ems_bst_pre = u.float_in_range(0_f32..=4094_f32)?;
        let cr_ems_eng_oil_temp = u.float_in_range(0_f32..=254_f32)?;
        let dpf_lamp_stat = u.int_in_range(0..=3)?;
        let bat_lamp_stat = u.int_in_range(0..=1)? == 1;
        let cf_ems_modeled_amb_temp = u.float_in_range(-41_f32..=85.5_f32)?;
        let cf_ems_ops_fail = u.int_in_range(0..=1)? == 1;
        let cf_ems_alive_counter_ems9 = u.int_in_range(0..=3)?;
        let cf_ems_checksum_ems9 = u.int_in_range(0..=15)?;
        Ems19::new(cf_ems_brk_req,cf_ems_dn_shft_req,cf_ems_rep_mod_chk,cf_ems_aaf_open_req,cf_ems_decel_req,cr_ems_bst_pre,cr_ems_eng_oil_temp,dpf_lamp_stat,bat_lamp_stat,cf_ems_modeled_amb_temp,cf_ems_ops_fail,cf_ems_alive_counter_ems9,cf_ems_checksum_ems9).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// AFLS11
///
/// - ID: 1425 (0x591)
/// - Size: 2 bytes
/// - Transmitter: AFLS
#[derive(Clone, Copy)]
pub struct Afls11 {
    raw: [u8; 2],
}

impl Afls11 {
    pub const MESSAGE_ID: u32 = 1425;
    
    pub const AFLS_STAT_MIN: u8 = 0_u8;
    pub const AFLS_STAT_MAX: u8 = 3_u8;
    pub const CF_AFLS_LED_HL_STAT_MIN: u8 = 0_u8;
    pub const CF_AFLS_LED_HL_STAT_MAX: u8 = 3_u8;
    
    /// Construct new AFLS11 from values
    pub fn new(afls_stat: u8, cf_afls_trf_chg_stat: bool, cf_afls_led_hl_stat: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_afls_stat(afls_stat)?;
        res.set_cf_afls_trf_chg_stat(cf_afls_trf_chg_stat)?;
        res.set_cf_afls_led_hl_stat(cf_afls_led_hl_stat)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AFLS_STAT
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn afls_stat(&self) -> u8 {
        self.afls_stat_raw()
    }
    
    /// Get raw value of AFLS_STAT
    ///
    /// - Start bit: 1
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn afls_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[1..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AFLS_STAT
    #[inline(always)]
    pub fn set_afls_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1425 });
        }
        self.raw.view_bits_mut::<Lsb0>()[1..3].store_le(value);
        Ok(())
    }
    
    /// CF_Afls_TrfChgStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_afls_trf_chg_stat(&self) -> bool {
        self.cf_afls_trf_chg_stat_raw()
    }
    
    /// Get raw value of CF_Afls_TrfChgStat
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_afls_trf_chg_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Afls_TrfChgStat
    #[inline(always)]
    pub fn set_cf_afls_trf_chg_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// CF_Afls_LedHLStat
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_afls_led_hl_stat(&self) -> u8 {
        self.cf_afls_led_hl_stat_raw()
    }
    
    /// Get raw value of CF_Afls_LedHLStat
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_afls_led_hl_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Afls_LedHLStat
    #[inline(always)]
    pub fn set_cf_afls_led_hl_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1425 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Afls11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Afls11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Afls11")
                .field("afls_stat", &self.afls_stat())
                .field("cf_afls_trf_chg_stat", &self.cf_afls_trf_chg_stat())
                .field("cf_afls_led_hl_stat", &self.cf_afls_led_hl_stat())
            .finish()
        } else {
            f.debug_tuple("Afls11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Afls11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let afls_stat = u.int_in_range(0..=3)?;
        let cf_afls_trf_chg_stat = u.int_in_range(0..=1)? == 1;
        let cf_afls_led_hl_stat = u.int_in_range(0..=3)?;
        Afls11::new(afls_stat,cf_afls_trf_chg_stat,cf_afls_led_hl_stat).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// SPAS11
///
/// - ID: 912 (0x390)
/// - Size: 7 bytes
/// - Transmitter: SPAS
#[derive(Clone, Copy)]
pub struct Spas11 {
    raw: [u8; 7],
}

impl Spas11 {
    pub const MESSAGE_ID: u32 = 912;
    
    pub const CF_SPAS_STAT_MIN: u8 = 0_u8;
    pub const CF_SPAS_STAT_MAX: u8 = 15_u8;
    pub const CF_SPAS_TEST_MODE_MIN: u8 = 0_u8;
    pub const CF_SPAS_TEST_MODE_MAX: u8 = 3_u8;
    pub const CR_SPAS_STR_ANG_CMD_MIN: f32 = -3276.8_f32;
    pub const CR_SPAS_STR_ANG_CMD_MAX: f32 = 3276.7_f32;
    pub const CF_SPAS_BEEP_ALARM_MIN: u8 = 0_u8;
    pub const CF_SPAS_BEEP_ALARM_MAX: u8 = 15_u8;
    pub const CF_SPAS_MODE_SEQ_MIN: u8 = 0_u8;
    pub const CF_SPAS_MODE_SEQ_MAX: u8 = 3_u8;
    pub const CF_SPAS_ALIVE_CNT_MIN: u8 = 0_u8;
    pub const CF_SPAS_ALIVE_CNT_MAX: u8 = 255_u8;
    pub const CF_SPAS_CHKSUM_MIN: u8 = 0_u8;
    pub const CF_SPAS_CHKSUM_MAX: u8 = 255_u8;
    pub const CF_SPAS_PAS_VOL_MIN: u8 = 0_u8;
    pub const CF_SPAS_PAS_VOL_MAX: u8 = 7_u8;
    
    /// Construct new SPAS11 from values
    pub fn new(cf_spas_stat: u8, cf_spas_test_mode: u8, cr_spas_str_ang_cmd: f32, cf_spas_beep_alarm: u8, cf_spas_mode_seq: u8, cf_spas_alive_cnt: u8, cf_spas_chksum: u8, cf_spas_pas_vol: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 7] };
        res.set_cf_spas_stat(cf_spas_stat)?;
        res.set_cf_spas_test_mode(cf_spas_test_mode)?;
        res.set_cr_spas_str_ang_cmd(cr_spas_str_ang_cmd)?;
        res.set_cf_spas_beep_alarm(cf_spas_beep_alarm)?;
        res.set_cf_spas_mode_seq(cf_spas_mode_seq)?;
        res.set_cf_spas_alive_cnt(cf_spas_alive_cnt)?;
        res.set_cf_spas_chksum(cf_spas_chksum)?;
        res.set_cf_spas_pas_vol(cf_spas_pas_vol)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 7] {
        &self.raw
    }
    
    /// CF_Spas_Stat
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: ESC, MDPS
    #[inline(always)]
    pub fn cf_spas_stat(&self) -> u8 {
        self.cf_spas_stat_raw()
    }
    
    /// Get raw value of CF_Spas_Stat
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_Stat
    #[inline(always)]
    pub fn set_cf_spas_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 912 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..4].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_TestMode
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn cf_spas_test_mode(&self) -> u8 {
        self.cf_spas_test_mode_raw()
    }
    
    /// Get raw value of CF_Spas_TestMode
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_test_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_TestMode
    #[inline(always)]
    pub fn set_cf_spas_test_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 912 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
    /// CR_Spas_StrAngCmd
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: ""
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn cr_spas_str_ang_cmd(&self) -> f32 {
        self.cr_spas_str_ang_cmd_raw()
    }
    
    /// Get raw value of CR_Spas_StrAngCmd
    ///
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn cr_spas_str_ang_cmd_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..24].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Spas_StrAngCmd
    #[inline(always)]
    pub fn set_cr_spas_str_ang_cmd(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 912 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[8..24].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_BeepAlarm
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_spas_beep_alarm(&self) -> u8 {
        self.cf_spas_beep_alarm_raw()
    }
    
    /// Get raw value of CF_Spas_BeepAlarm
    ///
    /// - Start bit: 24
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_beep_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_BeepAlarm
    #[inline(always)]
    pub fn set_cf_spas_beep_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 912 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..28].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_Mode_Seq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_spas_mode_seq(&self) -> u8 {
        self.cf_spas_mode_seq_raw()
    }
    
    /// Get raw value of CF_Spas_Mode_Seq
    ///
    /// - Start bit: 28
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_mode_seq_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[28..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_Mode_Seq
    #[inline(always)]
    pub fn set_cf_spas_mode_seq(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 912 });
        }
        self.raw.view_bits_mut::<Lsb0>()[28..30].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_AliveCnt
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn cf_spas_alive_cnt(&self) -> u8 {
        self.cf_spas_alive_cnt_raw()
    }
    
    /// Get raw value of CF_Spas_AliveCnt
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_alive_cnt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_AliveCnt
    #[inline(always)]
    pub fn set_cf_spas_alive_cnt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 912 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_Chksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn cf_spas_chksum(&self) -> u8 {
        self.cf_spas_chksum_raw()
    }
    
    /// Get raw value of CF_Spas_Chksum
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_chksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_Chksum
    #[inline(always)]
    pub fn set_cf_spas_chksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 912 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// CF_Spas_PasVol
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CGW, CLU
    #[inline(always)]
    pub fn cf_spas_pas_vol(&self) -> u8 {
        self.cf_spas_pas_vol_raw()
    }
    
    /// Get raw value of CF_Spas_PasVol
    ///
    /// - Start bit: 48
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_spas_pas_vol_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..51].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Spas_PasVol
    #[inline(always)]
    pub fn set_cf_spas_pas_vol(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 912 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..51].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Spas11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 7 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 7];
        raw.copy_from_slice(&payload[..7]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Spas11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Spas11")
                .field("cf_spas_stat", &self.cf_spas_stat())
                .field("cf_spas_test_mode", &self.cf_spas_test_mode())
                .field("cr_spas_str_ang_cmd", &self.cr_spas_str_ang_cmd())
                .field("cf_spas_beep_alarm", &self.cf_spas_beep_alarm())
                .field("cf_spas_mode_seq", &self.cf_spas_mode_seq())
                .field("cf_spas_alive_cnt", &self.cf_spas_alive_cnt())
                .field("cf_spas_chksum", &self.cf_spas_chksum())
                .field("cf_spas_pas_vol", &self.cf_spas_pas_vol())
            .finish()
        } else {
            f.debug_tuple("Spas11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Spas11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_spas_stat = u.int_in_range(0..=15)?;
        let cf_spas_test_mode = u.int_in_range(0..=3)?;
        let cr_spas_str_ang_cmd = u.float_in_range(-3276.8_f32..=3276.7_f32)?;
        let cf_spas_beep_alarm = u.int_in_range(0..=15)?;
        let cf_spas_mode_seq = u.int_in_range(0..=3)?;
        let cf_spas_alive_cnt = u.int_in_range(0..=255)?;
        let cf_spas_chksum = u.int_in_range(0..=255)?;
        let cf_spas_pas_vol = u.int_in_range(0..=7)?;
        Spas11::new(cf_spas_stat,cf_spas_test_mode,cr_spas_str_ang_cmd,cf_spas_beep_alarm,cf_spas_mode_seq,cf_spas_alive_cnt,cf_spas_chksum,cf_spas_pas_vol).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EPB11
///
/// - ID: 1168 (0x490)
/// - Size: 7 bytes
/// - Transmitter: EPB
#[derive(Clone, Copy)]
pub struct Epb11 {
    raw: [u8; 7],
}

impl Epb11 {
    pub const MESSAGE_ID: u32 = 1168;
    
    pub const EPB_I_LAMP_MIN: u8 = 0_u8;
    pub const EPB_I_LAMP_MAX: u8 = 15_u8;
    pub const EPB_F_LAMP_MIN: u8 = 0_u8;
    pub const EPB_F_LAMP_MAX: u8 = 3_u8;
    pub const EPB_ALARM_MIN: u8 = 0_u8;
    pub const EPB_ALARM_MAX: u8 = 3_u8;
    pub const EPB_CLU_MIN: u8 = 0_u8;
    pub const EPB_CLU_MAX: u8 = 255_u8;
    pub const EPB_SWITCH_MIN: u8 = 0_u8;
    pub const EPB_SWITCH_MAX: u8 = 3_u8;
    pub const EPB_STATUS_MIN: u8 = 0_u8;
    pub const EPB_STATUS_MAX: u8 = 7_u8;
    pub const EPB_FRC_ERR_MIN: u8 = 0_u8;
    pub const EPB_FRC_ERR_MAX: u8 = 3_u8;
    pub const EPB_FAIL_MIN: u8 = 0_u8;
    pub const EPB_FAIL_MAX: u8 = 7_u8;
    pub const EPB_FORCE_MIN: f32 = -1000_f32;
    pub const EPB_FORCE_MAX: f32 = 3000_f32;
    pub const EPB_DBF_DECEL_MIN: f32 = 0_f32;
    pub const EPB_DBF_DECEL_MAX: f32 = 2.54_f32;
    
    /// Construct new EPB11 from values
    pub fn new(epb_i_lamp: u8, epb_f_lamp: u8, epb_alarm: u8, epb_clu: u8, epb_switch: u8, epb_rbl: bool, epb_status: u8, epb_frc_err: u8, epb_dbf_stat: bool, esp_ack: bool, epb_dbf_req: bool, epb_fail: u8, epb_force: f32, epb_dbf_decel: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 7] };
        res.set_epb_i_lamp(epb_i_lamp)?;
        res.set_epb_f_lamp(epb_f_lamp)?;
        res.set_epb_alarm(epb_alarm)?;
        res.set_epb_clu(epb_clu)?;
        res.set_epb_switch(epb_switch)?;
        res.set_epb_rbl(epb_rbl)?;
        res.set_epb_status(epb_status)?;
        res.set_epb_frc_err(epb_frc_err)?;
        res.set_epb_dbf_stat(epb_dbf_stat)?;
        res.set_esp_ack(esp_ack)?;
        res.set_epb_dbf_req(epb_dbf_req)?;
        res.set_epb_fail(epb_fail)?;
        res.set_epb_force(epb_force)?;
        res.set_epb_dbf_decel(epb_dbf_decel)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 7] {
        &self.raw
    }
    
    /// EPB_I_LAMP
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: BCM, CLU, CUBIS, ESC, IBOX
    #[inline(always)]
    pub fn epb_i_lamp(&self) -> u8 {
        self.epb_i_lamp_raw()
    }
    
    /// Get raw value of EPB_I_LAMP
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn epb_i_lamp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of EPB_I_LAMP
    #[inline(always)]
    pub fn set_epb_i_lamp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1168 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..4].store_le(value);
        Ok(())
    }
    
    /// EPB_F_LAMP
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, CUBIS, ESC, IBOX
    #[inline(always)]
    pub fn epb_f_lamp(&self) -> u8 {
        self.epb_f_lamp_raw()
    }
    
    /// Get raw value of EPB_F_LAMP
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn epb_f_lamp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of EPB_F_LAMP
    #[inline(always)]
    pub fn set_epb_f_lamp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1168 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
    /// EPB_ALARM
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, ESC
    #[inline(always)]
    pub fn epb_alarm(&self) -> u8 {
        self.epb_alarm_raw()
    }
    
    /// Get raw value of EPB_ALARM
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn epb_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of EPB_ALARM
    #[inline(always)]
    pub fn set_epb_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1168 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// EPB_CLU
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU, ESC
    #[inline(always)]
    pub fn epb_clu(&self) -> u8 {
        self.epb_clu_raw()
    }
    
    /// Get raw value of EPB_CLU
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn epb_clu_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of EPB_CLU
    #[inline(always)]
    pub fn set_epb_clu(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1168 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// EPB_SWITCH
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: ESC, SCC
    #[inline(always)]
    pub fn epb_switch(&self) -> u8 {
        self.epb_switch_raw()
    }
    
    /// Get raw value of EPB_SWITCH
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn epb_switch_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of EPB_SWITCH
    #[inline(always)]
    pub fn set_epb_switch(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1168 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..18].store_le(value);
        Ok(())
    }
    
    /// EPB_RBL
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, ESC
    #[inline(always)]
    pub fn epb_rbl(&self) -> bool {
        self.epb_rbl_raw()
    }
    
    /// Get raw value of EPB_RBL
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn epb_rbl_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of EPB_RBL
    #[inline(always)]
    pub fn set_epb_rbl(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[18..19].store_le(value);
        Ok(())
    }
    
    /// EPB_STATUS
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, EMS, ESC, SCC, TCU
    #[inline(always)]
    pub fn epb_status(&self) -> u8 {
        self.epb_status_raw()
    }
    
    /// Get raw value of EPB_STATUS
    ///
    /// - Start bit: 19
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn epb_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[19..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of EPB_STATUS
    #[inline(always)]
    pub fn set_epb_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1168 });
        }
        self.raw.view_bits_mut::<Lsb0>()[19..22].store_le(value);
        Ok(())
    }
    
    /// EPB_FRC_ERR
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, ESC, SCC, TCU
    #[inline(always)]
    pub fn epb_frc_err(&self) -> u8 {
        self.epb_frc_err_raw()
    }
    
    /// Get raw value of EPB_FRC_ERR
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn epb_frc_err_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of EPB_FRC_ERR
    #[inline(always)]
    pub fn set_epb_frc_err(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1168 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
    /// EPB_DBF_STAT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn epb_dbf_stat(&self) -> bool {
        self.epb_dbf_stat_raw()
    }
    
    /// Get raw value of EPB_DBF_STAT
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn epb_dbf_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of EPB_DBF_STAT
    #[inline(always)]
    pub fn set_epb_dbf_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[24..25].store_le(value);
        Ok(())
    }
    
    /// ESP_ACK
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn esp_ack(&self) -> bool {
        self.esp_ack_raw()
    }
    
    /// Get raw value of ESP_ACK
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_ack_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_ACK
    #[inline(always)]
    pub fn set_esp_ack(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[25..26].store_le(value);
        Ok(())
    }
    
    /// EPB_DBF_REQ
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn epb_dbf_req(&self) -> bool {
        self.epb_dbf_req_raw()
    }
    
    /// Get raw value of EPB_DBF_REQ
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn epb_dbf_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of EPB_DBF_REQ
    #[inline(always)]
    pub fn set_epb_dbf_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[26..27].store_le(value);
        Ok(())
    }
    
    /// EPB_FAIL
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: ESC, SCC
    #[inline(always)]
    pub fn epb_fail(&self) -> u8 {
        self.epb_fail_raw()
    }
    
    /// Get raw value of EPB_FAIL
    ///
    /// - Start bit: 29
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn epb_fail_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[29..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of EPB_FAIL
    #[inline(always)]
    pub fn set_epb_fail(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1168 });
        }
        self.raw.view_bits_mut::<Lsb0>()[29..32].store_le(value);
        Ok(())
    }
    
    /// EPB_FORCE
    ///
    /// - Min: -1000
    /// - Max: 3000
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn epb_force(&self) -> f32 {
        self.epb_force_raw()
    }
    
    /// Get raw value of EPB_FORCE
    ///
    /// - Start bit: 32
    /// - Signal size: 12 bits
    /// - Factor: 1
    /// - Offset: -1000
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn epb_force_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..44].load_le::<u16>();
        
        let factor = 1_f32;
        let offset = -1000_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of EPB_FORCE
    #[inline(always)]
    pub fn set_epb_force(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1000_f32 || 3000_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1168 });
        }
        let factor = 1_f32;
        let offset = -1000_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[32..44].store_le(value);
        Ok(())
    }
    
    /// EPB_DBF_DECEL
    ///
    /// - Min: 0
    /// - Max: 2.54
    /// - Unit: "g"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn epb_dbf_decel(&self) -> f32 {
        self.epb_dbf_decel_raw()
    }
    
    /// Get raw value of EPB_DBF_DECEL
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn epb_dbf_decel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of EPB_DBF_DECEL
    #[inline(always)]
    pub fn set_epb_dbf_decel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2.54_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1168 });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Epb11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 7 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 7];
        raw.copy_from_slice(&payload[..7]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Epb11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Epb11")
                .field("epb_i_lamp", &self.epb_i_lamp())
                .field("epb_f_lamp", &self.epb_f_lamp())
                .field("epb_alarm", &self.epb_alarm())
                .field("epb_clu", &self.epb_clu())
                .field("epb_switch", &self.epb_switch())
                .field("epb_rbl", &self.epb_rbl())
                .field("epb_status", &self.epb_status())
                .field("epb_frc_err", &self.epb_frc_err())
                .field("epb_dbf_stat", &self.epb_dbf_stat())
                .field("esp_ack", &self.esp_ack())
                .field("epb_dbf_req", &self.epb_dbf_req())
                .field("epb_fail", &self.epb_fail())
                .field("epb_force", &self.epb_force())
                .field("epb_dbf_decel", &self.epb_dbf_decel())
            .finish()
        } else {
            f.debug_tuple("Epb11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Epb11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let epb_i_lamp = u.int_in_range(0..=15)?;
        let epb_f_lamp = u.int_in_range(0..=3)?;
        let epb_alarm = u.int_in_range(0..=3)?;
        let epb_clu = u.int_in_range(0..=255)?;
        let epb_switch = u.int_in_range(0..=3)?;
        let epb_rbl = u.int_in_range(0..=1)? == 1;
        let epb_status = u.int_in_range(0..=7)?;
        let epb_frc_err = u.int_in_range(0..=3)?;
        let epb_dbf_stat = u.int_in_range(0..=1)? == 1;
        let esp_ack = u.int_in_range(0..=1)? == 1;
        let epb_dbf_req = u.int_in_range(0..=1)? == 1;
        let epb_fail = u.int_in_range(0..=7)?;
        let epb_force = u.float_in_range(-1000_f32..=3000_f32)?;
        let epb_dbf_decel = u.float_in_range(0_f32..=2.54_f32)?;
        Epb11::new(epb_i_lamp,epb_f_lamp,epb_alarm,epb_clu,epb_switch,epb_rbl,epb_status,epb_frc_err,epb_dbf_stat,esp_ack,epb_dbf_req,epb_fail,epb_force,epb_dbf_decel).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EMS_H12
///
/// - ID: 399 (0x18f)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct EmsH12 {
    raw: [u8; 8],
}

impl EmsH12 {
    pub const MESSAGE_ID: u32 = 399;
    
    pub const R_TQ_ACN_APV_C_MIN: f32 = 0_f32;
    pub const R_TQ_ACN_APV_C_MAX: f32 = 51_f32;
    pub const R_P_ACN_C_MIN: f32 = 0_f32;
    pub const R_P_ACN_C_MAX: f32 = 31875_f32;
    pub const TQI_B_MIN: f32 = 0_f32;
    pub const TQI_B_MAX: f32 = 99.609375_f32;
    pub const SLD_VS_MIN: u8 = 0_u8;
    pub const SLD_VS_MAX: u8 = 255_u8;
    pub const CF_CDA_STAT_MIN: u8 = 0_u8;
    pub const CF_CDA_STAT_MAX: u8 = 7_u8;
    pub const CF_EMS_ISG_STAT_MIN: u8 = 0_u8;
    pub const CF_EMS_ISG_STAT_MAX: u8 = 7_u8;
    pub const R_N_ENG_IDL_TG_C_MIN: f32 = 0_f32;
    pub const R_N_ENG_IDL_TG_C_MAX: f32 = 2550_f32;
    pub const CF_EMS_DES_CUR_GR_MIN: u8 = 0_u8;
    pub const CF_EMS_DES_CUR_GR_MAX: u8 = 15_u8;
    pub const CF_EMS_ISG_STAT2_MIN: f32 = 0_f32;
    pub const CF_EMS_ISG_STAT2_MAX: f32 = 3_f32;
    
    /// Construct new EMS_H12 from values
    pub fn new(r_tq_acn_apv_c: f32, r_p_acn_c: f32, tqi_b: f32, sld_vs: u8, cf_cda_stat: u8, cf_ems_isg_stat: u8, cf_ems_oil_chg: bool, cf_ems_etc_limp_mod: bool, r_n_eng_idl_tg_c: f32, cf_ems_up_tar_gr: bool, cf_ems_down_tar_gr: bool, cf_ems_des_cur_gr: u8, cf_ems_sld_act: bool, cf_ems_sld_pos_act: bool, cf_ems_h_pres_stat: bool, cf_ems_isg_buz: bool, cf_ems_idl_stp_fco: bool, cf_ems_f_copen: bool, cf_ems_act_eco_act: bool, cf_ems_eng_run_norm: bool, cf_ems_isg_stat2: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_r_tq_acn_apv_c(r_tq_acn_apv_c)?;
        res.set_r_p_acn_c(r_p_acn_c)?;
        res.set_tqi_b(tqi_b)?;
        res.set_sld_vs(sld_vs)?;
        res.set_cf_cda_stat(cf_cda_stat)?;
        res.set_cf_ems_isg_stat(cf_ems_isg_stat)?;
        res.set_cf_ems_oil_chg(cf_ems_oil_chg)?;
        res.set_cf_ems_etc_limp_mod(cf_ems_etc_limp_mod)?;
        res.set_r_n_eng_idl_tg_c(r_n_eng_idl_tg_c)?;
        res.set_cf_ems_up_tar_gr(cf_ems_up_tar_gr)?;
        res.set_cf_ems_down_tar_gr(cf_ems_down_tar_gr)?;
        res.set_cf_ems_des_cur_gr(cf_ems_des_cur_gr)?;
        res.set_cf_ems_sld_act(cf_ems_sld_act)?;
        res.set_cf_ems_sld_pos_act(cf_ems_sld_pos_act)?;
        res.set_cf_ems_h_pres_stat(cf_ems_h_pres_stat)?;
        res.set_cf_ems_isg_buz(cf_ems_isg_buz)?;
        res.set_cf_ems_idl_stp_fco(cf_ems_idl_stp_fco)?;
        res.set_cf_ems_f_copen(cf_ems_f_copen)?;
        res.set_cf_ems_act_eco_act(cf_ems_act_eco_act)?;
        res.set_cf_ems_eng_run_norm(cf_ems_eng_run_norm)?;
        res.set_cf_ems_isg_stat2(cf_ems_isg_stat2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// R_TqAcnApvC
    ///
    /// - Min: 0
    /// - Max: 51
    /// - Unit: "Nm"
    /// - Receivers: DATC, IBOX
    #[inline(always)]
    pub fn r_tq_acn_apv_c(&self) -> f32 {
        self.r_tq_acn_apv_c_raw()
    }
    
    /// Get raw value of R_TqAcnApvC
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 0.2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn r_tq_acn_apv_c_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 0.2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of R_TqAcnApvC
    #[inline(always)]
    pub fn set_r_tq_acn_apv_c(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 51_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 399 });
        }
        let factor = 0.2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// R_PAcnC
    ///
    /// - Min: 0
    /// - Max: 31875
    /// - Unit: "hPa"
    /// - Receivers: DATC, IBOX
    #[inline(always)]
    pub fn r_p_acn_c(&self) -> f32 {
        self.r_p_acn_c_raw()
    }
    
    /// Get raw value of R_PAcnC
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn r_p_acn_c_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of R_PAcnC
    #[inline(always)]
    pub fn set_r_p_acn_c(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 31875_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 399 });
        }
        let factor = 125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// TQI_B
    ///
    /// - Min: 0
    /// - Max: 99.609375
    /// - Unit: "%"
    /// - Receivers: ABS, ESC, IBOX
    #[inline(always)]
    pub fn tqi_b(&self) -> f32 {
        self.tqi_b_raw()
    }
    
    /// Get raw value of TQI_B
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_b_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI_B
    #[inline(always)]
    pub fn set_tqi_b(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.609375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 399 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// SLD_VS
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: "km/h"
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn sld_vs(&self) -> u8 {
        self.sld_vs_raw()
    }
    
    /// Get raw value of SLD_VS
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn sld_vs_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of SLD_VS
    #[inline(always)]
    pub fn set_sld_vs(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 399 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CF_CdaStat
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AEMC, IBOX, TCU
    #[inline(always)]
    pub fn cf_cda_stat(&self) -> u8 {
        self.cf_cda_stat_raw()
    }
    
    /// Get raw value of CF_CdaStat
    ///
    /// - Start bit: 32
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_cda_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..35].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_CdaStat
    #[inline(always)]
    pub fn set_cf_cda_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 399 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..35].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_IsgStat
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: ABS, BCM, CLU, DATC, EPB, ESC, IBOX, LDWS_LKAS, MDPS, SMK, TCU
    #[inline(always)]
    pub fn cf_ems_isg_stat(&self) -> u8 {
        self.cf_ems_isg_stat_raw()
    }
    
    /// Get raw value of CF_Ems_IsgStat
    ///
    /// - Start bit: 35
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_isg_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[35..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_IsgStat
    #[inline(always)]
    pub fn set_cf_ems_isg_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 399 });
        }
        self.raw.view_bits_mut::<Lsb0>()[35..38].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_OilChg
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_ems_oil_chg(&self) -> bool {
        self.cf_ems_oil_chg_raw()
    }
    
    /// Get raw value of CF_Ems_OilChg
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_oil_chg_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_OilChg
    #[inline(always)]
    pub fn set_cf_ems_oil_chg(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[38..39].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_EtcLimpMod
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_ems_etc_limp_mod(&self) -> bool {
        self.cf_ems_etc_limp_mod_raw()
    }
    
    /// Get raw value of CF_Ems_EtcLimpMod
    ///
    /// - Start bit: 39
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_etc_limp_mod_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[39..40].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_EtcLimpMod
    #[inline(always)]
    pub fn set_cf_ems_etc_limp_mod(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[39..40].store_le(value);
        Ok(())
    }
    
    /// R_NEngIdlTgC
    ///
    /// - Min: 0
    /// - Max: 2550
    /// - Unit: "rpm"
    /// - Receivers: DATC, IBOX, TCU
    #[inline(always)]
    pub fn r_n_eng_idl_tg_c(&self) -> f32 {
        self.r_n_eng_idl_tg_c_raw()
    }
    
    /// Get raw value of R_NEngIdlTgC
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn r_n_eng_idl_tg_c_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 10_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of R_NEngIdlTgC
    #[inline(always)]
    pub fn set_r_n_eng_idl_tg_c(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2550_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 399 });
        }
        let factor = 10_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_UpTarGr
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_ems_up_tar_gr(&self) -> bool {
        self.cf_ems_up_tar_gr_raw()
    }
    
    /// Get raw value of CF_Ems_UpTarGr
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_up_tar_gr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_UpTarGr
    #[inline(always)]
    pub fn set_cf_ems_up_tar_gr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[48..49].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_DownTarGr
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_ems_down_tar_gr(&self) -> bool {
        self.cf_ems_down_tar_gr_raw()
    }
    
    /// Get raw value of CF_Ems_DownTarGr
    ///
    /// - Start bit: 49
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_down_tar_gr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[49..50].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_DownTarGr
    #[inline(always)]
    pub fn set_cf_ems_down_tar_gr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[49..50].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_DesCurGr
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_ems_des_cur_gr(&self) -> u8 {
        self.cf_ems_des_cur_gr_raw()
    }
    
    /// Get raw value of CF_Ems_DesCurGr
    ///
    /// - Start bit: 50
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_des_cur_gr_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[50..54].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_DesCurGr
    #[inline(always)]
    pub fn set_cf_ems_des_cur_gr(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 399 });
        }
        self.raw.view_bits_mut::<Lsb0>()[50..54].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_SldAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_ems_sld_act(&self) -> bool {
        self.cf_ems_sld_act_raw()
    }
    
    /// Get raw value of CF_Ems_SldAct
    ///
    /// - Start bit: 54
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_sld_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[54..55].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_SldAct
    #[inline(always)]
    pub fn set_cf_ems_sld_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[54..55].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_SldPosAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_ems_sld_pos_act(&self) -> bool {
        self.cf_ems_sld_pos_act_raw()
    }
    
    /// Get raw value of CF_Ems_SldPosAct
    ///
    /// - Start bit: 55
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_sld_pos_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[55..56].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_SldPosAct
    #[inline(always)]
    pub fn set_cf_ems_sld_pos_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[55..56].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_HPresStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: IBOX, TCU
    #[inline(always)]
    pub fn cf_ems_h_pres_stat(&self) -> bool {
        self.cf_ems_h_pres_stat_raw()
    }
    
    /// Get raw value of CF_Ems_HPresStat
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_h_pres_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_HPresStat
    #[inline(always)]
    pub fn set_cf_ems_h_pres_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[56..57].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_IsgBuz
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_ems_isg_buz(&self) -> bool {
        self.cf_ems_isg_buz_raw()
    }
    
    /// Get raw value of CF_Ems_IsgBuz
    ///
    /// - Start bit: 57
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_isg_buz_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[57..58].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_IsgBuz
    #[inline(always)]
    pub fn set_cf_ems_isg_buz(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[57..58].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_IdlStpFCO
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_ems_idl_stp_fco(&self) -> bool {
        self.cf_ems_idl_stp_fco_raw()
    }
    
    /// Get raw value of CF_Ems_IdlStpFCO
    ///
    /// - Start bit: 58
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_idl_stp_fco_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[58..59].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_IdlStpFCO
    #[inline(always)]
    pub fn set_cf_ems_idl_stp_fco(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[58..59].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_FCopen
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_ems_f_copen(&self) -> bool {
        self.cf_ems_f_copen_raw()
    }
    
    /// Get raw value of CF_Ems_FCopen
    ///
    /// - Start bit: 59
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_f_copen_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[59..60].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_FCopen
    #[inline(always)]
    pub fn set_cf_ems_f_copen(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[59..60].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_ActEcoAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX, TCU
    #[inline(always)]
    pub fn cf_ems_act_eco_act(&self) -> bool {
        self.cf_ems_act_eco_act_raw()
    }
    
    /// Get raw value of CF_Ems_ActEcoAct
    ///
    /// - Start bit: 60
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_act_eco_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[60..61].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_ActEcoAct
    #[inline(always)]
    pub fn set_cf_ems_act_eco_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[60..61].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_EngRunNorm
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ABS, ESC, IBOX, TCU
    #[inline(always)]
    pub fn cf_ems_eng_run_norm(&self) -> bool {
        self.cf_ems_eng_run_norm_raw()
    }
    
    /// Get raw value of CF_Ems_EngRunNorm
    ///
    /// - Start bit: 61
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_eng_run_norm_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[61..62].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_EngRunNorm
    #[inline(always)]
    pub fn set_cf_ems_eng_run_norm(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[61..62].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_IsgStat2
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, IBOX, TCU
    #[inline(always)]
    pub fn cf_ems_isg_stat2(&self) -> f32 {
        self.cf_ems_isg_stat2_raw()
    }
    
    /// Get raw value of CF_Ems_IsgStat2
    ///
    /// - Start bit: 62
    /// - Signal size: 2 bits
    /// - Factor: 2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_isg_stat2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[62..64].load_le::<u8>();
        
        let factor = 2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CF_Ems_IsgStat2
    #[inline(always)]
    pub fn set_cf_ems_isg_stat2(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 3_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 399 });
        }
        let factor = 2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[62..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for EmsH12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for EmsH12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("EmsH12")
                .field("r_tq_acn_apv_c", &self.r_tq_acn_apv_c())
                .field("r_p_acn_c", &self.r_p_acn_c())
                .field("tqi_b", &self.tqi_b())
                .field("sld_vs", &self.sld_vs())
                .field("cf_cda_stat", &self.cf_cda_stat())
                .field("cf_ems_isg_stat", &self.cf_ems_isg_stat())
                .field("cf_ems_oil_chg", &self.cf_ems_oil_chg())
                .field("cf_ems_etc_limp_mod", &self.cf_ems_etc_limp_mod())
                .field("r_n_eng_idl_tg_c", &self.r_n_eng_idl_tg_c())
                .field("cf_ems_up_tar_gr", &self.cf_ems_up_tar_gr())
                .field("cf_ems_down_tar_gr", &self.cf_ems_down_tar_gr())
                .field("cf_ems_des_cur_gr", &self.cf_ems_des_cur_gr())
                .field("cf_ems_sld_act", &self.cf_ems_sld_act())
                .field("cf_ems_sld_pos_act", &self.cf_ems_sld_pos_act())
                .field("cf_ems_h_pres_stat", &self.cf_ems_h_pres_stat())
                .field("cf_ems_isg_buz", &self.cf_ems_isg_buz())
                .field("cf_ems_idl_stp_fco", &self.cf_ems_idl_stp_fco())
                .field("cf_ems_f_copen", &self.cf_ems_f_copen())
                .field("cf_ems_act_eco_act", &self.cf_ems_act_eco_act())
                .field("cf_ems_eng_run_norm", &self.cf_ems_eng_run_norm())
                .field("cf_ems_isg_stat2", &self.cf_ems_isg_stat2())
            .finish()
        } else {
            f.debug_tuple("EmsH12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for EmsH12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let r_tq_acn_apv_c = u.float_in_range(0_f32..=51_f32)?;
        let r_p_acn_c = u.float_in_range(0_f32..=31875_f32)?;
        let tqi_b = u.float_in_range(0_f32..=99.609375_f32)?;
        let sld_vs = u.int_in_range(0..=255)?;
        let cf_cda_stat = u.int_in_range(0..=7)?;
        let cf_ems_isg_stat = u.int_in_range(0..=7)?;
        let cf_ems_oil_chg = u.int_in_range(0..=1)? == 1;
        let cf_ems_etc_limp_mod = u.int_in_range(0..=1)? == 1;
        let r_n_eng_idl_tg_c = u.float_in_range(0_f32..=2550_f32)?;
        let cf_ems_up_tar_gr = u.int_in_range(0..=1)? == 1;
        let cf_ems_down_tar_gr = u.int_in_range(0..=1)? == 1;
        let cf_ems_des_cur_gr = u.int_in_range(0..=15)?;
        let cf_ems_sld_act = u.int_in_range(0..=1)? == 1;
        let cf_ems_sld_pos_act = u.int_in_range(0..=1)? == 1;
        let cf_ems_h_pres_stat = u.int_in_range(0..=1)? == 1;
        let cf_ems_isg_buz = u.int_in_range(0..=1)? == 1;
        let cf_ems_idl_stp_fco = u.int_in_range(0..=1)? == 1;
        let cf_ems_f_copen = u.int_in_range(0..=1)? == 1;
        let cf_ems_act_eco_act = u.int_in_range(0..=1)? == 1;
        let cf_ems_eng_run_norm = u.int_in_range(0..=1)? == 1;
        let cf_ems_isg_stat2 = u.float_in_range(0_f32..=3_f32)?;
        EmsH12::new(r_tq_acn_apv_c,r_p_acn_c,tqi_b,sld_vs,cf_cda_stat,cf_ems_isg_stat,cf_ems_oil_chg,cf_ems_etc_limp_mod,r_n_eng_idl_tg_c,cf_ems_up_tar_gr,cf_ems_down_tar_gr,cf_ems_des_cur_gr,cf_ems_sld_act,cf_ems_sld_pos_act,cf_ems_h_pres_stat,cf_ems_isg_buz,cf_ems_idl_stp_fco,cf_ems_f_copen,cf_ems_act_eco_act,cf_ems_eng_run_norm,cf_ems_isg_stat2).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// LCA11
///
/// - ID: 1419 (0x58b)
/// - Size: 8 bytes
/// - Transmitter: LCA
#[derive(Clone, Copy)]
pub struct Lca11 {
    raw: [u8; 8],
}

impl Lca11 {
    pub const MESSAGE_ID: u32 = 1419;
    
    pub const CF_LCA_STAT_MIN: u8 = 0_u8;
    pub const CF_LCA_STAT_MAX: u8 = 15_u8;
    pub const CF_RCTA_STAT_MIN: u8 = 0_u8;
    pub const CF_RCTA_STAT_MAX: u8 = 15_u8;
    pub const CF_LCA_IND_LEFT_MIN: u8 = 0_u8;
    pub const CF_LCA_IND_LEFT_MAX: u8 = 3_u8;
    pub const CF_RCW_STAT_MIN: u8 = 0_u8;
    pub const CF_RCW_STAT_MAX: u8 = 15_u8;
    pub const CF_RCW_WARNING_MIN: u8 = 0_u8;
    pub const CF_RCW_WARNING_MAX: u8 = 3_u8;
    pub const CF_LCA_IND_RIGHT_MIN: u8 = 0_u8;
    pub const CF_LCA_IND_RIGHT_MAX: u8 = 3_u8;
    pub const CF_LCA_SND_WAN_STAT_MIN: u8 = 0_u8;
    pub const CF_LCA_SND_WAN_STAT_MAX: u8 = 3_u8;
    pub const CF_LCA_IND_BRI_LEFT_MIN: u8 = 0_u8;
    pub const CF_LCA_IND_BRI_LEFT_MAX: u8 = 255_u8;
    pub const CF_LCA_IND_BRI_RIGHT_MIN: u8 = 0_u8;
    pub const CF_LCA_IND_BRI_RIGHT_MAX: u8 = 255_u8;
    pub const CF_RCTA_IND_BRI_LEFT_MIN: u8 = 0_u8;
    pub const CF_RCTA_IND_BRI_LEFT_MAX: u8 = 255_u8;
    pub const CF_RCTA_IND_BRI_RIGHT_MIN: u8 = 0_u8;
    pub const CF_RCTA_IND_BRI_RIGHT_MAX: u8 = 255_u8;
    pub const CF_RCTA_IND_LEFT_MIN: u8 = 0_u8;
    pub const CF_RCTA_IND_LEFT_MAX: u8 = 3_u8;
    pub const CF_RCTA_IND_RIGHT_MIN: u8 = 0_u8;
    pub const CF_RCTA_IND_RIGHT_MAX: u8 = 3_u8;
    
    /// Construct new LCA11 from values
    pub fn new(cf_lca_stat: u8, cf_rcta_stat: u8, cf_lca_ind_left: u8, cf_rcw_stat: u8, cf_rcw_warning: u8, cf_lca_ind_right: u8, cf_lca_snd_wan_stat: u8, cf_fr_snd_wan: bool, cf_fl_snd_wan: bool, cf_rr_snd_wan: bool, cf_rl_snd_wan: bool, cf_lca_ind_bri_left: u8, cf_lca_ind_bri_right: u8, cf_rcta_ind_bri_left: u8, cf_rcta_ind_bri_right: u8, cf_rcta_ind_left: u8, cf_rcta_ind_right: u8, cf_snd_warn_for_clu: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_lca_stat(cf_lca_stat)?;
        res.set_cf_rcta_stat(cf_rcta_stat)?;
        res.set_cf_lca_ind_left(cf_lca_ind_left)?;
        res.set_cf_rcw_stat(cf_rcw_stat)?;
        res.set_cf_rcw_warning(cf_rcw_warning)?;
        res.set_cf_lca_ind_right(cf_lca_ind_right)?;
        res.set_cf_lca_snd_wan_stat(cf_lca_snd_wan_stat)?;
        res.set_cf_fr_snd_wan(cf_fr_snd_wan)?;
        res.set_cf_fl_snd_wan(cf_fl_snd_wan)?;
        res.set_cf_rr_snd_wan(cf_rr_snd_wan)?;
        res.set_cf_rl_snd_wan(cf_rl_snd_wan)?;
        res.set_cf_lca_ind_bri_left(cf_lca_ind_bri_left)?;
        res.set_cf_lca_ind_bri_right(cf_lca_ind_bri_right)?;
        res.set_cf_rcta_ind_bri_left(cf_rcta_ind_bri_left)?;
        res.set_cf_rcta_ind_bri_right(cf_rcta_ind_bri_right)?;
        res.set_cf_rcta_ind_left(cf_rcta_ind_left)?;
        res.set_cf_rcta_ind_right(cf_rcta_ind_right)?;
        res.set_cf_snd_warn_for_clu(cf_snd_warn_for_clu)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Lca_Stat
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_lca_stat(&self) -> u8 {
        self.cf_lca_stat_raw()
    }
    
    /// Get raw value of CF_Lca_Stat
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lca_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lca_Stat
    #[inline(always)]
    pub fn set_cf_lca_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1419 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..4].store_le(value);
        Ok(())
    }
    
    /// CF_Rcta_Stat
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_rcta_stat(&self) -> u8 {
        self.cf_rcta_stat_raw()
    }
    
    /// Get raw value of CF_Rcta_Stat
    ///
    /// - Start bit: 4
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rcta_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Rcta_Stat
    #[inline(always)]
    pub fn set_cf_rcta_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1419 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..8].store_le(value);
        Ok(())
    }
    
    /// CF_Lca_IndLeft
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_lca_ind_left(&self) -> u8 {
        self.cf_lca_ind_left_raw()
    }
    
    /// Get raw value of CF_Lca_IndLeft
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lca_ind_left_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lca_IndLeft
    #[inline(always)]
    pub fn set_cf_lca_ind_left(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1419 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// CF_Rcw_Stat
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_rcw_stat(&self) -> u8 {
        self.cf_rcw_stat_raw()
    }
    
    /// Get raw value of CF_Rcw_Stat
    ///
    /// - Start bit: 10
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rcw_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Rcw_Stat
    #[inline(always)]
    pub fn set_cf_rcw_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1419 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..14].store_le(value);
        Ok(())
    }
    
    /// CF_RCW_Warning
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_rcw_warning(&self) -> u8 {
        self.cf_rcw_warning_raw()
    }
    
    /// Get raw value of CF_RCW_Warning
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rcw_warning_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_RCW_Warning
    #[inline(always)]
    pub fn set_cf_rcw_warning(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1419 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
    /// CF_Lca_IndRight
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_lca_ind_right(&self) -> u8 {
        self.cf_lca_ind_right_raw()
    }
    
    /// Get raw value of CF_Lca_IndRight
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lca_ind_right_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lca_IndRight
    #[inline(always)]
    pub fn set_cf_lca_ind_right(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1419 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..18].store_le(value);
        Ok(())
    }
    
    /// CF_Lca_SndWan_Stat
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_lca_snd_wan_stat(&self) -> u8 {
        self.cf_lca_snd_wan_stat_raw()
    }
    
    /// Get raw value of CF_Lca_SndWan_Stat
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lca_snd_wan_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lca_SndWan_Stat
    #[inline(always)]
    pub fn set_cf_lca_snd_wan_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1419 });
        }
        self.raw.view_bits_mut::<Lsb0>()[18..20].store_le(value);
        Ok(())
    }
    
    /// CF_FR_SndWan
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_fr_snd_wan(&self) -> bool {
        self.cf_fr_snd_wan_raw()
    }
    
    /// Get raw value of CF_FR_SndWan
    ///
    /// - Start bit: 20
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fr_snd_wan_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[20..21].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_FR_SndWan
    #[inline(always)]
    pub fn set_cf_fr_snd_wan(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[20..21].store_le(value);
        Ok(())
    }
    
    /// CF_FL_SndWan
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_fl_snd_wan(&self) -> bool {
        self.cf_fl_snd_wan_raw()
    }
    
    /// Get raw value of CF_FL_SndWan
    ///
    /// - Start bit: 21
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fl_snd_wan_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[21..22].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_FL_SndWan
    #[inline(always)]
    pub fn set_cf_fl_snd_wan(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[21..22].store_le(value);
        Ok(())
    }
    
    /// CF_RR_SndWan
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_rr_snd_wan(&self) -> bool {
        self.cf_rr_snd_wan_raw()
    }
    
    /// Get raw value of CF_RR_SndWan
    ///
    /// - Start bit: 22
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rr_snd_wan_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[22..23].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_RR_SndWan
    #[inline(always)]
    pub fn set_cf_rr_snd_wan(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[22..23].store_le(value);
        Ok(())
    }
    
    /// CF_RL_SndWan
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_rl_snd_wan(&self) -> bool {
        self.cf_rl_snd_wan_raw()
    }
    
    /// Get raw value of CF_RL_SndWan
    ///
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rl_snd_wan_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[23..24].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_RL_SndWan
    #[inline(always)]
    pub fn set_cf_rl_snd_wan(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[23..24].store_le(value);
        Ok(())
    }
    
    /// CF_Lca_IndBriLeft
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_lca_ind_bri_left(&self) -> u8 {
        self.cf_lca_ind_bri_left_raw()
    }
    
    /// Get raw value of CF_Lca_IndBriLeft
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lca_ind_bri_left_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lca_IndBriLeft
    #[inline(always)]
    pub fn set_cf_lca_ind_bri_left(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1419 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CF_Lca_IndBriRight
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_lca_ind_bri_right(&self) -> u8 {
        self.cf_lca_ind_bri_right_raw()
    }
    
    /// Get raw value of CF_Lca_IndBriRight
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lca_ind_bri_right_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lca_IndBriRight
    #[inline(always)]
    pub fn set_cf_lca_ind_bri_right(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1419 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CF_RCTA_IndBriLeft
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_rcta_ind_bri_left(&self) -> u8 {
        self.cf_rcta_ind_bri_left_raw()
    }
    
    /// Get raw value of CF_RCTA_IndBriLeft
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rcta_ind_bri_left_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_RCTA_IndBriLeft
    #[inline(always)]
    pub fn set_cf_rcta_ind_bri_left(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1419 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// CF_RCTA_IndBriRight
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_rcta_ind_bri_right(&self) -> u8 {
        self.cf_rcta_ind_bri_right_raw()
    }
    
    /// Get raw value of CF_RCTA_IndBriRight
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rcta_ind_bri_right_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_RCTA_IndBriRight
    #[inline(always)]
    pub fn set_cf_rcta_ind_bri_right(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1419 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// CF_RCTA_IndLeft
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_rcta_ind_left(&self) -> u8 {
        self.cf_rcta_ind_left_raw()
    }
    
    /// Get raw value of CF_RCTA_IndLeft
    ///
    /// - Start bit: 56
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rcta_ind_left_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..58].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_RCTA_IndLeft
    #[inline(always)]
    pub fn set_cf_rcta_ind_left(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1419 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..58].store_le(value);
        Ok(())
    }
    
    /// CF_RCTA_IndRight
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_rcta_ind_right(&self) -> u8 {
        self.cf_rcta_ind_right_raw()
    }
    
    /// Get raw value of CF_RCTA_IndRight
    ///
    /// - Start bit: 58
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rcta_ind_right_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[58..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_RCTA_IndRight
    #[inline(always)]
    pub fn set_cf_rcta_ind_right(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1419 });
        }
        self.raw.view_bits_mut::<Lsb0>()[58..60].store_le(value);
        Ok(())
    }
    
    /// CF_SndWarnForClu
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_snd_warn_for_clu(&self) -> bool {
        self.cf_snd_warn_for_clu_raw()
    }
    
    /// Get raw value of CF_SndWarnForClu
    ///
    /// - Start bit: 60
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_snd_warn_for_clu_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[60..61].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_SndWarnForClu
    #[inline(always)]
    pub fn set_cf_snd_warn_for_clu(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[60..61].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Lca11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Lca11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Lca11")
                .field("cf_lca_stat", &self.cf_lca_stat())
                .field("cf_rcta_stat", &self.cf_rcta_stat())
                .field("cf_lca_ind_left", &self.cf_lca_ind_left())
                .field("cf_rcw_stat", &self.cf_rcw_stat())
                .field("cf_rcw_warning", &self.cf_rcw_warning())
                .field("cf_lca_ind_right", &self.cf_lca_ind_right())
                .field("cf_lca_snd_wan_stat", &self.cf_lca_snd_wan_stat())
                .field("cf_fr_snd_wan", &self.cf_fr_snd_wan())
                .field("cf_fl_snd_wan", &self.cf_fl_snd_wan())
                .field("cf_rr_snd_wan", &self.cf_rr_snd_wan())
                .field("cf_rl_snd_wan", &self.cf_rl_snd_wan())
                .field("cf_lca_ind_bri_left", &self.cf_lca_ind_bri_left())
                .field("cf_lca_ind_bri_right", &self.cf_lca_ind_bri_right())
                .field("cf_rcta_ind_bri_left", &self.cf_rcta_ind_bri_left())
                .field("cf_rcta_ind_bri_right", &self.cf_rcta_ind_bri_right())
                .field("cf_rcta_ind_left", &self.cf_rcta_ind_left())
                .field("cf_rcta_ind_right", &self.cf_rcta_ind_right())
                .field("cf_snd_warn_for_clu", &self.cf_snd_warn_for_clu())
            .finish()
        } else {
            f.debug_tuple("Lca11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Lca11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_lca_stat = u.int_in_range(0..=15)?;
        let cf_rcta_stat = u.int_in_range(0..=15)?;
        let cf_lca_ind_left = u.int_in_range(0..=3)?;
        let cf_rcw_stat = u.int_in_range(0..=15)?;
        let cf_rcw_warning = u.int_in_range(0..=3)?;
        let cf_lca_ind_right = u.int_in_range(0..=3)?;
        let cf_lca_snd_wan_stat = u.int_in_range(0..=3)?;
        let cf_fr_snd_wan = u.int_in_range(0..=1)? == 1;
        let cf_fl_snd_wan = u.int_in_range(0..=1)? == 1;
        let cf_rr_snd_wan = u.int_in_range(0..=1)? == 1;
        let cf_rl_snd_wan = u.int_in_range(0..=1)? == 1;
        let cf_lca_ind_bri_left = u.int_in_range(0..=255)?;
        let cf_lca_ind_bri_right = u.int_in_range(0..=255)?;
        let cf_rcta_ind_bri_left = u.int_in_range(0..=255)?;
        let cf_rcta_ind_bri_right = u.int_in_range(0..=255)?;
        let cf_rcta_ind_left = u.int_in_range(0..=3)?;
        let cf_rcta_ind_right = u.int_in_range(0..=3)?;
        let cf_snd_warn_for_clu = u.int_in_range(0..=1)? == 1;
        Lca11::new(cf_lca_stat,cf_rcta_stat,cf_lca_ind_left,cf_rcw_stat,cf_rcw_warning,cf_lca_ind_right,cf_lca_snd_wan_stat,cf_fr_snd_wan,cf_fl_snd_wan,cf_rr_snd_wan,cf_rl_snd_wan,cf_lca_ind_bri_left,cf_lca_ind_bri_right,cf_rcta_ind_bri_left,cf_rcta_ind_bri_right,cf_rcta_ind_left,cf_rcta_ind_right,cf_snd_warn_for_clu).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ABS11
///
/// - ID: 906 (0x38a)
/// - Size: 8 bytes
/// - Transmitter: ABS
#[derive(Clone, Copy)]
pub struct Abs11 {
    raw: [u8; 8],
}

impl Abs11 {
    pub const MESSAGE_ID: u32 = 906;
    
    pub const ESS_STAT_MIN: u8 = 0_u8;
    pub const ESS_STAT_MAX: u8 = 3_u8;
    
    /// Construct new ABS11 from values
    pub fn new(abs_def: bool, ebd_def: bool, abs_act: bool, abs_w_lamp: bool, ebd_w_lamp: bool, abs_diag: bool, ess_stat: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_abs_def(abs_def)?;
        res.set_ebd_def(ebd_def)?;
        res.set_abs_act(abs_act)?;
        res.set_abs_w_lamp(abs_w_lamp)?;
        res.set_ebd_w_lamp(ebd_w_lamp)?;
        res.set_abs_diag(abs_diag)?;
        res.set_ess_stat(ess_stat)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// ABS_DEF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ACU, EMS, SPAS, TCU
    #[inline(always)]
    pub fn abs_def(&self) -> bool {
        self.abs_def_raw()
    }
    
    /// Get raw value of ABS_DEF
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn abs_def_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ABS_DEF
    #[inline(always)]
    pub fn set_abs_def(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// EBD_DEF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, SPAS, TCU
    #[inline(always)]
    pub fn ebd_def(&self) -> bool {
        self.ebd_def_raw()
    }
    
    /// Get raw value of EBD_DEF
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ebd_def_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of EBD_DEF
    #[inline(always)]
    pub fn set_ebd_def(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// ABS_ACT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ACU, EPB, SPAS, TCU
    #[inline(always)]
    pub fn abs_act(&self) -> bool {
        self.abs_act_raw()
    }
    
    /// Get raw value of ABS_ACT
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn abs_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ABS_ACT
    #[inline(always)]
    pub fn set_abs_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// ABS_W_LAMP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, CLU, CUBIS, MTS, TMU
    #[inline(always)]
    pub fn abs_w_lamp(&self) -> bool {
        self.abs_w_lamp_raw()
    }
    
    /// Get raw value of ABS_W_LAMP
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn abs_w_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ABS_W_LAMP
    #[inline(always)]
    pub fn set_abs_w_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// EBD_W_LAMP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, CLU
    #[inline(always)]
    pub fn ebd_w_lamp(&self) -> bool {
        self.ebd_w_lamp_raw()
    }
    
    /// Get raw value of EBD_W_LAMP
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ebd_w_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of EBD_W_LAMP
    #[inline(always)]
    pub fn set_ebd_w_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// ABS_DIAG
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, CLU
    #[inline(always)]
    pub fn abs_diag(&self) -> bool {
        self.abs_diag_raw()
    }
    
    /// Get raw value of ABS_DIAG
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn abs_diag_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ABS_DIAG
    #[inline(always)]
    pub fn set_abs_diag(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// ESS_STAT
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: _4WD, BCM, CLU, EMS
    #[inline(always)]
    pub fn ess_stat(&self) -> u8 {
        self.ess_stat_raw()
    }
    
    /// Get raw value of ESS_STAT
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ess_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESS_STAT
    #[inline(always)]
    pub fn set_ess_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 906 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Abs11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Abs11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Abs11")
                .field("abs_def", &self.abs_def())
                .field("ebd_def", &self.ebd_def())
                .field("abs_act", &self.abs_act())
                .field("abs_w_lamp", &self.abs_w_lamp())
                .field("ebd_w_lamp", &self.ebd_w_lamp())
                .field("abs_diag", &self.abs_diag())
                .field("ess_stat", &self.ess_stat())
            .finish()
        } else {
            f.debug_tuple("Abs11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Abs11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let abs_def = u.int_in_range(0..=1)? == 1;
        let ebd_def = u.int_in_range(0..=1)? == 1;
        let abs_act = u.int_in_range(0..=1)? == 1;
        let abs_w_lamp = u.int_in_range(0..=1)? == 1;
        let ebd_w_lamp = u.int_in_range(0..=1)? == 1;
        let abs_diag = u.int_in_range(0..=1)? == 1;
        let ess_stat = u.int_in_range(0..=3)?;
        Abs11::new(abs_def,ebd_def,abs_act,abs_w_lamp,ebd_w_lamp,abs_diag,ess_stat).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// WHL_PUL11
///
/// - ID: 903 (0x387)
/// - Size: 6 bytes
/// - Transmitter: ABS
#[derive(Clone, Copy)]
pub struct WhlPul11 {
    raw: [u8; 6],
}

impl WhlPul11 {
    pub const MESSAGE_ID: u32 = 903;
    
    pub const WHL_PUL_FL_MIN: f32 = 0_f32;
    pub const WHL_PUL_FL_MAX: f32 = 127.5_f32;
    pub const WHL_PUL_FR_MIN: f32 = 0_f32;
    pub const WHL_PUL_FR_MAX: f32 = 127.5_f32;
    pub const WHL_PUL_RL_MIN: f32 = 0_f32;
    pub const WHL_PUL_RL_MAX: f32 = 127.5_f32;
    pub const WHL_PUL_RR_MIN: f32 = 0_f32;
    pub const WHL_PUL_RR_MAX: f32 = 127.5_f32;
    pub const WHL_DIR_FL_MIN: u8 = 0_u8;
    pub const WHL_DIR_FL_MAX: u8 = 3_u8;
    pub const WHL_DIR_FR_MIN: u8 = 0_u8;
    pub const WHL_DIR_FR_MAX: u8 = 3_u8;
    pub const WHL_DIR_RL_MIN: u8 = 0_u8;
    pub const WHL_DIR_RL_MAX: u8 = 3_u8;
    pub const WHL_DIR_RR_MIN: u8 = 0_u8;
    pub const WHL_DIR_RR_MAX: u8 = 3_u8;
    pub const WHL_PUL_CHKSUM_MIN: u8 = 0_u8;
    pub const WHL_PUL_CHKSUM_MAX: u8 = 255_u8;
    
    /// Construct new WHL_PUL11 from values
    pub fn new(whl_pul_fl: f32, whl_pul_fr: f32, whl_pul_rl: f32, whl_pul_rr: f32, whl_dir_fl: u8, whl_dir_fr: u8, whl_dir_rl: u8, whl_dir_rr: u8, whl_pul_chksum: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 6] };
        res.set_whl_pul_fl(whl_pul_fl)?;
        res.set_whl_pul_fr(whl_pul_fr)?;
        res.set_whl_pul_rl(whl_pul_rl)?;
        res.set_whl_pul_rr(whl_pul_rr)?;
        res.set_whl_dir_fl(whl_dir_fl)?;
        res.set_whl_dir_fr(whl_dir_fr)?;
        res.set_whl_dir_rl(whl_dir_rl)?;
        res.set_whl_dir_rr(whl_dir_rr)?;
        res.set_whl_pul_chksum(whl_pul_chksum)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 6] {
        &self.raw
    }
    
    /// WHL_PUL_FL
    ///
    /// - Min: 0
    /// - Max: 127.5
    /// - Unit: "pulse count"
    /// - Receivers: CUBIS, EPB, IBOX, SPAS, TMU, TPMS, CUBIS, EPB, IBOX, LDWS_LKAS, SPAS, TMU, TPMS
    #[inline(always)]
    pub fn whl_pul_fl(&self) -> f32 {
        self.whl_pul_fl_raw()
    }
    
    /// Get raw value of WHL_PUL_FL
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_pul_fl_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of WHL_PUL_FL
    #[inline(always)]
    pub fn set_whl_pul_fl(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 903 });
        }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// WHL_PUL_FR
    ///
    /// - Min: 0
    /// - Max: 127.5
    /// - Unit: "pulse count"
    /// - Receivers: CUBIS, EPB, IBOX, SPAS, TMU, TPMS, CUBIS, EPB, IBOX, LDWS_LKAS, SPAS, TMU, TPMS
    #[inline(always)]
    pub fn whl_pul_fr(&self) -> f32 {
        self.whl_pul_fr_raw()
    }
    
    /// Get raw value of WHL_PUL_FR
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_pul_fr_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of WHL_PUL_FR
    #[inline(always)]
    pub fn set_whl_pul_fr(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 903 });
        }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// WHL_PUL_RL
    ///
    /// - Min: 0
    /// - Max: 127.5
    /// - Unit: "pulse count"
    /// - Receivers: CUBIS, EPB, IBOX, SPAS, TMU, TPMS, CUBIS, EPB, IBOX, LDWS_LKAS, SPAS, TMU, TPMS
    #[inline(always)]
    pub fn whl_pul_rl(&self) -> f32 {
        self.whl_pul_rl_raw()
    }
    
    /// Get raw value of WHL_PUL_RL
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_pul_rl_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of WHL_PUL_RL
    #[inline(always)]
    pub fn set_whl_pul_rl(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 903 });
        }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// WHL_PUL_RR
    ///
    /// - Min: 0
    /// - Max: 127.5
    /// - Unit: "pulse count"
    /// - Receivers: CUBIS, EPB, IBOX, SPAS, TMU, TPMS, CUBIS, EPB, IBOX, LDWS_LKAS, SPAS, TMU, TPMS
    #[inline(always)]
    pub fn whl_pul_rr(&self) -> f32 {
        self.whl_pul_rr_raw()
    }
    
    /// Get raw value of WHL_PUL_RR
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_pul_rr_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of WHL_PUL_RR
    #[inline(always)]
    pub fn set_whl_pul_rr(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 127.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 903 });
        }
        let factor = 0.5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// WHL_DIR_FL
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EPB, SPAS, TPMS, EPB, LCA, SPAS, TPMS
    #[inline(always)]
    pub fn whl_dir_fl(&self) -> u8 {
        self.whl_dir_fl_raw()
    }
    
    /// Get raw value of WHL_DIR_FL
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_dir_fl_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of WHL_DIR_FL
    #[inline(always)]
    pub fn set_whl_dir_fl(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 903 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..34].store_le(value);
        Ok(())
    }
    
    /// WHL_DIR_FR
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EPB, SPAS, TPMS, EPB, LCA, SPAS, TPMS
    #[inline(always)]
    pub fn whl_dir_fr(&self) -> u8 {
        self.whl_dir_fr_raw()
    }
    
    /// Get raw value of WHL_DIR_FR
    ///
    /// - Start bit: 34
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_dir_fr_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[34..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of WHL_DIR_FR
    #[inline(always)]
    pub fn set_whl_dir_fr(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 903 });
        }
        self.raw.view_bits_mut::<Lsb0>()[34..36].store_le(value);
        Ok(())
    }
    
    /// WHL_DIR_RL
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EPB, SPAS, TPMS, EPB, LCA, SPAS, TPMS
    #[inline(always)]
    pub fn whl_dir_rl(&self) -> u8 {
        self.whl_dir_rl_raw()
    }
    
    /// Get raw value of WHL_DIR_RL
    ///
    /// - Start bit: 36
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_dir_rl_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[36..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of WHL_DIR_RL
    #[inline(always)]
    pub fn set_whl_dir_rl(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 903 });
        }
        self.raw.view_bits_mut::<Lsb0>()[36..38].store_le(value);
        Ok(())
    }
    
    /// WHL_DIR_RR
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EPB, SPAS, TPMS, EPB, LCA, SPAS, TPMS
    #[inline(always)]
    pub fn whl_dir_rr(&self) -> u8 {
        self.whl_dir_rr_raw()
    }
    
    /// Get raw value of WHL_DIR_RR
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_dir_rr_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of WHL_DIR_RR
    #[inline(always)]
    pub fn set_whl_dir_rr(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 903 });
        }
        self.raw.view_bits_mut::<Lsb0>()[38..40].store_le(value);
        Ok(())
    }
    
    /// WHL_PUL_Chksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EPB, SPAS, TPMS, EPB, LCA, LDWS_LKAS, SPAS, TPMS
    #[inline(always)]
    pub fn whl_pul_chksum(&self) -> u8 {
        self.whl_pul_chksum_raw()
    }
    
    /// Get raw value of WHL_PUL_Chksum
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_pul_chksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of WHL_PUL_Chksum
    #[inline(always)]
    pub fn set_whl_pul_chksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 903 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for WhlPul11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 6 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 6];
        raw.copy_from_slice(&payload[..6]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for WhlPul11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("WhlPul11")
                .field("whl_pul_fl", &self.whl_pul_fl())
                .field("whl_pul_fr", &self.whl_pul_fr())
                .field("whl_pul_rl", &self.whl_pul_rl())
                .field("whl_pul_rr", &self.whl_pul_rr())
                .field("whl_dir_fl", &self.whl_dir_fl())
                .field("whl_dir_fr", &self.whl_dir_fr())
                .field("whl_dir_rl", &self.whl_dir_rl())
                .field("whl_dir_rr", &self.whl_dir_rr())
                .field("whl_pul_chksum", &self.whl_pul_chksum())
            .finish()
        } else {
            f.debug_tuple("WhlPul11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for WhlPul11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let whl_pul_fl = u.float_in_range(0_f32..=127.5_f32)?;
        let whl_pul_fr = u.float_in_range(0_f32..=127.5_f32)?;
        let whl_pul_rl = u.float_in_range(0_f32..=127.5_f32)?;
        let whl_pul_rr = u.float_in_range(0_f32..=127.5_f32)?;
        let whl_dir_fl = u.int_in_range(0..=3)?;
        let whl_dir_fr = u.int_in_range(0..=3)?;
        let whl_dir_rl = u.int_in_range(0..=3)?;
        let whl_dir_rr = u.int_in_range(0..=3)?;
        let whl_pul_chksum = u.int_in_range(0..=255)?;
        WhlPul11::new(whl_pul_fl,whl_pul_fr,whl_pul_rl,whl_pul_rr,whl_dir_fl,whl_dir_fr,whl_dir_rl,whl_dir_rr,whl_pul_chksum).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// TMU11
///
/// - ID: 1415 (0x587)
/// - Size: 8 bytes
/// - Transmitter: IBOX
#[derive(Clone, Copy)]
pub struct Tmu11 {
    raw: [u8; 8],
}

impl Tmu11 {
    pub const MESSAGE_ID: u32 = 1415;
    
    pub const CF_TMU_REQ_REP_CND_MIN: u8 = 0_u8;
    pub const CF_TMU_REQ_REP_CND_MAX: u8 = 3_u8;
    pub const CF_TMU_TEMP_SET_MIN: u16 = 0_u16;
    pub const CF_TMU_TEMP_SET_MAX: u16 = 20_u16;
    pub const CF_TMU_ALIVE_CNT1_MIN: u8 = 0_u8;
    pub const CF_TMU_ALIVE_CNT1_MAX: u8 = 15_u8;
    
    /// Construct new TMU11 from values
    pub fn new(cf_tmu_veh_sld: bool, cf_tmu_veh_immo: bool, cf_tmu_req_rep_cnd: u8, cf_tmu_aircon_ctr: bool, cf_tmu_temp_md: bool, cf_tmu_temp_set: u16, cf_tmu_defrost_ctr: bool, cf_tmu_alive_cnt1: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_tmu_veh_sld(cf_tmu_veh_sld)?;
        res.set_cf_tmu_veh_immo(cf_tmu_veh_immo)?;
        res.set_cf_tmu_req_rep_cnd(cf_tmu_req_rep_cnd)?;
        res.set_cf_tmu_aircon_ctr(cf_tmu_aircon_ctr)?;
        res.set_cf_tmu_temp_md(cf_tmu_temp_md)?;
        res.set_cf_tmu_temp_set(cf_tmu_temp_set)?;
        res.set_cf_tmu_defrost_ctr(cf_tmu_defrost_ctr)?;
        res.set_cf_tmu_alive_cnt1(cf_tmu_alive_cnt1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Tmu_VehSld
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_tmu_veh_sld(&self) -> bool {
        self.cf_tmu_veh_sld_raw()
    }
    
    /// Get raw value of CF_Tmu_VehSld
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tmu_veh_sld_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tmu_VehSld
    #[inline(always)]
    pub fn set_cf_tmu_veh_sld(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// CF_Tmu_VehImmo
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_tmu_veh_immo(&self) -> bool {
        self.cf_tmu_veh_immo_raw()
    }
    
    /// Get raw value of CF_Tmu_VehImmo
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tmu_veh_immo_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tmu_VehImmo
    #[inline(always)]
    pub fn set_cf_tmu_veh_immo(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// CF_Tmu_ReqRepCnd
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_tmu_req_rep_cnd(&self) -> u8 {
        self.cf_tmu_req_rep_cnd_raw()
    }
    
    /// Get raw value of CF_Tmu_ReqRepCnd
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tmu_req_rep_cnd_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Tmu_ReqRepCnd
    #[inline(always)]
    pub fn set_cf_tmu_req_rep_cnd(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1415 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// CF_Tmu_AirconCtr
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: DATC
    #[inline(always)]
    pub fn cf_tmu_aircon_ctr(&self) -> bool {
        self.cf_tmu_aircon_ctr_raw()
    }
    
    /// Get raw value of CF_Tmu_AirconCtr
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tmu_aircon_ctr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tmu_AirconCtr
    #[inline(always)]
    pub fn set_cf_tmu_aircon_ctr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// CF_Tmu_TempMd
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: DATC
    #[inline(always)]
    pub fn cf_tmu_temp_md(&self) -> bool {
        self.cf_tmu_temp_md_raw()
    }
    
    /// Get raw value of CF_Tmu_TempMd
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tmu_temp_md_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tmu_TempMd
    #[inline(always)]
    pub fn set_cf_tmu_temp_md(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// CF_Tmu_TempSet
    ///
    /// - Min: 0
    /// - Max: 20
    /// - Unit: ""
    /// - Receivers: DATC
    #[inline(always)]
    pub fn cf_tmu_temp_set(&self) -> u16 {
        self.cf_tmu_temp_set_raw()
    }
    
    /// Get raw value of CF_Tmu_TempSet
    ///
    /// - Start bit: 6
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tmu_temp_set_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[6..22].load_le::<u16>();
        
        signal
    }
    
    /// Set value of CF_Tmu_TempSet
    #[inline(always)]
    pub fn set_cf_tmu_temp_set(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 20_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1415 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..22].store_le(value);
        Ok(())
    }
    
    /// CF_Tmu_DefrostCtr
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: DATC, FATC
    #[inline(always)]
    pub fn cf_tmu_defrost_ctr(&self) -> bool {
        self.cf_tmu_defrost_ctr_raw()
    }
    
    /// Get raw value of CF_Tmu_DefrostCtr
    ///
    /// - Start bit: 22
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tmu_defrost_ctr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[22..23].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tmu_DefrostCtr
    #[inline(always)]
    pub fn set_cf_tmu_defrost_ctr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[22..23].store_le(value);
        Ok(())
    }
    
    /// CF_Tmu_AliveCnt1
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_tmu_alive_cnt1(&self) -> u8 {
        self.cf_tmu_alive_cnt1_raw()
    }
    
    /// Get raw value of CF_Tmu_AliveCnt1
    ///
    /// - Start bit: 56
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tmu_alive_cnt1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Tmu_AliveCnt1
    #[inline(always)]
    pub fn set_cf_tmu_alive_cnt1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1415 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..60].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Tmu11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Tmu11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Tmu11")
                .field("cf_tmu_veh_sld", &self.cf_tmu_veh_sld())
                .field("cf_tmu_veh_immo", &self.cf_tmu_veh_immo())
                .field("cf_tmu_req_rep_cnd", &self.cf_tmu_req_rep_cnd())
                .field("cf_tmu_aircon_ctr", &self.cf_tmu_aircon_ctr())
                .field("cf_tmu_temp_md", &self.cf_tmu_temp_md())
                .field("cf_tmu_temp_set", &self.cf_tmu_temp_set())
                .field("cf_tmu_defrost_ctr", &self.cf_tmu_defrost_ctr())
                .field("cf_tmu_alive_cnt1", &self.cf_tmu_alive_cnt1())
            .finish()
        } else {
            f.debug_tuple("Tmu11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Tmu11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_tmu_veh_sld = u.int_in_range(0..=1)? == 1;
        let cf_tmu_veh_immo = u.int_in_range(0..=1)? == 1;
        let cf_tmu_req_rep_cnd = u.int_in_range(0..=3)?;
        let cf_tmu_aircon_ctr = u.int_in_range(0..=1)? == 1;
        let cf_tmu_temp_md = u.int_in_range(0..=1)? == 1;
        let cf_tmu_temp_set = u.int_in_range(0..=20)?;
        let cf_tmu_defrost_ctr = u.int_in_range(0..=1)? == 1;
        let cf_tmu_alive_cnt1 = u.int_in_range(0..=15)?;
        Tmu11::new(cf_tmu_veh_sld,cf_tmu_veh_immo,cf_tmu_req_rep_cnd,cf_tmu_aircon_ctr,cf_tmu_temp_md,cf_tmu_temp_set,cf_tmu_defrost_ctr,cf_tmu_alive_cnt1).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// WHL_SPD11
///
/// - ID: 902 (0x386)
/// - Size: 8 bytes
/// - Transmitter: ABS
#[derive(Clone, Copy)]
pub struct WhlSpd11 {
    raw: [u8; 8],
}

impl WhlSpd11 {
    pub const MESSAGE_ID: u32 = 902;
    
    pub const WHL_SPD_FL_MIN: f32 = 0_f32;
    pub const WHL_SPD_FL_MAX: f32 = 511.96875_f32;
    pub const WHL_SPD_FR_MIN: f32 = 0_f32;
    pub const WHL_SPD_FR_MAX: f32 = 511.96875_f32;
    pub const WHL_SPD_RL_MIN: f32 = 0_f32;
    pub const WHL_SPD_RL_MAX: f32 = 511.96875_f32;
    pub const WHL_SPD_RR_MIN: f32 = 0_f32;
    pub const WHL_SPD_RR_MAX: f32 = 511.96875_f32;
    pub const WHL_SPD_ALIVE_COUNTER_LSB_MIN: u8 = 0_u8;
    pub const WHL_SPD_ALIVE_COUNTER_LSB_MAX: u8 = 15_u8;
    pub const WHL_SPD_ALIVE_COUNTER_MSB_MIN: u8 = 0_u8;
    pub const WHL_SPD_ALIVE_COUNTER_MSB_MAX: u8 = 15_u8;
    pub const WHL_SPD_CHECKSUM_LSB_MIN: u8 = 0_u8;
    pub const WHL_SPD_CHECKSUM_LSB_MAX: u8 = 15_u8;
    pub const WHL_SPD_CHECKSUM_MSB_MIN: u8 = 0_u8;
    pub const WHL_SPD_CHECKSUM_MSB_MAX: u8 = 15_u8;
    
    /// Construct new WHL_SPD11 from values
    pub fn new(whl_spd_fl: f32, whl_spd_fr: f32, whl_spd_rl: f32, whl_spd_rr: f32, whl_spd_alive_counter_lsb: u8, whl_spd_alive_counter_msb: u8, whl_spd_checksum_lsb: u8, whl_spd_checksum_msb: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_whl_spd_fl(whl_spd_fl)?;
        res.set_whl_spd_fr(whl_spd_fr)?;
        res.set_whl_spd_rl(whl_spd_rl)?;
        res.set_whl_spd_rr(whl_spd_rr)?;
        res.set_whl_spd_alive_counter_lsb(whl_spd_alive_counter_lsb)?;
        res.set_whl_spd_alive_counter_msb(whl_spd_alive_counter_msb)?;
        res.set_whl_spd_checksum_lsb(whl_spd_checksum_lsb)?;
        res.set_whl_spd_checksum_msb(whl_spd_checksum_msb)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// WHL_SPD_FL
    ///
    /// - Min: 0
    /// - Max: 511.96875
    /// - Unit: "km/h"
    /// - Receivers: _4WD, AFLS, AHLS, AVM, CLU, CUBIS, ECS, EMS, EPB, IBOX, LDWS_LKAS, PGS, PSB, SCC, SMK, SPAS, TCU, TPMS, _4WD, ACU, AFLS, AHLS, AVM, CLU, ECS, EMS, EPB, IBOX, LCA, LDWS_LKAS, PGS, PSB, SCC, SMK, SPAS, TCU, TPMS
    #[inline(always)]
    pub fn whl_spd_fl(&self) -> f32 {
        self.whl_spd_fl_raw()
    }
    
    /// Get raw value of WHL_SPD_FL
    ///
    /// - Start bit: 0
    /// - Signal size: 14 bits
    /// - Factor: 0.03125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_spd_fl_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..14].load_le::<u16>();
        
        let factor = 0.03125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of WHL_SPD_FL
    #[inline(always)]
    pub fn set_whl_spd_fl(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 511.96875_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 902 });
        }
        let factor = 0.03125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..14].store_le(value);
        Ok(())
    }
    
    /// WHL_SPD_FR
    ///
    /// - Min: 0
    /// - Max: 511.96875
    /// - Unit: "km/h"
    /// - Receivers: _4WD, ACU, AFLS, AHLS, AVM, CLU, CUBIS, ECS, EMS, EPB, IBOX, LDWS_LKAS, PGS, PSB, SCC, SMK, SPAS, TCU, TPMS, _4WD, ACU, AFLS, AHLS, AVM, CLU, ECS, EMS, EPB, IBOX, LCA, LDWS_LKAS, PGS, PSB, SCC, SMK, SPAS, TCU, TPMS
    #[inline(always)]
    pub fn whl_spd_fr(&self) -> f32 {
        self.whl_spd_fr_raw()
    }
    
    /// Get raw value of WHL_SPD_FR
    ///
    /// - Start bit: 16
    /// - Signal size: 14 bits
    /// - Factor: 0.03125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_spd_fr_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..30].load_le::<u16>();
        
        let factor = 0.03125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of WHL_SPD_FR
    #[inline(always)]
    pub fn set_whl_spd_fr(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 511.96875_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 902 });
        }
        let factor = 0.03125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[16..30].store_le(value);
        Ok(())
    }
    
    /// WHL_SPD_RL
    ///
    /// - Min: 0
    /// - Max: 511.96875
    /// - Unit: "km/h"
    /// - Receivers: _4WD, AFLS, AHLS, AVM, BCM, CLU, CUBIS, ECS, EMS, EPB, IBOX, LDWS_LKAS, PGS, PSB, SCC, SMK, SPAS, TCU, TPMS, _4WD, ACU, AFLS, AHLS, AVM, BCM, CLU, ECS, EMS, EPB, IBOX, LCA, LDWS_LKAS, PGS, PSB, SCC, SMK, SPAS, TCU, TPMS
    #[inline(always)]
    pub fn whl_spd_rl(&self) -> f32 {
        self.whl_spd_rl_raw()
    }
    
    /// Get raw value of WHL_SPD_RL
    ///
    /// - Start bit: 32
    /// - Signal size: 14 bits
    /// - Factor: 0.03125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_spd_rl_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..46].load_le::<u16>();
        
        let factor = 0.03125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of WHL_SPD_RL
    #[inline(always)]
    pub fn set_whl_spd_rl(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 511.96875_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 902 });
        }
        let factor = 0.03125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[32..46].store_le(value);
        Ok(())
    }
    
    /// WHL_SPD_RR
    ///
    /// - Min: 0
    /// - Max: 511.96875
    /// - Unit: "km/h"
    /// - Receivers: _4WD, AFLS, AHLS, AVM, CLU, CUBIS, ECS, EMS, EPB, IBOX, LDWS_LKAS, PGS, PSB, SCC, SMK, SPAS, TCU, TPMS, _4WD, ACU, AFLS, AHLS, AVM, CLU, ECS, EMS, EPB, IBOX, LCA, LDWS_LKAS, PGS, PSB, SCC, SMK, SPAS, TCU, TPMS
    #[inline(always)]
    pub fn whl_spd_rr(&self) -> f32 {
        self.whl_spd_rr_raw()
    }
    
    /// Get raw value of WHL_SPD_RR
    ///
    /// - Start bit: 48
    /// - Signal size: 14 bits
    /// - Factor: 0.03125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_spd_rr_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..62].load_le::<u16>();
        
        let factor = 0.03125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of WHL_SPD_RR
    #[inline(always)]
    pub fn set_whl_spd_rr(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 511.96875_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 902 });
        }
        let factor = 0.03125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[48..62].store_le(value);
        Ok(())
    }
    
    /// WHL_SPD_AliveCounter_LSB
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, LPI, TCU, TMU
    #[inline(always)]
    pub fn whl_spd_alive_counter_lsb(&self) -> u8 {
        self.whl_spd_alive_counter_lsb_raw()
    }
    
    /// Get raw value of WHL_SPD_AliveCounter_LSB
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_spd_alive_counter_lsb_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of WHL_SPD_AliveCounter_LSB
    #[inline(always)]
    pub fn set_whl_spd_alive_counter_lsb(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 902 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
    /// WHL_SPD_AliveCounter_MSB
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, LPI, TCU, TMU
    #[inline(always)]
    pub fn whl_spd_alive_counter_msb(&self) -> u8 {
        self.whl_spd_alive_counter_msb_raw()
    }
    
    /// Get raw value of WHL_SPD_AliveCounter_MSB
    ///
    /// - Start bit: 30
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_spd_alive_counter_msb_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[30..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of WHL_SPD_AliveCounter_MSB
    #[inline(always)]
    pub fn set_whl_spd_alive_counter_msb(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 902 });
        }
        self.raw.view_bits_mut::<Lsb0>()[30..32].store_le(value);
        Ok(())
    }
    
    /// WHL_SPD_Checksum_LSB
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, LPI, TCU, TMU
    #[inline(always)]
    pub fn whl_spd_checksum_lsb(&self) -> u8 {
        self.whl_spd_checksum_lsb_raw()
    }
    
    /// Get raw value of WHL_SPD_Checksum_LSB
    ///
    /// - Start bit: 46
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_spd_checksum_lsb_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[46..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of WHL_SPD_Checksum_LSB
    #[inline(always)]
    pub fn set_whl_spd_checksum_lsb(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 902 });
        }
        self.raw.view_bits_mut::<Lsb0>()[46..48].store_le(value);
        Ok(())
    }
    
    /// WHL_SPD_Checksum_MSB
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, LPI, TCU, TMU
    #[inline(always)]
    pub fn whl_spd_checksum_msb(&self) -> u8 {
        self.whl_spd_checksum_msb_raw()
    }
    
    /// Get raw value of WHL_SPD_Checksum_MSB
    ///
    /// - Start bit: 62
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_spd_checksum_msb_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[62..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of WHL_SPD_Checksum_MSB
    #[inline(always)]
    pub fn set_whl_spd_checksum_msb(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 902 });
        }
        self.raw.view_bits_mut::<Lsb0>()[62..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for WhlSpd11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for WhlSpd11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("WhlSpd11")
                .field("whl_spd_fl", &self.whl_spd_fl())
                .field("whl_spd_fr", &self.whl_spd_fr())
                .field("whl_spd_rl", &self.whl_spd_rl())
                .field("whl_spd_rr", &self.whl_spd_rr())
                .field("whl_spd_alive_counter_lsb", &self.whl_spd_alive_counter_lsb())
                .field("whl_spd_alive_counter_msb", &self.whl_spd_alive_counter_msb())
                .field("whl_spd_checksum_lsb", &self.whl_spd_checksum_lsb())
                .field("whl_spd_checksum_msb", &self.whl_spd_checksum_msb())
            .finish()
        } else {
            f.debug_tuple("WhlSpd11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for WhlSpd11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let whl_spd_fl = u.float_in_range(0_f32..=511.96875_f32)?;
        let whl_spd_fr = u.float_in_range(0_f32..=511.96875_f32)?;
        let whl_spd_rl = u.float_in_range(0_f32..=511.96875_f32)?;
        let whl_spd_rr = u.float_in_range(0_f32..=511.96875_f32)?;
        let whl_spd_alive_counter_lsb = u.int_in_range(0..=15)?;
        let whl_spd_alive_counter_msb = u.int_in_range(0..=15)?;
        let whl_spd_checksum_lsb = u.int_in_range(0..=15)?;
        let whl_spd_checksum_msb = u.int_in_range(0..=15)?;
        WhlSpd11::new(whl_spd_fl,whl_spd_fr,whl_spd_rl,whl_spd_rr,whl_spd_alive_counter_lsb,whl_spd_alive_counter_msb,whl_spd_checksum_lsb,whl_spd_checksum_msb).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EVP11
///
/// - ID: 1414 (0x586)
/// - Size: 3 bytes
/// - Transmitter: EVP
#[derive(Clone, Copy)]
pub struct Evp11 {
    raw: [u8; 3],
}

impl Evp11 {
    pub const MESSAGE_ID: u32 = 1414;
    
    
    /// Construct new EVP11 from values
    pub fn new(cf_evp_stat: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_cf_evp_stat(cf_evp_stat)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// CF_Evp_Stat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_evp_stat(&self) -> bool {
        self.cf_evp_stat_raw()
    }
    
    /// Get raw value of CF_Evp_Stat
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_evp_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Evp_Stat
    #[inline(always)]
    pub fn set_cf_evp_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Evp11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Evp11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Evp11")
                .field("cf_evp_stat", &self.cf_evp_stat())
            .finish()
        } else {
            f.debug_tuple("Evp11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Evp11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_evp_stat = u.int_in_range(0..=1)? == 1;
        Evp11::new(cf_evp_stat).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// AAF11
///
/// - ID: 1412 (0x584)
/// - Size: 8 bytes
/// - Transmitter: AAF
#[derive(Clone, Copy)]
pub struct Aaf11 {
    raw: [u8; 8],
}

impl Aaf11 {
    pub const MESSAGE_ID: u32 = 1412;
    
    pub const CF_AAF_ACT_FLAP_STATUS_MIN: u8 = 0_u8;
    pub const CF_AAF_ACT_FLAP_STATUS_MAX: u8 = 3_u8;
    pub const CF_AAF_MODE_STATUS_MIN: u8 = 0_u8;
    pub const CF_AAF_MODE_STATUS_MAX: u8 = 7_u8;
    pub const CF_AAF_ERR_STATUS_MIN: u16 = 0_u16;
    pub const CF_AAF_ERR_STATUS_MAX: u16 = 1023_u16;
    pub const CF_AAF_OPEN_RQ_SYS_ACT_MIN: u8 = 0_u8;
    pub const CF_AAF_OPEN_RQ_SYS_ACT_MAX: u8 = 255_u8;
    pub const CF_AAF_P_STATUS_MIN: u8 = 0_u8;
    pub const CF_AAF_P_STATUS_MAX: u8 = 100_u8;
    pub const CF_AAF_OPEN_RQ_SYS_SOL_MIN: u8 = 0_u8;
    pub const CF_AAF_OPEN_RQ_SYS_SOL_MAX: u8 = 255_u8;
    pub const CF_AAF_SOL_FLAP_STATUS_MIN: u8 = 0_u8;
    pub const CF_AAF_SOL_FLAP_STATUS_MAX: u8 = 3_u8;
    
    /// Construct new AAF11 from values
    pub fn new(cf_aaf_act_flap_status: u8, cf_aaf_mode_status: u8, cf_aaf_wrn_lamp: bool, cf_aaf_err_status: u16, cf_aaf_open_rq_sys_act: u8, cf_aaf_p_status: u8, cf_aaf_open_rq_sys_sol: u8, cf_aaf_sol_flap_status: u8, cf_aaf_mil_on_req: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_aaf_act_flap_status(cf_aaf_act_flap_status)?;
        res.set_cf_aaf_mode_status(cf_aaf_mode_status)?;
        res.set_cf_aaf_wrn_lamp(cf_aaf_wrn_lamp)?;
        res.set_cf_aaf_err_status(cf_aaf_err_status)?;
        res.set_cf_aaf_open_rq_sys_act(cf_aaf_open_rq_sys_act)?;
        res.set_cf_aaf_p_status(cf_aaf_p_status)?;
        res.set_cf_aaf_open_rq_sys_sol(cf_aaf_open_rq_sys_sol)?;
        res.set_cf_aaf_sol_flap_status(cf_aaf_sol_flap_status)?;
        res.set_cf_aaf_mil_on_req(cf_aaf_mil_on_req)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Aaf_ActFlapStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: AAF_Tester
    #[inline(always)]
    pub fn cf_aaf_act_flap_status(&self) -> u8 {
        self.cf_aaf_act_flap_status_raw()
    }
    
    /// Get raw value of CF_Aaf_ActFlapStatus
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_aaf_act_flap_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Aaf_ActFlapStatus
    #[inline(always)]
    pub fn set_cf_aaf_act_flap_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1412 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// CF_Aaf_ModeStatus
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AAF_Tester
    #[inline(always)]
    pub fn cf_aaf_mode_status(&self) -> u8 {
        self.cf_aaf_mode_status_raw()
    }
    
    /// Get raw value of CF_Aaf_ModeStatus
    ///
    /// - Start bit: 2
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_aaf_mode_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Aaf_ModeStatus
    #[inline(always)]
    pub fn set_cf_aaf_mode_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1412 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..5].store_le(value);
        Ok(())
    }
    
    /// CF_Aaf_WrnLamp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_aaf_wrn_lamp(&self) -> bool {
        self.cf_aaf_wrn_lamp_raw()
    }
    
    /// Get raw value of CF_Aaf_WrnLamp
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_aaf_wrn_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Aaf_WrnLamp
    #[inline(always)]
    pub fn set_cf_aaf_wrn_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// CF_Aaf_ErrStatus
    ///
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: ""
    /// - Receivers: AAF_Tester, EMS
    #[inline(always)]
    pub fn cf_aaf_err_status(&self) -> u16 {
        self.cf_aaf_err_status_raw()
    }
    
    /// Get raw value of CF_Aaf_ErrStatus
    ///
    /// - Start bit: 6
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_aaf_err_status_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[6..16].load_le::<u16>();
        
        signal
    }
    
    /// Set value of CF_Aaf_ErrStatus
    #[inline(always)]
    pub fn set_cf_aaf_err_status(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1023_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1412 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..16].store_le(value);
        Ok(())
    }
    
    /// CF_Aaf_OpenRqSysAct
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: AAF_Tester
    #[inline(always)]
    pub fn cf_aaf_open_rq_sys_act(&self) -> u8 {
        self.cf_aaf_open_rq_sys_act_raw()
    }
    
    /// Get raw value of CF_Aaf_OpenRqSysAct
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_aaf_open_rq_sys_act_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Aaf_OpenRqSysAct
    #[inline(always)]
    pub fn set_cf_aaf_open_rq_sys_act(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1412 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// CF_Aaf_PStatus
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: AAF_Tester
    #[inline(always)]
    pub fn cf_aaf_p_status(&self) -> u8 {
        self.cf_aaf_p_status_raw()
    }
    
    /// Get raw value of CF_Aaf_PStatus
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_aaf_p_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Aaf_PStatus
    #[inline(always)]
    pub fn set_cf_aaf_p_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1412 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CF_Aaf_OpenRqSysSol
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: AAF_Tester
    #[inline(always)]
    pub fn cf_aaf_open_rq_sys_sol(&self) -> u8 {
        self.cf_aaf_open_rq_sys_sol_raw()
    }
    
    /// Get raw value of CF_Aaf_OpenRqSysSol
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_aaf_open_rq_sys_sol_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Aaf_OpenRqSysSol
    #[inline(always)]
    pub fn set_cf_aaf_open_rq_sys_sol(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1412 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CF_Aaf_SolFlapStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: AAF_Tester
    #[inline(always)]
    pub fn cf_aaf_sol_flap_status(&self) -> u8 {
        self.cf_aaf_sol_flap_status_raw()
    }
    
    /// Get raw value of CF_Aaf_SolFlapStatus
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_aaf_sol_flap_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Aaf_SolFlapStatus
    #[inline(always)]
    pub fn set_cf_aaf_sol_flap_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1412 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..42].store_le(value);
        Ok(())
    }
    
    /// CF_Aaf_MilOnReq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_aaf_mil_on_req(&self) -> bool {
        self.cf_aaf_mil_on_req_raw()
    }
    
    /// Get raw value of CF_Aaf_MilOnReq
    ///
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_aaf_mil_on_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[42..43].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Aaf_MilOnReq
    #[inline(always)]
    pub fn set_cf_aaf_mil_on_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[42..43].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Aaf11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Aaf11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Aaf11")
                .field("cf_aaf_act_flap_status", &self.cf_aaf_act_flap_status())
                .field("cf_aaf_mode_status", &self.cf_aaf_mode_status())
                .field("cf_aaf_wrn_lamp", &self.cf_aaf_wrn_lamp())
                .field("cf_aaf_err_status", &self.cf_aaf_err_status())
                .field("cf_aaf_open_rq_sys_act", &self.cf_aaf_open_rq_sys_act())
                .field("cf_aaf_p_status", &self.cf_aaf_p_status())
                .field("cf_aaf_open_rq_sys_sol", &self.cf_aaf_open_rq_sys_sol())
                .field("cf_aaf_sol_flap_status", &self.cf_aaf_sol_flap_status())
                .field("cf_aaf_mil_on_req", &self.cf_aaf_mil_on_req())
            .finish()
        } else {
            f.debug_tuple("Aaf11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Aaf11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_aaf_act_flap_status = u.int_in_range(0..=3)?;
        let cf_aaf_mode_status = u.int_in_range(0..=7)?;
        let cf_aaf_wrn_lamp = u.int_in_range(0..=1)? == 1;
        let cf_aaf_err_status = u.int_in_range(0..=1023)?;
        let cf_aaf_open_rq_sys_act = u.int_in_range(0..=255)?;
        let cf_aaf_p_status = u.int_in_range(0..=100)?;
        let cf_aaf_open_rq_sys_sol = u.int_in_range(0..=255)?;
        let cf_aaf_sol_flap_status = u.int_in_range(0..=3)?;
        let cf_aaf_mil_on_req = u.int_in_range(0..=1)? == 1;
        Aaf11::new(cf_aaf_act_flap_status,cf_aaf_mode_status,cf_aaf_wrn_lamp,cf_aaf_err_status,cf_aaf_open_rq_sys_act,cf_aaf_p_status,cf_aaf_open_rq_sys_sol,cf_aaf_sol_flap_status,cf_aaf_mil_on_req).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EMS17
///
/// - ID: 900 (0x384)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct Ems17 {
    raw: [u8; 8],
}

impl Ems17 {
    pub const MESSAGE_ID: u32 = 900;
    
    pub const CF_EMS_PKP_CUR_MSV_MIN: u8 = 0_u8;
    pub const CF_EMS_PKP_CUR_MSV_MAX: u8 = 255_u8;
    pub const CF_EMS_HOL_CUR_MSV_MIN: u8 = 0_u8;
    pub const CF_EMS_HOL_CUR_MSV_MAX: u8 = 255_u8;
    pub const CF_EMS_INJ_V_BNK_ACT_MIN: u8 = 0_u8;
    pub const CF_EMS_INJ_V_BNK_ACT_MAX: u8 = 255_u8;
    pub const CF_EMS_INJ_V_ACT_SET_MIN: u8 = 0_u8;
    pub const CF_EMS_INJ_V_ACT_SET_MAX: u8 = 255_u8;
    pub const CR_EMS_DUTY_CYC_MSV_MIN: f32 = 0_f32;
    pub const CR_EMS_DUTY_CYC_MSV_MAX: f32 = 100_f32;
    pub const CR_EMS_BAT_VOL_RLY_MIN: f32 = 0_f32;
    pub const CR_EMS_BAT_VOL_RLY_MAX: f32 = 25.5_f32;
    
    /// Construct new EMS17 from values
    pub fn new(cf_ems_pkp_cur_msv: u8, cf_ems_hol_cur_msv: u8, cf_ems_inj_v_bnk_act: u8, cf_ems_inj_v_act_set: u8, cf_ems_diag_ful_hdev: bool, cf_ems_swi_off_ic1: bool, cf_ems_swi_off_ic2: bool, cf_ems_diag_req_hdev: bool, cr_ems_duty_cyc_msv: f32, cr_ems_bat_vol_rly: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_ems_pkp_cur_msv(cf_ems_pkp_cur_msv)?;
        res.set_cf_ems_hol_cur_msv(cf_ems_hol_cur_msv)?;
        res.set_cf_ems_inj_v_bnk_act(cf_ems_inj_v_bnk_act)?;
        res.set_cf_ems_inj_v_act_set(cf_ems_inj_v_act_set)?;
        res.set_cf_ems_diag_ful_hdev(cf_ems_diag_ful_hdev)?;
        res.set_cf_ems_swi_off_ic1(cf_ems_swi_off_ic1)?;
        res.set_cf_ems_swi_off_ic2(cf_ems_swi_off_ic2)?;
        res.set_cf_ems_diag_req_hdev(cf_ems_diag_req_hdev)?;
        res.set_cr_ems_duty_cyc_msv(cr_ems_duty_cyc_msv)?;
        res.set_cr_ems_bat_vol_rly(cr_ems_bat_vol_rly)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Ems_PkpCurMSV
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cf_ems_pkp_cur_msv(&self) -> u8 {
        self.cf_ems_pkp_cur_msv_raw()
    }
    
    /// Get raw value of CF_Ems_PkpCurMSV
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_pkp_cur_msv_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_PkpCurMSV
    #[inline(always)]
    pub fn set_cf_ems_pkp_cur_msv(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 900 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_HolCurMSV
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cf_ems_hol_cur_msv(&self) -> u8 {
        self.cf_ems_hol_cur_msv_raw()
    }
    
    /// Get raw value of CF_Ems_HolCurMSV
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_hol_cur_msv_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_HolCurMSV
    #[inline(always)]
    pub fn set_cf_ems_hol_cur_msv(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 900 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_InjVBnkAct
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cf_ems_inj_v_bnk_act(&self) -> u8 {
        self.cf_ems_inj_v_bnk_act_raw()
    }
    
    /// Get raw value of CF_Ems_InjVBnkAct
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_inj_v_bnk_act_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_InjVBnkAct
    #[inline(always)]
    pub fn set_cf_ems_inj_v_bnk_act(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 900 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_InjVActSet
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cf_ems_inj_v_act_set(&self) -> u8 {
        self.cf_ems_inj_v_act_set_raw()
    }
    
    /// Get raw value of CF_Ems_InjVActSet
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_inj_v_act_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_InjVActSet
    #[inline(always)]
    pub fn set_cf_ems_inj_v_act_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 900 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_DiagFulHDEV
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cf_ems_diag_ful_hdev(&self) -> bool {
        self.cf_ems_diag_ful_hdev_raw()
    }
    
    /// Get raw value of CF_Ems_DiagFulHDEV
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_diag_ful_hdev_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_DiagFulHDEV
    #[inline(always)]
    pub fn set_cf_ems_diag_ful_hdev(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[32..33].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_SwiOffIC1
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cf_ems_swi_off_ic1(&self) -> bool {
        self.cf_ems_swi_off_ic1_raw()
    }
    
    /// Get raw value of CF_Ems_SwiOffIC1
    ///
    /// - Start bit: 33
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_swi_off_ic1_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[33..34].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_SwiOffIC1
    #[inline(always)]
    pub fn set_cf_ems_swi_off_ic1(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[33..34].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_SwiOffIC2
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cf_ems_swi_off_ic2(&self) -> bool {
        self.cf_ems_swi_off_ic2_raw()
    }
    
    /// Get raw value of CF_Ems_SwiOffIC2
    ///
    /// - Start bit: 34
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_swi_off_ic2_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[34..35].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_SwiOffIC2
    #[inline(always)]
    pub fn set_cf_ems_swi_off_ic2(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[34..35].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_DiagReqHDEV
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cf_ems_diag_req_hdev(&self) -> bool {
        self.cf_ems_diag_req_hdev_raw()
    }
    
    /// Get raw value of CF_Ems_DiagReqHDEV
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_diag_req_hdev_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_DiagReqHDEV
    #[inline(always)]
    pub fn set_cf_ems_diag_req_hdev(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[38..39].store_le(value);
        Ok(())
    }
    
    /// CR_Ems_DutyCycMSV
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cr_ems_duty_cyc_msv(&self) -> f32 {
        self.cr_ems_duty_cyc_msv_raw()
    }
    
    /// Get raw value of CR_Ems_DutyCycMSV
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.3921568627
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ems_duty_cyc_msv_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 0.3921568627_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Ems_DutyCycMSV
    #[inline(always)]
    pub fn set_cr_ems_duty_cyc_msv(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 900 });
        }
        let factor = 0.3921568627_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// CR_Ems_BatVolRly
    ///
    /// - Min: 0
    /// - Max: 25.5
    /// - Unit: "V"
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cr_ems_bat_vol_rly(&self) -> f32 {
        self.cr_ems_bat_vol_rly_raw()
    }
    
    /// Get raw value of CR_Ems_BatVolRly
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ems_bat_vol_rly_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Ems_BatVolRly
    #[inline(always)]
    pub fn set_cr_ems_bat_vol_rly(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 25.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 900 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ems17 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ems17 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ems17")
                .field("cf_ems_pkp_cur_msv", &self.cf_ems_pkp_cur_msv())
                .field("cf_ems_hol_cur_msv", &self.cf_ems_hol_cur_msv())
                .field("cf_ems_inj_v_bnk_act", &self.cf_ems_inj_v_bnk_act())
                .field("cf_ems_inj_v_act_set", &self.cf_ems_inj_v_act_set())
                .field("cf_ems_diag_ful_hdev", &self.cf_ems_diag_ful_hdev())
                .field("cf_ems_swi_off_ic1", &self.cf_ems_swi_off_ic1())
                .field("cf_ems_swi_off_ic2", &self.cf_ems_swi_off_ic2())
                .field("cf_ems_diag_req_hdev", &self.cf_ems_diag_req_hdev())
                .field("cr_ems_duty_cyc_msv", &self.cr_ems_duty_cyc_msv())
                .field("cr_ems_bat_vol_rly", &self.cr_ems_bat_vol_rly())
            .finish()
        } else {
            f.debug_tuple("Ems17").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ems17 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_ems_pkp_cur_msv = u.int_in_range(0..=255)?;
        let cf_ems_hol_cur_msv = u.int_in_range(0..=255)?;
        let cf_ems_inj_v_bnk_act = u.int_in_range(0..=255)?;
        let cf_ems_inj_v_act_set = u.int_in_range(0..=255)?;
        let cf_ems_diag_ful_hdev = u.int_in_range(0..=1)? == 1;
        let cf_ems_swi_off_ic1 = u.int_in_range(0..=1)? == 1;
        let cf_ems_swi_off_ic2 = u.int_in_range(0..=1)? == 1;
        let cf_ems_diag_req_hdev = u.int_in_range(0..=1)? == 1;
        let cr_ems_duty_cyc_msv = u.float_in_range(0_f32..=100_f32)?;
        let cr_ems_bat_vol_rly = u.float_in_range(0_f32..=25.5_f32)?;
        Ems17::new(cf_ems_pkp_cur_msv,cf_ems_hol_cur_msv,cf_ems_inj_v_bnk_act,cf_ems_inj_v_act_set,cf_ems_diag_ful_hdev,cf_ems_swi_off_ic1,cf_ems_swi_off_ic2,cf_ems_diag_req_hdev,cr_ems_duty_cyc_msv,cr_ems_bat_vol_rly).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// REA11
///
/// - ID: 387 (0x183)
/// - Size: 8 bytes
/// - Transmitter: REA
#[derive(Clone, Copy)]
pub struct Rea11 {
    raw: [u8; 8],
}

impl Rea11 {
    pub const MESSAGE_ID: u32 = 387;
    
    pub const CR_END_BST_ACT_POS_MIN: f32 = 1.989_f32;
    pub const CR_END_BST_ACT_POS_MAX: f32 = 118.053_f32;
    pub const CR_END_BST_DEM_POS_MIN: f32 = 0_f32;
    pub const CR_END_BST_DEM_POS_MAX: f32 = 119.691_f32;
    pub const CR_END_BST_HBRI_PWR_MIN: f32 = 0_f32;
    pub const CR_END_BST_HBRI_PWR_MAX: f32 = 99.99_f32;
    
    /// Construct new REA11 from values
    pub fn new(cf_end_bst_pwm_du_h: bool, cf_end_bst_pwm_du_l: bool, cf_end_bst_pwm_fq_out_rng: bool, cf_end_bst_hbri_over_cur: bool, cf_end_bst_hbri_over_temp: bool, cf_end_bst_pos_sns_kor: bool, cf_end_bst_pos_sns_osor: bool, cf_end_bst_eep_flt: bool, cf_end_bst_rom_flt: bool, cf_end_bst_ram_flt: bool, cf_end_bst_can_flt: bool, cf_end_bst_ag_h: bool, cf_end_bst_ag_l: bool, cf_end_bst_or_vol: bool, cr_end_bst_act_pos: f32, cr_end_bst_dem_pos: f32, cr_end_bst_hbri_pwr: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_end_bst_pwm_du_h(cf_end_bst_pwm_du_h)?;
        res.set_cf_end_bst_pwm_du_l(cf_end_bst_pwm_du_l)?;
        res.set_cf_end_bst_pwm_fq_out_rng(cf_end_bst_pwm_fq_out_rng)?;
        res.set_cf_end_bst_hbri_over_cur(cf_end_bst_hbri_over_cur)?;
        res.set_cf_end_bst_hbri_over_temp(cf_end_bst_hbri_over_temp)?;
        res.set_cf_end_bst_pos_sns_kor(cf_end_bst_pos_sns_kor)?;
        res.set_cf_end_bst_pos_sns_osor(cf_end_bst_pos_sns_osor)?;
        res.set_cf_end_bst_eep_flt(cf_end_bst_eep_flt)?;
        res.set_cf_end_bst_rom_flt(cf_end_bst_rom_flt)?;
        res.set_cf_end_bst_ram_flt(cf_end_bst_ram_flt)?;
        res.set_cf_end_bst_can_flt(cf_end_bst_can_flt)?;
        res.set_cf_end_bst_ag_h(cf_end_bst_ag_h)?;
        res.set_cf_end_bst_ag_l(cf_end_bst_ag_l)?;
        res.set_cf_end_bst_or_vol(cf_end_bst_or_vol)?;
        res.set_cr_end_bst_act_pos(cr_end_bst_act_pos)?;
        res.set_cr_end_bst_dem_pos(cr_end_bst_dem_pos)?;
        res.set_cr_end_bst_hbri_pwr(cr_end_bst_hbri_pwr)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_EndBst_PwmDuH
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_end_bst_pwm_du_h(&self) -> bool {
        self.cf_end_bst_pwm_du_h_raw()
    }
    
    /// Get raw value of CF_EndBst_PwmDuH
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_end_bst_pwm_du_h_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_EndBst_PwmDuH
    #[inline(always)]
    pub fn set_cf_end_bst_pwm_du_h(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// CF_EndBst_PwmDuL
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_end_bst_pwm_du_l(&self) -> bool {
        self.cf_end_bst_pwm_du_l_raw()
    }
    
    /// Get raw value of CF_EndBst_PwmDuL
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_end_bst_pwm_du_l_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_EndBst_PwmDuL
    #[inline(always)]
    pub fn set_cf_end_bst_pwm_du_l(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// CF_EndBst_PwmFqOutRng
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_end_bst_pwm_fq_out_rng(&self) -> bool {
        self.cf_end_bst_pwm_fq_out_rng_raw()
    }
    
    /// Get raw value of CF_EndBst_PwmFqOutRng
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_end_bst_pwm_fq_out_rng_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_EndBst_PwmFqOutRng
    #[inline(always)]
    pub fn set_cf_end_bst_pwm_fq_out_rng(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// CF_EndBst_HbriOverCur
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_end_bst_hbri_over_cur(&self) -> bool {
        self.cf_end_bst_hbri_over_cur_raw()
    }
    
    /// Get raw value of CF_EndBst_HbriOverCur
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_end_bst_hbri_over_cur_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_EndBst_HbriOverCur
    #[inline(always)]
    pub fn set_cf_end_bst_hbri_over_cur(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// CF_EndBst_HbriOverTemp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_end_bst_hbri_over_temp(&self) -> bool {
        self.cf_end_bst_hbri_over_temp_raw()
    }
    
    /// Get raw value of CF_EndBst_HbriOverTemp
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_end_bst_hbri_over_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_EndBst_HbriOverTemp
    #[inline(always)]
    pub fn set_cf_end_bst_hbri_over_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// CF_EndBst_PosSnsKOR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_end_bst_pos_sns_kor(&self) -> bool {
        self.cf_end_bst_pos_sns_kor_raw()
    }
    
    /// Get raw value of CF_EndBst_PosSnsKOR
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_end_bst_pos_sns_kor_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_EndBst_PosSnsKOR
    #[inline(always)]
    pub fn set_cf_end_bst_pos_sns_kor(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[6..7].store_le(value);
        Ok(())
    }
    
    /// CF_EndBst_PosSnsOSOR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_end_bst_pos_sns_osor(&self) -> bool {
        self.cf_end_bst_pos_sns_osor_raw()
    }
    
    /// Get raw value of CF_EndBst_PosSnsOSOR
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_end_bst_pos_sns_osor_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_EndBst_PosSnsOSOR
    #[inline(always)]
    pub fn set_cf_end_bst_pos_sns_osor(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// CF_EndBst_EepFlt
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_end_bst_eep_flt(&self) -> bool {
        self.cf_end_bst_eep_flt_raw()
    }
    
    /// Get raw value of CF_EndBst_EepFlt
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_end_bst_eep_flt_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_EndBst_EepFlt
    #[inline(always)]
    pub fn set_cf_end_bst_eep_flt(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[8..9].store_le(value);
        Ok(())
    }
    
    /// CF_EndBst_RomFlt
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_end_bst_rom_flt(&self) -> bool {
        self.cf_end_bst_rom_flt_raw()
    }
    
    /// Get raw value of CF_EndBst_RomFlt
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_end_bst_rom_flt_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_EndBst_RomFlt
    #[inline(always)]
    pub fn set_cf_end_bst_rom_flt(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[9..10].store_le(value);
        Ok(())
    }
    
    /// CF_EndBst_RamFlt
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_end_bst_ram_flt(&self) -> bool {
        self.cf_end_bst_ram_flt_raw()
    }
    
    /// Get raw value of CF_EndBst_RamFlt
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_end_bst_ram_flt_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_EndBst_RamFlt
    #[inline(always)]
    pub fn set_cf_end_bst_ram_flt(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[10..11].store_le(value);
        Ok(())
    }
    
    /// CF_EndBst_CanFlt
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_end_bst_can_flt(&self) -> bool {
        self.cf_end_bst_can_flt_raw()
    }
    
    /// Get raw value of CF_EndBst_CanFlt
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_end_bst_can_flt_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_EndBst_CanFlt
    #[inline(always)]
    pub fn set_cf_end_bst_can_flt(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[11..12].store_le(value);
        Ok(())
    }
    
    /// CF_EndBst_AgH
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_end_bst_ag_h(&self) -> bool {
        self.cf_end_bst_ag_h_raw()
    }
    
    /// Get raw value of CF_EndBst_AgH
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_end_bst_ag_h_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_EndBst_AgH
    #[inline(always)]
    pub fn set_cf_end_bst_ag_h(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[12..13].store_le(value);
        Ok(())
    }
    
    /// CF_EndBst_AgL
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_end_bst_ag_l(&self) -> bool {
        self.cf_end_bst_ag_l_raw()
    }
    
    /// Get raw value of CF_EndBst_AgL
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_end_bst_ag_l_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_EndBst_AgL
    #[inline(always)]
    pub fn set_cf_end_bst_ag_l(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[13..14].store_le(value);
        Ok(())
    }
    
    /// CF_EndBst_ORVol
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_end_bst_or_vol(&self) -> bool {
        self.cf_end_bst_or_vol_raw()
    }
    
    /// Get raw value of CF_EndBst_ORVol
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_end_bst_or_vol_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_EndBst_ORVol
    #[inline(always)]
    pub fn set_cf_end_bst_or_vol(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[14..15].store_le(value);
        Ok(())
    }
    
    /// CR_EndBst_ActPos
    ///
    /// - Min: 1.989
    /// - Max: 118.053
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cr_end_bst_act_pos(&self) -> f32 {
        self.cr_end_bst_act_pos_raw()
    }
    
    /// Get raw value of CR_EndBst_ActPos
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.117
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_end_bst_act_pos_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<u16>();
        
        let factor = 0.117_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_EndBst_ActPos
    #[inline(always)]
    pub fn set_cr_end_bst_act_pos(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 1.989_f32 || 118.053_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 387 });
        }
        let factor = 0.117_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// CR_EndBst_DemPos
    ///
    /// - Min: 0
    /// - Max: 119.691
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cr_end_bst_dem_pos(&self) -> f32 {
        self.cr_end_bst_dem_pos_raw()
    }
    
    /// Get raw value of CR_EndBst_DemPos
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.117
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_end_bst_dem_pos_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<u16>();
        
        let factor = 0.117_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_EndBst_DemPos
    #[inline(always)]
    pub fn set_cr_end_bst_dem_pos(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 119.691_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 387 });
        }
        let factor = 0.117_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// CR_EndBst_HbriPwr
    ///
    /// - Min: 0
    /// - Max: 99.99
    /// - Unit: "%"
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cr_end_bst_hbri_pwr(&self) -> f32 {
        self.cr_end_bst_hbri_pwr_raw()
    }
    
    /// Get raw value of CR_EndBst_HbriPwr
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.045
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_end_bst_hbri_pwr_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<u16>();
        
        let factor = 0.045_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_EndBst_HbriPwr
    #[inline(always)]
    pub fn set_cr_end_bst_hbri_pwr(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.99_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 387 });
        }
        let factor = 0.045_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Rea11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Rea11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Rea11")
                .field("cf_end_bst_pwm_du_h", &self.cf_end_bst_pwm_du_h())
                .field("cf_end_bst_pwm_du_l", &self.cf_end_bst_pwm_du_l())
                .field("cf_end_bst_pwm_fq_out_rng", &self.cf_end_bst_pwm_fq_out_rng())
                .field("cf_end_bst_hbri_over_cur", &self.cf_end_bst_hbri_over_cur())
                .field("cf_end_bst_hbri_over_temp", &self.cf_end_bst_hbri_over_temp())
                .field("cf_end_bst_pos_sns_kor", &self.cf_end_bst_pos_sns_kor())
                .field("cf_end_bst_pos_sns_osor", &self.cf_end_bst_pos_sns_osor())
                .field("cf_end_bst_eep_flt", &self.cf_end_bst_eep_flt())
                .field("cf_end_bst_rom_flt", &self.cf_end_bst_rom_flt())
                .field("cf_end_bst_ram_flt", &self.cf_end_bst_ram_flt())
                .field("cf_end_bst_can_flt", &self.cf_end_bst_can_flt())
                .field("cf_end_bst_ag_h", &self.cf_end_bst_ag_h())
                .field("cf_end_bst_ag_l", &self.cf_end_bst_ag_l())
                .field("cf_end_bst_or_vol", &self.cf_end_bst_or_vol())
                .field("cr_end_bst_act_pos", &self.cr_end_bst_act_pos())
                .field("cr_end_bst_dem_pos", &self.cr_end_bst_dem_pos())
                .field("cr_end_bst_hbri_pwr", &self.cr_end_bst_hbri_pwr())
            .finish()
        } else {
            f.debug_tuple("Rea11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Rea11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_end_bst_pwm_du_h = u.int_in_range(0..=1)? == 1;
        let cf_end_bst_pwm_du_l = u.int_in_range(0..=1)? == 1;
        let cf_end_bst_pwm_fq_out_rng = u.int_in_range(0..=1)? == 1;
        let cf_end_bst_hbri_over_cur = u.int_in_range(0..=1)? == 1;
        let cf_end_bst_hbri_over_temp = u.int_in_range(0..=1)? == 1;
        let cf_end_bst_pos_sns_kor = u.int_in_range(0..=1)? == 1;
        let cf_end_bst_pos_sns_osor = u.int_in_range(0..=1)? == 1;
        let cf_end_bst_eep_flt = u.int_in_range(0..=1)? == 1;
        let cf_end_bst_rom_flt = u.int_in_range(0..=1)? == 1;
        let cf_end_bst_ram_flt = u.int_in_range(0..=1)? == 1;
        let cf_end_bst_can_flt = u.int_in_range(0..=1)? == 1;
        let cf_end_bst_ag_h = u.int_in_range(0..=1)? == 1;
        let cf_end_bst_ag_l = u.int_in_range(0..=1)? == 1;
        let cf_end_bst_or_vol = u.int_in_range(0..=1)? == 1;
        let cr_end_bst_act_pos = u.float_in_range(1.989_f32..=118.053_f32)?;
        let cr_end_bst_dem_pos = u.float_in_range(0_f32..=119.691_f32)?;
        let cr_end_bst_hbri_pwr = u.float_in_range(0_f32..=99.99_f32)?;
        Rea11::new(cf_end_bst_pwm_du_h,cf_end_bst_pwm_du_l,cf_end_bst_pwm_fq_out_rng,cf_end_bst_hbri_over_cur,cf_end_bst_hbri_over_temp,cf_end_bst_pos_sns_kor,cf_end_bst_pos_sns_osor,cf_end_bst_eep_flt,cf_end_bst_rom_flt,cf_end_bst_ram_flt,cf_end_bst_can_flt,cf_end_bst_ag_h,cf_end_bst_ag_l,cf_end_bst_or_vol,cr_end_bst_act_pos,cr_end_bst_dem_pos,cr_end_bst_hbri_pwr).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// CUBIS11
///
/// - ID: 1411 (0x583)
/// - Size: 8 bytes
/// - Transmitter: CUBIS
#[derive(Clone, Copy)]
pub struct Cubis11 {
    raw: [u8; 8],
}

impl Cubis11 {
    pub const MESSAGE_ID: u32 = 1411;
    
    pub const CF_CUBIS_HU_DISP_MIN: u8 = 0_u8;
    pub const CF_CUBIS_HU_DISP_MAX: u8 = 15_u8;
    
    /// Construct new CUBIS11 from values
    pub fn new(cf_cubis_hu_disp: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_cubis_hu_disp(cf_cubis_hu_disp)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Cubis_HUDisp
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_cubis_hu_disp(&self) -> u8 {
        self.cf_cubis_hu_disp_raw()
    }
    
    /// Get raw value of CF_Cubis_HUDisp
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_cubis_hu_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Cubis_HUDisp
    #[inline(always)]
    pub fn set_cf_cubis_hu_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1411 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..4].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Cubis11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Cubis11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Cubis11")
                .field("cf_cubis_hu_disp", &self.cf_cubis_hu_disp())
            .finish()
        } else {
            f.debug_tuple("Cubis11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Cubis11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_cubis_hu_disp = u.int_in_range(0..=15)?;
        Cubis11::new(cf_cubis_hu_disp).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// FATC11
///
/// - ID: 899 (0x383)
/// - Size: 8 bytes
/// - Transmitter: DATC
#[derive(Clone, Copy)]
pub struct Fatc11 {
    raw: [u8; 8],
}

impl Fatc11 {
    pub const MESSAGE_ID: u32 = 899;
    
    pub const CR_FATC_TQ_ACN_OUT_MIN: f32 = 0_f32;
    pub const CR_FATC_TQ_ACN_OUT_MAX: f32 = 50.8_f32;
    pub const CF_FATC_IDEN_MIN: u8 = 0_u8;
    pub const CF_FATC_IDEN_MAX: u8 = 3_u8;
    pub const CF_FATC_CTR_INF_MIN: u8 = 0_u8;
    pub const CF_FATC_CTR_INF_MAX: u8 = 7_u8;
    pub const CF_FATC_MSG_CNT_MIN: u8 = 0_u8;
    pub const CF_FATC_MSG_CNT_MAX: u8 = 15_u8;
    pub const CR_FATC_OUT_TEMP_MIN: f32 = -40_f32;
    pub const CR_FATC_OUT_TEMP_MAX: f32 = 60_f32;
    pub const CR_FATC_OUT_TEMP_SNS_MIN: f32 = -40_f32;
    pub const CR_FATC_OUT_TEMP_SNS_MAX: f32 = 60_f32;
    pub const CF_FATC_COMPLOAD_MIN: u8 = 0_u8;
    pub const CF_FATC_COMPLOAD_MAX: u8 = 7_u8;
    pub const CF_FATC_CHK_SUM_MIN: u8 = 0_u8;
    pub const CF_FATC_CHK_SUM_MAX: u8 = 255_u8;
    
    /// Construct new FATC11 from values
    pub fn new(cr_fatc_tq_acn_out: f32, cf_fatc_acn_rq_swi: bool, cf_fatc_acn_clt_en_rq: bool, cf_fatc_ecv_flt: bool, cf_fatc_blwr_on: bool, cf_fatc_iden: u8, cf_fatc_blwr_max: bool, cf_fatc_eng_start_req: bool, cf_fatc_isg_stop_req: bool, cf_fatc_ctr_inf: u8, cf_fatc_msg_cnt: u8, cr_fatc_out_temp: f32, cr_fatc_out_temp_sns: f32, cf_fatc_compload: u8, cf_fatc_active_eco: bool, cf_fatc_auto_activation: bool, cf_fatc_def_sw: bool, cf_fatc_ptc_rly_stat: bool, cf_fatc_chk_sum: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cr_fatc_tq_acn_out(cr_fatc_tq_acn_out)?;
        res.set_cf_fatc_acn_rq_swi(cf_fatc_acn_rq_swi)?;
        res.set_cf_fatc_acn_clt_en_rq(cf_fatc_acn_clt_en_rq)?;
        res.set_cf_fatc_ecv_flt(cf_fatc_ecv_flt)?;
        res.set_cf_fatc_blwr_on(cf_fatc_blwr_on)?;
        res.set_cf_fatc_iden(cf_fatc_iden)?;
        res.set_cf_fatc_blwr_max(cf_fatc_blwr_max)?;
        res.set_cf_fatc_eng_start_req(cf_fatc_eng_start_req)?;
        res.set_cf_fatc_isg_stop_req(cf_fatc_isg_stop_req)?;
        res.set_cf_fatc_ctr_inf(cf_fatc_ctr_inf)?;
        res.set_cf_fatc_msg_cnt(cf_fatc_msg_cnt)?;
        res.set_cr_fatc_out_temp(cr_fatc_out_temp)?;
        res.set_cr_fatc_out_temp_sns(cr_fatc_out_temp_sns)?;
        res.set_cf_fatc_compload(cf_fatc_compload)?;
        res.set_cf_fatc_active_eco(cf_fatc_active_eco)?;
        res.set_cf_fatc_auto_activation(cf_fatc_auto_activation)?;
        res.set_cf_fatc_def_sw(cf_fatc_def_sw)?;
        res.set_cf_fatc_ptc_rly_stat(cf_fatc_ptc_rly_stat)?;
        res.set_cf_fatc_chk_sum(cf_fatc_chk_sum)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CR_Fatc_TqAcnOut
    ///
    /// - Min: 0
    /// - Max: 50.8
    /// - Unit: "Nm"
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cr_fatc_tq_acn_out(&self) -> f32 {
        self.cr_fatc_tq_acn_out_raw()
    }
    
    /// Get raw value of CR_Fatc_TqAcnOut
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 0.2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_fatc_tq_acn_out_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 0.2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Fatc_TqAcnOut
    #[inline(always)]
    pub fn set_cr_fatc_tq_acn_out(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 50.8_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 899 });
        }
        let factor = 0.2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_AcnRqSwi
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: AAF, EMS, IBOX
    #[inline(always)]
    pub fn cf_fatc_acn_rq_swi(&self) -> bool {
        self.cf_fatc_acn_rq_swi_raw()
    }
    
    /// Get raw value of CF_Fatc_AcnRqSwi
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_acn_rq_swi_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fatc_AcnRqSwi
    #[inline(always)]
    pub fn set_cf_fatc_acn_rq_swi(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[8..9].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_AcnCltEnRq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_fatc_acn_clt_en_rq(&self) -> bool {
        self.cf_fatc_acn_clt_en_rq_raw()
    }
    
    /// Get raw value of CF_Fatc_AcnCltEnRq
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_acn_clt_en_rq_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fatc_AcnCltEnRq
    #[inline(always)]
    pub fn set_cf_fatc_acn_clt_en_rq(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[9..10].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_EcvFlt
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_fatc_ecv_flt(&self) -> bool {
        self.cf_fatc_ecv_flt_raw()
    }
    
    /// Get raw value of CF_Fatc_EcvFlt
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_ecv_flt_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fatc_EcvFlt
    #[inline(always)]
    pub fn set_cf_fatc_ecv_flt(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[10..11].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_BlwrOn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_fatc_blwr_on(&self) -> bool {
        self.cf_fatc_blwr_on_raw()
    }
    
    /// Get raw value of CF_Fatc_BlwrOn
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_blwr_on_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fatc_BlwrOn
    #[inline(always)]
    pub fn set_cf_fatc_blwr_on(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[11..12].store_le(value);
        Ok(())
    }
    
    /// CF_FATC_Iden
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_fatc_iden(&self) -> u8 {
        self.cf_fatc_iden_raw()
    }
    
    /// Get raw value of CF_FATC_Iden
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_iden_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_FATC_Iden
    #[inline(always)]
    pub fn set_cf_fatc_iden(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 899 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..14].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_BlwrMax
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, EMS, IBOX
    #[inline(always)]
    pub fn cf_fatc_blwr_max(&self) -> bool {
        self.cf_fatc_blwr_max_raw()
    }
    
    /// Get raw value of CF_Fatc_BlwrMax
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_blwr_max_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fatc_BlwrMax
    #[inline(always)]
    pub fn set_cf_fatc_blwr_max(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[14..15].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_EngStartReq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_fatc_eng_start_req(&self) -> bool {
        self.cf_fatc_eng_start_req_raw()
    }
    
    /// Get raw value of CF_Fatc_EngStartReq
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_eng_start_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fatc_EngStartReq
    #[inline(always)]
    pub fn set_cf_fatc_eng_start_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[15..16].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_IsgStopReq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_fatc_isg_stop_req(&self) -> bool {
        self.cf_fatc_isg_stop_req_raw()
    }
    
    /// Get raw value of CF_Fatc_IsgStopReq
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_isg_stop_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fatc_IsgStopReq
    #[inline(always)]
    pub fn set_cf_fatc_isg_stop_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[16..17].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_CtrInf
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_fatc_ctr_inf(&self) -> u8 {
        self.cf_fatc_ctr_inf_raw()
    }
    
    /// Get raw value of CF_Fatc_CtrInf
    ///
    /// - Start bit: 17
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_ctr_inf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[17..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Fatc_CtrInf
    #[inline(always)]
    pub fn set_cf_fatc_ctr_inf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 899 });
        }
        self.raw.view_bits_mut::<Lsb0>()[17..20].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_MsgCnt
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_fatc_msg_cnt(&self) -> u8 {
        self.cf_fatc_msg_cnt_raw()
    }
    
    /// Get raw value of CF_Fatc_MsgCnt
    ///
    /// - Start bit: 20
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_msg_cnt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Fatc_MsgCnt
    #[inline(always)]
    pub fn set_cf_fatc_msg_cnt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 899 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..24].store_le(value);
        Ok(())
    }
    
    /// CR_Fatc_OutTemp
    ///
    /// - Min: -40
    /// - Max: 60
    /// - Unit: "deg"
    /// - Receivers: BCM, CLU, EMS, IBOX, SPAS, TCU, TPMS
    #[inline(always)]
    pub fn cr_fatc_out_temp(&self) -> f32 {
        self.cr_fatc_out_temp_raw()
    }
    
    /// Get raw value of CR_Fatc_OutTemp
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_fatc_out_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Fatc_OutTemp
    #[inline(always)]
    pub fn set_cr_fatc_out_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 60_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 899 });
        }
        let factor = 0.5_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CR_Fatc_OutTempSns
    ///
    /// - Min: -40
    /// - Max: 60
    /// - Unit: "deg"
    /// - Receivers: AAF, AHLS, CLU, EMS, IBOX, SPAS, TCU
    #[inline(always)]
    pub fn cr_fatc_out_temp_sns(&self) -> f32 {
        self.cr_fatc_out_temp_sns_raw()
    }
    
    /// Get raw value of CR_Fatc_OutTempSns
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_fatc_out_temp_sns_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Fatc_OutTempSns
    #[inline(always)]
    pub fn set_cr_fatc_out_temp_sns(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 60_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 899 });
        }
        let factor = 0.5_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_Compload
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_fatc_compload(&self) -> u8 {
        self.cf_fatc_compload_raw()
    }
    
    /// Get raw value of CF_Fatc_Compload
    ///
    /// - Start bit: 40
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_compload_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..43].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Fatc_Compload
    #[inline(always)]
    pub fn set_cf_fatc_compload(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 899 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..43].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_ActiveEco
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_fatc_active_eco(&self) -> bool {
        self.cf_fatc_active_eco_raw()
    }
    
    /// Get raw value of CF_Fatc_ActiveEco
    ///
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_active_eco_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[43..44].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fatc_ActiveEco
    #[inline(always)]
    pub fn set_cf_fatc_active_eco(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[43..44].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_AutoActivation
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: IBOX
    #[inline(always)]
    pub fn cf_fatc_auto_activation(&self) -> bool {
        self.cf_fatc_auto_activation_raw()
    }
    
    /// Get raw value of CF_Fatc_AutoActivation
    ///
    /// - Start bit: 44
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_auto_activation_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[44..45].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fatc_AutoActivation
    #[inline(always)]
    pub fn set_cf_fatc_auto_activation(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[44..45].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_DefSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM, IBOX
    #[inline(always)]
    pub fn cf_fatc_def_sw(&self) -> bool {
        self.cf_fatc_def_sw_raw()
    }
    
    /// Get raw value of CF_Fatc_DefSw
    ///
    /// - Start bit: 45
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_def_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[45..46].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fatc_DefSw
    #[inline(always)]
    pub fn set_cf_fatc_def_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[45..46].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_PtcRlyStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_fatc_ptc_rly_stat(&self) -> bool {
        self.cf_fatc_ptc_rly_stat_raw()
    }
    
    /// Get raw value of CF_Fatc_PtcRlyStat
    ///
    /// - Start bit: 46
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_ptc_rly_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[46..47].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fatc_PtcRlyStat
    #[inline(always)]
    pub fn set_cf_fatc_ptc_rly_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[46..47].store_le(value);
        Ok(())
    }
    
    /// CF_Fatc_ChkSum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS, IBOX, SPAS
    #[inline(always)]
    pub fn cf_fatc_chk_sum(&self) -> u8 {
        self.cf_fatc_chk_sum_raw()
    }
    
    /// Get raw value of CF_Fatc_ChkSum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fatc_chk_sum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Fatc_ChkSum
    #[inline(always)]
    pub fn set_cf_fatc_chk_sum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 899 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Fatc11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Fatc11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Fatc11")
                .field("cr_fatc_tq_acn_out", &self.cr_fatc_tq_acn_out())
                .field("cf_fatc_acn_rq_swi", &self.cf_fatc_acn_rq_swi())
                .field("cf_fatc_acn_clt_en_rq", &self.cf_fatc_acn_clt_en_rq())
                .field("cf_fatc_ecv_flt", &self.cf_fatc_ecv_flt())
                .field("cf_fatc_blwr_on", &self.cf_fatc_blwr_on())
                .field("cf_fatc_iden", &self.cf_fatc_iden())
                .field("cf_fatc_blwr_max", &self.cf_fatc_blwr_max())
                .field("cf_fatc_eng_start_req", &self.cf_fatc_eng_start_req())
                .field("cf_fatc_isg_stop_req", &self.cf_fatc_isg_stop_req())
                .field("cf_fatc_ctr_inf", &self.cf_fatc_ctr_inf())
                .field("cf_fatc_msg_cnt", &self.cf_fatc_msg_cnt())
                .field("cr_fatc_out_temp", &self.cr_fatc_out_temp())
                .field("cr_fatc_out_temp_sns", &self.cr_fatc_out_temp_sns())
                .field("cf_fatc_compload", &self.cf_fatc_compload())
                .field("cf_fatc_active_eco", &self.cf_fatc_active_eco())
                .field("cf_fatc_auto_activation", &self.cf_fatc_auto_activation())
                .field("cf_fatc_def_sw", &self.cf_fatc_def_sw())
                .field("cf_fatc_ptc_rly_stat", &self.cf_fatc_ptc_rly_stat())
                .field("cf_fatc_chk_sum", &self.cf_fatc_chk_sum())
            .finish()
        } else {
            f.debug_tuple("Fatc11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Fatc11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cr_fatc_tq_acn_out = u.float_in_range(0_f32..=50.8_f32)?;
        let cf_fatc_acn_rq_swi = u.int_in_range(0..=1)? == 1;
        let cf_fatc_acn_clt_en_rq = u.int_in_range(0..=1)? == 1;
        let cf_fatc_ecv_flt = u.int_in_range(0..=1)? == 1;
        let cf_fatc_blwr_on = u.int_in_range(0..=1)? == 1;
        let cf_fatc_iden = u.int_in_range(0..=3)?;
        let cf_fatc_blwr_max = u.int_in_range(0..=1)? == 1;
        let cf_fatc_eng_start_req = u.int_in_range(0..=1)? == 1;
        let cf_fatc_isg_stop_req = u.int_in_range(0..=1)? == 1;
        let cf_fatc_ctr_inf = u.int_in_range(0..=7)?;
        let cf_fatc_msg_cnt = u.int_in_range(0..=15)?;
        let cr_fatc_out_temp = u.float_in_range(-40_f32..=60_f32)?;
        let cr_fatc_out_temp_sns = u.float_in_range(-40_f32..=60_f32)?;
        let cf_fatc_compload = u.int_in_range(0..=7)?;
        let cf_fatc_active_eco = u.int_in_range(0..=1)? == 1;
        let cf_fatc_auto_activation = u.int_in_range(0..=1)? == 1;
        let cf_fatc_def_sw = u.int_in_range(0..=1)? == 1;
        let cf_fatc_ptc_rly_stat = u.int_in_range(0..=1)? == 1;
        let cf_fatc_chk_sum = u.int_in_range(0..=255)?;
        Fatc11::new(cr_fatc_tq_acn_out,cf_fatc_acn_rq_swi,cf_fatc_acn_clt_en_rq,cf_fatc_ecv_flt,cf_fatc_blwr_on,cf_fatc_iden,cf_fatc_blwr_max,cf_fatc_eng_start_req,cf_fatc_isg_stop_req,cf_fatc_ctr_inf,cf_fatc_msg_cnt,cr_fatc_out_temp,cr_fatc_out_temp_sns,cf_fatc_compload,cf_fatc_active_eco,cf_fatc_auto_activation,cf_fatc_def_sw,cf_fatc_ptc_rly_stat,cf_fatc_chk_sum).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EMS_DCT12
///
/// - ID: 129 (0x81)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct EmsDct12 {
    raw: [u8; 8],
}

impl EmsDct12 {
    pub const MESSAGE_ID: u32 = 129;
    
    pub const CR_EMS_SOAK_TIME_EXT_MIN: f32 = 0_f32;
    pub const CR_EMS_SOAK_TIME_EXT_MAX: f32 = 315_f32;
    pub const BRAKE_ACT_MIN: u8 = 0_u8;
    pub const BRAKE_ACT_MAX: u8 = 3_u8;
    pub const CF_EMS_ENG_OPER_STAT_MIN: u8 = 0_u8;
    pub const CF_EMS_ENG_OPER_STAT_MAX: u8 = 255_u8;
    pub const CR_EMS_IND_AIR_TEMP_MIN: f32 = -48_f32;
    pub const CR_EMS_IND_AIR_TEMP_MAX: f32 = 143.25_f32;
    pub const CF_EMS_ALIVE2_MIN: u8 = 0_u8;
    pub const CF_EMS_ALIVE2_MAX: u8 = 15_u8;
    pub const CF_EMS_CHK_SUM2_MIN: u8 = 0_u8;
    pub const CF_EMS_CHK_SUM2_MAX: u8 = 15_u8;
    
    /// Construct new EMS_DCT12 from values
    pub fn new(cr_ems_soak_time_ext: f32, brake_act: u8, cf_ems_eng_oper_stat: u8, cr_ems_ind_air_temp: f32, cf_ems_alive2: u8, cf_ems_chk_sum2: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cr_ems_soak_time_ext(cr_ems_soak_time_ext)?;
        res.set_brake_act(brake_act)?;
        res.set_cf_ems_eng_oper_stat(cf_ems_eng_oper_stat)?;
        res.set_cr_ems_ind_air_temp(cr_ems_ind_air_temp)?;
        res.set_cf_ems_alive2(cf_ems_alive2)?;
        res.set_cf_ems_chk_sum2(cf_ems_chk_sum2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CR_Ems_SoakTimeExt
    ///
    /// - Min: 0
    /// - Max: 315
    /// - Unit: "Min"
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cr_ems_soak_time_ext(&self) -> f32 {
        self.cr_ems_soak_time_ext_raw()
    }
    
    /// Get raw value of CR_Ems_SoakTimeExt
    ///
    /// - Start bit: 0
    /// - Signal size: 6 bits
    /// - Factor: 5
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ems_soak_time_ext_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..6].load_le::<u8>();
        
        let factor = 5_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Ems_SoakTimeExt
    #[inline(always)]
    pub fn set_cr_ems_soak_time_ext(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 315_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 129 });
        }
        let factor = 5_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..6].store_le(value);
        Ok(())
    }
    
    /// BRAKE_ACT
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn brake_act(&self) -> u8 {
        self.brake_act_raw()
    }
    
    /// Get raw value of BRAKE_ACT
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn brake_act_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BRAKE_ACT
    #[inline(always)]
    pub fn set_brake_act(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 129 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_EngOperStat
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_ems_eng_oper_stat(&self) -> u8 {
        self.cf_ems_eng_oper_stat_raw()
    }
    
    /// Get raw value of CF_Ems_EngOperStat
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_eng_oper_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_EngOperStat
    #[inline(always)]
    pub fn set_cf_ems_eng_oper_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 129 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CR_Ems_IndAirTemp
    ///
    /// - Min: -48
    /// - Max: 143.25
    /// - Unit: "deg"
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cr_ems_ind_air_temp(&self) -> f32 {
        self.cr_ems_ind_air_temp_raw()
    }
    
    /// Get raw value of CR_Ems_IndAirTemp
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.75
    /// - Offset: -48
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ems_ind_air_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 0.75_f32;
        let offset = -48_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Ems_IndAirTemp
    #[inline(always)]
    pub fn set_cr_ems_ind_air_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -48_f32 || 143.25_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 129 });
        }
        let factor = 0.75_f32;
        let offset = -48_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_Alive2
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_ems_alive2(&self) -> u8 {
        self.cf_ems_alive2_raw()
    }
    
    /// Get raw value of CF_Ems_Alive2
    ///
    /// - Start bit: 56
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_alive2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_Alive2
    #[inline(always)]
    pub fn set_cf_ems_alive2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 129 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..60].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_ChkSum2
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_ems_chk_sum2(&self) -> u8 {
        self.cf_ems_chk_sum2_raw()
    }
    
    /// Get raw value of CF_Ems_ChkSum2
    ///
    /// - Start bit: 60
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_chk_sum2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_ChkSum2
    #[inline(always)]
    pub fn set_cf_ems_chk_sum2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 129 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for EmsDct12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for EmsDct12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("EmsDct12")
                .field("cr_ems_soak_time_ext", &self.cr_ems_soak_time_ext())
                .field("brake_act", &self.brake_act())
                .field("cf_ems_eng_oper_stat", &self.cf_ems_eng_oper_stat())
                .field("cr_ems_ind_air_temp", &self.cr_ems_ind_air_temp())
                .field("cf_ems_alive2", &self.cf_ems_alive2())
                .field("cf_ems_chk_sum2", &self.cf_ems_chk_sum2())
            .finish()
        } else {
            f.debug_tuple("EmsDct12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for EmsDct12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cr_ems_soak_time_ext = u.float_in_range(0_f32..=315_f32)?;
        let brake_act = u.int_in_range(0..=3)?;
        let cf_ems_eng_oper_stat = u.int_in_range(0..=255)?;
        let cr_ems_ind_air_temp = u.float_in_range(-48_f32..=143.25_f32)?;
        let cf_ems_alive2 = u.int_in_range(0..=15)?;
        let cf_ems_chk_sum2 = u.int_in_range(0..=15)?;
        EmsDct12::new(cr_ems_soak_time_ext,brake_act,cf_ems_eng_oper_stat,cr_ems_ind_air_temp,cf_ems_alive2,cf_ems_chk_sum2).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// MDPS11
///
/// - ID: 897 (0x381)
/// - Size: 8 bytes
/// - Transmitter: MDPS
#[derive(Clone, Copy)]
pub struct Mdps11 {
    raw: [u8; 8],
}

impl Mdps11 {
    pub const MESSAGE_ID: u32 = 897;
    
    pub const CF_MDPS_W_LMP_MIN: u8 = 0_u8;
    pub const CF_MDPS_W_LMP_MAX: u8 = 3_u8;
    pub const CF_MDPS_FLEX_MIN: u8 = 0_u8;
    pub const CF_MDPS_FLEX_MAX: u8 = 3_u8;
    pub const CF_MDPS_STAT_MIN: u8 = 0_u8;
    pub const CF_MDPS_STAT_MAX: u8 = 15_u8;
    pub const CR_MDPS_DRV_TQ_MIN: f32 = -2048_f32;
    pub const CR_MDPS_DRV_TQ_MAX: f32 = 2046_f32;
    pub const CR_MDPS_STR_ANG_MIN: f32 = -3276.8_f32;
    pub const CR_MDPS_STR_ANG_MAX: f32 = 3276.7_f32;
    pub const CF_MDPS_ALIVE_CNT_MIN: u8 = 0_u8;
    pub const CF_MDPS_ALIVE_CNT_MAX: u8 = 255_u8;
    pub const CF_MDPS_CHKSUM_MIN: u8 = 0_u8;
    pub const CF_MDPS_CHKSUM_MAX: u8 = 255_u8;
    pub const CF_MDPS_CURR_MODE_MIN: u8 = 0_u8;
    pub const CF_MDPS_CURR_MODE_MAX: u8 = 3_u8;
    pub const CF_MDPS_TYPE_MIN: u8 = 0_u8;
    pub const CF_MDPS_TYPE_MAX: u8 = 2_u8;
    
    /// Construct new MDPS11 from values
    pub fn new(cf_mdps_w_lmp: u8, cf_mdps_flex: u8, cf_mdps_flex_disp: bool, cf_mdps_stat: u8, cr_mdps_drv_tq: f32, cf_mdps_alt_request: bool, cr_mdps_str_ang: f32, cf_mdps_alive_cnt: u8, cf_mdps_chksum: u8, cf_mdps_spas_func: bool, cf_mdps_lkas_func: bool, cf_mdps_curr_mode: u8, cf_mdps_type: u8, cf_mdps_vsm_func: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_mdps_w_lmp(cf_mdps_w_lmp)?;
        res.set_cf_mdps_flex(cf_mdps_flex)?;
        res.set_cf_mdps_flex_disp(cf_mdps_flex_disp)?;
        res.set_cf_mdps_stat(cf_mdps_stat)?;
        res.set_cr_mdps_drv_tq(cr_mdps_drv_tq)?;
        res.set_cf_mdps_alt_request(cf_mdps_alt_request)?;
        res.set_cr_mdps_str_ang(cr_mdps_str_ang)?;
        res.set_cf_mdps_alive_cnt(cf_mdps_alive_cnt)?;
        res.set_cf_mdps_chksum(cf_mdps_chksum)?;
        res.set_cf_mdps_spas_func(cf_mdps_spas_func)?;
        res.set_cf_mdps_lkas_func(cf_mdps_lkas_func)?;
        res.set_cf_mdps_curr_mode(cf_mdps_curr_mode)?;
        res.set_cf_mdps_type(cf_mdps_type)?;
        res.set_cf_mdps_vsm_func(cf_mdps_vsm_func)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Mdps_WLmp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, CUBIS, EMS, IBOX, SPAS
    #[inline(always)]
    pub fn cf_mdps_w_lmp(&self) -> u8 {
        self.cf_mdps_w_lmp_raw()
    }
    
    /// Get raw value of CF_Mdps_WLmp
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_w_lmp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Mdps_WLmp
    #[inline(always)]
    pub fn set_cf_mdps_w_lmp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 897 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_Flex
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, LDWS_LKAS
    #[inline(always)]
    pub fn cf_mdps_flex(&self) -> u8 {
        self.cf_mdps_flex_raw()
    }
    
    /// Get raw value of CF_Mdps_Flex
    ///
    /// - Start bit: 2
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_flex_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Mdps_Flex
    #[inline(always)]
    pub fn set_cf_mdps_flex(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 897 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..5].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_FlexDisp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_mdps_flex_disp(&self) -> bool {
        self.cf_mdps_flex_disp_raw()
    }
    
    /// Get raw value of CF_Mdps_FlexDisp
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_flex_disp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Mdps_FlexDisp
    #[inline(always)]
    pub fn set_cf_mdps_flex_disp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_Stat
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: SPAS
    #[inline(always)]
    pub fn cf_mdps_stat(&self) -> u8 {
        self.cf_mdps_stat_raw()
    }
    
    /// Get raw value of CF_Mdps_Stat
    ///
    /// - Start bit: 7
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[7..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Mdps_Stat
    #[inline(always)]
    pub fn set_cf_mdps_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 897 });
        }
        self.raw.view_bits_mut::<Lsb0>()[7..11].store_le(value);
        Ok(())
    }
    
    /// CR_Mdps_DrvTq
    ///
    /// - Min: -2048
    /// - Max: 2046
    /// - Unit: ""
    /// - Receivers: SPAS
    #[inline(always)]
    pub fn cr_mdps_drv_tq(&self) -> f32 {
        self.cr_mdps_drv_tq_raw()
    }
    
    /// Get raw value of CR_Mdps_DrvTq
    ///
    /// - Start bit: 11
    /// - Signal size: 12 bits
    /// - Factor: 1
    /// - Offset: -2048
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_mdps_drv_tq_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[11..23].load_le::<u16>();
        
        let factor = 1_f32;
        let offset = -2048_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Mdps_DrvTq
    #[inline(always)]
    pub fn set_cr_mdps_drv_tq(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -2048_f32 || 2046_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 897 });
        }
        let factor = 1_f32;
        let offset = -2048_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[11..23].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_ALTRequest
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_mdps_alt_request(&self) -> bool {
        self.cf_mdps_alt_request_raw()
    }
    
    /// Get raw value of CF_Mdps_ALTRequest
    ///
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_alt_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[23..24].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Mdps_ALTRequest
    #[inline(always)]
    pub fn set_cf_mdps_alt_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[23..24].store_le(value);
        Ok(())
    }
    
    /// CR_Mdps_StrAng
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "Deg"
    /// - Receivers: SPAS
    #[inline(always)]
    pub fn cr_mdps_str_ang(&self) -> f32 {
        self.cr_mdps_str_ang_raw()
    }
    
    /// Get raw value of CR_Mdps_StrAng
    ///
    /// - Start bit: 24
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn cr_mdps_str_ang_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..40].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Mdps_StrAng
    #[inline(always)]
    pub fn set_cr_mdps_str_ang(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 897 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[24..40].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_AliveCnt
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS, SPAS
    #[inline(always)]
    pub fn cf_mdps_alive_cnt(&self) -> u8 {
        self.cf_mdps_alive_cnt_raw()
    }
    
    /// Get raw value of CF_Mdps_AliveCnt
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_alive_cnt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Mdps_AliveCnt
    #[inline(always)]
    pub fn set_cf_mdps_alive_cnt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 897 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_Chksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS, SPAS
    #[inline(always)]
    pub fn cf_mdps_chksum(&self) -> u8 {
        self.cf_mdps_chksum_raw()
    }
    
    /// Get raw value of CF_Mdps_Chksum
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_chksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Mdps_Chksum
    #[inline(always)]
    pub fn set_cf_mdps_chksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 897 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_SPAS_FUNC
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: "flag"
    /// - Receivers: SPAS
    #[inline(always)]
    pub fn cf_mdps_spas_func(&self) -> bool {
        self.cf_mdps_spas_func_raw()
    }
    
    /// Get raw value of CF_Mdps_SPAS_FUNC
    ///
    /// - Start bit: 57
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_spas_func_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[57..58].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Mdps_SPAS_FUNC
    #[inline(always)]
    pub fn set_cf_mdps_spas_func(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[57..58].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_LKAS_FUNC
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: "flag"
    /// - Receivers: LDWS_LKAS
    #[inline(always)]
    pub fn cf_mdps_lkas_func(&self) -> bool {
        self.cf_mdps_lkas_func_raw()
    }
    
    /// Get raw value of CF_Mdps_LKAS_FUNC
    ///
    /// - Start bit: 58
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_lkas_func_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[58..59].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Mdps_LKAS_FUNC
    #[inline(always)]
    pub fn set_cf_mdps_lkas_func(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[58..59].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_CurrMode
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS
    #[inline(always)]
    pub fn cf_mdps_curr_mode(&self) -> u8 {
        self.cf_mdps_curr_mode_raw()
    }
    
    /// Get raw value of CF_Mdps_CurrMode
    ///
    /// - Start bit: 59
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_curr_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[59..61].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Mdps_CurrMode
    #[inline(always)]
    pub fn set_cf_mdps_curr_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 897 });
        }
        self.raw.view_bits_mut::<Lsb0>()[59..61].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_Type
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS, SPAS
    #[inline(always)]
    pub fn cf_mdps_type(&self) -> u8 {
        self.cf_mdps_type_raw()
    }
    
    /// Get raw value of CF_Mdps_Type
    ///
    /// - Start bit: 61
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[61..63].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Mdps_Type
    #[inline(always)]
    pub fn set_cf_mdps_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 2_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 897 });
        }
        self.raw.view_bits_mut::<Lsb0>()[61..63].store_le(value);
        Ok(())
    }
    
    /// CF_MDPS_VSM_FUNC
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_mdps_vsm_func(&self) -> bool {
        self.cf_mdps_vsm_func_raw()
    }
    
    /// Get raw value of CF_MDPS_VSM_FUNC
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_vsm_func_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[63..64].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_MDPS_VSM_FUNC
    #[inline(always)]
    pub fn set_cf_mdps_vsm_func(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[63..64].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Mdps11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Mdps11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Mdps11")
                .field("cf_mdps_w_lmp", &self.cf_mdps_w_lmp())
                .field("cf_mdps_flex", &self.cf_mdps_flex())
                .field("cf_mdps_flex_disp", &self.cf_mdps_flex_disp())
                .field("cf_mdps_stat", &self.cf_mdps_stat())
                .field("cr_mdps_drv_tq", &self.cr_mdps_drv_tq())
                .field("cf_mdps_alt_request", &self.cf_mdps_alt_request())
                .field("cr_mdps_str_ang", &self.cr_mdps_str_ang())
                .field("cf_mdps_alive_cnt", &self.cf_mdps_alive_cnt())
                .field("cf_mdps_chksum", &self.cf_mdps_chksum())
                .field("cf_mdps_spas_func", &self.cf_mdps_spas_func())
                .field("cf_mdps_lkas_func", &self.cf_mdps_lkas_func())
                .field("cf_mdps_curr_mode", &self.cf_mdps_curr_mode())
                .field("cf_mdps_type", &self.cf_mdps_type())
                .field("cf_mdps_vsm_func", &self.cf_mdps_vsm_func())
            .finish()
        } else {
            f.debug_tuple("Mdps11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Mdps11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_mdps_w_lmp = u.int_in_range(0..=3)?;
        let cf_mdps_flex = u.int_in_range(0..=3)?;
        let cf_mdps_flex_disp = u.int_in_range(0..=1)? == 1;
        let cf_mdps_stat = u.int_in_range(0..=15)?;
        let cr_mdps_drv_tq = u.float_in_range(-2048_f32..=2046_f32)?;
        let cf_mdps_alt_request = u.int_in_range(0..=1)? == 1;
        let cr_mdps_str_ang = u.float_in_range(-3276.8_f32..=3276.7_f32)?;
        let cf_mdps_alive_cnt = u.int_in_range(0..=255)?;
        let cf_mdps_chksum = u.int_in_range(0..=255)?;
        let cf_mdps_spas_func = u.int_in_range(0..=1)? == 1;
        let cf_mdps_lkas_func = u.int_in_range(0..=1)? == 1;
        let cf_mdps_curr_mode = u.int_in_range(0..=3)?;
        let cf_mdps_type = u.int_in_range(0..=2)?;
        let cf_mdps_vsm_func = u.int_in_range(0..=1)? == 1;
        Mdps11::new(cf_mdps_w_lmp,cf_mdps_flex,cf_mdps_flex_disp,cf_mdps_stat,cr_mdps_drv_tq,cf_mdps_alt_request,cr_mdps_str_ang,cf_mdps_alive_cnt,cf_mdps_chksum,cf_mdps_spas_func,cf_mdps_lkas_func,cf_mdps_curr_mode,cf_mdps_type,cf_mdps_vsm_func).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// DI_BOX13
///
/// - ID: 896 (0x380)
/// - Size: 8 bytes
/// - Transmitter: DI_BOX
#[derive(Clone, Copy)]
pub struct DiBox13 {
    raw: [u8; 8],
}

impl DiBox13 {
    pub const MESSAGE_ID: u32 = 896;
    
    pub const CF_DI_BOX_H_PRE_INJ_V_CONF_STAT_MIN: u8 = 0_u8;
    pub const CF_DI_BOX_H_PRE_INJ_V_CONF_STAT_MAX: u8 = 255_u8;
    pub const CF_DI_BOX_H_PRE_INJ_V_STAT1_MIN: u8 = 0_u8;
    pub const CF_DI_BOX_H_PRE_INJ_V_STAT1_MAX: u8 = 255_u8;
    pub const CF_DI_BOX_H_PRE_INJ_V_STAT2_MIN: u8 = 0_u8;
    pub const CF_DI_BOX_H_PRE_INJ_V_STAT2_MAX: u8 = 255_u8;
    pub const CF_DI_BOX_H_PRE_INJ_V_PKP_MIN: u8 = 0_u8;
    pub const CF_DI_BOX_H_PRE_INJ_V_PKP_MAX: u8 = 255_u8;
    pub const CF_DI_BOX_H_PRE_INJ_V_BPT_MIN: u8 = 0_u8;
    pub const CF_DI_BOX_H_PRE_INJ_V_BPT_MAX: u8 = 255_u8;
    pub const CF_DI_BOX_ERR_REG_FRT_MSV_MIN: u8 = 0_u8;
    pub const CF_DI_BOX_ERR_REG_FRT_MSV_MAX: u8 = 255_u8;
    pub const CF_DI_BOX_ERR_REG_SED_MSV_MIN: u8 = 0_u8;
    pub const CF_DI_BOX_ERR_REG_SED_MSV_MAX: u8 = 255_u8;
    
    /// Construct new DI_BOX13 from values
    pub fn new(cf_di_box_h_pre_inj_v_conf_stat: u8, cf_di_box_h_pre_inj_v_stat1: u8, cf_di_box_h_pre_inj_v_stat2: u8, cf_di_box_h_pre_inj_v_pkp: u8, cf_di_box_h_pre_inj_v_bpt: u8, cf_di_box_err_reg_frt_msv: u8, cf_di_box_err_reg_sed_msv: u8, cf_di_box_spi_err_sed_msv: bool, cf_di_box_spi_err_frt_msv: bool, cf_di_box_id_err_sed_msv: bool, cf_di_box_id_err_frt_msv: bool, cf_di_box_ini_stat_msv: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_di_box_h_pre_inj_v_conf_stat(cf_di_box_h_pre_inj_v_conf_stat)?;
        res.set_cf_di_box_h_pre_inj_v_stat1(cf_di_box_h_pre_inj_v_stat1)?;
        res.set_cf_di_box_h_pre_inj_v_stat2(cf_di_box_h_pre_inj_v_stat2)?;
        res.set_cf_di_box_h_pre_inj_v_pkp(cf_di_box_h_pre_inj_v_pkp)?;
        res.set_cf_di_box_h_pre_inj_v_bpt(cf_di_box_h_pre_inj_v_bpt)?;
        res.set_cf_di_box_err_reg_frt_msv(cf_di_box_err_reg_frt_msv)?;
        res.set_cf_di_box_err_reg_sed_msv(cf_di_box_err_reg_sed_msv)?;
        res.set_cf_di_box_spi_err_sed_msv(cf_di_box_spi_err_sed_msv)?;
        res.set_cf_di_box_spi_err_frt_msv(cf_di_box_spi_err_frt_msv)?;
        res.set_cf_di_box_id_err_sed_msv(cf_di_box_id_err_sed_msv)?;
        res.set_cf_di_box_id_err_frt_msv(cf_di_box_id_err_frt_msv)?;
        res.set_cf_di_box_ini_stat_msv(cf_di_box_ini_stat_msv)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_DiBox_HPreInjVConfStat
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_h_pre_inj_v_conf_stat(&self) -> u8 {
        self.cf_di_box_h_pre_inj_v_conf_stat_raw()
    }
    
    /// Get raw value of CF_DiBox_HPreInjVConfStat
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_h_pre_inj_v_conf_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_DiBox_HPreInjVConfStat
    #[inline(always)]
    pub fn set_cf_di_box_h_pre_inj_v_conf_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 896 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_HPreInjVStat1
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_h_pre_inj_v_stat1(&self) -> u8 {
        self.cf_di_box_h_pre_inj_v_stat1_raw()
    }
    
    /// Get raw value of CF_DiBox_HPreInjVStat1
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_h_pre_inj_v_stat1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_DiBox_HPreInjVStat1
    #[inline(always)]
    pub fn set_cf_di_box_h_pre_inj_v_stat1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 896 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_HPreInjVStat2
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_h_pre_inj_v_stat2(&self) -> u8 {
        self.cf_di_box_h_pre_inj_v_stat2_raw()
    }
    
    /// Get raw value of CF_DiBox_HPreInjVStat2
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_h_pre_inj_v_stat2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_DiBox_HPreInjVStat2
    #[inline(always)]
    pub fn set_cf_di_box_h_pre_inj_v_stat2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 896 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_HPreInjVPkp
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_h_pre_inj_v_pkp(&self) -> u8 {
        self.cf_di_box_h_pre_inj_v_pkp_raw()
    }
    
    /// Get raw value of CF_DiBox_HPreInjVPkp
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_h_pre_inj_v_pkp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_DiBox_HPreInjVPkp
    #[inline(always)]
    pub fn set_cf_di_box_h_pre_inj_v_pkp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 896 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_HPreInjVBpt
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_h_pre_inj_v_bpt(&self) -> u8 {
        self.cf_di_box_h_pre_inj_v_bpt_raw()
    }
    
    /// Get raw value of CF_DiBox_HPreInjVBpt
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_h_pre_inj_v_bpt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_DiBox_HPreInjVBpt
    #[inline(always)]
    pub fn set_cf_di_box_h_pre_inj_v_bpt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 896 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_ErrRegFrtMSV
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_err_reg_frt_msv(&self) -> u8 {
        self.cf_di_box_err_reg_frt_msv_raw()
    }
    
    /// Get raw value of CF_DiBox_ErrRegFrtMSV
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_err_reg_frt_msv_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_DiBox_ErrRegFrtMSV
    #[inline(always)]
    pub fn set_cf_di_box_err_reg_frt_msv(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 896 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_ErrRegSedMSV
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_err_reg_sed_msv(&self) -> u8 {
        self.cf_di_box_err_reg_sed_msv_raw()
    }
    
    /// Get raw value of CF_DiBox_ErrRegSedMSV
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_err_reg_sed_msv_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_DiBox_ErrRegSedMSV
    #[inline(always)]
    pub fn set_cf_di_box_err_reg_sed_msv(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 896 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_SPIErrSedMSV
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_spi_err_sed_msv(&self) -> bool {
        self.cf_di_box_spi_err_sed_msv_raw()
    }
    
    /// Get raw value of CF_DiBox_SPIErrSedMSV
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_spi_err_sed_msv_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_DiBox_SPIErrSedMSV
    #[inline(always)]
    pub fn set_cf_di_box_spi_err_sed_msv(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[56..57].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_SPIErrFrtMSV
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_spi_err_frt_msv(&self) -> bool {
        self.cf_di_box_spi_err_frt_msv_raw()
    }
    
    /// Get raw value of CF_DiBox_SPIErrFrtMSV
    ///
    /// - Start bit: 57
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_spi_err_frt_msv_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[57..58].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_DiBox_SPIErrFrtMSV
    #[inline(always)]
    pub fn set_cf_di_box_spi_err_frt_msv(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[57..58].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_IDErrSedMSV
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_id_err_sed_msv(&self) -> bool {
        self.cf_di_box_id_err_sed_msv_raw()
    }
    
    /// Get raw value of CF_DiBox_IDErrSedMSV
    ///
    /// - Start bit: 58
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_id_err_sed_msv_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[58..59].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_DiBox_IDErrSedMSV
    #[inline(always)]
    pub fn set_cf_di_box_id_err_sed_msv(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[58..59].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_IDErrFrtMSV
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_id_err_frt_msv(&self) -> bool {
        self.cf_di_box_id_err_frt_msv_raw()
    }
    
    /// Get raw value of CF_DiBox_IDErrFrtMSV
    ///
    /// - Start bit: 59
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_id_err_frt_msv_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[59..60].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_DiBox_IDErrFrtMSV
    #[inline(always)]
    pub fn set_cf_di_box_id_err_frt_msv(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[59..60].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_IniStatMSV
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_ini_stat_msv(&self) -> bool {
        self.cf_di_box_ini_stat_msv_raw()
    }
    
    /// Get raw value of CF_DiBox_IniStatMSV
    ///
    /// - Start bit: 60
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_ini_stat_msv_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[60..61].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_DiBox_IniStatMSV
    #[inline(always)]
    pub fn set_cf_di_box_ini_stat_msv(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[60..61].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for DiBox13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for DiBox13 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("DiBox13")
                .field("cf_di_box_h_pre_inj_v_conf_stat", &self.cf_di_box_h_pre_inj_v_conf_stat())
                .field("cf_di_box_h_pre_inj_v_stat1", &self.cf_di_box_h_pre_inj_v_stat1())
                .field("cf_di_box_h_pre_inj_v_stat2", &self.cf_di_box_h_pre_inj_v_stat2())
                .field("cf_di_box_h_pre_inj_v_pkp", &self.cf_di_box_h_pre_inj_v_pkp())
                .field("cf_di_box_h_pre_inj_v_bpt", &self.cf_di_box_h_pre_inj_v_bpt())
                .field("cf_di_box_err_reg_frt_msv", &self.cf_di_box_err_reg_frt_msv())
                .field("cf_di_box_err_reg_sed_msv", &self.cf_di_box_err_reg_sed_msv())
                .field("cf_di_box_spi_err_sed_msv", &self.cf_di_box_spi_err_sed_msv())
                .field("cf_di_box_spi_err_frt_msv", &self.cf_di_box_spi_err_frt_msv())
                .field("cf_di_box_id_err_sed_msv", &self.cf_di_box_id_err_sed_msv())
                .field("cf_di_box_id_err_frt_msv", &self.cf_di_box_id_err_frt_msv())
                .field("cf_di_box_ini_stat_msv", &self.cf_di_box_ini_stat_msv())
            .finish()
        } else {
            f.debug_tuple("DiBox13").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for DiBox13 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_di_box_h_pre_inj_v_conf_stat = u.int_in_range(0..=255)?;
        let cf_di_box_h_pre_inj_v_stat1 = u.int_in_range(0..=255)?;
        let cf_di_box_h_pre_inj_v_stat2 = u.int_in_range(0..=255)?;
        let cf_di_box_h_pre_inj_v_pkp = u.int_in_range(0..=255)?;
        let cf_di_box_h_pre_inj_v_bpt = u.int_in_range(0..=255)?;
        let cf_di_box_err_reg_frt_msv = u.int_in_range(0..=255)?;
        let cf_di_box_err_reg_sed_msv = u.int_in_range(0..=255)?;
        let cf_di_box_spi_err_sed_msv = u.int_in_range(0..=1)? == 1;
        let cf_di_box_spi_err_frt_msv = u.int_in_range(0..=1)? == 1;
        let cf_di_box_id_err_sed_msv = u.int_in_range(0..=1)? == 1;
        let cf_di_box_id_err_frt_msv = u.int_in_range(0..=1)? == 1;
        let cf_di_box_ini_stat_msv = u.int_in_range(0..=1)? == 1;
        DiBox13::new(cf_di_box_h_pre_inj_v_conf_stat,cf_di_box_h_pre_inj_v_stat1,cf_di_box_h_pre_inj_v_stat2,cf_di_box_h_pre_inj_v_pkp,cf_di_box_h_pre_inj_v_bpt,cf_di_box_err_reg_frt_msv,cf_di_box_err_reg_sed_msv,cf_di_box_spi_err_sed_msv,cf_di_box_spi_err_frt_msv,cf_di_box_id_err_sed_msv,cf_di_box_id_err_frt_msv,cf_di_box_ini_stat_msv).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EMS13
///
/// - ID: 640 (0x280)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct Ems13 {
    raw: [u8; 8],
}

impl Ems13 {
    pub const MESSAGE_ID: u32 = 640;
    
    pub const ERR_FUEL_MIN: u8 = 0_u8;
    pub const ERR_FUEL_MAX: u8 = 255_u8;
    pub const EOS_MIN: u8 = 0_u8;
    pub const EOS_MAX: u8 = 255_u8;
    pub const TCO_MIN: f32 = -48_f32;
    pub const TCO_MAX: f32 = 143.25_f32;
    pub const N_32_MIN: f32 = 0_f32;
    pub const N_32_MAX: f32 = 8160_f32;
    pub const MAF_MIN: f32 = 0_f32;
    pub const MAF_MAX: f32 = 1388.985_f32;
    pub const TIA_MIN: f32 = -48_f32;
    pub const TIA_MAX: f32 = 143.25_f32;
    pub const MAP_MIN: f32 = 0_f32;
    pub const MAP_MAX: f32 = 119.9979_f32;
    pub const AMP_MIN: f32 = 0_f32;
    pub const AMP_MAX: f32 = 5411.1_f32;
    
    /// Construct new EMS13 from values
    pub fn new(lv_fuel_type_ecu: bool, lv_bfs_cfirm: bool, lv_crash: bool, lv_vb_off_act: bool, lv_gsl_map: bool, lv_eng_turn: bool, err_fuel: u8, eos: u8, tco: f32, n_32: f32, maf: f32, tia: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_lv_fuel_type_ecu(lv_fuel_type_ecu)?;
        res.set_lv_bfs_cfirm(lv_bfs_cfirm)?;
        res.set_lv_crash(lv_crash)?;
        res.set_lv_vb_off_act(lv_vb_off_act)?;
        res.set_lv_gsl_map(lv_gsl_map)?;
        res.set_lv_eng_turn(lv_eng_turn)?;
        res.set_err_fuel(err_fuel)?;
        res.set_eos(eos)?;
        res.set_tco(tco)?;
        res.set_n_32(n_32)?;
        res.set_maf(maf)?;
        res.set_tia(tia)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// LV_FUEL_TYPE_ECU
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM, CLU, LPI, SMK
    #[inline(always)]
    pub fn lv_fuel_type_ecu(&self) -> bool {
        self.lv_fuel_type_ecu_raw()
    }
    
    /// Get raw value of LV_FUEL_TYPE_ECU
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lv_fuel_type_ecu_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LV_FUEL_TYPE_ECU
    #[inline(always)]
    pub fn set_lv_fuel_type_ecu(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// LV_BFS_CFIRM
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LPI
    #[inline(always)]
    pub fn lv_bfs_cfirm(&self) -> bool {
        self.lv_bfs_cfirm_raw()
    }
    
    /// Get raw value of LV_BFS_CFIRM
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lv_bfs_cfirm_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LV_BFS_CFIRM
    #[inline(always)]
    pub fn set_lv_bfs_cfirm(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// LV_CRASH
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LPI
    #[inline(always)]
    pub fn lv_crash(&self) -> bool {
        self.lv_crash_raw()
    }
    
    /// Get raw value of LV_CRASH
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lv_crash_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LV_CRASH
    #[inline(always)]
    pub fn set_lv_crash(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// LV_VB_OFF_ACT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LPI
    #[inline(always)]
    pub fn lv_vb_off_act(&self) -> bool {
        self.lv_vb_off_act_raw()
    }
    
    /// Get raw value of LV_VB_OFF_ACT
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lv_vb_off_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LV_VB_OFF_ACT
    #[inline(always)]
    pub fn set_lv_vb_off_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// Get raw value of LV_GSL_MAP
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lv_gsl_map_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    pub fn lv_gsl_map(&mut self) -> Result<Ems13LvGslMap, CanError> {
        match self.lv_gsl_map_raw() {
            false => Ok(Ems13LvGslMap::M0(Ems13LvGslMapM0{ raw: self.raw })),
            true => Ok(Ems13LvGslMap::M1(Ems13LvGslMapM1{ raw: self.raw })),
            multiplexor => Err(CanError::InvalidMultiplexor { message_id: 640, multiplexor: multiplexor.into() }),
        }
    }
    /// Set value of LV_GSL_MAP
    #[inline(always)]
    fn set_lv_gsl_map(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// Set value of LV_GSL_MAP
    #[inline(always)]
    pub fn set_m0(&mut self, value: Ems13LvGslMapM0) -> Result<(), CanError> {
        let b0 = BitArray::<_, LocalBits>::new(self.raw);
        let b1 = BitArray::<_, LocalBits>::new(value.raw);
        self.raw = b0.bitor(b1).into_inner();
        self.set_lv_gsl_map(false)?;
        Ok(())
    }
    
    /// Set value of LV_GSL_MAP
    #[inline(always)]
    pub fn set_m1(&mut self, value: Ems13LvGslMapM1) -> Result<(), CanError> {
        let b0 = BitArray::<_, LocalBits>::new(self.raw);
        let b1 = BitArray::<_, LocalBits>::new(value.raw);
        self.raw = b0.bitor(b1).into_inner();
        self.set_lv_gsl_map(true)?;
        Ok(())
    }
    
    /// LV_ENG_TURN
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LPI
    #[inline(always)]
    pub fn lv_eng_turn(&self) -> bool {
        self.lv_eng_turn_raw()
    }
    
    /// Get raw value of LV_ENG_TURN
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lv_eng_turn_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LV_ENG_TURN
    #[inline(always)]
    pub fn set_lv_eng_turn(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// ERR_FUEL
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LPI
    #[inline(always)]
    pub fn err_fuel(&self) -> u8 {
        self.err_fuel_raw()
    }
    
    /// Get raw value of ERR_FUEL
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn err_fuel_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ERR_FUEL
    #[inline(always)]
    pub fn set_err_fuel(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 640 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// EOS
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LPI
    #[inline(always)]
    pub fn eos(&self) -> u8 {
        self.eos_raw()
    }
    
    /// Get raw value of EOS
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn eos_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of EOS
    #[inline(always)]
    pub fn set_eos(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 640 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// TCO
    ///
    /// - Min: -48
    /// - Max: 143.25
    /// - Unit: "deg"
    /// - Receivers: LPI
    #[inline(always)]
    pub fn tco(&self) -> f32 {
        self.tco_raw()
    }
    
    /// Get raw value of TCO
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.75
    /// - Offset: -48
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tco_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 0.75_f32;
        let offset = -48_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TCO
    #[inline(always)]
    pub fn set_tco(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -48_f32 || 143.25_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 640 });
        }
        let factor = 0.75_f32;
        let offset = -48_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// N_32
    ///
    /// - Min: 0
    /// - Max: 8160
    /// - Unit: "rpm"
    /// - Receivers: LPI
    #[inline(always)]
    pub fn n_32(&self) -> f32 {
        self.n_32_raw()
    }
    
    /// Get raw value of N_32
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 32
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn n_32_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 32_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of N_32
    #[inline(always)]
    pub fn set_n_32(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 8160_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 640 });
        }
        let factor = 32_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// MAF
    ///
    /// - Min: 0
    /// - Max: 1388.985
    /// - Unit: "mg/TDC"
    /// - Receivers: LPI
    #[inline(always)]
    pub fn maf(&self) -> f32 {
        self.maf_raw()
    }
    
    /// Get raw value of MAF
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 5.447
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn maf_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 5.447_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of MAF
    #[inline(always)]
    pub fn set_maf(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1388.985_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 640 });
        }
        let factor = 5.447_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// TIA
    ///
    /// - Min: -48
    /// - Max: 143.25
    /// - Unit: "deg"
    /// - Receivers: LPI
    #[inline(always)]
    pub fn tia(&self) -> f32 {
        self.tia_raw()
    }
    
    /// Get raw value of TIA
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.75
    /// - Offset: -48
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tia_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        let factor = 0.75_f32;
        let offset = -48_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TIA
    #[inline(always)]
    pub fn set_tia(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -48_f32 || 143.25_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 640 });
        }
        let factor = 0.75_f32;
        let offset = -48_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ems13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ems13 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ems13")
                .field("lv_fuel_type_ecu", &self.lv_fuel_type_ecu())
                .field("lv_bfs_cfirm", &self.lv_bfs_cfirm())
                .field("lv_crash", &self.lv_crash())
                .field("lv_vb_off_act", &self.lv_vb_off_act())
                .field("lv_eng_turn", &self.lv_eng_turn())
                .field("err_fuel", &self.err_fuel())
                .field("eos", &self.eos())
                .field("tco", &self.tco())
                .field("n_32", &self.n_32())
                .field("maf", &self.maf())
                .field("tia", &self.tia())
            .finish()
        } else {
            f.debug_tuple("Ems13").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ems13 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let lv_fuel_type_ecu = u.int_in_range(0..=1)? == 1;
        let lv_bfs_cfirm = u.int_in_range(0..=1)? == 1;
        let lv_crash = u.int_in_range(0..=1)? == 1;
        let lv_vb_off_act = u.int_in_range(0..=1)? == 1;
        let lv_gsl_map = u.int_in_range(0..=1)? == 1;
        let lv_eng_turn = u.int_in_range(0..=1)? == 1;
        let err_fuel = u.int_in_range(0..=255)?;
        let eos = u.int_in_range(0..=255)?;
        let tco = u.float_in_range(-48_f32..=143.25_f32)?;
        let n_32 = u.float_in_range(0_f32..=8160_f32)?;
        let maf = u.float_in_range(0_f32..=1388.985_f32)?;
        let tia = u.float_in_range(-48_f32..=143.25_f32)?;
        Ems13::new(lv_fuel_type_ecu,lv_bfs_cfirm,lv_crash,lv_vb_off_act,lv_gsl_map,lv_eng_turn,err_fuel,eos,tco,n_32,maf,tia).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for multiplexed signal EMS13
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Ems13LvGslMap {
    M0(Ems13LvGslMapM0),
    M1(Ems13LvGslMapM1),
}

#[derive(Default)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Ems13LvGslMapM0 { raw: [u8; 8] }

impl Ems13LvGslMapM0 {
pub fn new() -> Self { Self { raw: [0u8; 8] } }
/// AMP
///
/// - Min: 0
/// - Max: 5411.1
/// - Unit: "hPa"
/// - Receivers: LPI
#[inline(always)]
pub fn amp(&self) -> f32 {
    self.amp_raw()
}

/// Get raw value of AMP
///
/// - Start bit: 56
/// - Signal size: 8 bits
/// - Factor: 21.22
/// - Offset: 0
/// - Byte order: LittleEndian
/// - Value type: Unsigned
#[inline(always)]
pub fn amp_raw(&self) -> f32 {
    let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
    
    let factor = 21.22_f32;
    let offset = 0_f32;
    (signal as f32) * factor + offset
}

/// Set value of AMP
#[inline(always)]
pub fn set_amp(&mut self, value: f32) -> Result<(), CanError> {
    #[cfg(feature = "range_checked")]
    if value < 0_f32 || 5411.1_f32 < value {
        return Err(CanError::ParameterOutOfRange { message_id: 640 });
    }
    let factor = 21.22_f32;
    let offset = 0_f32;
    let value = ((value - offset) / factor) as u8;
    
    self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
    Ok(())
}

}

#[derive(Default)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Ems13LvGslMapM1 { raw: [u8; 8] }

impl Ems13LvGslMapM1 {
pub fn new() -> Self { Self { raw: [0u8; 8] } }
/// MAP
///
/// - Min: 0
/// - Max: 119.9979
/// - Unit: "kPa"
/// - Receivers: LPI
#[inline(always)]
pub fn map(&self) -> f32 {
    self.map_raw()
}

/// Get raw value of MAP
///
/// - Start bit: 56
/// - Signal size: 8 bits
/// - Factor: 0.47058
/// - Offset: 0
/// - Byte order: LittleEndian
/// - Value type: Unsigned
#[inline(always)]
pub fn map_raw(&self) -> f32 {
    let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
    
    let factor = 0.47058_f32;
    let offset = 0_f32;
    (signal as f32) * factor + offset
}

/// Set value of MAP
#[inline(always)]
pub fn set_map(&mut self, value: f32) -> Result<(), CanError> {
    #[cfg(feature = "range_checked")]
    if value < 0_f32 || 119.9979_f32 < value {
        return Err(CanError::ParameterOutOfRange { message_id: 640 });
    }
    let factor = 0.47058_f32;
    let offset = 0_f32;
    let value = ((value - offset) / factor) as u8;
    
    self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
    Ok(())
}

}


/// EMS_DCT11
///
/// - ID: 128 (0x80)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct EmsDct11 {
    raw: [u8; 8],
}

impl EmsDct11 {
    pub const MESSAGE_ID: u32 = 128;
    
    pub const PV_AV_CAN_MIN: f32 = 0_f32;
    pub const PV_AV_CAN_MAX: f32 = 99.603_f32;
    pub const TQ_STND_MIN: f32 = 0_f32;
    pub const TQ_STND_MAX: f32 = 630_f32;
    pub const N_MIN: f32 = 0_f32;
    pub const N_MAX: f32 = 16383.75_f32;
    pub const TQI_ACOR_MIN: f32 = 0_f32;
    pub const TQI_ACOR_MAX: f32 = 99.6094_f32;
    pub const TQFR_MIN: f32 = 0_f32;
    pub const TQFR_MAX: f32 = 99.6094_f32;
    pub const TQI_MIN: f32 = 0_f32;
    pub const TQI_MAX: f32 = 99.609375_f32;
    pub const CF_EMS_ALIVE_MIN: u8 = 0_u8;
    pub const CF_EMS_ALIVE_MAX: u8 = 15_u8;
    pub const CF_EMS_CHK_SUM_MIN: u8 = 0_u8;
    pub const CF_EMS_CHK_SUM_MAX: u8 = 15_u8;
    
    /// Construct new EMS_DCT11 from values
    pub fn new(pv_av_can: f32, tq_stnd: f32, f_n_eng: bool, f_sub_tqi: bool, n: f32, tqi_acor: f32, tqfr: f32, tqi: f32, cf_ems_alive: u8, cf_ems_chk_sum: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_pv_av_can(pv_av_can)?;
        res.set_tq_stnd(tq_stnd)?;
        res.set_f_n_eng(f_n_eng)?;
        res.set_f_sub_tqi(f_sub_tqi)?;
        res.set_n(n)?;
        res.set_tqi_acor(tqi_acor)?;
        res.set_tqfr(tqfr)?;
        res.set_tqi(tqi)?;
        res.set_cf_ems_alive(cf_ems_alive)?;
        res.set_cf_ems_chk_sum(cf_ems_chk_sum)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// PV_AV_CAN
    ///
    /// - Min: 0
    /// - Max: 99.603
    /// - Unit: "%"
    /// - Receivers: TCU
    #[inline(always)]
    pub fn pv_av_can(&self) -> f32 {
        self.pv_av_can_raw()
    }
    
    /// Get raw value of PV_AV_CAN
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 0.3906
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pv_av_can_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 0.3906_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PV_AV_CAN
    #[inline(always)]
    pub fn set_pv_av_can(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.603_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 128 });
        }
        let factor = 0.3906_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// TQ_STND
    ///
    /// - Min: 0
    /// - Max: 630
    /// - Unit: "Nm"
    /// - Receivers: TCU
    #[inline(always)]
    pub fn tq_stnd(&self) -> f32 {
        self.tq_stnd_raw()
    }
    
    /// Get raw value of TQ_STND
    ///
    /// - Start bit: 8
    /// - Signal size: 6 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tq_stnd_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..14].load_le::<u8>();
        
        let factor = 10_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQ_STND
    #[inline(always)]
    pub fn set_tq_stnd(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 630_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 128 });
        }
        let factor = 10_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..14].store_le(value);
        Ok(())
    }
    
    /// F_N_ENG
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn f_n_eng(&self) -> bool {
        self.f_n_eng_raw()
    }
    
    /// Get raw value of F_N_ENG
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn f_n_eng_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of F_N_ENG
    #[inline(always)]
    pub fn set_f_n_eng(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[14..15].store_le(value);
        Ok(())
    }
    
    /// F_SUB_TQI
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn f_sub_tqi(&self) -> bool {
        self.f_sub_tqi_raw()
    }
    
    /// Get raw value of F_SUB_TQI
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn f_sub_tqi_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of F_SUB_TQI
    #[inline(always)]
    pub fn set_f_sub_tqi(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[15..16].store_le(value);
        Ok(())
    }
    
    /// N
    ///
    /// - Min: 0
    /// - Max: 16383.75
    /// - Unit: "rpm"
    /// - Receivers: TCU
    #[inline(always)]
    pub fn n(&self) -> f32 {
        self.n_raw()
    }
    
    /// Get raw value of N
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.25
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn n_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<u16>();
        
        let factor = 0.25_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of N
    #[inline(always)]
    pub fn set_n(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 16383.75_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 128 });
        }
        let factor = 0.25_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// TQI_ACOR
    ///
    /// - Min: 0
    /// - Max: 99.6094
    /// - Unit: "%"
    /// - Receivers: IBOX, TCU
    #[inline(always)]
    pub fn tqi_acor(&self) -> f32 {
        self.tqi_acor_raw()
    }
    
    /// Get raw value of TQI_ACOR
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_acor_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI_ACOR
    #[inline(always)]
    pub fn set_tqi_acor(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.6094_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 128 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// TQFR
    ///
    /// - Min: 0
    /// - Max: 99.6094
    /// - Unit: "%"
    /// - Receivers: TCU
    #[inline(always)]
    pub fn tqfr(&self) -> f32 {
        self.tqfr_raw()
    }
    
    /// Get raw value of TQFR
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqfr_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQFR
    #[inline(always)]
    pub fn set_tqfr(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.6094_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 128 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// TQI
    ///
    /// - Min: 0
    /// - Max: 99.609375
    /// - Unit: "%"
    /// - Receivers: TCU
    #[inline(always)]
    pub fn tqi(&self) -> f32 {
        self.tqi_raw()
    }
    
    /// Get raw value of TQI
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI
    #[inline(always)]
    pub fn set_tqi(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.609375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 128 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_Alive
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_ems_alive(&self) -> u8 {
        self.cf_ems_alive_raw()
    }
    
    /// Get raw value of CF_Ems_Alive
    ///
    /// - Start bit: 56
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_alive_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_Alive
    #[inline(always)]
    pub fn set_cf_ems_alive(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 128 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..60].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_ChkSum
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_ems_chk_sum(&self) -> u8 {
        self.cf_ems_chk_sum_raw()
    }
    
    /// Get raw value of CF_Ems_ChkSum
    ///
    /// - Start bit: 60
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_chk_sum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_ChkSum
    #[inline(always)]
    pub fn set_cf_ems_chk_sum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 128 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for EmsDct11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for EmsDct11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("EmsDct11")
                .field("pv_av_can", &self.pv_av_can())
                .field("tq_stnd", &self.tq_stnd())
                .field("f_n_eng", &self.f_n_eng())
                .field("f_sub_tqi", &self.f_sub_tqi())
                .field("n", &self.n())
                .field("tqi_acor", &self.tqi_acor())
                .field("tqfr", &self.tqfr())
                .field("tqi", &self.tqi())
                .field("cf_ems_alive", &self.cf_ems_alive())
                .field("cf_ems_chk_sum", &self.cf_ems_chk_sum())
            .finish()
        } else {
            f.debug_tuple("EmsDct11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for EmsDct11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let pv_av_can = u.float_in_range(0_f32..=99.603_f32)?;
        let tq_stnd = u.float_in_range(0_f32..=630_f32)?;
        let f_n_eng = u.int_in_range(0..=1)? == 1;
        let f_sub_tqi = u.int_in_range(0..=1)? == 1;
        let n = u.float_in_range(0_f32..=16383.75_f32)?;
        let tqi_acor = u.float_in_range(0_f32..=99.6094_f32)?;
        let tqfr = u.float_in_range(0_f32..=99.6094_f32)?;
        let tqi = u.float_in_range(0_f32..=99.609375_f32)?;
        let cf_ems_alive = u.int_in_range(0..=15)?;
        let cf_ems_chk_sum = u.int_in_range(0..=15)?;
        EmsDct11::new(pv_av_can,tq_stnd,f_n_eng,f_sub_tqi,n,tqi_acor,tqfr,tqi,cf_ems_alive,cf_ems_chk_sum).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// HU_MON_PE_01
///
/// - ID: 1407 (0x57f)
/// - Size: 8 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct HuMonPe01 {
    raw: [u8; 8],
}

impl HuMonPe01 {
    pub const MESSAGE_ID: u32 = 1407;
    
    pub const HU_TYPE_MIN: u8 = 0_u8;
    pub const HU_TYPE_MAX: u8 = 255_u8;
    
    /// Construct new HU_MON_PE_01 from values
    pub fn new(hu_type: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_hu_type(hu_type)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// HU_Type
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_type(&self) -> u8 {
        self.hu_type_raw()
    }
    
    /// Get raw value of HU_Type
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_Type
    #[inline(always)]
    pub fn set_hu_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1407 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for HuMonPe01 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for HuMonPe01 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("HuMonPe01")
                .field("hu_type", &self.hu_type())
            .finish()
        } else {
            f.debug_tuple("HuMonPe01").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for HuMonPe01 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let hu_type = u.int_in_range(0..=255)?;
        HuMonPe01::new(hu_type).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// CGW5
///
/// - ID: 127 (0x7f)
/// - Size: 8 bytes
/// - Transmitter: BCM
#[derive(Clone, Copy)]
pub struct Cgw5 {
    raw: [u8; 8],
}

impl Cgw5 {
    pub const MESSAGE_ID: u32 = 127;
    
    
    /// Construct new CGW5 from values
    pub fn new(c_stop_lamp_lh_open_sts: bool, c_stop_lamp_rh_open_sts: bool, c_hmsl_open_sts: bool, c_h_lamp_low_lh_open_sts: bool, c_h_lamp_low_rh_open_sts: bool, c_h_lamp_high_lh_open_sts: bool, c_h_lamp_high_rh_open_sts: bool, c_drl_lamp_lh_open_sts: bool, c_drl_lamp_rh_open_sts: bool, c_rear_fog_lh_open_sts: bool, c_rear_fog_rh_open_sts: bool, c_front_fog_lh_open_sts: bool, c_front_fog_rh_open_sts: bool, c_rear_ext_tail_lh_open_sts: bool, c_rear_ext_tail_rh_open_sts: bool, c_front_ext_tail_lh_open_sts: bool, c_front_ext_tail_rh_open_sts: bool, c_rear_tsig_lh_open_sts: bool, c_rear_tsig_rh_open_sts: bool, c_front_tsig_lh_open_sts: bool, c_front_tsig_rh_open_sts: bool, c_s_bending_lh_open_sts: bool, c_s_bending_rh_open_sts: bool, c_license_plate_lh_open_sts: bool, c_license_plate_rh_open_sts: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_c_stop_lamp_lh_open_sts(c_stop_lamp_lh_open_sts)?;
        res.set_c_stop_lamp_rh_open_sts(c_stop_lamp_rh_open_sts)?;
        res.set_c_hmsl_open_sts(c_hmsl_open_sts)?;
        res.set_c_h_lamp_low_lh_open_sts(c_h_lamp_low_lh_open_sts)?;
        res.set_c_h_lamp_low_rh_open_sts(c_h_lamp_low_rh_open_sts)?;
        res.set_c_h_lamp_high_lh_open_sts(c_h_lamp_high_lh_open_sts)?;
        res.set_c_h_lamp_high_rh_open_sts(c_h_lamp_high_rh_open_sts)?;
        res.set_c_drl_lamp_lh_open_sts(c_drl_lamp_lh_open_sts)?;
        res.set_c_drl_lamp_rh_open_sts(c_drl_lamp_rh_open_sts)?;
        res.set_c_rear_fog_lh_open_sts(c_rear_fog_lh_open_sts)?;
        res.set_c_rear_fog_rh_open_sts(c_rear_fog_rh_open_sts)?;
        res.set_c_front_fog_lh_open_sts(c_front_fog_lh_open_sts)?;
        res.set_c_front_fog_rh_open_sts(c_front_fog_rh_open_sts)?;
        res.set_c_rear_ext_tail_lh_open_sts(c_rear_ext_tail_lh_open_sts)?;
        res.set_c_rear_ext_tail_rh_open_sts(c_rear_ext_tail_rh_open_sts)?;
        res.set_c_front_ext_tail_lh_open_sts(c_front_ext_tail_lh_open_sts)?;
        res.set_c_front_ext_tail_rh_open_sts(c_front_ext_tail_rh_open_sts)?;
        res.set_c_rear_tsig_lh_open_sts(c_rear_tsig_lh_open_sts)?;
        res.set_c_rear_tsig_rh_open_sts(c_rear_tsig_rh_open_sts)?;
        res.set_c_front_tsig_lh_open_sts(c_front_tsig_lh_open_sts)?;
        res.set_c_front_tsig_rh_open_sts(c_front_tsig_rh_open_sts)?;
        res.set_c_s_bending_lh_open_sts(c_s_bending_lh_open_sts)?;
        res.set_c_s_bending_rh_open_sts(c_s_bending_rh_open_sts)?;
        res.set_c_license_plate_lh_open_sts(c_license_plate_lh_open_sts)?;
        res.set_c_license_plate_rh_open_sts(c_license_plate_rh_open_sts)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// C_StopLampLhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_stop_lamp_lh_open_sts(&self) -> bool {
        self.c_stop_lamp_lh_open_sts_raw()
    }
    
    /// Get raw value of C_StopLampLhOpenSts
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_stop_lamp_lh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_StopLampLhOpenSts
    #[inline(always)]
    pub fn set_c_stop_lamp_lh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// C_StopLampRhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_stop_lamp_rh_open_sts(&self) -> bool {
        self.c_stop_lamp_rh_open_sts_raw()
    }
    
    /// Get raw value of C_StopLampRhOpenSts
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_stop_lamp_rh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_StopLampRhOpenSts
    #[inline(always)]
    pub fn set_c_stop_lamp_rh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// C_HMSLOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_hmsl_open_sts(&self) -> bool {
        self.c_hmsl_open_sts_raw()
    }
    
    /// Get raw value of C_HMSLOpenSts
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_hmsl_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_HMSLOpenSts
    #[inline(always)]
    pub fn set_c_hmsl_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// C_HLampLowLhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_h_lamp_low_lh_open_sts(&self) -> bool {
        self.c_h_lamp_low_lh_open_sts_raw()
    }
    
    /// Get raw value of C_HLampLowLhOpenSts
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_h_lamp_low_lh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_HLampLowLhOpenSts
    #[inline(always)]
    pub fn set_c_h_lamp_low_lh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// C_HLampLowRhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_h_lamp_low_rh_open_sts(&self) -> bool {
        self.c_h_lamp_low_rh_open_sts_raw()
    }
    
    /// Get raw value of C_HLampLowRhOpenSts
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_h_lamp_low_rh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_HLampLowRhOpenSts
    #[inline(always)]
    pub fn set_c_h_lamp_low_rh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// C_HLampHighLhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_h_lamp_high_lh_open_sts(&self) -> bool {
        self.c_h_lamp_high_lh_open_sts_raw()
    }
    
    /// Get raw value of C_HLampHighLhOpenSts
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_h_lamp_high_lh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_HLampHighLhOpenSts
    #[inline(always)]
    pub fn set_c_h_lamp_high_lh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// C_HLampHighRhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_h_lamp_high_rh_open_sts(&self) -> bool {
        self.c_h_lamp_high_rh_open_sts_raw()
    }
    
    /// Get raw value of C_HLampHighRhOpenSts
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_h_lamp_high_rh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_HLampHighRhOpenSts
    #[inline(always)]
    pub fn set_c_h_lamp_high_rh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[6..7].store_le(value);
        Ok(())
    }
    
    /// C_DRLLampLhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_drl_lamp_lh_open_sts(&self) -> bool {
        self.c_drl_lamp_lh_open_sts_raw()
    }
    
    /// Get raw value of C_DRLLampLhOpenSts
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_drl_lamp_lh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_DRLLampLhOpenSts
    #[inline(always)]
    pub fn set_c_drl_lamp_lh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// C_DRLLampRhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_drl_lamp_rh_open_sts(&self) -> bool {
        self.c_drl_lamp_rh_open_sts_raw()
    }
    
    /// Get raw value of C_DRLLampRhOpenSts
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_drl_lamp_rh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_DRLLampRhOpenSts
    #[inline(always)]
    pub fn set_c_drl_lamp_rh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[8..9].store_le(value);
        Ok(())
    }
    
    /// C_RearFOGLhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_rear_fog_lh_open_sts(&self) -> bool {
        self.c_rear_fog_lh_open_sts_raw()
    }
    
    /// Get raw value of C_RearFOGLhOpenSts
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_rear_fog_lh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_RearFOGLhOpenSts
    #[inline(always)]
    pub fn set_c_rear_fog_lh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[9..10].store_le(value);
        Ok(())
    }
    
    /// C_RearFOGRhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_rear_fog_rh_open_sts(&self) -> bool {
        self.c_rear_fog_rh_open_sts_raw()
    }
    
    /// Get raw value of C_RearFOGRhOpenSts
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_rear_fog_rh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_RearFOGRhOpenSts
    #[inline(always)]
    pub fn set_c_rear_fog_rh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[10..11].store_le(value);
        Ok(())
    }
    
    /// C_FrontFOGLhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_front_fog_lh_open_sts(&self) -> bool {
        self.c_front_fog_lh_open_sts_raw()
    }
    
    /// Get raw value of C_FrontFOGLhOpenSts
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_front_fog_lh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_FrontFOGLhOpenSts
    #[inline(always)]
    pub fn set_c_front_fog_lh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[11..12].store_le(value);
        Ok(())
    }
    
    /// C_FrontFOGRhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_front_fog_rh_open_sts(&self) -> bool {
        self.c_front_fog_rh_open_sts_raw()
    }
    
    /// Get raw value of C_FrontFOGRhOpenSts
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_front_fog_rh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_FrontFOGRhOpenSts
    #[inline(always)]
    pub fn set_c_front_fog_rh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[12..13].store_le(value);
        Ok(())
    }
    
    /// C_RearEXTTailLhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_rear_ext_tail_lh_open_sts(&self) -> bool {
        self.c_rear_ext_tail_lh_open_sts_raw()
    }
    
    /// Get raw value of C_RearEXTTailLhOpenSts
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_rear_ext_tail_lh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_RearEXTTailLhOpenSts
    #[inline(always)]
    pub fn set_c_rear_ext_tail_lh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[13..14].store_le(value);
        Ok(())
    }
    
    /// C_RearEXTTailRhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_rear_ext_tail_rh_open_sts(&self) -> bool {
        self.c_rear_ext_tail_rh_open_sts_raw()
    }
    
    /// Get raw value of C_RearEXTTailRhOpenSts
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_rear_ext_tail_rh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_RearEXTTailRhOpenSts
    #[inline(always)]
    pub fn set_c_rear_ext_tail_rh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[14..15].store_le(value);
        Ok(())
    }
    
    /// C_FrontEXTTailLhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_front_ext_tail_lh_open_sts(&self) -> bool {
        self.c_front_ext_tail_lh_open_sts_raw()
    }
    
    /// Get raw value of C_FrontEXTTailLhOpenSts
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_front_ext_tail_lh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_FrontEXTTailLhOpenSts
    #[inline(always)]
    pub fn set_c_front_ext_tail_lh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[15..16].store_le(value);
        Ok(())
    }
    
    /// C_FrontEXTTailRhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_front_ext_tail_rh_open_sts(&self) -> bool {
        self.c_front_ext_tail_rh_open_sts_raw()
    }
    
    /// Get raw value of C_FrontEXTTailRhOpenSts
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_front_ext_tail_rh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_FrontEXTTailRhOpenSts
    #[inline(always)]
    pub fn set_c_front_ext_tail_rh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[16..17].store_le(value);
        Ok(())
    }
    
    /// C_RearTSIGLhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_rear_tsig_lh_open_sts(&self) -> bool {
        self.c_rear_tsig_lh_open_sts_raw()
    }
    
    /// Get raw value of C_RearTSIGLhOpenSts
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_rear_tsig_lh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_RearTSIGLhOpenSts
    #[inline(always)]
    pub fn set_c_rear_tsig_lh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[17..18].store_le(value);
        Ok(())
    }
    
    /// C_RearTSIGRhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_rear_tsig_rh_open_sts(&self) -> bool {
        self.c_rear_tsig_rh_open_sts_raw()
    }
    
    /// Get raw value of C_RearTSIGRhOpenSts
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_rear_tsig_rh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_RearTSIGRhOpenSts
    #[inline(always)]
    pub fn set_c_rear_tsig_rh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[18..19].store_le(value);
        Ok(())
    }
    
    /// C_FrontTSIGLhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_front_tsig_lh_open_sts(&self) -> bool {
        self.c_front_tsig_lh_open_sts_raw()
    }
    
    /// Get raw value of C_FrontTSIGLhOpenSts
    ///
    /// - Start bit: 19
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_front_tsig_lh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[19..20].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_FrontTSIGLhOpenSts
    #[inline(always)]
    pub fn set_c_front_tsig_lh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[19..20].store_le(value);
        Ok(())
    }
    
    /// C_FrontTSIGRhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_front_tsig_rh_open_sts(&self) -> bool {
        self.c_front_tsig_rh_open_sts_raw()
    }
    
    /// Get raw value of C_FrontTSIGRhOpenSts
    ///
    /// - Start bit: 20
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_front_tsig_rh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[20..21].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_FrontTSIGRhOpenSts
    #[inline(always)]
    pub fn set_c_front_tsig_rh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[20..21].store_le(value);
        Ok(())
    }
    
    /// C_SBendingLhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_s_bending_lh_open_sts(&self) -> bool {
        self.c_s_bending_lh_open_sts_raw()
    }
    
    /// Get raw value of C_SBendingLhOpenSts
    ///
    /// - Start bit: 21
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_s_bending_lh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[21..22].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_SBendingLhOpenSts
    #[inline(always)]
    pub fn set_c_s_bending_lh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[21..22].store_le(value);
        Ok(())
    }
    
    /// C_SBendingRhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_s_bending_rh_open_sts(&self) -> bool {
        self.c_s_bending_rh_open_sts_raw()
    }
    
    /// Get raw value of C_SBendingRhOpenSts
    ///
    /// - Start bit: 22
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_s_bending_rh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[22..23].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_SBendingRhOpenSts
    #[inline(always)]
    pub fn set_c_s_bending_rh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[22..23].store_le(value);
        Ok(())
    }
    
    /// C_LicensePlateLhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_license_plate_lh_open_sts(&self) -> bool {
        self.c_license_plate_lh_open_sts_raw()
    }
    
    /// Get raw value of C_LicensePlateLhOpenSts
    ///
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_license_plate_lh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[23..24].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_LicensePlateLhOpenSts
    #[inline(always)]
    pub fn set_c_license_plate_lh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[23..24].store_le(value);
        Ok(())
    }
    
    /// C_LicensePlateRhOpenSts
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_license_plate_rh_open_sts(&self) -> bool {
        self.c_license_plate_rh_open_sts_raw()
    }
    
    /// Get raw value of C_LicensePlateRhOpenSts
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_license_plate_rh_open_sts_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_LicensePlateRhOpenSts
    #[inline(always)]
    pub fn set_c_license_plate_rh_open_sts(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[24..25].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Cgw5 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Cgw5 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Cgw5")
                .field("c_stop_lamp_lh_open_sts", &self.c_stop_lamp_lh_open_sts())
                .field("c_stop_lamp_rh_open_sts", &self.c_stop_lamp_rh_open_sts())
                .field("c_hmsl_open_sts", &self.c_hmsl_open_sts())
                .field("c_h_lamp_low_lh_open_sts", &self.c_h_lamp_low_lh_open_sts())
                .field("c_h_lamp_low_rh_open_sts", &self.c_h_lamp_low_rh_open_sts())
                .field("c_h_lamp_high_lh_open_sts", &self.c_h_lamp_high_lh_open_sts())
                .field("c_h_lamp_high_rh_open_sts", &self.c_h_lamp_high_rh_open_sts())
                .field("c_drl_lamp_lh_open_sts", &self.c_drl_lamp_lh_open_sts())
                .field("c_drl_lamp_rh_open_sts", &self.c_drl_lamp_rh_open_sts())
                .field("c_rear_fog_lh_open_sts", &self.c_rear_fog_lh_open_sts())
                .field("c_rear_fog_rh_open_sts", &self.c_rear_fog_rh_open_sts())
                .field("c_front_fog_lh_open_sts", &self.c_front_fog_lh_open_sts())
                .field("c_front_fog_rh_open_sts", &self.c_front_fog_rh_open_sts())
                .field("c_rear_ext_tail_lh_open_sts", &self.c_rear_ext_tail_lh_open_sts())
                .field("c_rear_ext_tail_rh_open_sts", &self.c_rear_ext_tail_rh_open_sts())
                .field("c_front_ext_tail_lh_open_sts", &self.c_front_ext_tail_lh_open_sts())
                .field("c_front_ext_tail_rh_open_sts", &self.c_front_ext_tail_rh_open_sts())
                .field("c_rear_tsig_lh_open_sts", &self.c_rear_tsig_lh_open_sts())
                .field("c_rear_tsig_rh_open_sts", &self.c_rear_tsig_rh_open_sts())
                .field("c_front_tsig_lh_open_sts", &self.c_front_tsig_lh_open_sts())
                .field("c_front_tsig_rh_open_sts", &self.c_front_tsig_rh_open_sts())
                .field("c_s_bending_lh_open_sts", &self.c_s_bending_lh_open_sts())
                .field("c_s_bending_rh_open_sts", &self.c_s_bending_rh_open_sts())
                .field("c_license_plate_lh_open_sts", &self.c_license_plate_lh_open_sts())
                .field("c_license_plate_rh_open_sts", &self.c_license_plate_rh_open_sts())
            .finish()
        } else {
            f.debug_tuple("Cgw5").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Cgw5 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let c_stop_lamp_lh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_stop_lamp_rh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_hmsl_open_sts = u.int_in_range(0..=1)? == 1;
        let c_h_lamp_low_lh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_h_lamp_low_rh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_h_lamp_high_lh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_h_lamp_high_rh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_drl_lamp_lh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_drl_lamp_rh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_rear_fog_lh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_rear_fog_rh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_front_fog_lh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_front_fog_rh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_rear_ext_tail_lh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_rear_ext_tail_rh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_front_ext_tail_lh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_front_ext_tail_rh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_rear_tsig_lh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_rear_tsig_rh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_front_tsig_lh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_front_tsig_rh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_s_bending_lh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_s_bending_rh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_license_plate_lh_open_sts = u.int_in_range(0..=1)? == 1;
        let c_license_plate_rh_open_sts = u.int_in_range(0..=1)? == 1;
        Cgw5::new(c_stop_lamp_lh_open_sts,c_stop_lamp_rh_open_sts,c_hmsl_open_sts,c_h_lamp_low_lh_open_sts,c_h_lamp_low_rh_open_sts,c_h_lamp_high_lh_open_sts,c_h_lamp_high_rh_open_sts,c_drl_lamp_lh_open_sts,c_drl_lamp_rh_open_sts,c_rear_fog_lh_open_sts,c_rear_fog_rh_open_sts,c_front_fog_lh_open_sts,c_front_fog_rh_open_sts,c_rear_ext_tail_lh_open_sts,c_rear_ext_tail_rh_open_sts,c_front_ext_tail_lh_open_sts,c_front_ext_tail_rh_open_sts,c_rear_tsig_lh_open_sts,c_rear_tsig_rh_open_sts,c_front_tsig_lh_open_sts,c_front_tsig_rh_open_sts,c_s_bending_lh_open_sts,c_s_bending_rh_open_sts,c_license_plate_lh_open_sts,c_license_plate_rh_open_sts).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ESP11
///
/// - ID: 1151 (0x47f)
/// - Size: 6 bytes
/// - Transmitter: ESC
#[derive(Clone, Copy)]
pub struct Esp11 {
    raw: [u8; 6],
}

impl Esp11 {
    pub const MESSAGE_ID: u32 = 1151;
    
    pub const AVH_STAT_MIN: u8 = 0_u8;
    pub const AVH_STAT_MAX: u8 = 3_u8;
    pub const REQ_EPB_ACT_MIN: u8 = 0_u8;
    pub const REQ_EPB_ACT_MAX: u8 = 3_u8;
    pub const ROL_CNT_ESP_MIN: u8 = 0_u8;
    pub const ROL_CNT_ESP_MAX: u8 = 255_u8;
    pub const X4WD_TQC_LIM_MIN: u16 = 0_u16;
    pub const X4WD_TQC_LIM_MAX: u16 = 65535_u16;
    pub const X4WD_CLU_LIM_MIN: f32 = 0_f32;
    pub const X4WD_CLU_LIM_MAX: f32 = 99.609375_f32;
    pub const X4WD_OPEN_MIN: u8 = 0_u8;
    pub const X4WD_OPEN_MAX: u8 = 3_u8;
    
    /// Construct new ESP11 from values
    pub fn new(avh_stat: u8, ldm_stat: bool, req_epb_act: u8, req_epb_stat: bool, ecd_act: bool, x4wd_lim_req: bool, rol_cnt_esp: u8, x4wd_tqc_lim: u16, x4wd_clu_lim: f32, x4wd_open: u8, x4wd_lim_mode: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 6] };
        res.set_avh_stat(avh_stat)?;
        res.set_ldm_stat(ldm_stat)?;
        res.set_req_epb_act(req_epb_act)?;
        res.set_req_epb_stat(req_epb_stat)?;
        res.set_ecd_act(ecd_act)?;
        res.set_x4wd_lim_req(x4wd_lim_req)?;
        res.set_rol_cnt_esp(rol_cnt_esp)?;
        res.set_x4wd_tqc_lim(x4wd_tqc_lim)?;
        res.set_x4wd_clu_lim(x4wd_clu_lim)?;
        res.set_x4wd_open(x4wd_open)?;
        res.set_x4wd_lim_mode(x4wd_lim_mode)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 6] {
        &self.raw
    }
    
    /// AVH_STAT
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, EPB, TCU
    #[inline(always)]
    pub fn avh_stat(&self) -> u8 {
        self.avh_stat_raw()
    }
    
    /// Get raw value of AVH_STAT
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avh_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVH_STAT
    #[inline(always)]
    pub fn set_avh_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1151 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// LDM_STAT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EPB, TCU
    #[inline(always)]
    pub fn ldm_stat(&self) -> bool {
        self.ldm_stat_raw()
    }
    
    /// Get raw value of LDM_STAT
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ldm_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LDM_STAT
    #[inline(always)]
    pub fn set_ldm_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// REQ_EPB_ACT
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EPB, TCU
    #[inline(always)]
    pub fn req_epb_act(&self) -> u8 {
        self.req_epb_act_raw()
    }
    
    /// Get raw value of REQ_EPB_ACT
    ///
    /// - Start bit: 3
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn req_epb_act_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[3..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of REQ_EPB_ACT
    #[inline(always)]
    pub fn set_req_epb_act(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1151 });
        }
        self.raw.view_bits_mut::<Lsb0>()[3..5].store_le(value);
        Ok(())
    }
    
    /// REQ_EPB_STAT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EPB
    #[inline(always)]
    pub fn req_epb_stat(&self) -> bool {
        self.req_epb_stat_raw()
    }
    
    /// Get raw value of REQ_EPB_STAT
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn req_epb_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of REQ_EPB_STAT
    #[inline(always)]
    pub fn set_req_epb_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// ECD_ACT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EPB
    #[inline(always)]
    pub fn ecd_act(&self) -> bool {
        self.ecd_act_raw()
    }
    
    /// Get raw value of ECD_ACT
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ecd_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ECD_ACT
    #[inline(always)]
    pub fn set_ecd_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[6..7].store_le(value);
        Ok(())
    }
    
    /// _4WD_LIM_REQ
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, EMS
    #[inline(always)]
    pub fn x4wd_lim_req(&self) -> bool {
        self.x4wd_lim_req_raw()
    }
    
    /// Get raw value of _4WD_LIM_REQ
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4wd_lim_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of _4WD_LIM_REQ
    #[inline(always)]
    pub fn set_x4wd_lim_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// ROL_CNT_ESP
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EPB, TCU
    #[inline(always)]
    pub fn rol_cnt_esp(&self) -> u8 {
        self.rol_cnt_esp_raw()
    }
    
    /// Get raw value of ROL_CNT_ESP
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rol_cnt_esp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ROL_CNT_ESP
    #[inline(always)]
    pub fn set_rol_cnt_esp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1151 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// _4WD_TQC_LIM
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: "Nm"
    /// - Receivers: _4WD, EMS
    #[inline(always)]
    pub fn x4wd_tqc_lim(&self) -> u16 {
        self.x4wd_tqc_lim_raw()
    }
    
    /// Get raw value of _4WD_TQC_LIM
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4wd_tqc_lim_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<u16>();
        
        signal
    }
    
    /// Set value of _4WD_TQC_LIM
    #[inline(always)]
    pub fn set_x4wd_tqc_lim(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1151 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// _4WD_CLU_LIM
    ///
    /// - Min: 0
    /// - Max: 99.609375
    /// - Unit: "%"
    /// - Receivers: _4WD, EMS
    #[inline(always)]
    pub fn x4wd_clu_lim(&self) -> f32 {
        self.x4wd_clu_lim_raw()
    }
    
    /// Get raw value of _4WD_CLU_LIM
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4wd_clu_lim_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of _4WD_CLU_LIM
    #[inline(always)]
    pub fn set_x4wd_clu_lim(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.609375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1151 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// _4WD_OPEN
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: _4WD, EMS
    #[inline(always)]
    pub fn x4wd_open(&self) -> u8 {
        self.x4wd_open_raw()
    }
    
    /// Get raw value of _4WD_OPEN
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4wd_open_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of _4WD_OPEN
    #[inline(always)]
    pub fn set_x4wd_open(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1151 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..42].store_le(value);
        Ok(())
    }
    
    /// _4WD_LIM_MODE
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD
    #[inline(always)]
    pub fn x4wd_lim_mode(&self) -> bool {
        self.x4wd_lim_mode_raw()
    }
    
    /// Get raw value of _4WD_LIM_MODE
    ///
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4wd_lim_mode_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[42..43].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of _4WD_LIM_MODE
    #[inline(always)]
    pub fn set_x4wd_lim_mode(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[42..43].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Esp11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 6 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 6];
        raw.copy_from_slice(&payload[..6]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Esp11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Esp11")
                .field("avh_stat", &self.avh_stat())
                .field("ldm_stat", &self.ldm_stat())
                .field("req_epb_act", &self.req_epb_act())
                .field("req_epb_stat", &self.req_epb_stat())
                .field("ecd_act", &self.ecd_act())
                .field("x4wd_lim_req", &self.x4wd_lim_req())
                .field("rol_cnt_esp", &self.rol_cnt_esp())
                .field("x4wd_tqc_lim", &self.x4wd_tqc_lim())
                .field("x4wd_clu_lim", &self.x4wd_clu_lim())
                .field("x4wd_open", &self.x4wd_open())
                .field("x4wd_lim_mode", &self.x4wd_lim_mode())
            .finish()
        } else {
            f.debug_tuple("Esp11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Esp11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let avh_stat = u.int_in_range(0..=3)?;
        let ldm_stat = u.int_in_range(0..=1)? == 1;
        let req_epb_act = u.int_in_range(0..=3)?;
        let req_epb_stat = u.int_in_range(0..=1)? == 1;
        let ecd_act = u.int_in_range(0..=1)? == 1;
        let x4wd_lim_req = u.int_in_range(0..=1)? == 1;
        let rol_cnt_esp = u.int_in_range(0..=255)?;
        let x4wd_tqc_lim = u.int_in_range(0..=65535)?;
        let x4wd_clu_lim = u.float_in_range(0_f32..=99.609375_f32)?;
        let x4wd_open = u.int_in_range(0..=3)?;
        let x4wd_lim_mode = u.int_in_range(0..=1)? == 1;
        Esp11::new(avh_stat,ldm_stat,req_epb_act,req_epb_stat,ecd_act,x4wd_lim_req,rol_cnt_esp,x4wd_tqc_lim,x4wd_clu_lim,x4wd_open,x4wd_lim_mode).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// HU_AVM_E_00
///
/// - ID: 1397 (0x575)
/// - Size: 8 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct HuAvmE00 {
    raw: [u8; 8],
}

impl HuAvmE00 {
    pub const MESSAGE_ID: u32 = 1397;
    
    pub const HU_AVM_CAL_CMD_MIN: u8 = 0_u8;
    pub const HU_AVM_CAL_CMD_MAX: u8 = 15_u8;
    pub const HU_AVM_CAL_METHOD_MIN: u8 = 0_u8;
    pub const HU_AVM_CAL_METHOD_MAX: u8 = 3_u8;
    pub const HU_AVM_SAVE_CONTROLPOINT_MIN: u8 = 0_u8;
    pub const HU_AVM_SAVE_CONTROLPOINT_MAX: u8 = 3_u8;
    pub const HU_AVM_PT_X_MIN: u16 = 0_u16;
    pub const HU_AVM_PT_X_MAX: u16 = 15_u16;
    pub const HU_AVM_REAR_VIEW_POINT_OPT_MIN: u8 = 0_u8;
    pub const HU_AVM_REAR_VIEW_POINT_OPT_MAX: u8 = 15_u8;
    pub const HU_AVM_PT_Y_MIN: u16 = 0_u16;
    pub const HU_AVM_PT_Y_MAX: u16 = 4095_u16;
    pub const HU_AVM_FRONT_VIEW_POINT_OPT_MIN: u8 = 0_u8;
    pub const HU_AVM_FRONT_VIEW_POINT_OPT_MAX: u8 = 15_u8;
    pub const HU_AVM_SELECTED_MENU_MIN: u8 = 0_u8;
    pub const HU_AVM_SELECTED_MENU_MAX: u8 = 31_u8;
    pub const HU_AVM_CAMERA_OFF_MIN: u8 = 0_u8;
    pub const HU_AVM_CAMERA_OFF_MAX: u8 = 3_u8;
    pub const HU_AVM_OPTION_MIN: u8 = 0_u8;
    pub const HU_AVM_OPTION_MAX: u8 = 15_u8;
    pub const HU_AVM_CROSS_LINE_MOVE_CMD_MIN: u8 = 0_u8;
    pub const HU_AVM_CROSS_LINE_MOVE_CMD_MAX: u8 = 15_u8;
    pub const HU_AVM_REAR_VIEW_OPTION_MIN: u8 = 0_u8;
    pub const HU_AVM_REAR_VIEW_OPTION_MAX: u8 = 15_u8;
    pub const HU_AVM_FRONT_VIEW_OPTION_MIN: u8 = 0_u8;
    pub const HU_AVM_FRONT_VIEW_OPTION_MAX: u8 = 15_u8;
    
    /// Construct new HU_AVM_E_00 from values
    pub fn new(hu_avm_cal_cmd: u8, hu_avm_cal_method: u8, hu_avm_save_controlpoint: u8, hu_avm_pt_x: u16, hu_avm_rear_view_point_opt: u8, hu_avm_pt_y: u16, hu_avm_front_view_point_opt: u8, hu_avm_selected_menu: u8, hu_avm_camera_off: u8, hu_avm_option: u8, hu_avm_cross_line_move_cmd: u8, hu_avm_rear_view_option: u8, hu_avm_front_view_option: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_hu_avm_cal_cmd(hu_avm_cal_cmd)?;
        res.set_hu_avm_cal_method(hu_avm_cal_method)?;
        res.set_hu_avm_save_controlpoint(hu_avm_save_controlpoint)?;
        res.set_hu_avm_pt_x(hu_avm_pt_x)?;
        res.set_hu_avm_rear_view_point_opt(hu_avm_rear_view_point_opt)?;
        res.set_hu_avm_pt_y(hu_avm_pt_y)?;
        res.set_hu_avm_front_view_point_opt(hu_avm_front_view_point_opt)?;
        res.set_hu_avm_selected_menu(hu_avm_selected_menu)?;
        res.set_hu_avm_camera_off(hu_avm_camera_off)?;
        res.set_hu_avm_option(hu_avm_option)?;
        res.set_hu_avm_cross_line_move_cmd(hu_avm_cross_line_move_cmd)?;
        res.set_hu_avm_rear_view_option(hu_avm_rear_view_option)?;
        res.set_hu_avm_front_view_option(hu_avm_front_view_option)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// HU_AVM_Cal_Cmd
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_cal_cmd(&self) -> u8 {
        self.hu_avm_cal_cmd_raw()
    }
    
    /// Get raw value of HU_AVM_Cal_Cmd
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_cal_cmd_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_AVM_Cal_Cmd
    #[inline(always)]
    pub fn set_hu_avm_cal_cmd(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1397 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..4].store_le(value);
        Ok(())
    }
    
    /// HU_AVM_Cal_Method
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_cal_method(&self) -> u8 {
        self.hu_avm_cal_method_raw()
    }
    
    /// Get raw value of HU_AVM_Cal_Method
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_cal_method_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_AVM_Cal_Method
    #[inline(always)]
    pub fn set_hu_avm_cal_method(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1397 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
    /// HU_AVM_Save_Controlpoint
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_save_controlpoint(&self) -> u8 {
        self.hu_avm_save_controlpoint_raw()
    }
    
    /// Get raw value of HU_AVM_Save_Controlpoint
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_save_controlpoint_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_AVM_Save_Controlpoint
    #[inline(always)]
    pub fn set_hu_avm_save_controlpoint(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1397 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// HU_AVM_PT_X
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_pt_x(&self) -> u16 {
        self.hu_avm_pt_x_raw()
    }
    
    /// Get raw value of HU_AVM_PT_X
    ///
    /// - Start bit: 8
    /// - Signal size: 12 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_pt_x_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[8..20].load_le::<u16>();
        
        signal
    }
    
    /// Set value of HU_AVM_PT_X
    #[inline(always)]
    pub fn set_hu_avm_pt_x(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 15_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1397 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..20].store_le(value);
        Ok(())
    }
    
    /// HU_AVM_RearViewPointOpt
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_rear_view_point_opt(&self) -> u8 {
        self.hu_avm_rear_view_point_opt_raw()
    }
    
    /// Get raw value of HU_AVM_RearViewPointOpt
    ///
    /// - Start bit: 20
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_rear_view_point_opt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_AVM_RearViewPointOpt
    #[inline(always)]
    pub fn set_hu_avm_rear_view_point_opt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1397 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..24].store_le(value);
        Ok(())
    }
    
    /// HU_AVM_PT_Y
    ///
    /// - Min: 0
    /// - Max: 4095
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_pt_y(&self) -> u16 {
        self.hu_avm_pt_y_raw()
    }
    
    /// Get raw value of HU_AVM_PT_Y
    ///
    /// - Start bit: 24
    /// - Signal size: 12 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_pt_y_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[24..36].load_le::<u16>();
        
        signal
    }
    
    /// Set value of HU_AVM_PT_Y
    #[inline(always)]
    pub fn set_hu_avm_pt_y(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 4095_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1397 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..36].store_le(value);
        Ok(())
    }
    
    /// HU_AVM_FrontViewPointOpt
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_front_view_point_opt(&self) -> u8 {
        self.hu_avm_front_view_point_opt_raw()
    }
    
    /// Get raw value of HU_AVM_FrontViewPointOpt
    ///
    /// - Start bit: 36
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_front_view_point_opt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[36..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_AVM_FrontViewPointOpt
    #[inline(always)]
    pub fn set_hu_avm_front_view_point_opt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1397 });
        }
        self.raw.view_bits_mut::<Lsb0>()[36..40].store_le(value);
        Ok(())
    }
    
    /// HU_AVM_SelectedMenu
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_selected_menu(&self) -> u8 {
        self.hu_avm_selected_menu_raw()
    }
    
    /// Get raw value of HU_AVM_SelectedMenu
    ///
    /// - Start bit: 40
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_selected_menu_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..45].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_AVM_SelectedMenu
    #[inline(always)]
    pub fn set_hu_avm_selected_menu(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 31_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1397 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..45].store_le(value);
        Ok(())
    }
    
    /// HU_AVM_CameraOff
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_camera_off(&self) -> u8 {
        self.hu_avm_camera_off_raw()
    }
    
    /// Get raw value of HU_AVM_CameraOff
    ///
    /// - Start bit: 45
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_camera_off_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[45..47].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_AVM_CameraOff
    #[inline(always)]
    pub fn set_hu_avm_camera_off(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1397 });
        }
        self.raw.view_bits_mut::<Lsb0>()[45..47].store_le(value);
        Ok(())
    }
    
    /// HU_AVM_Option
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_option(&self) -> u8 {
        self.hu_avm_option_raw()
    }
    
    /// Get raw value of HU_AVM_Option
    ///
    /// - Start bit: 48
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_option_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_AVM_Option
    #[inline(always)]
    pub fn set_hu_avm_option(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1397 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..52].store_le(value);
        Ok(())
    }
    
    /// HU_AVM_CrossLineMove_Cmd
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_cross_line_move_cmd(&self) -> u8 {
        self.hu_avm_cross_line_move_cmd_raw()
    }
    
    /// Get raw value of HU_AVM_CrossLineMove_Cmd
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_cross_line_move_cmd_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_AVM_CrossLineMove_Cmd
    #[inline(always)]
    pub fn set_hu_avm_cross_line_move_cmd(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1397 });
        }
        self.raw.view_bits_mut::<Lsb0>()[52..56].store_le(value);
        Ok(())
    }
    
    /// HU_AVM_RearView_Option
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_rear_view_option(&self) -> u8 {
        self.hu_avm_rear_view_option_raw()
    }
    
    /// Get raw value of HU_AVM_RearView_Option
    ///
    /// - Start bit: 56
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_rear_view_option_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_AVM_RearView_Option
    #[inline(always)]
    pub fn set_hu_avm_rear_view_option(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1397 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..60].store_le(value);
        Ok(())
    }
    
    /// HU_AVM_FrontView_Option
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_front_view_option(&self) -> u8 {
        self.hu_avm_front_view_option_raw()
    }
    
    /// Get raw value of HU_AVM_FrontView_Option
    ///
    /// - Start bit: 60
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_front_view_option_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_AVM_FrontView_Option
    #[inline(always)]
    pub fn set_hu_avm_front_view_option(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1397 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for HuAvmE00 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for HuAvmE00 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("HuAvmE00")
                .field("hu_avm_cal_cmd", &self.hu_avm_cal_cmd())
                .field("hu_avm_cal_method", &self.hu_avm_cal_method())
                .field("hu_avm_save_controlpoint", &self.hu_avm_save_controlpoint())
                .field("hu_avm_pt_x", &self.hu_avm_pt_x())
                .field("hu_avm_rear_view_point_opt", &self.hu_avm_rear_view_point_opt())
                .field("hu_avm_pt_y", &self.hu_avm_pt_y())
                .field("hu_avm_front_view_point_opt", &self.hu_avm_front_view_point_opt())
                .field("hu_avm_selected_menu", &self.hu_avm_selected_menu())
                .field("hu_avm_camera_off", &self.hu_avm_camera_off())
                .field("hu_avm_option", &self.hu_avm_option())
                .field("hu_avm_cross_line_move_cmd", &self.hu_avm_cross_line_move_cmd())
                .field("hu_avm_rear_view_option", &self.hu_avm_rear_view_option())
                .field("hu_avm_front_view_option", &self.hu_avm_front_view_option())
            .finish()
        } else {
            f.debug_tuple("HuAvmE00").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for HuAvmE00 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let hu_avm_cal_cmd = u.int_in_range(0..=15)?;
        let hu_avm_cal_method = u.int_in_range(0..=3)?;
        let hu_avm_save_controlpoint = u.int_in_range(0..=3)?;
        let hu_avm_pt_x = u.int_in_range(0..=15)?;
        let hu_avm_rear_view_point_opt = u.int_in_range(0..=15)?;
        let hu_avm_pt_y = u.int_in_range(0..=4095)?;
        let hu_avm_front_view_point_opt = u.int_in_range(0..=15)?;
        let hu_avm_selected_menu = u.int_in_range(0..=31)?;
        let hu_avm_camera_off = u.int_in_range(0..=3)?;
        let hu_avm_option = u.int_in_range(0..=15)?;
        let hu_avm_cross_line_move_cmd = u.int_in_range(0..=15)?;
        let hu_avm_rear_view_option = u.int_in_range(0..=15)?;
        let hu_avm_front_view_option = u.int_in_range(0..=15)?;
        HuAvmE00::new(hu_avm_cal_cmd,hu_avm_cal_method,hu_avm_save_controlpoint,hu_avm_pt_x,hu_avm_rear_view_point_opt,hu_avm_pt_y,hu_avm_front_view_point_opt,hu_avm_selected_menu,hu_avm_camera_off,hu_avm_option,hu_avm_cross_line_move_cmd,hu_avm_rear_view_option,hu_avm_front_view_option).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// HU_AVM_E_01
///
/// - ID: 1395 (0x573)
/// - Size: 8 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct HuAvmE01 {
    raw: [u8; 8],
}

impl HuAvmE01 {
    pub const MESSAGE_ID: u32 = 1395;
    
    pub const HU_PGS_SELECTED_MENU_MIN: u8 = 0_u8;
    pub const HU_PGS_SELECTED_MENU_MAX: u8 = 15_u8;
    pub const HU_PGS_OPTION_MIN: u8 = 0_u8;
    pub const HU_PGS_OPTION_MAX: u8 = 31_u8;
    pub const HU_AVM_PARKING_ASSIST_MENU_MIN: u8 = 0_u8;
    pub const HU_AVM_PARKING_ASSIST_MENU_MAX: u8 = 15_u8;
    pub const HU_AVM_PARKING_ASSIST_SB_MIN: u8 = 0_u8;
    pub const HU_AVM_PARKING_ASSIST_SB_MAX: u8 = 15_u8;
    
    /// Construct new HU_AVM_E_01 from values
    pub fn new(hu_pgs_selected_menu: u8, hu_pgs_option: u8, hu_avm_parking_assist_menu: u8, hu_avm_parking_assist_sb: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_hu_pgs_selected_menu(hu_pgs_selected_menu)?;
        res.set_hu_pgs_option(hu_pgs_option)?;
        res.set_hu_avm_parking_assist_menu(hu_avm_parking_assist_menu)?;
        res.set_hu_avm_parking_assist_sb(hu_avm_parking_assist_sb)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// HU_PGSSelectedMenu
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_pgs_selected_menu(&self) -> u8 {
        self.hu_pgs_selected_menu_raw()
    }
    
    /// Get raw value of HU_PGSSelectedMenu
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_pgs_selected_menu_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_PGSSelectedMenu
    #[inline(always)]
    pub fn set_hu_pgs_selected_menu(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1395 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..4].store_le(value);
        Ok(())
    }
    
    /// HU_PGSOption
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_pgs_option(&self) -> u8 {
        self.hu_pgs_option_raw()
    }
    
    /// Get raw value of HU_PGSOption
    ///
    /// - Start bit: 8
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_pgs_option_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_PGSOption
    #[inline(always)]
    pub fn set_hu_pgs_option(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 31_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1395 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..13].store_le(value);
        Ok(())
    }
    
    /// HU_AVM_ParkingAssistMenu
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_parking_assist_menu(&self) -> u8 {
        self.hu_avm_parking_assist_menu_raw()
    }
    
    /// Get raw value of HU_AVM_ParkingAssistMenu
    ///
    /// - Start bit: 56
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_parking_assist_menu_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_AVM_ParkingAssistMenu
    #[inline(always)]
    pub fn set_hu_avm_parking_assist_menu(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1395 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..60].store_le(value);
        Ok(())
    }
    
    /// HU_AVM_ParkingAssistSB
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_parking_assist_sb(&self) -> u8 {
        self.hu_avm_parking_assist_sb_raw()
    }
    
    /// Get raw value of HU_AVM_ParkingAssistSB
    ///
    /// - Start bit: 60
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_parking_assist_sb_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_AVM_ParkingAssistSB
    #[inline(always)]
    pub fn set_hu_avm_parking_assist_sb(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1395 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for HuAvmE01 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for HuAvmE01 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("HuAvmE01")
                .field("hu_pgs_selected_menu", &self.hu_pgs_selected_menu())
                .field("hu_pgs_option", &self.hu_pgs_option())
                .field("hu_avm_parking_assist_menu", &self.hu_avm_parking_assist_menu())
                .field("hu_avm_parking_assist_sb", &self.hu_avm_parking_assist_sb())
            .finish()
        } else {
            f.debug_tuple("HuAvmE01").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for HuAvmE01 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let hu_pgs_selected_menu = u.int_in_range(0..=15)?;
        let hu_pgs_option = u.int_in_range(0..=31)?;
        let hu_avm_parking_assist_menu = u.int_in_range(0..=15)?;
        let hu_avm_parking_assist_sb = u.int_in_range(0..=15)?;
        HuAvmE01::new(hu_pgs_selected_menu,hu_pgs_option,hu_avm_parking_assist_menu,hu_avm_parking_assist_sb).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// OPI11
///
/// - ID: 1393 (0x571)
/// - Size: 5 bytes
/// - Transmitter: OPI
#[derive(Clone, Copy)]
pub struct Opi11 {
    raw: [u8; 5],
}

impl Opi11 {
    pub const MESSAGE_ID: u32 = 1393;
    
    pub const CR_OPI_SPD_RPM_MIN: f32 = 0_f32;
    pub const CR_OPI_SPD_RPM_MAX: f32 = 3500_f32;
    pub const CF_OPI_ROMVER_MIN: u8 = 0_u8;
    pub const CF_OPI_ROMVER_MAX: u8 = 255_u8;
    pub const CF_OPI_PWM_RATE_MIN: u16 = 0_u16;
    pub const CF_OPI_PWM_RATE_MAX: u16 = 100_u16;
    
    /// Construct new OPI11 from values
    pub fn new(cr_opi_spd_rpm: f32, cf_opi_over_temp: bool, cf_opi_over_cur: bool, cf_opi_over_vol: bool, cf_opi_hall_fail: bool, cf_opi_flt: bool, cf_opi_motor_dir: bool, cf_opi_romver: u8, cf_opi_pwm_rate: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 5] };
        res.set_cr_opi_spd_rpm(cr_opi_spd_rpm)?;
        res.set_cf_opi_over_temp(cf_opi_over_temp)?;
        res.set_cf_opi_over_cur(cf_opi_over_cur)?;
        res.set_cf_opi_over_vol(cf_opi_over_vol)?;
        res.set_cf_opi_hall_fail(cf_opi_hall_fail)?;
        res.set_cf_opi_flt(cf_opi_flt)?;
        res.set_cf_opi_motor_dir(cf_opi_motor_dir)?;
        res.set_cf_opi_romver(cf_opi_romver)?;
        res.set_cf_opi_pwm_rate(cf_opi_pwm_rate)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 5] {
        &self.raw
    }
    
    /// CR_Opi_Spd_Rpm
    ///
    /// - Min: 0
    /// - Max: 3500
    /// - Unit: "rpm"
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cr_opi_spd_rpm(&self) -> f32 {
        self.cr_opi_spd_rpm_raw()
    }
    
    /// Get raw value of CR_Opi_Spd_Rpm
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 20
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_opi_spd_rpm_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 20_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Opi_Spd_Rpm
    #[inline(always)]
    pub fn set_cr_opi_spd_rpm(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 3500_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1393 });
        }
        let factor = 20_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CF_Opi_Over_Temp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_opi_over_temp(&self) -> bool {
        self.cf_opi_over_temp_raw()
    }
    
    /// Get raw value of CF_Opi_Over_Temp
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_opi_over_temp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Opi_Over_Temp
    #[inline(always)]
    pub fn set_cf_opi_over_temp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[8..9].store_le(value);
        Ok(())
    }
    
    /// CF_Opi_Over_Cur
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, TCU
    #[inline(always)]
    pub fn cf_opi_over_cur(&self) -> bool {
        self.cf_opi_over_cur_raw()
    }
    
    /// Get raw value of CF_Opi_Over_Cur
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_opi_over_cur_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Opi_Over_Cur
    #[inline(always)]
    pub fn set_cf_opi_over_cur(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[9..10].store_le(value);
        Ok(())
    }
    
    /// CF_Opi_Over_Vol
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_opi_over_vol(&self) -> bool {
        self.cf_opi_over_vol_raw()
    }
    
    /// Get raw value of CF_Opi_Over_Vol
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_opi_over_vol_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Opi_Over_Vol
    #[inline(always)]
    pub fn set_cf_opi_over_vol(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[10..11].store_le(value);
        Ok(())
    }
    
    /// CF_Opi_Hall_Fail
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, TCU
    #[inline(always)]
    pub fn cf_opi_hall_fail(&self) -> bool {
        self.cf_opi_hall_fail_raw()
    }
    
    /// Get raw value of CF_Opi_Hall_Fail
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_opi_hall_fail_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Opi_Hall_Fail
    #[inline(always)]
    pub fn set_cf_opi_hall_fail(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[11..12].store_le(value);
        Ok(())
    }
    
    /// CF_Opi_Flt
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, TCU
    #[inline(always)]
    pub fn cf_opi_flt(&self) -> bool {
        self.cf_opi_flt_raw()
    }
    
    /// Get raw value of CF_Opi_Flt
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_opi_flt_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Opi_Flt
    #[inline(always)]
    pub fn set_cf_opi_flt(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[12..13].store_le(value);
        Ok(())
    }
    
    /// CF_Opi_Motor_Dir
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_opi_motor_dir(&self) -> bool {
        self.cf_opi_motor_dir_raw()
    }
    
    /// Get raw value of CF_Opi_Motor_Dir
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_opi_motor_dir_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Opi_Motor_Dir
    #[inline(always)]
    pub fn set_cf_opi_motor_dir(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[15..16].store_le(value);
        Ok(())
    }
    
    /// CF_Opi_Romver
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_opi_romver(&self) -> u8 {
        self.cf_opi_romver_raw()
    }
    
    /// Get raw value of CF_Opi_Romver
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_opi_romver_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Opi_Romver
    #[inline(always)]
    pub fn set_cf_opi_romver(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1393 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// CF_Opi_PWM_Rate
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_opi_pwm_rate(&self) -> u16 {
        self.cf_opi_pwm_rate_raw()
    }
    
    /// Get raw value of CF_Opi_PWM_Rate
    ///
    /// - Start bit: 24
    /// - Signal size: 12 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_opi_pwm_rate_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[24..36].load_le::<u16>();
        
        signal
    }
    
    /// Set value of CF_Opi_PWM_Rate
    #[inline(always)]
    pub fn set_cf_opi_pwm_rate(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 100_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1393 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..36].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Opi11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 5 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 5];
        raw.copy_from_slice(&payload[..5]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Opi11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Opi11")
                .field("cr_opi_spd_rpm", &self.cr_opi_spd_rpm())
                .field("cf_opi_over_temp", &self.cf_opi_over_temp())
                .field("cf_opi_over_cur", &self.cf_opi_over_cur())
                .field("cf_opi_over_vol", &self.cf_opi_over_vol())
                .field("cf_opi_hall_fail", &self.cf_opi_hall_fail())
                .field("cf_opi_flt", &self.cf_opi_flt())
                .field("cf_opi_motor_dir", &self.cf_opi_motor_dir())
                .field("cf_opi_romver", &self.cf_opi_romver())
                .field("cf_opi_pwm_rate", &self.cf_opi_pwm_rate())
            .finish()
        } else {
            f.debug_tuple("Opi11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Opi11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cr_opi_spd_rpm = u.float_in_range(0_f32..=3500_f32)?;
        let cf_opi_over_temp = u.int_in_range(0..=1)? == 1;
        let cf_opi_over_cur = u.int_in_range(0..=1)? == 1;
        let cf_opi_over_vol = u.int_in_range(0..=1)? == 1;
        let cf_opi_hall_fail = u.int_in_range(0..=1)? == 1;
        let cf_opi_flt = u.int_in_range(0..=1)? == 1;
        let cf_opi_motor_dir = u.int_in_range(0..=1)? == 1;
        let cf_opi_romver = u.int_in_range(0..=255)?;
        let cf_opi_pwm_rate = u.int_in_range(0..=100)?;
        Opi11::new(cr_opi_spd_rpm,cf_opi_over_temp,cf_opi_over_cur,cf_opi_over_vol,cf_opi_hall_fail,cf_opi_flt,cf_opi_motor_dir,cf_opi_romver,cf_opi_pwm_rate).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// LPI11
///
/// - ID: 625 (0x271)
/// - Size: 8 bytes
/// - Transmitter: LPI
#[derive(Clone, Copy)]
pub struct Lpi11 {
    raw: [u8; 8],
}

impl Lpi11 {
    pub const MESSAGE_ID: u32 = 625;
    
    pub const FUP_LPG_MMV_MIN: f32 = 0_f32;
    pub const FUP_LPG_MMV_MAX: f32 = 32640_f32;
    pub const LPI_OBD_MIN: u8 = 0_u8;
    pub const LPI_OBD_MAX: u8 = 15_u8;
    pub const ERR_GAS_MIN: u8 = 0_u8;
    pub const ERR_GAS_MAX: u8 = 255_u8;
    pub const FAC_TI_GAS_COR_MIN: f32 = 0_f32;
    pub const FAC_TI_GAS_COR_MAX: f32 = 1.9988175_f32;
    pub const FTL_AFU_MIN: f32 = 0_f32;
    pub const FTL_AFU_MAX: f32 = 99.96_f32;
    pub const BFS_CYL_MIN: u8 = 0_u8;
    pub const BFS_CYL_MAX: u8 = 6_u8;
    
    /// Construct new LPI11 from values
    pub fn new(fup_lpg_mmv: f32, lv_fuel_type_box: bool, lv_bfs_in_progress: bool, lv_gas_ok: bool, lv_fup_ena_thd: bool, lpi_obd: u8, err_gas: u8, fac_ti_gas_cor: f32, ftl_afu: f32, bfs_cyl: u8, lv_pre_cdn_leak: bool, lv_conf_injection_delay: bool, lv_lpg_sw_driver_req: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_fup_lpg_mmv(fup_lpg_mmv)?;
        res.set_lv_fuel_type_box(lv_fuel_type_box)?;
        res.set_lv_bfs_in_progress(lv_bfs_in_progress)?;
        res.set_lv_gas_ok(lv_gas_ok)?;
        res.set_lv_fup_ena_thd(lv_fup_ena_thd)?;
        res.set_lpi_obd(lpi_obd)?;
        res.set_err_gas(err_gas)?;
        res.set_fac_ti_gas_cor(fac_ti_gas_cor)?;
        res.set_ftl_afu(ftl_afu)?;
        res.set_bfs_cyl(bfs_cyl)?;
        res.set_lv_pre_cdn_leak(lv_pre_cdn_leak)?;
        res.set_lv_conf_injection_delay(lv_conf_injection_delay)?;
        res.set_lv_lpg_sw_driver_req(lv_lpg_sw_driver_req)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// FUP_LPG_MMV
    ///
    /// - Min: 0
    /// - Max: 32640
    /// - Unit: "hPa"
    /// - Receivers: EMS
    #[inline(always)]
    pub fn fup_lpg_mmv(&self) -> f32 {
        self.fup_lpg_mmv_raw()
    }
    
    /// Get raw value of FUP_LPG_MMV
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 128
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fup_lpg_mmv_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 128_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of FUP_LPG_MMV
    #[inline(always)]
    pub fn set_fup_lpg_mmv(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 32640_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 625 });
        }
        let factor = 128_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// LV_FUEL_TYPE_BOX
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn lv_fuel_type_box(&self) -> bool {
        self.lv_fuel_type_box_raw()
    }
    
    /// Get raw value of LV_FUEL_TYPE_BOX
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lv_fuel_type_box_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LV_FUEL_TYPE_BOX
    #[inline(always)]
    pub fn set_lv_fuel_type_box(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[8..9].store_le(value);
        Ok(())
    }
    
    /// LV_BFS_IN_PROGRESS
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn lv_bfs_in_progress(&self) -> bool {
        self.lv_bfs_in_progress_raw()
    }
    
    /// Get raw value of LV_BFS_IN_PROGRESS
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lv_bfs_in_progress_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LV_BFS_IN_PROGRESS
    #[inline(always)]
    pub fn set_lv_bfs_in_progress(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[9..10].store_le(value);
        Ok(())
    }
    
    /// LV_GAS_OK
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn lv_gas_ok(&self) -> bool {
        self.lv_gas_ok_raw()
    }
    
    /// Get raw value of LV_GAS_OK
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lv_gas_ok_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LV_GAS_OK
    #[inline(always)]
    pub fn set_lv_gas_ok(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[10..11].store_le(value);
        Ok(())
    }
    
    /// LV_FUP_ENA_THD
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM, CLU, EMS, SMK
    #[inline(always)]
    pub fn lv_fup_ena_thd(&self) -> bool {
        self.lv_fup_ena_thd_raw()
    }
    
    /// Get raw value of LV_FUP_ENA_THD
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lv_fup_ena_thd_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LV_FUP_ENA_THD
    #[inline(always)]
    pub fn set_lv_fup_ena_thd(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[11..12].store_le(value);
        Ok(())
    }
    
    /// LPI_OBD
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn lpi_obd(&self) -> u8 {
        self.lpi_obd_raw()
    }
    
    /// Get raw value of LPI_OBD
    ///
    /// - Start bit: 12
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lpi_obd_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of LPI_OBD
    #[inline(always)]
    pub fn set_lpi_obd(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 625 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..16].store_le(value);
        Ok(())
    }
    
    /// ERR_GAS
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn err_gas(&self) -> u8 {
        self.err_gas_raw()
    }
    
    /// Get raw value of ERR_GAS
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn err_gas_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ERR_GAS
    #[inline(always)]
    pub fn set_err_gas(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 625 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// FAC_TI_GAS_COR
    ///
    /// - Min: 0
    /// - Max: 1.9988175
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn fac_ti_gas_cor(&self) -> f32 {
        self.fac_ti_gas_cor_raw()
    }
    
    /// Get raw value of FAC_TI_GAS_COR
    ///
    /// - Start bit: 24
    /// - Signal size: 16 bits
    /// - Factor: 0.0000305
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fac_ti_gas_cor_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..40].load_le::<u16>();
        
        let factor = 0.0000305_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of FAC_TI_GAS_COR
    #[inline(always)]
    pub fn set_fac_ti_gas_cor(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1.9988175_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 625 });
        }
        let factor = 0.0000305_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[24..40].store_le(value);
        Ok(())
    }
    
    /// FTL_AFU
    ///
    /// - Min: 0
    /// - Max: 99.96
    /// - Unit: "%"
    /// - Receivers: EMS
    #[inline(always)]
    pub fn ftl_afu(&self) -> f32 {
        self.ftl_afu_raw()
    }
    
    /// Get raw value of FTL_AFU
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.392
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ftl_afu_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 0.392_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of FTL_AFU
    #[inline(always)]
    pub fn set_ftl_afu(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.96_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 625 });
        }
        let factor = 0.392_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// BFS_CYL
    ///
    /// - Min: 0
    /// - Max: 6
    /// - Unit: "Cyl Nr."
    /// - Receivers: EMS
    #[inline(always)]
    pub fn bfs_cyl(&self) -> u8 {
        self.bfs_cyl_raw()
    }
    
    /// Get raw value of BFS_CYL
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bfs_cyl_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BFS_CYL
    #[inline(always)]
    pub fn set_bfs_cyl(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 6_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 625 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// LV_PRE_CDN_LEAK
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn lv_pre_cdn_leak(&self) -> bool {
        self.lv_pre_cdn_leak_raw()
    }
    
    /// Get raw value of LV_PRE_CDN_LEAK
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lv_pre_cdn_leak_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LV_PRE_CDN_LEAK
    #[inline(always)]
    pub fn set_lv_pre_cdn_leak(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[56..57].store_le(value);
        Ok(())
    }
    
    /// LV_CONF_INJECTION_DELAY
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn lv_conf_injection_delay(&self) -> bool {
        self.lv_conf_injection_delay_raw()
    }
    
    /// Get raw value of LV_CONF_INJECTION_DELAY
    ///
    /// - Start bit: 57
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lv_conf_injection_delay_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[57..58].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LV_CONF_INJECTION_DELAY
    #[inline(always)]
    pub fn set_lv_conf_injection_delay(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[57..58].store_le(value);
        Ok(())
    }
    
    /// LV_LPG_SW_DRIVER_REQ
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn lv_lpg_sw_driver_req(&self) -> bool {
        self.lv_lpg_sw_driver_req_raw()
    }
    
    /// Get raw value of LV_LPG_SW_DRIVER_REQ
    ///
    /// - Start bit: 58
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lv_lpg_sw_driver_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[58..59].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LV_LPG_SW_DRIVER_REQ
    #[inline(always)]
    pub fn set_lv_lpg_sw_driver_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[58..59].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Lpi11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Lpi11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Lpi11")
                .field("fup_lpg_mmv", &self.fup_lpg_mmv())
                .field("lv_fuel_type_box", &self.lv_fuel_type_box())
                .field("lv_bfs_in_progress", &self.lv_bfs_in_progress())
                .field("lv_gas_ok", &self.lv_gas_ok())
                .field("lv_fup_ena_thd", &self.lv_fup_ena_thd())
                .field("lpi_obd", &self.lpi_obd())
                .field("err_gas", &self.err_gas())
                .field("fac_ti_gas_cor", &self.fac_ti_gas_cor())
                .field("ftl_afu", &self.ftl_afu())
                .field("bfs_cyl", &self.bfs_cyl())
                .field("lv_pre_cdn_leak", &self.lv_pre_cdn_leak())
                .field("lv_conf_injection_delay", &self.lv_conf_injection_delay())
                .field("lv_lpg_sw_driver_req", &self.lv_lpg_sw_driver_req())
            .finish()
        } else {
            f.debug_tuple("Lpi11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Lpi11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let fup_lpg_mmv = u.float_in_range(0_f32..=32640_f32)?;
        let lv_fuel_type_box = u.int_in_range(0..=1)? == 1;
        let lv_bfs_in_progress = u.int_in_range(0..=1)? == 1;
        let lv_gas_ok = u.int_in_range(0..=1)? == 1;
        let lv_fup_ena_thd = u.int_in_range(0..=1)? == 1;
        let lpi_obd = u.int_in_range(0..=15)?;
        let err_gas = u.int_in_range(0..=255)?;
        let fac_ti_gas_cor = u.float_in_range(0_f32..=1.9988175_f32)?;
        let ftl_afu = u.float_in_range(0_f32..=99.96_f32)?;
        let bfs_cyl = u.int_in_range(0..=6)?;
        let lv_pre_cdn_leak = u.int_in_range(0..=1)? == 1;
        let lv_conf_injection_delay = u.int_in_range(0..=1)? == 1;
        let lv_lpg_sw_driver_req = u.int_in_range(0..=1)? == 1;
        Lpi11::new(fup_lpg_mmv,lv_fuel_type_box,lv_bfs_in_progress,lv_gas_ok,lv_fup_ena_thd,lpi_obd,err_gas,fac_ti_gas_cor,ftl_afu,bfs_cyl,lv_pre_cdn_leak,lv_conf_injection_delay,lv_lpg_sw_driver_req).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// VSM11
///
/// - ID: 356 (0x164)
/// - Size: 4 bytes
/// - Transmitter: ESC
#[derive(Clone, Copy)]
pub struct Vsm11 {
    raw: [u8; 4],
}

impl Vsm11 {
    pub const MESSAGE_ID: u32 = 356;
    
    pub const CR_ESC_STR_TQ_REQ_MIN: f32 = -20.48_f32;
    pub const CR_ESC_STR_TQ_REQ_MAX: f32 = 20.47_f32;
    pub const CF_ESC_CTR_MODE_MIN: u8 = 0_u8;
    pub const CF_ESC_CTR_MODE_MAX: u8 = 7_u8;
    pub const CF_ESC_ALIVE_CNT_MIN: u8 = 0_u8;
    pub const CF_ESC_ALIVE_CNT_MAX: u8 = 15_u8;
    pub const CF_ESC_CHKSUM_MIN: u8 = 0_u8;
    pub const CF_ESC_CHKSUM_MAX: u8 = 255_u8;
    
    /// Construct new VSM11 from values
    pub fn new(cr_esc_str_tq_req: f32, cf_esc_act: bool, cf_esc_ctr_mode: u8, cf_esc_def: bool, cf_esc_alive_cnt: u8, cf_esc_chksum: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_cr_esc_str_tq_req(cr_esc_str_tq_req)?;
        res.set_cf_esc_act(cf_esc_act)?;
        res.set_cf_esc_ctr_mode(cf_esc_ctr_mode)?;
        res.set_cf_esc_def(cf_esc_def)?;
        res.set_cf_esc_alive_cnt(cf_esc_alive_cnt)?;
        res.set_cf_esc_chksum(cf_esc_chksum)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 4] {
        &self.raw
    }
    
    /// CR_Esc_StrTqReq
    ///
    /// - Min: -20.48
    /// - Max: 20.47
    /// - Unit: "Nm"
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn cr_esc_str_tq_req(&self) -> f32 {
        self.cr_esc_str_tq_req_raw()
    }
    
    /// Get raw value of CR_Esc_StrTqReq
    ///
    /// - Start bit: 0
    /// - Signal size: 12 bits
    /// - Factor: 0.01
    /// - Offset: -20.48
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_esc_str_tq_req_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..12].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = -20.48_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Esc_StrTqReq
    #[inline(always)]
    pub fn set_cr_esc_str_tq_req(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20.48_f32 || 20.47_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 356 });
        }
        let factor = 0.01_f32;
        let offset = -20.48_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..12].store_le(value);
        Ok(())
    }
    
    /// CF_Esc_Act
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS, MDPS
    #[inline(always)]
    pub fn cf_esc_act(&self) -> bool {
        self.cf_esc_act_raw()
    }
    
    /// Get raw value of CF_Esc_Act
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_esc_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Esc_Act
    #[inline(always)]
    pub fn set_cf_esc_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[12..13].store_le(value);
        Ok(())
    }
    
    /// CF_Esc_CtrMode
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn cf_esc_ctr_mode(&self) -> u8 {
        self.cf_esc_ctr_mode_raw()
    }
    
    /// Get raw value of CF_Esc_CtrMode
    ///
    /// - Start bit: 13
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_esc_ctr_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[13..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Esc_CtrMode
    #[inline(always)]
    pub fn set_cf_esc_ctr_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 356 });
        }
        self.raw.view_bits_mut::<Lsb0>()[13..16].store_le(value);
        Ok(())
    }
    
    /// CF_Esc_Def
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn cf_esc_def(&self) -> bool {
        self.cf_esc_def_raw()
    }
    
    /// Get raw value of CF_Esc_Def
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_esc_def_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Esc_Def
    #[inline(always)]
    pub fn set_cf_esc_def(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[16..17].store_le(value);
        Ok(())
    }
    
    /// CF_Esc_AliveCnt
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS, MDPS
    #[inline(always)]
    pub fn cf_esc_alive_cnt(&self) -> u8 {
        self.cf_esc_alive_cnt_raw()
    }
    
    /// Get raw value of CF_Esc_AliveCnt
    ///
    /// - Start bit: 17
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_esc_alive_cnt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[17..21].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Esc_AliveCnt
    #[inline(always)]
    pub fn set_cf_esc_alive_cnt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 356 });
        }
        self.raw.view_bits_mut::<Lsb0>()[17..21].store_le(value);
        Ok(())
    }
    
    /// CF_Esc_Chksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS, MDPS
    #[inline(always)]
    pub fn cf_esc_chksum(&self) -> u8 {
        self.cf_esc_chksum_raw()
    }
    
    /// Get raw value of CF_Esc_Chksum
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_esc_chksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Esc_Chksum
    #[inline(always)]
    pub fn set_cf_esc_chksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 356 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Vsm11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Vsm11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Vsm11")
                .field("cr_esc_str_tq_req", &self.cr_esc_str_tq_req())
                .field("cf_esc_act", &self.cf_esc_act())
                .field("cf_esc_ctr_mode", &self.cf_esc_ctr_mode())
                .field("cf_esc_def", &self.cf_esc_def())
                .field("cf_esc_alive_cnt", &self.cf_esc_alive_cnt())
                .field("cf_esc_chksum", &self.cf_esc_chksum())
            .finish()
        } else {
            f.debug_tuple("Vsm11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Vsm11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cr_esc_str_tq_req = u.float_in_range(-20.48_f32..=20.47_f32)?;
        let cf_esc_act = u.int_in_range(0..=1)? == 1;
        let cf_esc_ctr_mode = u.int_in_range(0..=7)?;
        let cf_esc_def = u.int_in_range(0..=1)? == 1;
        let cf_esc_alive_cnt = u.int_in_range(0..=15)?;
        let cf_esc_chksum = u.int_in_range(0..=255)?;
        Vsm11::new(cr_esc_str_tq_req,cf_esc_act,cf_esc_ctr_mode,cf_esc_def,cf_esc_alive_cnt,cf_esc_chksum).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// PGS_HU_PE_01
///
/// - ID: 1379 (0x563)
/// - Size: 8 bytes
/// - Transmitter: PGS
#[derive(Clone, Copy)]
pub struct PgsHuPe01 {
    raw: [u8; 8],
}

impl PgsHuPe01 {
    pub const MESSAGE_ID: u32 = 1379;
    
    pub const PGS_STATE_MIN: u8 = 0_u8;
    pub const PGS_STATE_MAX: u8 = 15_u8;
    pub const PGS_PARK_GUIDE_STATE_MIN: u8 = 0_u8;
    pub const PGS_PARK_GUIDE_STATE_MAX: u8 = 31_u8;
    pub const PGS_OPTION_MIN: u8 = 0_u8;
    pub const PGS_OPTION_MAX: u8 = 31_u8;
    pub const PGS_VERSION_MIN: u16 = 0_u16;
    pub const PGS_VERSION_MAX: u16 = 65535_u16;
    
    /// Construct new PGS_HU_PE_01 from values
    pub fn new(pgs_state: u8, pgs_park_guide_state: u8, pgs_option: u8, pgs_version: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_pgs_state(pgs_state)?;
        res.set_pgs_park_guide_state(pgs_park_guide_state)?;
        res.set_pgs_option(pgs_option)?;
        res.set_pgs_version(pgs_version)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// PGS_State
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn pgs_state(&self) -> u8 {
        self.pgs_state_raw()
    }
    
    /// Get raw value of PGS_State
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pgs_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PGS_State
    #[inline(always)]
    pub fn set_pgs_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1379 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..4].store_le(value);
        Ok(())
    }
    
    /// PGS_ParkGuideState
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn pgs_park_guide_state(&self) -> u8 {
        self.pgs_park_guide_state_raw()
    }
    
    /// Get raw value of PGS_ParkGuideState
    ///
    /// - Start bit: 8
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pgs_park_guide_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PGS_ParkGuideState
    #[inline(always)]
    pub fn set_pgs_park_guide_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 31_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1379 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..13].store_le(value);
        Ok(())
    }
    
    /// PGS_Option
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn pgs_option(&self) -> u8 {
        self.pgs_option_raw()
    }
    
    /// Get raw value of PGS_Option
    ///
    /// - Start bit: 16
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pgs_option_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..21].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PGS_Option
    #[inline(always)]
    pub fn set_pgs_option(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 31_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1379 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..21].store_le(value);
        Ok(())
    }
    
    /// PGS_Version
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn pgs_version(&self) -> u16 {
        self.pgs_version_raw()
    }
    
    /// Get raw value of PGS_Version
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pgs_version_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<u16>();
        
        signal
    }
    
    /// Set value of PGS_Version
    #[inline(always)]
    pub fn set_pgs_version(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1379 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for PgsHuPe01 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for PgsHuPe01 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("PgsHuPe01")
                .field("pgs_state", &self.pgs_state())
                .field("pgs_park_guide_state", &self.pgs_park_guide_state())
                .field("pgs_option", &self.pgs_option())
                .field("pgs_version", &self.pgs_version())
            .finish()
        } else {
            f.debug_tuple("PgsHuPe01").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for PgsHuPe01 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let pgs_state = u.int_in_range(0..=15)?;
        let pgs_park_guide_state = u.int_in_range(0..=31)?;
        let pgs_option = u.int_in_range(0..=31)?;
        let pgs_version = u.int_in_range(0..=65535)?;
        PgsHuPe01::new(pgs_state,pgs_park_guide_state,pgs_option,pgs_version).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// TCU_DCT13
///
/// - ID: 354 (0x162)
/// - Size: 3 bytes
/// - Transmitter: TCU
#[derive(Clone, Copy)]
pub struct TcuDct13 {
    raw: [u8; 3],
}

impl TcuDct13 {
    pub const MESSAGE_ID: u32 = 354;
    
    pub const CLUTCH_DRIVING_TQ_MIN: f32 = 0_f32;
    pub const CLUTCH_DRIVING_TQ_MAX: f32 = 0_f32;
    pub const CLUSTER_ENGINE_RPM_MIN: f32 = 0_f32;
    pub const CLUSTER_ENGINE_RPM_MAX: f32 = 0_f32;
    
    /// Construct new TCU_DCT13 from values
    pub fn new(clutch_driving_tq: f32, cluster_engine_rpm: f32, cluster_engine_rpm_flag: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_clutch_driving_tq(clutch_driving_tq)?;
        res.set_cluster_engine_rpm(cluster_engine_rpm)?;
        res.set_cluster_engine_rpm_flag(cluster_engine_rpm_flag)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Clutch_Driving_Tq
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: "Nm"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn clutch_driving_tq(&self) -> f32 {
        self.clutch_driving_tq_raw()
    }
    
    /// Get raw value of Clutch_Driving_Tq
    ///
    /// - Start bit: 0
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: -512
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn clutch_driving_tq_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..10].load_le::<u16>();
        
        let factor = 1_f32;
        let offset = -512_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Clutch_Driving_Tq
    #[inline(always)]
    pub fn set_clutch_driving_tq(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 354 });
        }
        let factor = 1_f32;
        let offset = -512_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..10].store_le(value);
        Ok(())
    }
    
    /// Cluster_Engine_RPM
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cluster_engine_rpm(&self) -> f32 {
        self.cluster_engine_rpm_raw()
    }
    
    /// Get raw value of Cluster_Engine_RPM
    ///
    /// - Start bit: 10
    /// - Signal size: 13 bits
    /// - Factor: 0.9766
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cluster_engine_rpm_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[10..23].load_le::<u16>();
        
        let factor = 0.9766_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Cluster_Engine_RPM
    #[inline(always)]
    pub fn set_cluster_engine_rpm(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 354 });
        }
        let factor = 0.9766_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[10..23].store_le(value);
        Ok(())
    }
    
    /// Cluster_Engine_RPM_Flag
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cluster_engine_rpm_flag(&self) -> bool {
        self.cluster_engine_rpm_flag_raw()
    }
    
    /// Get raw value of Cluster_Engine_RPM_Flag
    ///
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cluster_engine_rpm_flag_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[23..24].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Cluster_Engine_RPM_Flag
    #[inline(always)]
    pub fn set_cluster_engine_rpm_flag(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[23..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for TcuDct13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for TcuDct13 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("TcuDct13")
                .field("clutch_driving_tq", &self.clutch_driving_tq())
                .field("cluster_engine_rpm", &self.cluster_engine_rpm())
                .field("cluster_engine_rpm_flag", &self.cluster_engine_rpm_flag())
            .finish()
        } else {
            f.debug_tuple("TcuDct13").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for TcuDct13 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let clutch_driving_tq = u.float_in_range(0_f32..=0_f32)?;
        let cluster_engine_rpm = u.float_in_range(0_f32..=0_f32)?;
        let cluster_engine_rpm_flag = u.int_in_range(0..=1)? == 1;
        TcuDct13::new(clutch_driving_tq,cluster_engine_rpm,cluster_engine_rpm_flag).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// HUD11
///
/// - ID: 1378 (0x562)
/// - Size: 4 bytes
/// - Transmitter: HUD
#[derive(Clone, Copy)]
pub struct Hud11 {
    raw: [u8; 4],
}

impl Hud11 {
    pub const MESSAGE_ID: u32 = 1378;
    
    pub const CF_HUD_HEIGHT_STAUS_MIN: u8 = 0_u8;
    pub const CF_HUD_HEIGHT_STAUS_MAX: u8 = 31_u8;
    pub const CF_HUD_P_BACK_STATUS_MIN: u8 = 0_u8;
    pub const CF_HUD_P_BACK_STATUS_MAX: u8 = 0_u8;
    pub const CF_HUD_BRIGHTNESS_MIN: u8 = 0_u8;
    pub const CF_HUD_BRIGHTNESS_MAX: u8 = 31_u8;
    
    /// Construct new HUD11 from values
    pub fn new(cf_hud_height_staus: u8, cf_hud_p_back_status: u8, cf_hud_brightness: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_cf_hud_height_staus(cf_hud_height_staus)?;
        res.set_cf_hud_p_back_status(cf_hud_p_back_status)?;
        res.set_cf_hud_brightness(cf_hud_brightness)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 4] {
        &self.raw
    }
    
    /// CF_Hud_HeightStaus
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_hud_height_staus(&self) -> u8 {
        self.cf_hud_height_staus_raw()
    }
    
    /// Get raw value of CF_Hud_HeightStaus
    ///
    /// - Start bit: 0
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_hud_height_staus_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Hud_HeightStaus
    #[inline(always)]
    pub fn set_cf_hud_height_staus(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 31_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1378 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..5].store_le(value);
        Ok(())
    }
    
    /// CF_Hud_PBackStatus
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_hud_p_back_status(&self) -> u8 {
        self.cf_hud_p_back_status_raw()
    }
    
    /// Get raw value of CF_Hud_PBackStatus
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_hud_p_back_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Hud_PBackStatus
    #[inline(always)]
    pub fn set_cf_hud_p_back_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1378 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// CF_Hud_Brightness
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_hud_brightness(&self) -> u8 {
        self.cf_hud_brightness_raw()
    }
    
    /// Get raw value of CF_Hud_Brightness
    ///
    /// - Start bit: 8
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_hud_brightness_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Hud_Brightness
    #[inline(always)]
    pub fn set_cf_hud_brightness(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 31_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1378 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..13].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Hud11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Hud11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Hud11")
                .field("cf_hud_height_staus", &self.cf_hud_height_staus())
                .field("cf_hud_p_back_status", &self.cf_hud_p_back_status())
                .field("cf_hud_brightness", &self.cf_hud_brightness())
            .finish()
        } else {
            f.debug_tuple("Hud11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Hud11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_hud_height_staus = u.int_in_range(0..=31)?;
        let cf_hud_p_back_status = u.int_in_range(0..=0)?;
        let cf_hud_brightness = u.int_in_range(0..=31)?;
        Hud11::new(cf_hud_height_staus,cf_hud_p_back_status,cf_hud_brightness).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EMS16
///
/// - ID: 608 (0x260)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct Ems16 {
    raw: [u8; 8],
}

impl Ems16 {
    pub const MESSAGE_ID: u32 = 608;
    
    pub const TQI_MIN_MIN: f32 = 0_f32;
    pub const TQI_MIN_MAX: f32 = 99.609375_f32;
    pub const TQI_MIN: f32 = 0_f32;
    pub const TQI_MAX: f32 = 99.609375_f32;
    pub const TQI_TARGET_MIN: f32 = 0_f32;
    pub const TQI_TARGET_MAX: f32 = 99.609375_f32;
    pub const ENG_STAT_MIN: u8 = 0_u8;
    pub const ENG_STAT_MAX: u8 = 7_u8;
    pub const SOAK_TIME_MIN: u8 = 0_u8;
    pub const SOAK_TIME_MAX: u8 = 255_u8;
    pub const TQI_MAX_MIN: f32 = 0_f32;
    pub const TQI_MAX_MAX: f32 = 99.609375_f32;
    pub const SPK_TIME_CUR_MIN: f32 = -35.625_f32;
    pub const SPK_TIME_CUR_MAX: f32 = 60_f32;
    pub const CHECKSUM_MIN: u8 = 0_u8;
    pub const CHECKSUM_MAX: u8 = 15_u8;
    pub const ALIVE_COUNTER_MIN: u8 = 0_u8;
    pub const ALIVE_COUNTER_MAX: u8 = 3_u8;
    pub const CF_EMS_ACL_ACT_MIN: u8 = 0_u8;
    pub const CF_EMS_ACL_ACT_MAX: u8 = 3_u8;
    
    /// Construct new EMS16 from values
    pub fn new(tqi_min: f32, tqi: f32, tqi_target: f32, glow_stat: bool, cruise_lamp_m: bool, cruise_lamp_s: bool, pre_fuel_cut_in: bool, eng_stat: u8, soak_time_error: bool, soak_time: u8, tqi_max: f32, spk_time_cur: f32, checksum: u8, alive_counter: u8, cf_ems_acl_act: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_tqi_min(tqi_min)?;
        res.set_tqi(tqi)?;
        res.set_tqi_target(tqi_target)?;
        res.set_glow_stat(glow_stat)?;
        res.set_cruise_lamp_m(cruise_lamp_m)?;
        res.set_cruise_lamp_s(cruise_lamp_s)?;
        res.set_pre_fuel_cut_in(pre_fuel_cut_in)?;
        res.set_eng_stat(eng_stat)?;
        res.set_soak_time_error(soak_time_error)?;
        res.set_soak_time(soak_time)?;
        res.set_tqi_max(tqi_max)?;
        res.set_spk_time_cur(spk_time_cur)?;
        res.set_checksum(checksum)?;
        res.set_alive_counter(alive_counter)?;
        res.set_cf_ems_acl_act(cf_ems_acl_act)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// TQI_MIN
    ///
    /// - Min: 0
    /// - Max: 99.609375
    /// - Unit: "%"
    /// - Receivers: ESC, IBOX, TCU
    #[inline(always)]
    pub fn tqi_min(&self) -> f32 {
        self.tqi_min_raw()
    }
    
    /// Get raw value of TQI_MIN
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_min_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI_MIN
    #[inline(always)]
    pub fn set_tqi_min(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.609375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 608 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// TQI
    ///
    /// - Min: 0
    /// - Max: 99.609375
    /// - Unit: "%"
    /// - Receivers: ESC, IBOX, TCU
    #[inline(always)]
    pub fn tqi(&self) -> f32 {
        self.tqi_raw()
    }
    
    /// Get raw value of TQI
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI
    #[inline(always)]
    pub fn set_tqi(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.609375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 608 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// TQI_TARGET
    ///
    /// - Min: 0
    /// - Max: 99.609375
    /// - Unit: "%"
    /// - Receivers: EPB, ESC, IBOX, TCU
    #[inline(always)]
    pub fn tqi_target(&self) -> f32 {
        self.tqi_target_raw()
    }
    
    /// Get raw value of TQI_TARGET
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_target_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI_TARGET
    #[inline(always)]
    pub fn set_tqi_target(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.609375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 608 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// GLOW_STAT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM, CLU, IBOX, SMK
    #[inline(always)]
    pub fn glow_stat(&self) -> bool {
        self.glow_stat_raw()
    }
    
    /// Get raw value of GLOW_STAT
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn glow_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of GLOW_STAT
    #[inline(always)]
    pub fn set_glow_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[24..25].store_le(value);
        Ok(())
    }
    
    /// CRUISE_LAMP_M
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX, TCU
    #[inline(always)]
    pub fn cruise_lamp_m(&self) -> bool {
        self.cruise_lamp_m_raw()
    }
    
    /// Get raw value of CRUISE_LAMP_M
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cruise_lamp_m_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CRUISE_LAMP_M
    #[inline(always)]
    pub fn set_cruise_lamp_m(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[25..26].store_le(value);
        Ok(())
    }
    
    /// CRUISE_LAMP_S
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX, TCU
    #[inline(always)]
    pub fn cruise_lamp_s(&self) -> bool {
        self.cruise_lamp_s_raw()
    }
    
    /// Get raw value of CRUISE_LAMP_S
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cruise_lamp_s_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CRUISE_LAMP_S
    #[inline(always)]
    pub fn set_cruise_lamp_s(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[26..27].store_le(value);
        Ok(())
    }
    
    /// PRE_FUEL_CUT_IN
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: IBOX, TCU
    #[inline(always)]
    pub fn pre_fuel_cut_in(&self) -> bool {
        self.pre_fuel_cut_in_raw()
    }
    
    /// Get raw value of PRE_FUEL_CUT_IN
    ///
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pre_fuel_cut_in_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[27..28].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of PRE_FUEL_CUT_IN
    #[inline(always)]
    pub fn set_pre_fuel_cut_in(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[27..28].store_le(value);
        Ok(())
    }
    
    /// ENG_STAT
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: ABS, AHLS, AVM, BCM, CLU, EPB, ESC, EVP, FPCM, IBOX, LCA, LDWS_LKAS, MDPS, SCC, SMK, TCU
    #[inline(always)]
    pub fn eng_stat(&self) -> u8 {
        self.eng_stat_raw()
    }
    
    /// Get raw value of ENG_STAT
    ///
    /// - Start bit: 28
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn eng_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[28..31].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ENG_STAT
    #[inline(always)]
    pub fn set_eng_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 608 });
        }
        self.raw.view_bits_mut::<Lsb0>()[28..31].store_le(value);
        Ok(())
    }
    
    /// SOAK_TIME_ERROR
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: DATC, EPB, IBOX, TCU
    #[inline(always)]
    pub fn soak_time_error(&self) -> bool {
        self.soak_time_error_raw()
    }
    
    /// Get raw value of SOAK_TIME_ERROR
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn soak_time_error_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of SOAK_TIME_ERROR
    #[inline(always)]
    pub fn set_soak_time_error(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[31..32].store_le(value);
        Ok(())
    }
    
    /// SOAK_TIME
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: "Min"
    /// - Receivers: _4WD, DATC, EPB, IBOX, TCU
    #[inline(always)]
    pub fn soak_time(&self) -> u8 {
        self.soak_time_raw()
    }
    
    /// Get raw value of SOAK_TIME
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn soak_time_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of SOAK_TIME
    #[inline(always)]
    pub fn set_soak_time(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 608 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// TQI_MAX
    ///
    /// - Min: 0
    /// - Max: 99.609375
    /// - Unit: "%"
    /// - Receivers: ESC, IBOX, TCU
    #[inline(always)]
    pub fn tqi_max(&self) -> f32 {
        self.tqi_max_raw()
    }
    
    /// Get raw value of TQI_MAX
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_max_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI_MAX
    #[inline(always)]
    pub fn set_tqi_max(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.609375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 608 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// SPK_TIME_CUR
    ///
    /// - Min: -35.625
    /// - Max: 60
    /// - Unit: ""
    /// - Receivers: IBOX, TCU
    #[inline(always)]
    pub fn spk_time_cur(&self) -> f32 {
        self.spk_time_cur_raw()
    }
    
    /// Get raw value of SPK_TIME_CUR
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.375
    /// - Offset: -35.625
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn spk_time_cur_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        let factor = 0.375_f32;
        let offset = -35.625_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of SPK_TIME_CUR
    #[inline(always)]
    pub fn set_spk_time_cur(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -35.625_f32 || 60_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 608 });
        }
        let factor = 0.375_f32;
        let offset = -35.625_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// Checksum
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: ECS, IBOX, LDWS_LKAS, MDPS, SCC
    #[inline(always)]
    pub fn checksum(&self) -> u8 {
        self.checksum_raw()
    }
    
    /// Get raw value of Checksum
    ///
    /// - Start bit: 56
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Checksum
    #[inline(always)]
    pub fn set_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 608 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..60].store_le(value);
        Ok(())
    }
    
    /// AliveCounter
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: IBOX, LDWS_LKAS, MDPS, SCC
    #[inline(always)]
    pub fn alive_counter(&self) -> u8 {
        self.alive_counter_raw()
    }
    
    /// Get raw value of AliveCounter
    ///
    /// - Start bit: 60
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn alive_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..62].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AliveCounter
    #[inline(always)]
    pub fn set_alive_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 608 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..62].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_AclAct
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: IBOX, SCC
    #[inline(always)]
    pub fn cf_ems_acl_act(&self) -> u8 {
        self.cf_ems_acl_act_raw()
    }
    
    /// Get raw value of CF_Ems_AclAct
    ///
    /// - Start bit: 62
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_acl_act_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[62..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_AclAct
    #[inline(always)]
    pub fn set_cf_ems_acl_act(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 608 });
        }
        self.raw.view_bits_mut::<Lsb0>()[62..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ems16 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ems16 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ems16")
                .field("tqi_min", &self.tqi_min())
                .field("tqi", &self.tqi())
                .field("tqi_target", &self.tqi_target())
                .field("glow_stat", &self.glow_stat())
                .field("cruise_lamp_m", &self.cruise_lamp_m())
                .field("cruise_lamp_s", &self.cruise_lamp_s())
                .field("pre_fuel_cut_in", &self.pre_fuel_cut_in())
                .field("eng_stat", &self.eng_stat())
                .field("soak_time_error", &self.soak_time_error())
                .field("soak_time", &self.soak_time())
                .field("tqi_max", &self.tqi_max())
                .field("spk_time_cur", &self.spk_time_cur())
                .field("checksum", &self.checksum())
                .field("alive_counter", &self.alive_counter())
                .field("cf_ems_acl_act", &self.cf_ems_acl_act())
            .finish()
        } else {
            f.debug_tuple("Ems16").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ems16 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let tqi_min = u.float_in_range(0_f32..=99.609375_f32)?;
        let tqi = u.float_in_range(0_f32..=99.609375_f32)?;
        let tqi_target = u.float_in_range(0_f32..=99.609375_f32)?;
        let glow_stat = u.int_in_range(0..=1)? == 1;
        let cruise_lamp_m = u.int_in_range(0..=1)? == 1;
        let cruise_lamp_s = u.int_in_range(0..=1)? == 1;
        let pre_fuel_cut_in = u.int_in_range(0..=1)? == 1;
        let eng_stat = u.int_in_range(0..=7)?;
        let soak_time_error = u.int_in_range(0..=1)? == 1;
        let soak_time = u.int_in_range(0..=255)?;
        let tqi_max = u.float_in_range(0_f32..=99.609375_f32)?;
        let spk_time_cur = u.float_in_range(-35.625_f32..=60_f32)?;
        let checksum = u.int_in_range(0..=15)?;
        let alive_counter = u.int_in_range(0..=3)?;
        let cf_ems_acl_act = u.int_in_range(0..=3)?;
        Ems16::new(tqi_min,tqi,tqi_target,glow_stat,cruise_lamp_m,cruise_lamp_s,pre_fuel_cut_in,eng_stat,soak_time_error,soak_time,tqi_max,spk_time_cur,checksum,alive_counter,cf_ems_acl_act).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// AVM_HU_PE_00
///
/// - ID: 1371 (0x55b)
/// - Size: 8 bytes
/// - Transmitter: AVM
#[derive(Clone, Copy)]
pub struct AvmHuPe00 {
    raw: [u8; 8],
}

impl AvmHuPe00 {
    pub const MESSAGE_ID: u32 = 1371;
    
    pub const AVM_VIEW_MIN: u8 = 0_u8;
    pub const AVM_VIEW_MAX: u8 = 31_u8;
    pub const AVM_PARKING_ASSIST_BTN_STS_MIN: u8 = 0_u8;
    pub const AVM_PARKING_ASSIST_BTN_STS_MAX: u8 = 7_u8;
    pub const AVM_DISPLAY_MESSAGE_MIN: u8 = 0_u8;
    pub const AVM_DISPLAY_MESSAGE_MAX: u8 = 255_u8;
    pub const AVM_POPUP_MSG_MIN: u8 = 0_u8;
    pub const AVM_POPUP_MSG_MAX: u8 = 15_u8;
    pub const AVM_READY_MIN: u8 = 0_u8;
    pub const AVM_READY_MAX: u8 = 15_u8;
    pub const AVM_PARKING_ASSIST_STEP_MIN: u8 = 0_u8;
    pub const AVM_PARKING_ASSIST_STEP_MAX: u8 = 15_u8;
    pub const AVM_FRONT_BTN_TYPE_MIN: u8 = 0_u8;
    pub const AVM_FRONT_BTN_TYPE_MAX: u8 = 15_u8;
    pub const AVM_OPTION_MIN: u8 = 0_u8;
    pub const AVM_OPTION_MAX: u8 = 15_u8;
    pub const AVM_HU_FRONT_VIEW_POINT_OPT_MIN: u8 = 0_u8;
    pub const AVM_HU_FRONT_VIEW_POINT_OPT_MAX: u8 = 15_u8;
    pub const AVM_HU_REAR_VIEW_OPTION_MIN: u8 = 0_u8;
    pub const AVM_HU_REAR_VIEW_OPTION_MAX: u8 = 15_u8;
    pub const AVM_HU_FRONT_VIEW_OPTION_MIN: u8 = 0_u8;
    pub const AVM_HU_FRONT_VIEW_OPTION_MAX: u8 = 15_u8;
    pub const AVM_VERSION_MIN: u16 = 0_u16;
    pub const AVM_VERSION_MAX: u16 = 65535_u16;
    
    /// Construct new AVM_HU_PE_00 from values
    pub fn new(avm_view: u8, avm_parking_assist_btn_sts: u8, avm_display_message: u8, avm_popup_msg: u8, avm_ready: u8, avm_parking_assist_step: u8, avm_front_btn_type: u8, avm_option: u8, avm_hu_front_view_point_opt: u8, avm_hu_rear_view_option: u8, avm_hu_front_view_option: u8, avm_version: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_avm_view(avm_view)?;
        res.set_avm_parking_assist_btn_sts(avm_parking_assist_btn_sts)?;
        res.set_avm_display_message(avm_display_message)?;
        res.set_avm_popup_msg(avm_popup_msg)?;
        res.set_avm_ready(avm_ready)?;
        res.set_avm_parking_assist_step(avm_parking_assist_step)?;
        res.set_avm_front_btn_type(avm_front_btn_type)?;
        res.set_avm_option(avm_option)?;
        res.set_avm_hu_front_view_point_opt(avm_hu_front_view_point_opt)?;
        res.set_avm_hu_rear_view_option(avm_hu_rear_view_option)?;
        res.set_avm_hu_front_view_option(avm_hu_front_view_option)?;
        res.set_avm_version(avm_version)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// AVM_View
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn avm_view(&self) -> u8 {
        self.avm_view_raw()
    }
    
    /// Get raw value of AVM_View
    ///
    /// - Start bit: 0
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avm_view_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVM_View
    #[inline(always)]
    pub fn set_avm_view(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 31_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1371 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..5].store_le(value);
        Ok(())
    }
    
    /// AVM_ParkingAssist_BtnSts
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn avm_parking_assist_btn_sts(&self) -> u8 {
        self.avm_parking_assist_btn_sts_raw()
    }
    
    /// Get raw value of AVM_ParkingAssist_BtnSts
    ///
    /// - Start bit: 5
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avm_parking_assist_btn_sts_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[5..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVM_ParkingAssist_BtnSts
    #[inline(always)]
    pub fn set_avm_parking_assist_btn_sts(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1371 });
        }
        self.raw.view_bits_mut::<Lsb0>()[5..8].store_le(value);
        Ok(())
    }
    
    /// AVM_Display_Message
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn avm_display_message(&self) -> u8 {
        self.avm_display_message_raw()
    }
    
    /// Get raw value of AVM_Display_Message
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avm_display_message_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVM_Display_Message
    #[inline(always)]
    pub fn set_avm_display_message(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1371 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// AVM_Popup_Msg
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn avm_popup_msg(&self) -> u8 {
        self.avm_popup_msg_raw()
    }
    
    /// Get raw value of AVM_Popup_Msg
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avm_popup_msg_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVM_Popup_Msg
    #[inline(always)]
    pub fn set_avm_popup_msg(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1371 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..20].store_le(value);
        Ok(())
    }
    
    /// AVM_Ready
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn avm_ready(&self) -> u8 {
        self.avm_ready_raw()
    }
    
    /// Get raw value of AVM_Ready
    ///
    /// - Start bit: 20
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avm_ready_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVM_Ready
    #[inline(always)]
    pub fn set_avm_ready(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1371 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..24].store_le(value);
        Ok(())
    }
    
    /// AVM_ParkingAssist_Step
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn avm_parking_assist_step(&self) -> u8 {
        self.avm_parking_assist_step_raw()
    }
    
    /// Get raw value of AVM_ParkingAssist_Step
    ///
    /// - Start bit: 24
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avm_parking_assist_step_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVM_ParkingAssist_Step
    #[inline(always)]
    pub fn set_avm_parking_assist_step(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1371 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..28].store_le(value);
        Ok(())
    }
    
    /// AVM_FrontBtn_Type
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn avm_front_btn_type(&self) -> u8 {
        self.avm_front_btn_type_raw()
    }
    
    /// Get raw value of AVM_FrontBtn_Type
    ///
    /// - Start bit: 28
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avm_front_btn_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[28..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVM_FrontBtn_Type
    #[inline(always)]
    pub fn set_avm_front_btn_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1371 });
        }
        self.raw.view_bits_mut::<Lsb0>()[28..32].store_le(value);
        Ok(())
    }
    
    /// AVM_Option
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn avm_option(&self) -> u8 {
        self.avm_option_raw()
    }
    
    /// Get raw value of AVM_Option
    ///
    /// - Start bit: 32
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avm_option_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVM_Option
    #[inline(always)]
    pub fn set_avm_option(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1371 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..36].store_le(value);
        Ok(())
    }
    
    /// AVM_HU_FrontViewPointOpt
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn avm_hu_front_view_point_opt(&self) -> u8 {
        self.avm_hu_front_view_point_opt_raw()
    }
    
    /// Get raw value of AVM_HU_FrontViewPointOpt
    ///
    /// - Start bit: 36
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avm_hu_front_view_point_opt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[36..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVM_HU_FrontViewPointOpt
    #[inline(always)]
    pub fn set_avm_hu_front_view_point_opt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1371 });
        }
        self.raw.view_bits_mut::<Lsb0>()[36..40].store_le(value);
        Ok(())
    }
    
    /// AVM_HU_RearView_Option
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn avm_hu_rear_view_option(&self) -> u8 {
        self.avm_hu_rear_view_option_raw()
    }
    
    /// Get raw value of AVM_HU_RearView_Option
    ///
    /// - Start bit: 40
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avm_hu_rear_view_option_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..44].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVM_HU_RearView_Option
    #[inline(always)]
    pub fn set_avm_hu_rear_view_option(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1371 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..44].store_le(value);
        Ok(())
    }
    
    /// AVM_HU_FrontView_Option
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn avm_hu_front_view_option(&self) -> u8 {
        self.avm_hu_front_view_option_raw()
    }
    
    /// Get raw value of AVM_HU_FrontView_Option
    ///
    /// - Start bit: 44
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avm_hu_front_view_option_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[44..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVM_HU_FrontView_Option
    #[inline(always)]
    pub fn set_avm_hu_front_view_option(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1371 });
        }
        self.raw.view_bits_mut::<Lsb0>()[44..48].store_le(value);
        Ok(())
    }
    
    /// AVM_Version
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn avm_version(&self) -> u16 {
        self.avm_version_raw()
    }
    
    /// Get raw value of AVM_Version
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avm_version_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<u16>();
        
        signal
    }
    
    /// Set value of AVM_Version
    #[inline(always)]
    pub fn set_avm_version(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1371 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for AvmHuPe00 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for AvmHuPe00 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("AvmHuPe00")
                .field("avm_view", &self.avm_view())
                .field("avm_parking_assist_btn_sts", &self.avm_parking_assist_btn_sts())
                .field("avm_display_message", &self.avm_display_message())
                .field("avm_popup_msg", &self.avm_popup_msg())
                .field("avm_ready", &self.avm_ready())
                .field("avm_parking_assist_step", &self.avm_parking_assist_step())
                .field("avm_front_btn_type", &self.avm_front_btn_type())
                .field("avm_option", &self.avm_option())
                .field("avm_hu_front_view_point_opt", &self.avm_hu_front_view_point_opt())
                .field("avm_hu_rear_view_option", &self.avm_hu_rear_view_option())
                .field("avm_hu_front_view_option", &self.avm_hu_front_view_option())
                .field("avm_version", &self.avm_version())
            .finish()
        } else {
            f.debug_tuple("AvmHuPe00").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for AvmHuPe00 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let avm_view = u.int_in_range(0..=31)?;
        let avm_parking_assist_btn_sts = u.int_in_range(0..=7)?;
        let avm_display_message = u.int_in_range(0..=255)?;
        let avm_popup_msg = u.int_in_range(0..=15)?;
        let avm_ready = u.int_in_range(0..=15)?;
        let avm_parking_assist_step = u.int_in_range(0..=15)?;
        let avm_front_btn_type = u.int_in_range(0..=15)?;
        let avm_option = u.int_in_range(0..=15)?;
        let avm_hu_front_view_point_opt = u.int_in_range(0..=15)?;
        let avm_hu_rear_view_option = u.int_in_range(0..=15)?;
        let avm_hu_front_view_option = u.int_in_range(0..=15)?;
        let avm_version = u.int_in_range(0..=65535)?;
        AvmHuPe00::new(avm_view,avm_parking_assist_btn_sts,avm_display_message,avm_popup_msg,avm_ready,avm_parking_assist_step,avm_front_btn_type,avm_option,avm_hu_front_view_point_opt,avm_hu_rear_view_option,avm_hu_front_view_option,avm_version).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// HU_AVM_PE_00
///
/// - ID: 1370 (0x55a)
/// - Size: 8 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct HuAvmPe00 {
    raw: [u8; 8],
}

impl HuAvmPe00 {
    pub const MESSAGE_ID: u32 = 1370;
    
    pub const HU_AVM_STATUS_MIN: u8 = 0_u8;
    pub const HU_AVM_STATUS_MAX: u8 = 3_u8;
    
    /// Construct new HU_AVM_PE_00 from values
    pub fn new(hu_avm_status: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_hu_avm_status(hu_avm_status)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// HU_AVM_Status
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: AVM, PGS
    #[inline(always)]
    pub fn hu_avm_status(&self) -> u8 {
        self.hu_avm_status_raw()
    }
    
    /// Get raw value of HU_AVM_Status
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hu_avm_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HU_AVM_Status
    #[inline(always)]
    pub fn set_hu_avm_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1370 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for HuAvmPe00 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for HuAvmPe00 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("HuAvmPe00")
                .field("hu_avm_status", &self.hu_avm_status())
            .finish()
        } else {
            f.debug_tuple("HuAvmPe00").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for HuAvmPe00 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let hu_avm_status = u.int_in_range(0..=3)?;
        HuAvmPe00::new(hu_avm_status).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// CGW4
///
/// - ID: 1369 (0x559)
/// - Size: 8 bytes
/// - Transmitter: BCM
#[derive(Clone, Copy)]
pub struct Cgw4 {
    raw: [u8; 8],
}

impl Cgw4 {
    pub const MESSAGE_ID: u32 = 1369;
    
    pub const CF_GWAY_DRV_SEAT_BELT_IND_MIN: u8 = 0_u8;
    pub const CF_GWAY_DRV_SEAT_BELT_IND_MAX: u8 = 3_u8;
    pub const CF_GWAY_AST_SEAT_BELT_IND_MIN: u8 = 0_u8;
    pub const CF_GWAY_AST_SEAT_BELT_IND_MAX: u8 = 3_u8;
    pub const CF_GWAY_RC_SEAT_BELT_IND_MIN: u8 = 0_u8;
    pub const CF_GWAY_RC_SEAT_BELT_IND_MAX: u8 = 3_u8;
    pub const CF_GWAY_RL_SEAT_BELT_IND_MIN: u8 = 0_u8;
    pub const CF_GWAY_RL_SEAT_BELT_IND_MAX: u8 = 3_u8;
    pub const CF_GWAY_RR_SEAT_BELT_IND_MIN: u8 = 0_u8;
    pub const CF_GWAY_RR_SEAT_BELT_IND_MAX: u8 = 3_u8;
    
    /// Construct new CGW4 from values
    pub fn new(cf_gway_memory_p1_cmd: bool, cf_gway_memory_p2_cmd: bool, cf_gway_p_back_p1_cmd: bool, cf_gway_p_back_p2_cmd: bool, cf_gway_strg_whl_heated_state: bool, cf_gway_p_back_stop_cmd: bool, cf_gway_static_bend_lh_act: bool, cf_gway_static_bend_rh_act: bool, cf_gway_drv_wdw_stat: bool, cf_gway_rl_wdw_state: bool, cf_gway_rr_wdw_state: bool, cf_gway_ast_wdw_stat: bool, cf_gway_memory_enable: bool, cf_gway_pback_stop_cmd: bool, cf_gway_pback_stop: bool, cf_gway_ims_buzzer: bool, cf_gway_drv_seat_belt_ind: u8, cf_gway_ast_seat_belt_ind: u8, cf_gway_rc_seat_belt_ind: u8, cf_gway_rl_seat_belt_ind: u8, cf_gway_rr_seat_belt_ind: u8, cf_gway_rr_wiper_high_sw: bool, cf_gway_rr_wiper_low_sw: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_gway_memory_p1_cmd(cf_gway_memory_p1_cmd)?;
        res.set_cf_gway_memory_p2_cmd(cf_gway_memory_p2_cmd)?;
        res.set_cf_gway_p_back_p1_cmd(cf_gway_p_back_p1_cmd)?;
        res.set_cf_gway_p_back_p2_cmd(cf_gway_p_back_p2_cmd)?;
        res.set_cf_gway_strg_whl_heated_state(cf_gway_strg_whl_heated_state)?;
        res.set_cf_gway_p_back_stop_cmd(cf_gway_p_back_stop_cmd)?;
        res.set_cf_gway_static_bend_lh_act(cf_gway_static_bend_lh_act)?;
        res.set_cf_gway_static_bend_rh_act(cf_gway_static_bend_rh_act)?;
        res.set_cf_gway_drv_wdw_stat(cf_gway_drv_wdw_stat)?;
        res.set_cf_gway_rl_wdw_state(cf_gway_rl_wdw_state)?;
        res.set_cf_gway_rr_wdw_state(cf_gway_rr_wdw_state)?;
        res.set_cf_gway_ast_wdw_stat(cf_gway_ast_wdw_stat)?;
        res.set_cf_gway_memory_enable(cf_gway_memory_enable)?;
        res.set_cf_gway_pback_stop_cmd(cf_gway_pback_stop_cmd)?;
        res.set_cf_gway_pback_stop(cf_gway_pback_stop)?;
        res.set_cf_gway_ims_buzzer(cf_gway_ims_buzzer)?;
        res.set_cf_gway_drv_seat_belt_ind(cf_gway_drv_seat_belt_ind)?;
        res.set_cf_gway_ast_seat_belt_ind(cf_gway_ast_seat_belt_ind)?;
        res.set_cf_gway_rc_seat_belt_ind(cf_gway_rc_seat_belt_ind)?;
        res.set_cf_gway_rl_seat_belt_ind(cf_gway_rl_seat_belt_ind)?;
        res.set_cf_gway_rr_seat_belt_ind(cf_gway_rr_seat_belt_ind)?;
        res.set_cf_gway_rr_wiper_high_sw(cf_gway_rr_wiper_high_sw)?;
        res.set_cf_gway_rr_wiper_low_sw(cf_gway_rr_wiper_low_sw)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Gway_MemoryP1Cmd
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_memory_p1_cmd(&self) -> bool {
        self.cf_gway_memory_p1_cmd_raw()
    }
    
    /// Get raw value of CF_Gway_MemoryP1Cmd
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_memory_p1_cmd_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_MemoryP1Cmd
    #[inline(always)]
    pub fn set_cf_gway_memory_p1_cmd(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_MemoryP2Cmd
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_memory_p2_cmd(&self) -> bool {
        self.cf_gway_memory_p2_cmd_raw()
    }
    
    /// Get raw value of CF_Gway_MemoryP2Cmd
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_memory_p2_cmd_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_MemoryP2Cmd
    #[inline(always)]
    pub fn set_cf_gway_memory_p2_cmd(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PBackP1Cmd
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_p_back_p1_cmd(&self) -> bool {
        self.cf_gway_p_back_p1_cmd_raw()
    }
    
    /// Get raw value of CF_Gway_PBackP1Cmd
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_p_back_p1_cmd_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_PBackP1Cmd
    #[inline(always)]
    pub fn set_cf_gway_p_back_p1_cmd(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PBackP2Cmd
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_p_back_p2_cmd(&self) -> bool {
        self.cf_gway_p_back_p2_cmd_raw()
    }
    
    /// Get raw value of CF_Gway_PBackP2Cmd
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_p_back_p2_cmd_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_PBackP2Cmd
    #[inline(always)]
    pub fn set_cf_gway_p_back_p2_cmd(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_StrgWhlHeatedState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_strg_whl_heated_state(&self) -> bool {
        self.cf_gway_strg_whl_heated_state_raw()
    }
    
    /// Get raw value of CF_Gway_StrgWhlHeatedState
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_strg_whl_heated_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_StrgWhlHeatedState
    #[inline(always)]
    pub fn set_cf_gway_strg_whl_heated_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PBackStopCmd
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, HUD
    #[inline(always)]
    pub fn cf_gway_p_back_stop_cmd(&self) -> bool {
        self.cf_gway_p_back_stop_cmd_raw()
    }
    
    /// Get raw value of CF_Gway_PBackStopCmd
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_p_back_stop_cmd_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_PBackStopCmd
    #[inline(always)]
    pub fn set_cf_gway_p_back_stop_cmd(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_StaticBendLhAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_static_bend_lh_act(&self) -> bool {
        self.cf_gway_static_bend_lh_act_raw()
    }
    
    /// Get raw value of CF_Gway_StaticBendLhAct
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_static_bend_lh_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_StaticBendLhAct
    #[inline(always)]
    pub fn set_cf_gway_static_bend_lh_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[6..7].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_StaticBendRhAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_static_bend_rh_act(&self) -> bool {
        self.cf_gway_static_bend_rh_act_raw()
    }
    
    /// Get raw value of CF_Gway_StaticBendRhAct
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_static_bend_rh_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_StaticBendRhAct
    #[inline(always)]
    pub fn set_cf_gway_static_bend_rh_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_DrvWdwStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_drv_wdw_stat(&self) -> bool {
        self.cf_gway_drv_wdw_stat_raw()
    }
    
    /// Get raw value of CF_Gway_DrvWdwStat
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_drv_wdw_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_DrvWdwStat
    #[inline(always)]
    pub fn set_cf_gway_drv_wdw_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[8..9].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RLWdwState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_rl_wdw_state(&self) -> bool {
        self.cf_gway_rl_wdw_state_raw()
    }
    
    /// Get raw value of CF_Gway_RLWdwState
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rl_wdw_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_RLWdwState
    #[inline(always)]
    pub fn set_cf_gway_rl_wdw_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[9..10].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RRWdwState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_rr_wdw_state(&self) -> bool {
        self.cf_gway_rr_wdw_state_raw()
    }
    
    /// Get raw value of CF_Gway_RRWdwState
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rr_wdw_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_RRWdwState
    #[inline(always)]
    pub fn set_cf_gway_rr_wdw_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[10..11].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_AstWdwStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_ast_wdw_stat(&self) -> bool {
        self.cf_gway_ast_wdw_stat_raw()
    }
    
    /// Get raw value of CF_Gway_AstWdwStat
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ast_wdw_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_AstWdwStat
    #[inline(always)]
    pub fn set_cf_gway_ast_wdw_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[11..12].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_MemoryEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_memory_enable(&self) -> bool {
        self.cf_gway_memory_enable_raw()
    }
    
    /// Get raw value of CF_Gway_MemoryEnable
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_memory_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_MemoryEnable
    #[inline(always)]
    pub fn set_cf_gway_memory_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[12..13].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PBACKStopCmd
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_pback_stop_cmd(&self) -> bool {
        self.cf_gway_pback_stop_cmd_raw()
    }
    
    /// Get raw value of CF_Gway_PBACKStopCmd
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pback_stop_cmd_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_PBACKStopCmd
    #[inline(always)]
    pub fn set_cf_gway_pback_stop_cmd(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[13..14].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PBACKStop
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, HUD
    #[inline(always)]
    pub fn cf_gway_pback_stop(&self) -> bool {
        self.cf_gway_pback_stop_raw()
    }
    
    /// Get raw value of CF_Gway_PBACKStop
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pback_stop_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_PBACKStop
    #[inline(always)]
    pub fn set_cf_gway_pback_stop(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[14..15].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_IMSBuzzer
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_ims_buzzer(&self) -> bool {
        self.cf_gway_ims_buzzer_raw()
    }
    
    /// Get raw value of CF_Gway_IMSBuzzer
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ims_buzzer_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_IMSBuzzer
    #[inline(always)]
    pub fn set_cf_gway_ims_buzzer(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[15..16].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_DrvSeatBeltInd
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_drv_seat_belt_ind(&self) -> u8 {
        self.cf_gway_drv_seat_belt_ind_raw()
    }
    
    /// Get raw value of CF_Gway_DrvSeatBeltInd
    ///
    /// - Start bit: 36
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_drv_seat_belt_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[36..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_DrvSeatBeltInd
    #[inline(always)]
    pub fn set_cf_gway_drv_seat_belt_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1369 });
        }
        self.raw.view_bits_mut::<Lsb0>()[36..38].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_AstSeatBeltInd
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_ast_seat_belt_ind(&self) -> u8 {
        self.cf_gway_ast_seat_belt_ind_raw()
    }
    
    /// Get raw value of CF_Gway_AstSeatBeltInd
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ast_seat_belt_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_AstSeatBeltInd
    #[inline(always)]
    pub fn set_cf_gway_ast_seat_belt_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1369 });
        }
        self.raw.view_bits_mut::<Lsb0>()[38..40].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RCSeatBeltInd
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_rc_seat_belt_ind(&self) -> u8 {
        self.cf_gway_rc_seat_belt_ind_raw()
    }
    
    /// Get raw value of CF_Gway_RCSeatBeltInd
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rc_seat_belt_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_RCSeatBeltInd
    #[inline(always)]
    pub fn set_cf_gway_rc_seat_belt_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1369 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..42].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RLSeatBeltInd
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_rl_seat_belt_ind(&self) -> u8 {
        self.cf_gway_rl_seat_belt_ind_raw()
    }
    
    /// Get raw value of CF_Gway_RLSeatBeltInd
    ///
    /// - Start bit: 42
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rl_seat_belt_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[42..44].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_RLSeatBeltInd
    #[inline(always)]
    pub fn set_cf_gway_rl_seat_belt_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1369 });
        }
        self.raw.view_bits_mut::<Lsb0>()[42..44].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RRSeatBeltInd
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_rr_seat_belt_ind(&self) -> u8 {
        self.cf_gway_rr_seat_belt_ind_raw()
    }
    
    /// Get raw value of CF_Gway_RRSeatBeltInd
    ///
    /// - Start bit: 44
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rr_seat_belt_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[44..46].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_RRSeatBeltInd
    #[inline(always)]
    pub fn set_cf_gway_rr_seat_belt_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1369 });
        }
        self.raw.view_bits_mut::<Lsb0>()[44..46].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RrWiperHighSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_rr_wiper_high_sw(&self) -> bool {
        self.cf_gway_rr_wiper_high_sw_raw()
    }
    
    /// Get raw value of CF_Gway_RrWiperHighSw
    ///
    /// - Start bit: 46
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rr_wiper_high_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[46..47].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_RrWiperHighSw
    #[inline(always)]
    pub fn set_cf_gway_rr_wiper_high_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[46..47].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RrWiperLowSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_rr_wiper_low_sw(&self) -> bool {
        self.cf_gway_rr_wiper_low_sw_raw()
    }
    
    /// Get raw value of CF_Gway_RrWiperLowSw
    ///
    /// - Start bit: 47
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rr_wiper_low_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[47..48].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_RrWiperLowSw
    #[inline(always)]
    pub fn set_cf_gway_rr_wiper_low_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[47..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Cgw4 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Cgw4 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Cgw4")
                .field("cf_gway_memory_p1_cmd", &self.cf_gway_memory_p1_cmd())
                .field("cf_gway_memory_p2_cmd", &self.cf_gway_memory_p2_cmd())
                .field("cf_gway_p_back_p1_cmd", &self.cf_gway_p_back_p1_cmd())
                .field("cf_gway_p_back_p2_cmd", &self.cf_gway_p_back_p2_cmd())
                .field("cf_gway_strg_whl_heated_state", &self.cf_gway_strg_whl_heated_state())
                .field("cf_gway_p_back_stop_cmd", &self.cf_gway_p_back_stop_cmd())
                .field("cf_gway_static_bend_lh_act", &self.cf_gway_static_bend_lh_act())
                .field("cf_gway_static_bend_rh_act", &self.cf_gway_static_bend_rh_act())
                .field("cf_gway_drv_wdw_stat", &self.cf_gway_drv_wdw_stat())
                .field("cf_gway_rl_wdw_state", &self.cf_gway_rl_wdw_state())
                .field("cf_gway_rr_wdw_state", &self.cf_gway_rr_wdw_state())
                .field("cf_gway_ast_wdw_stat", &self.cf_gway_ast_wdw_stat())
                .field("cf_gway_memory_enable", &self.cf_gway_memory_enable())
                .field("cf_gway_pback_stop_cmd", &self.cf_gway_pback_stop_cmd())
                .field("cf_gway_pback_stop", &self.cf_gway_pback_stop())
                .field("cf_gway_ims_buzzer", &self.cf_gway_ims_buzzer())
                .field("cf_gway_drv_seat_belt_ind", &self.cf_gway_drv_seat_belt_ind())
                .field("cf_gway_ast_seat_belt_ind", &self.cf_gway_ast_seat_belt_ind())
                .field("cf_gway_rc_seat_belt_ind", &self.cf_gway_rc_seat_belt_ind())
                .field("cf_gway_rl_seat_belt_ind", &self.cf_gway_rl_seat_belt_ind())
                .field("cf_gway_rr_seat_belt_ind", &self.cf_gway_rr_seat_belt_ind())
                .field("cf_gway_rr_wiper_high_sw", &self.cf_gway_rr_wiper_high_sw())
                .field("cf_gway_rr_wiper_low_sw", &self.cf_gway_rr_wiper_low_sw())
            .finish()
        } else {
            f.debug_tuple("Cgw4").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Cgw4 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_gway_memory_p1_cmd = u.int_in_range(0..=1)? == 1;
        let cf_gway_memory_p2_cmd = u.int_in_range(0..=1)? == 1;
        let cf_gway_p_back_p1_cmd = u.int_in_range(0..=1)? == 1;
        let cf_gway_p_back_p2_cmd = u.int_in_range(0..=1)? == 1;
        let cf_gway_strg_whl_heated_state = u.int_in_range(0..=1)? == 1;
        let cf_gway_p_back_stop_cmd = u.int_in_range(0..=1)? == 1;
        let cf_gway_static_bend_lh_act = u.int_in_range(0..=1)? == 1;
        let cf_gway_static_bend_rh_act = u.int_in_range(0..=1)? == 1;
        let cf_gway_drv_wdw_stat = u.int_in_range(0..=1)? == 1;
        let cf_gway_rl_wdw_state = u.int_in_range(0..=1)? == 1;
        let cf_gway_rr_wdw_state = u.int_in_range(0..=1)? == 1;
        let cf_gway_ast_wdw_stat = u.int_in_range(0..=1)? == 1;
        let cf_gway_memory_enable = u.int_in_range(0..=1)? == 1;
        let cf_gway_pback_stop_cmd = u.int_in_range(0..=1)? == 1;
        let cf_gway_pback_stop = u.int_in_range(0..=1)? == 1;
        let cf_gway_ims_buzzer = u.int_in_range(0..=1)? == 1;
        let cf_gway_drv_seat_belt_ind = u.int_in_range(0..=3)?;
        let cf_gway_ast_seat_belt_ind = u.int_in_range(0..=3)?;
        let cf_gway_rc_seat_belt_ind = u.int_in_range(0..=3)?;
        let cf_gway_rl_seat_belt_ind = u.int_in_range(0..=3)?;
        let cf_gway_rr_seat_belt_ind = u.int_in_range(0..=3)?;
        let cf_gway_rr_wiper_high_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_rr_wiper_low_sw = u.int_in_range(0..=1)? == 1;
        Cgw4::new(cf_gway_memory_p1_cmd,cf_gway_memory_p2_cmd,cf_gway_p_back_p1_cmd,cf_gway_p_back_p2_cmd,cf_gway_strg_whl_heated_state,cf_gway_p_back_stop_cmd,cf_gway_static_bend_lh_act,cf_gway_static_bend_rh_act,cf_gway_drv_wdw_stat,cf_gway_rl_wdw_state,cf_gway_rr_wdw_state,cf_gway_ast_wdw_stat,cf_gway_memory_enable,cf_gway_pback_stop_cmd,cf_gway_pback_stop,cf_gway_ims_buzzer,cf_gway_drv_seat_belt_ind,cf_gway_ast_seat_belt_ind,cf_gway_rc_seat_belt_ind,cf_gway_rl_seat_belt_ind,cf_gway_rr_seat_belt_ind,cf_gway_rr_wiper_high_sw,cf_gway_rr_wiper_low_sw).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EngFrzFrm12
///
/// - ID: 1367 (0x557)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct EngFrzFrm12 {
    raw: [u8; 8],
}

impl EngFrzFrm12 {
    pub const MESSAGE_ID: u32 = 1367;
    
    pub const PID_06H_MIN: f32 = -100_f32;
    pub const PID_06H_MAX: f32 = 99.22_f32;
    pub const PID_07H_MIN: f32 = -100_f32;
    pub const PID_07H_MAX: f32 = 99.22_f32;
    pub const PID_08H_MIN: f32 = -100_f32;
    pub const PID_08H_MAX: f32 = 99.22_f32;
    pub const PID_09H_MIN: f32 = -100_f32;
    pub const PID_09H_MAX: f32 = 99.22_f32;
    pub const PID_0BH_MIN: u8 = 0_u8;
    pub const PID_0BH_MAX: u8 = 255_u8;
    pub const PID_23H_MIN: f32 = 0_f32;
    pub const PID_23H_MAX: f32 = 655350_f32;
    
    /// Construct new EngFrzFrm12 from values
    pub fn new(pid_06h: f32, pid_07h: f32, pid_08h: f32, pid_09h: f32, pid_0bh: u8, pid_23h: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_pid_06h(pid_06h)?;
        res.set_pid_07h(pid_07h)?;
        res.set_pid_08h(pid_08h)?;
        res.set_pid_09h(pid_09h)?;
        res.set_pid_0bh(pid_0bh)?;
        res.set_pid_23h(pid_23h)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// PID_06h
    ///
    /// - Min: -100
    /// - Max: 99.22
    /// - Unit: "%"
    /// - Receivers: AAF, IBOX, TCU
    #[inline(always)]
    pub fn pid_06h(&self) -> f32 {
        self.pid_06h_raw()
    }
    
    /// Get raw value of PID_06h
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 0.78125
    /// - Offset: -100
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pid_06h_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 0.78125_f32;
        let offset = -100_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PID_06h
    #[inline(always)]
    pub fn set_pid_06h(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -100_f32 || 99.22_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1367 });
        }
        let factor = 0.78125_f32;
        let offset = -100_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// PID_07h
    ///
    /// - Min: -100
    /// - Max: 99.22
    /// - Unit: "%"
    /// - Receivers: AAF, IBOX, TCU
    #[inline(always)]
    pub fn pid_07h(&self) -> f32 {
        self.pid_07h_raw()
    }
    
    /// Get raw value of PID_07h
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.78125
    /// - Offset: -100
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pid_07h_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 0.78125_f32;
        let offset = -100_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PID_07h
    #[inline(always)]
    pub fn set_pid_07h(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -100_f32 || 99.22_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1367 });
        }
        let factor = 0.78125_f32;
        let offset = -100_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// PID_08h
    ///
    /// - Min: -100
    /// - Max: 99.22
    /// - Unit: "%"
    /// - Receivers: AAF, IBOX, TCU
    #[inline(always)]
    pub fn pid_08h(&self) -> f32 {
        self.pid_08h_raw()
    }
    
    /// Get raw value of PID_08h
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.78125
    /// - Offset: -100
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pid_08h_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 0.78125_f32;
        let offset = -100_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PID_08h
    #[inline(always)]
    pub fn set_pid_08h(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -100_f32 || 99.22_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1367 });
        }
        let factor = 0.78125_f32;
        let offset = -100_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// PID_09h
    ///
    /// - Min: -100
    /// - Max: 99.22
    /// - Unit: "%"
    /// - Receivers: AAF, IBOX, TCU
    #[inline(always)]
    pub fn pid_09h(&self) -> f32 {
        self.pid_09h_raw()
    }
    
    /// Get raw value of PID_09h
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.78125
    /// - Offset: -100
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pid_09h_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 0.78125_f32;
        let offset = -100_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PID_09h
    #[inline(always)]
    pub fn set_pid_09h(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -100_f32 || 99.22_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1367 });
        }
        let factor = 0.78125_f32;
        let offset = -100_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// PID_0Bh
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: "kPa"
    /// - Receivers: AAF, IBOX, TCU
    #[inline(always)]
    pub fn pid_0bh(&self) -> u8 {
        self.pid_0bh_raw()
    }
    
    /// Get raw value of PID_0Bh
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pid_0bh_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PID_0Bh
    #[inline(always)]
    pub fn set_pid_0bh(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1367 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// PID_23h
    ///
    /// - Min: 0
    /// - Max: 655350
    /// - Unit: "kPa"
    /// - Receivers: AAF, IBOX, TCU
    #[inline(always)]
    pub fn pid_23h(&self) -> f32 {
        self.pid_23h_raw()
    }
    
    /// Get raw value of PID_23h
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pid_23h_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..56].load_le::<u16>();
        
        let factor = 10_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PID_23h
    #[inline(always)]
    pub fn set_pid_23h(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 655350_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1367 });
        }
        let factor = 10_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[40..56].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for EngFrzFrm12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for EngFrzFrm12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("EngFrzFrm12")
                .field("pid_06h", &self.pid_06h())
                .field("pid_07h", &self.pid_07h())
                .field("pid_08h", &self.pid_08h())
                .field("pid_09h", &self.pid_09h())
                .field("pid_0bh", &self.pid_0bh())
                .field("pid_23h", &self.pid_23h())
            .finish()
        } else {
            f.debug_tuple("EngFrzFrm12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for EngFrzFrm12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let pid_06h = u.float_in_range(-100_f32..=99.22_f32)?;
        let pid_07h = u.float_in_range(-100_f32..=99.22_f32)?;
        let pid_08h = u.float_in_range(-100_f32..=99.22_f32)?;
        let pid_09h = u.float_in_range(-100_f32..=99.22_f32)?;
        let pid_0bh = u.int_in_range(0..=255)?;
        let pid_23h = u.float_in_range(0_f32..=655350_f32)?;
        EngFrzFrm12::new(pid_06h,pid_07h,pid_08h,pid_09h,pid_0bh,pid_23h).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EngFrzFrm11
///
/// - ID: 1366 (0x556)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct EngFrzFrm11 {
    raw: [u8; 8],
}

impl EngFrzFrm11 {
    pub const MESSAGE_ID: u32 = 1366;
    
    pub const PID_04H_MIN: f32 = 0_f32;
    pub const PID_04H_MAX: f32 = 100_f32;
    pub const PID_05H_MIN: f32 = -40_f32;
    pub const PID_05H_MAX: f32 = 215_f32;
    pub const PID_0CH_MIN: f32 = 0_f32;
    pub const PID_0CH_MAX: f32 = 16383.75_f32;
    pub const PID_0DH_MIN: u8 = 0_u8;
    pub const PID_0DH_MAX: u8 = 255_u8;
    pub const PID_11H_MIN: f32 = 0_f32;
    pub const PID_11H_MAX: f32 = 100_f32;
    pub const PID_03H_MIN: u16 = 0_u16;
    pub const PID_03H_MAX: u16 = 65535_u16;
    
    /// Construct new EngFrzFrm11 from values
    pub fn new(pid_04h: f32, pid_05h: f32, pid_0ch: f32, pid_0dh: u8, pid_11h: f32, pid_03h: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_pid_04h(pid_04h)?;
        res.set_pid_05h(pid_05h)?;
        res.set_pid_0ch(pid_0ch)?;
        res.set_pid_0dh(pid_0dh)?;
        res.set_pid_11h(pid_11h)?;
        res.set_pid_03h(pid_03h)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// PID_04h
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: AAF, TCU
    #[inline(always)]
    pub fn pid_04h(&self) -> f32 {
        self.pid_04h_raw()
    }
    
    /// Get raw value of PID_04h
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 0.3921568627
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pid_04h_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 0.3921568627_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PID_04h
    #[inline(always)]
    pub fn set_pid_04h(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1366 });
        }
        let factor = 0.3921568627_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// PID_05h
    ///
    /// - Min: -40
    /// - Max: 215
    /// - Unit: "deg"
    /// - Receivers: AAF, TCU
    #[inline(always)]
    pub fn pid_05h(&self) -> f32 {
        self.pid_05h_raw()
    }
    
    /// Get raw value of PID_05h
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pid_05h_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PID_05h
    #[inline(always)]
    pub fn set_pid_05h(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 215_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1366 });
        }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// PID_0Ch
    ///
    /// - Min: 0
    /// - Max: 16383.75
    /// - Unit: "rpm"
    /// - Receivers: AAF, TCU
    #[inline(always)]
    pub fn pid_0ch(&self) -> f32 {
        self.pid_0ch_raw()
    }
    
    /// Get raw value of PID_0Ch
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.25
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pid_0ch_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<u16>();
        
        let factor = 0.25_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PID_0Ch
    #[inline(always)]
    pub fn set_pid_0ch(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 16383.75_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1366 });
        }
        let factor = 0.25_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// PID_0Dh
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: "km/h"
    /// - Receivers: AAF, TCU
    #[inline(always)]
    pub fn pid_0dh(&self) -> u8 {
        self.pid_0dh_raw()
    }
    
    /// Get raw value of PID_0Dh
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pid_0dh_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PID_0Dh
    #[inline(always)]
    pub fn set_pid_0dh(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1366 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// PID_11h
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: AAF, TCU
    #[inline(always)]
    pub fn pid_11h(&self) -> f32 {
        self.pid_11h_raw()
    }
    
    /// Get raw value of PID_11h
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.3921568627
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pid_11h_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 0.3921568627_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PID_11h
    #[inline(always)]
    pub fn set_pid_11h(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1366 });
        }
        let factor = 0.3921568627_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// PID_03h
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: AAF, TCU
    #[inline(always)]
    pub fn pid_03h(&self) -> u16 {
        self.pid_03h_raw()
    }
    
    /// Get raw value of PID_03h
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pid_03h_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<u16>();
        
        signal
    }
    
    /// Set value of PID_03h
    #[inline(always)]
    pub fn set_pid_03h(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1366 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for EngFrzFrm11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for EngFrzFrm11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("EngFrzFrm11")
                .field("pid_04h", &self.pid_04h())
                .field("pid_05h", &self.pid_05h())
                .field("pid_0ch", &self.pid_0ch())
                .field("pid_0dh", &self.pid_0dh())
                .field("pid_11h", &self.pid_11h())
                .field("pid_03h", &self.pid_03h())
            .finish()
        } else {
            f.debug_tuple("EngFrzFrm11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for EngFrzFrm11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let pid_04h = u.float_in_range(0_f32..=100_f32)?;
        let pid_05h = u.float_in_range(-40_f32..=215_f32)?;
        let pid_0ch = u.float_in_range(0_f32..=16383.75_f32)?;
        let pid_0dh = u.int_in_range(0..=255)?;
        let pid_11h = u.float_in_range(0_f32..=100_f32)?;
        let pid_03h = u.int_in_range(0..=65535)?;
        EngFrzFrm11::new(pid_04h,pid_05h,pid_0ch,pid_0dh,pid_11h,pid_03h).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// FPCM11
///
/// - ID: 1365 (0x555)
/// - Size: 8 bytes
/// - Transmitter: FPCM
#[derive(Clone, Copy)]
pub struct Fpcm11 {
    raw: [u8; 8],
}

impl Fpcm11 {
    pub const MESSAGE_ID: u32 = 1365;
    
    pub const CR_FPCM_LP_ACT_PRE_MIN: f32 = 0_f32;
    pub const CR_FPCM_LP_ACT_PRE_MAX: f32 = 800_f32;
    
    /// Construct new FPCM11 from values
    pub fn new(cr_fpcm_lp_act_pre: f32, cf_fpcm_lp_pump_over_cur: bool, cf_fpcm_pre_snr_hi: bool, cf_fpcm_pre_snr_disc: bool, cf_fpcm_pre_snr_short: bool, cf_fpcm_lp_pump_disc_short: bool, cf_fpcm_lp_system_error: bool, cf_fpcm_pre_snr_sig_err: bool, cf_fpcm_lp_ctr_cir_flt: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cr_fpcm_lp_act_pre(cr_fpcm_lp_act_pre)?;
        res.set_cf_fpcm_lp_pump_over_cur(cf_fpcm_lp_pump_over_cur)?;
        res.set_cf_fpcm_pre_snr_hi(cf_fpcm_pre_snr_hi)?;
        res.set_cf_fpcm_pre_snr_disc(cf_fpcm_pre_snr_disc)?;
        res.set_cf_fpcm_pre_snr_short(cf_fpcm_pre_snr_short)?;
        res.set_cf_fpcm_lp_pump_disc_short(cf_fpcm_lp_pump_disc_short)?;
        res.set_cf_fpcm_lp_system_error(cf_fpcm_lp_system_error)?;
        res.set_cf_fpcm_pre_snr_sig_err(cf_fpcm_pre_snr_sig_err)?;
        res.set_cf_fpcm_lp_ctr_cir_flt(cf_fpcm_lp_ctr_cir_flt)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CR_Fpcm_LPActPre
    ///
    /// - Min: 0
    /// - Max: 800
    /// - Unit: "kPa"
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cr_fpcm_lp_act_pre(&self) -> f32 {
        self.cr_fpcm_lp_act_pre_raw()
    }
    
    /// Get raw value of CR_Fpcm_LPActPre
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 3.137254902
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_fpcm_lp_act_pre_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 3.137254902_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Fpcm_LPActPre
    #[inline(always)]
    pub fn set_cr_fpcm_lp_act_pre(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 800_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1365 });
        }
        let factor = 3.137254902_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CF_Fpcm_LPPumpOverCur
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_fpcm_lp_pump_over_cur(&self) -> bool {
        self.cf_fpcm_lp_pump_over_cur_raw()
    }
    
    /// Get raw value of CF_Fpcm_LPPumpOverCur
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fpcm_lp_pump_over_cur_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fpcm_LPPumpOverCur
    #[inline(always)]
    pub fn set_cf_fpcm_lp_pump_over_cur(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[8..9].store_le(value);
        Ok(())
    }
    
    /// CF_Fpcm_PreSnrHi
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_fpcm_pre_snr_hi(&self) -> bool {
        self.cf_fpcm_pre_snr_hi_raw()
    }
    
    /// Get raw value of CF_Fpcm_PreSnrHi
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fpcm_pre_snr_hi_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fpcm_PreSnrHi
    #[inline(always)]
    pub fn set_cf_fpcm_pre_snr_hi(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[9..10].store_le(value);
        Ok(())
    }
    
    /// CF_Fpcm_PreSnrDisc
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_fpcm_pre_snr_disc(&self) -> bool {
        self.cf_fpcm_pre_snr_disc_raw()
    }
    
    /// Get raw value of CF_Fpcm_PreSnrDisc
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fpcm_pre_snr_disc_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fpcm_PreSnrDisc
    #[inline(always)]
    pub fn set_cf_fpcm_pre_snr_disc(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[10..11].store_le(value);
        Ok(())
    }
    
    /// CF_Fpcm_PreSnrShort
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_fpcm_pre_snr_short(&self) -> bool {
        self.cf_fpcm_pre_snr_short_raw()
    }
    
    /// Get raw value of CF_Fpcm_PreSnrShort
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fpcm_pre_snr_short_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fpcm_PreSnrShort
    #[inline(always)]
    pub fn set_cf_fpcm_pre_snr_short(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[11..12].store_le(value);
        Ok(())
    }
    
    /// CF_Fpcm_LPPumpDiscShort
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_fpcm_lp_pump_disc_short(&self) -> bool {
        self.cf_fpcm_lp_pump_disc_short_raw()
    }
    
    /// Get raw value of CF_Fpcm_LPPumpDiscShort
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fpcm_lp_pump_disc_short_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fpcm_LPPumpDiscShort
    #[inline(always)]
    pub fn set_cf_fpcm_lp_pump_disc_short(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[12..13].store_le(value);
        Ok(())
    }
    
    /// CF_Fpcm_LP_System_Error
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_fpcm_lp_system_error(&self) -> bool {
        self.cf_fpcm_lp_system_error_raw()
    }
    
    /// Get raw value of CF_Fpcm_LP_System_Error
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fpcm_lp_system_error_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fpcm_LP_System_Error
    #[inline(always)]
    pub fn set_cf_fpcm_lp_system_error(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[13..14].store_le(value);
        Ok(())
    }
    
    /// CF_Fpcm_PreSnrSigErr
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_fpcm_pre_snr_sig_err(&self) -> bool {
        self.cf_fpcm_pre_snr_sig_err_raw()
    }
    
    /// Get raw value of CF_Fpcm_PreSnrSigErr
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fpcm_pre_snr_sig_err_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fpcm_PreSnrSigErr
    #[inline(always)]
    pub fn set_cf_fpcm_pre_snr_sig_err(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[14..15].store_le(value);
        Ok(())
    }
    
    /// CF_Fpcm_LPCtrCirFlt
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_fpcm_lp_ctr_cir_flt(&self) -> bool {
        self.cf_fpcm_lp_ctr_cir_flt_raw()
    }
    
    /// Get raw value of CF_Fpcm_LPCtrCirFlt
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fpcm_lp_ctr_cir_flt_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Fpcm_LPCtrCirFlt
    #[inline(always)]
    pub fn set_cf_fpcm_lp_ctr_cir_flt(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[15..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Fpcm11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Fpcm11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Fpcm11")
                .field("cr_fpcm_lp_act_pre", &self.cr_fpcm_lp_act_pre())
                .field("cf_fpcm_lp_pump_over_cur", &self.cf_fpcm_lp_pump_over_cur())
                .field("cf_fpcm_pre_snr_hi", &self.cf_fpcm_pre_snr_hi())
                .field("cf_fpcm_pre_snr_disc", &self.cf_fpcm_pre_snr_disc())
                .field("cf_fpcm_pre_snr_short", &self.cf_fpcm_pre_snr_short())
                .field("cf_fpcm_lp_pump_disc_short", &self.cf_fpcm_lp_pump_disc_short())
                .field("cf_fpcm_lp_system_error", &self.cf_fpcm_lp_system_error())
                .field("cf_fpcm_pre_snr_sig_err", &self.cf_fpcm_pre_snr_sig_err())
                .field("cf_fpcm_lp_ctr_cir_flt", &self.cf_fpcm_lp_ctr_cir_flt())
            .finish()
        } else {
            f.debug_tuple("Fpcm11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Fpcm11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cr_fpcm_lp_act_pre = u.float_in_range(0_f32..=800_f32)?;
        let cf_fpcm_lp_pump_over_cur = u.int_in_range(0..=1)? == 1;
        let cf_fpcm_pre_snr_hi = u.int_in_range(0..=1)? == 1;
        let cf_fpcm_pre_snr_disc = u.int_in_range(0..=1)? == 1;
        let cf_fpcm_pre_snr_short = u.int_in_range(0..=1)? == 1;
        let cf_fpcm_lp_pump_disc_short = u.int_in_range(0..=1)? == 1;
        let cf_fpcm_lp_system_error = u.int_in_range(0..=1)? == 1;
        let cf_fpcm_pre_snr_sig_err = u.int_in_range(0..=1)? == 1;
        let cf_fpcm_lp_ctr_cir_flt = u.int_in_range(0..=1)? == 1;
        Fpcm11::new(cr_fpcm_lp_act_pre,cf_fpcm_lp_pump_over_cur,cf_fpcm_pre_snr_hi,cf_fpcm_pre_snr_disc,cf_fpcm_pre_snr_short,cf_fpcm_lp_pump_disc_short,cf_fpcm_lp_system_error,cf_fpcm_pre_snr_sig_err,cf_fpcm_lp_ctr_cir_flt).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// LVR12
///
/// - ID: 871 (0x367)
/// - Size: 8 bytes
/// - Transmitter: LVR
#[derive(Clone, Copy)]
pub struct Lvr12 {
    raw: [u8; 8],
}

impl Lvr12 {
    pub const MESSAGE_ID: u32 = 871;
    
    pub const CF_LVR_CRUISE_SET_MIN: u8 = 0_u8;
    pub const CF_LVR_CRUISE_SET_MAX: u8 = 255_u8;
    pub const CF_LVR_ISG_STATE_MIN: u8 = 0_u8;
    pub const CF_LVR_ISG_STATE_MAX: u8 = 3_u8;
    pub const CF_LVR_GEAR_MIN: u8 = 0_u8;
    pub const CF_LVR_GEAR_MAX: u8 = 15_u8;
    
    /// Construct new LVR12 from values
    pub fn new(cf_lvr_cruise_set: u8, cf_lvr_isg_state: u8, cf_lvr_gear: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_lvr_cruise_set(cf_lvr_cruise_set)?;
        res.set_cf_lvr_isg_state(cf_lvr_isg_state)?;
        res.set_cf_lvr_gear(cf_lvr_gear)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Lvr_CruiseSet
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU, TCU
    #[inline(always)]
    pub fn cf_lvr_cruise_set(&self) -> u8 {
        self.cf_lvr_cruise_set_raw()
    }
    
    /// Get raw value of CF_Lvr_CruiseSet
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_cruise_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lvr_CruiseSet
    #[inline(always)]
    pub fn set_cf_lvr_cruise_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 871 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CF_Lvr_IsgState
    ///
    /// Idle Stop and Go
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, TCU
    #[inline(always)]
    pub fn cf_lvr_isg_state(&self) -> Lvr12CfLvrIsgState {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        match signal {
            0 => Lvr12CfLvrIsgState::Enabled,
            1 => Lvr12CfLvrIsgState::Activated,
            2 => Lvr12CfLvrIsgState::Unknown,
            3 => Lvr12CfLvrIsgState::Disabled,
            _ => Lvr12CfLvrIsgState::_Other(self.cf_lvr_isg_state_raw()),
        }
    }
    
    /// Get raw value of CF_Lvr_IsgState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_isg_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lvr_IsgState
    #[inline(always)]
    pub fn set_cf_lvr_isg_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 871 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// CF_Lvr_Gear
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU, TCU
    #[inline(always)]
    pub fn cf_lvr_gear(&self) -> Lvr12CfLvrGear {
        let signal = self.raw.view_bits::<Lsb0>()[32..36].load_le::<u8>();
        
        match signal {
            12 => Lvr12CfLvrGear::T,
            5 => Lvr12CfLvrGear::D,
            8 => Lvr12CfLvrGear::S,
            6 => Lvr12CfLvrGear::N,
            7 => Lvr12CfLvrGear::R,
            0 => Lvr12CfLvrGear::P,
            _ => Lvr12CfLvrGear::_Other(self.cf_lvr_gear_raw()),
        }
    }
    
    /// Get raw value of CF_Lvr_Gear
    ///
    /// - Start bit: 32
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_gear_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lvr_Gear
    #[inline(always)]
    pub fn set_cf_lvr_gear(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 871 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..36].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Lvr12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Lvr12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Lvr12")
                .field("cf_lvr_cruise_set", &self.cf_lvr_cruise_set())
                .field("cf_lvr_isg_state", &self.cf_lvr_isg_state())
                .field("cf_lvr_gear", &self.cf_lvr_gear())
            .finish()
        } else {
            f.debug_tuple("Lvr12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Lvr12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_lvr_cruise_set = u.int_in_range(0..=255)?;
        let cf_lvr_isg_state = u.int_in_range(0..=3)?;
        let cf_lvr_gear = u.int_in_range(0..=15)?;
        Lvr12::new(cf_lvr_cruise_set,cf_lvr_isg_state,cf_lvr_gear).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for CF_Lvr_IsgState
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Lvr12CfLvrIsgState {
    Enabled,
    Activated,
    Unknown,
    Disabled,
    _Other(u8),
}

impl From<Lvr12CfLvrIsgState> for u8 {
    fn from(val: Lvr12CfLvrIsgState) -> u8 {
        match val {
            Lvr12CfLvrIsgState::Enabled => 0,
            Lvr12CfLvrIsgState::Activated => 1,
            Lvr12CfLvrIsgState::Unknown => 2,
            Lvr12CfLvrIsgState::Disabled => 3,
            Lvr12CfLvrIsgState::_Other(x) => x,
        }
    }
}

/// Defined values for CF_Lvr_Gear
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Lvr12CfLvrGear {
    T,
    D,
    S,
    N,
    R,
    P,
    _Other(u8),
}

impl From<Lvr12CfLvrGear> for u8 {
    fn from(val: Lvr12CfLvrGear) -> u8 {
        match val {
            Lvr12CfLvrGear::T => 12,
            Lvr12CfLvrGear::D => 5,
            Lvr12CfLvrGear::S => 8,
            Lvr12CfLvrGear::N => 6,
            Lvr12CfLvrGear::R => 7,
            Lvr12CfLvrGear::P => 0,
            Lvr12CfLvrGear::_Other(x) => x,
        }
    }
}


/// LVR11
///
/// - ID: 872 (0x368)
/// - Size: 8 bytes
/// - Transmitter: LVR
#[derive(Clone, Copy)]
pub struct Lvr11 {
    raw: [u8; 8],
}

impl Lvr11 {
    pub const MESSAGE_ID: u32 = 872;
    
    pub const CF_LVR_GEAR_INF_MIN: u8 = 0_u8;
    pub const CF_LVR_GEAR_INF_MAX: u8 = 15_u8;
    pub const CF_LVR_POS_INF_MIN: u8 = 0_u8;
    pub const CF_LVR_POS_INF_MAX: u8 = 15_u8;
    pub const CF_LVR_POS_CPL_MIN: u8 = 0_u8;
    pub const CF_LVR_POS_CPL_MAX: u8 = 15_u8;
    pub const CF_LVR_ULK_BUT_STAT_MIN: u8 = 0_u8;
    pub const CF_LVR_ULK_BUT_STAT_MAX: u8 = 3_u8;
    pub const CF_LVR_PN_STAT_MIN: u8 = 0_u8;
    pub const CF_LVR_PN_STAT_MAX: u8 = 3_u8;
    pub const CF_LVR_SHT_LK_STAT_MIN: u8 = 0_u8;
    pub const CF_LVR_SHT_LK_STAT_MAX: u8 = 15_u8;
    pub const CF_LVR_SHF_ERR_INF_MIN: u32 = 0_u32;
    pub const CF_LVR_SHF_ERR_INF_MAX: u32 = 8191_u32;
    pub const CF_LVR_AC_MIN: u8 = 0_u8;
    pub const CF_LVR_AC_MAX: u8 = 15_u8;
    pub const CF_LVR_CS_MIN: u8 = 0_u8;
    pub const CF_LVR_CS_MAX: u8 = 15_u8;
    
    /// Construct new LVR11 from values
    pub fn new(cf_lvr_gear_inf: u8, cf_lvr_p_rel_stat: bool, cf_lvr_bke_act: bool, cf_lvr_n_fn_stat: bool, cf_lvr_pos_inf: u8, cf_lvr_pos_cpl: u8, cf_lvr_ulk_but_stat: u8, cf_lvr_pn_stat: u8, cf_lvr_sht_lk_stat: u8, cf_lvr_shf_err_inf: u32, cf_lvr_ac: u8, cf_lvr_cs: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_lvr_gear_inf(cf_lvr_gear_inf)?;
        res.set_cf_lvr_p_rel_stat(cf_lvr_p_rel_stat)?;
        res.set_cf_lvr_bke_act(cf_lvr_bke_act)?;
        res.set_cf_lvr_n_fn_stat(cf_lvr_n_fn_stat)?;
        res.set_cf_lvr_pos_inf(cf_lvr_pos_inf)?;
        res.set_cf_lvr_pos_cpl(cf_lvr_pos_cpl)?;
        res.set_cf_lvr_ulk_but_stat(cf_lvr_ulk_but_stat)?;
        res.set_cf_lvr_pn_stat(cf_lvr_pn_stat)?;
        res.set_cf_lvr_sht_lk_stat(cf_lvr_sht_lk_stat)?;
        res.set_cf_lvr_shf_err_inf(cf_lvr_shf_err_inf)?;
        res.set_cf_lvr_ac(cf_lvr_ac)?;
        res.set_cf_lvr_cs(cf_lvr_cs)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Lvr_GearInf
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU, TCU
    #[inline(always)]
    pub fn cf_lvr_gear_inf(&self) -> u8 {
        self.cf_lvr_gear_inf_raw()
    }
    
    /// Get raw value of CF_Lvr_GearInf
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_gear_inf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lvr_GearInf
    #[inline(always)]
    pub fn set_cf_lvr_gear_inf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 872 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..4].store_le(value);
        Ok(())
    }
    
    /// CF_Lvr_PRelStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM, CLU, SMK, TCU
    #[inline(always)]
    pub fn cf_lvr_p_rel_stat(&self) -> bool {
        self.cf_lvr_p_rel_stat_raw()
    }
    
    /// Get raw value of CF_Lvr_PRelStat
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_p_rel_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Lvr_PRelStat
    #[inline(always)]
    pub fn set_cf_lvr_p_rel_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// CF_Lvr_BkeAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_lvr_bke_act(&self) -> bool {
        self.cf_lvr_bke_act_raw()
    }
    
    /// Get raw value of CF_Lvr_BkeAct
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_bke_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Lvr_BkeAct
    #[inline(always)]
    pub fn set_cf_lvr_bke_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// CF_Lvr_NFnStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_lvr_n_fn_stat(&self) -> bool {
        self.cf_lvr_n_fn_stat_raw()
    }
    
    /// Get raw value of CF_Lvr_NFnStat
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_n_fn_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Lvr_NFnStat
    #[inline(always)]
    pub fn set_cf_lvr_n_fn_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[6..7].store_le(value);
        Ok(())
    }
    
    /// CF_Lvr_PosInf
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_lvr_pos_inf(&self) -> u8 {
        self.cf_lvr_pos_inf_raw()
    }
    
    /// Get raw value of CF_Lvr_PosInf
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_pos_inf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lvr_PosInf
    #[inline(always)]
    pub fn set_cf_lvr_pos_inf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 872 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..12].store_le(value);
        Ok(())
    }
    
    /// CF_Lvr_PosCpl
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_lvr_pos_cpl(&self) -> u8 {
        self.cf_lvr_pos_cpl_raw()
    }
    
    /// Get raw value of CF_Lvr_PosCpl
    ///
    /// - Start bit: 12
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_pos_cpl_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lvr_PosCpl
    #[inline(always)]
    pub fn set_cf_lvr_pos_cpl(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 872 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..16].store_le(value);
        Ok(())
    }
    
    /// CF_Lvr_UlkButStat
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_lvr_ulk_but_stat(&self) -> u8 {
        self.cf_lvr_ulk_but_stat_raw()
    }
    
    /// Get raw value of CF_Lvr_UlkButStat
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_ulk_but_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lvr_UlkButStat
    #[inline(always)]
    pub fn set_cf_lvr_ulk_but_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 872 });
        }
        self.raw.view_bits_mut::<Lsb0>()[18..20].store_le(value);
        Ok(())
    }
    
    /// CF_Lvr_PNStat
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_lvr_pn_stat(&self) -> u8 {
        self.cf_lvr_pn_stat_raw()
    }
    
    /// Get raw value of CF_Lvr_PNStat
    ///
    /// - Start bit: 20
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_pn_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lvr_PNStat
    #[inline(always)]
    pub fn set_cf_lvr_pn_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 872 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..22].store_le(value);
        Ok(())
    }
    
    /// CF_Lvr_ShtLkStat
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_lvr_sht_lk_stat(&self) -> u8 {
        self.cf_lvr_sht_lk_stat_raw()
    }
    
    /// Get raw value of CF_Lvr_ShtLkStat
    ///
    /// - Start bit: 24
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_sht_lk_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lvr_ShtLkStat
    #[inline(always)]
    pub fn set_cf_lvr_sht_lk_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 872 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..28].store_le(value);
        Ok(())
    }
    
    /// CF_Lvr_ShfErrInf
    ///
    /// - Min: 0
    /// - Max: 8191
    /// - Unit: ""
    /// - Receivers: CLU, TCU
    #[inline(always)]
    pub fn cf_lvr_shf_err_inf(&self) -> u32 {
        self.cf_lvr_shf_err_inf_raw()
    }
    
    /// Get raw value of CF_Lvr_ShfErrInf
    ///
    /// - Start bit: 28
    /// - Signal size: 20 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_shf_err_inf_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<Lsb0>()[28..48].load_le::<u32>();
        
        signal
    }
    
    /// Set value of CF_Lvr_ShfErrInf
    #[inline(always)]
    pub fn set_cf_lvr_shf_err_inf(&mut self, value: u32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u32 || 8191_u32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 872 });
        }
        self.raw.view_bits_mut::<Lsb0>()[28..48].store_le(value);
        Ok(())
    }
    
    /// CF_Lvr_AC
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_lvr_ac(&self) -> u8 {
        self.cf_lvr_ac_raw()
    }
    
    /// Get raw value of CF_Lvr_AC
    ///
    /// - Start bit: 48
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_ac_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lvr_AC
    #[inline(always)]
    pub fn set_cf_lvr_ac(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 872 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..52].store_le(value);
        Ok(())
    }
    
    /// CF_Lvr_CS
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: TCU
    #[inline(always)]
    pub fn cf_lvr_cs(&self) -> u8 {
        self.cf_lvr_cs_raw()
    }
    
    /// Get raw value of CF_Lvr_CS
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lvr_cs_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lvr_CS
    #[inline(always)]
    pub fn set_cf_lvr_cs(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 872 });
        }
        self.raw.view_bits_mut::<Lsb0>()[52..56].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Lvr11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Lvr11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Lvr11")
                .field("cf_lvr_gear_inf", &self.cf_lvr_gear_inf())
                .field("cf_lvr_p_rel_stat", &self.cf_lvr_p_rel_stat())
                .field("cf_lvr_bke_act", &self.cf_lvr_bke_act())
                .field("cf_lvr_n_fn_stat", &self.cf_lvr_n_fn_stat())
                .field("cf_lvr_pos_inf", &self.cf_lvr_pos_inf())
                .field("cf_lvr_pos_cpl", &self.cf_lvr_pos_cpl())
                .field("cf_lvr_ulk_but_stat", &self.cf_lvr_ulk_but_stat())
                .field("cf_lvr_pn_stat", &self.cf_lvr_pn_stat())
                .field("cf_lvr_sht_lk_stat", &self.cf_lvr_sht_lk_stat())
                .field("cf_lvr_shf_err_inf", &self.cf_lvr_shf_err_inf())
                .field("cf_lvr_ac", &self.cf_lvr_ac())
                .field("cf_lvr_cs", &self.cf_lvr_cs())
            .finish()
        } else {
            f.debug_tuple("Lvr11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Lvr11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_lvr_gear_inf = u.int_in_range(0..=15)?;
        let cf_lvr_p_rel_stat = u.int_in_range(0..=1)? == 1;
        let cf_lvr_bke_act = u.int_in_range(0..=1)? == 1;
        let cf_lvr_n_fn_stat = u.int_in_range(0..=1)? == 1;
        let cf_lvr_pos_inf = u.int_in_range(0..=15)?;
        let cf_lvr_pos_cpl = u.int_in_range(0..=15)?;
        let cf_lvr_ulk_but_stat = u.int_in_range(0..=3)?;
        let cf_lvr_pn_stat = u.int_in_range(0..=3)?;
        let cf_lvr_sht_lk_stat = u.int_in_range(0..=15)?;
        let cf_lvr_shf_err_inf = u.int_in_range(0..=8191)?;
        let cf_lvr_ac = u.int_in_range(0..=15)?;
        let cf_lvr_cs = u.int_in_range(0..=15)?;
        Lvr11::new(cf_lvr_gear_inf,cf_lvr_p_rel_stat,cf_lvr_bke_act,cf_lvr_n_fn_stat,cf_lvr_pos_inf,cf_lvr_pos_cpl,cf_lvr_ulk_but_stat,cf_lvr_pn_stat,cf_lvr_sht_lk_stat,cf_lvr_shf_err_inf,cf_lvr_ac,cf_lvr_cs).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// CGW2
///
/// - ID: 1363 (0x553)
/// - Size: 8 bytes
/// - Transmitter: BCM
#[derive(Clone, Copy)]
pub struct Cgw2 {
    raw: [u8; 8],
}

impl Cgw2 {
    pub const MESSAGE_ID: u32 = 1363;
    
    pub const CF_GWAY_LDM_FAIL_MIN: u8 = 0_u8;
    pub const CF_GWAY_LDM_FAIL_MAX: u8 = 3_u8;
    pub const CF_GWAY_CLU_SW_GUI_CTRL_MIN: u8 = 0_u8;
    pub const CF_GWAY_CLU_SW_GUI_CTRL_MAX: u8 = 63_u8;
    pub const CF_GWAY_DRV_SEAT_BELT_IND_MIN: u8 = 0_u8;
    pub const CF_GWAY_DRV_SEAT_BELT_IND_MAX: u8 = 3_u8;
    pub const CF_GWAY_COUNTRY_CFG_MIN: u8 = 0_u8;
    pub const CF_GWAY_COUNTRY_CFG_MAX: u8 = 7_u8;
    pub const CF_GWAY_BCMRKEID_MIN: u8 = 0_u8;
    pub const CF_GWAY_BCMRKEID_MAX: u8 = 7_u8;
    pub const CF_GWAY_SMK_FOB_ID_MIN: u8 = 0_u8;
    pub const CF_GWAY_SMK_FOB_ID_MAX: u8 = 7_u8;
    pub const CF_GWAY_SMKRKE_CMD_MIN: u8 = 0_u8;
    pub const CF_GWAY_SMKRKE_CMD_MAX: u8 = 7_u8;
    pub const CF_GWAY_SMK_DISP_WARN_MIN: u8 = 0_u8;
    pub const CF_GWAY_SMK_DISP_WARN_MAX: u8 = 15_u8;
    pub const CF_GWAY_WNG_BUZ_MIN: u8 = 0_u8;
    pub const CF_GWAY_WNG_BUZ_MAX: u8 = 7_u8;
    
    /// Construct new CGW2 from values
    pub fn new(cf_gway_gway_diag_state: bool, cf_gway_ddm_diag_state: bool, cf_gway_scm_diag_state: bool, cf_gway_psm_diag_state: bool, cf_gway_sjb_diag_state: bool, cf_gway_ipm_diag_state: bool, cf_gway_ldm_fail: u8, cf_gway_clu_sw_gui_ctrl: u8, cf_gway_clu_sw_group: bool, cf_gway_clu_sw_mode: bool, cf_gway_clu_sw_enter: bool, cf_gway_auto_light_value: bool, cf_gway_brake_fluid_sw: bool, cf_gway_drv_seat_belt_ind: u8, cf_gway_av_tail: bool, cf_gway_rear_fog_act: bool, cf_gway_ext_tail_act: bool, cf_gway_rr_dr_sw: bool, cf_gway_rl_dr_sw: bool, cf_gway_int_tail_act: bool, cf_gway_country_cfg: u8, cf_gway_wiper_park_position: bool, cf_gway_hl_low_lh_fail: bool, cf_gway_hl_low_rh_fail: bool, cf_gway_escl_fail_warn: bool, cf_gway_escl_not_locked_warn: bool, cf_gway_escl_not_unlock_warn: bool, cf_gway_i_dout_warn: bool, cf_gway_immo_lp: bool, cf_gway_bcmrkeid: u8, cf_gway_vehicle_not_p_warn: bool, cf_gway_deactivation_warn: bool, cf_gway_key_bat_discharge_warn: bool, cf_gway_ssb_warn: bool, cf_gway_smk_fob_id: u8, cf_gway_smkrke_cmd: u8, cf_gway_auto_light_option: bool, cf_gway_sjb_delivery_mode: bool, cf_gway_keyout_lp: bool, cf_gway_smk_disp_warn: u8, cf_gway_wng_buz: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_gway_gway_diag_state(cf_gway_gway_diag_state)?;
        res.set_cf_gway_ddm_diag_state(cf_gway_ddm_diag_state)?;
        res.set_cf_gway_scm_diag_state(cf_gway_scm_diag_state)?;
        res.set_cf_gway_psm_diag_state(cf_gway_psm_diag_state)?;
        res.set_cf_gway_sjb_diag_state(cf_gway_sjb_diag_state)?;
        res.set_cf_gway_ipm_diag_state(cf_gway_ipm_diag_state)?;
        res.set_cf_gway_ldm_fail(cf_gway_ldm_fail)?;
        res.set_cf_gway_clu_sw_gui_ctrl(cf_gway_clu_sw_gui_ctrl)?;
        res.set_cf_gway_clu_sw_group(cf_gway_clu_sw_group)?;
        res.set_cf_gway_clu_sw_mode(cf_gway_clu_sw_mode)?;
        res.set_cf_gway_clu_sw_enter(cf_gway_clu_sw_enter)?;
        res.set_cf_gway_auto_light_value(cf_gway_auto_light_value)?;
        res.set_cf_gway_brake_fluid_sw(cf_gway_brake_fluid_sw)?;
        res.set_cf_gway_drv_seat_belt_ind(cf_gway_drv_seat_belt_ind)?;
        res.set_cf_gway_av_tail(cf_gway_av_tail)?;
        res.set_cf_gway_rear_fog_act(cf_gway_rear_fog_act)?;
        res.set_cf_gway_ext_tail_act(cf_gway_ext_tail_act)?;
        res.set_cf_gway_rr_dr_sw(cf_gway_rr_dr_sw)?;
        res.set_cf_gway_rl_dr_sw(cf_gway_rl_dr_sw)?;
        res.set_cf_gway_int_tail_act(cf_gway_int_tail_act)?;
        res.set_cf_gway_country_cfg(cf_gway_country_cfg)?;
        res.set_cf_gway_wiper_park_position(cf_gway_wiper_park_position)?;
        res.set_cf_gway_hl_low_lh_fail(cf_gway_hl_low_lh_fail)?;
        res.set_cf_gway_hl_low_rh_fail(cf_gway_hl_low_rh_fail)?;
        res.set_cf_gway_escl_fail_warn(cf_gway_escl_fail_warn)?;
        res.set_cf_gway_escl_not_locked_warn(cf_gway_escl_not_locked_warn)?;
        res.set_cf_gway_escl_not_unlock_warn(cf_gway_escl_not_unlock_warn)?;
        res.set_cf_gway_i_dout_warn(cf_gway_i_dout_warn)?;
        res.set_cf_gway_immo_lp(cf_gway_immo_lp)?;
        res.set_cf_gway_bcmrkeid(cf_gway_bcmrkeid)?;
        res.set_cf_gway_vehicle_not_p_warn(cf_gway_vehicle_not_p_warn)?;
        res.set_cf_gway_deactivation_warn(cf_gway_deactivation_warn)?;
        res.set_cf_gway_key_bat_discharge_warn(cf_gway_key_bat_discharge_warn)?;
        res.set_cf_gway_ssb_warn(cf_gway_ssb_warn)?;
        res.set_cf_gway_smk_fob_id(cf_gway_smk_fob_id)?;
        res.set_cf_gway_smkrke_cmd(cf_gway_smkrke_cmd)?;
        res.set_cf_gway_auto_light_option(cf_gway_auto_light_option)?;
        res.set_cf_gway_sjb_delivery_mode(cf_gway_sjb_delivery_mode)?;
        res.set_cf_gway_keyout_lp(cf_gway_keyout_lp)?;
        res.set_cf_gway_smk_disp_warn(cf_gway_smk_disp_warn)?;
        res.set_cf_gway_wng_buz(cf_gway_wng_buz)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Gway_GwayDiagState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_gway_diag_state(&self) -> bool {
        self.cf_gway_gway_diag_state_raw()
    }
    
    /// Get raw value of CF_Gway_GwayDiagState
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_gway_diag_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_GwayDiagState
    #[inline(always)]
    pub fn set_cf_gway_gway_diag_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_DDMDiagState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_ddm_diag_state(&self) -> bool {
        self.cf_gway_ddm_diag_state_raw()
    }
    
    /// Get raw value of CF_Gway_DDMDiagState
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ddm_diag_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_DDMDiagState
    #[inline(always)]
    pub fn set_cf_gway_ddm_diag_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_SCMDiagState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_scm_diag_state(&self) -> bool {
        self.cf_gway_scm_diag_state_raw()
    }
    
    /// Get raw value of CF_Gway_SCMDiagState
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_scm_diag_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_SCMDiagState
    #[inline(always)]
    pub fn set_cf_gway_scm_diag_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PSMDiagState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_psm_diag_state(&self) -> bool {
        self.cf_gway_psm_diag_state_raw()
    }
    
    /// Get raw value of CF_Gway_PSMDiagState
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_psm_diag_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_PSMDiagState
    #[inline(always)]
    pub fn set_cf_gway_psm_diag_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_SJBDiagState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_sjb_diag_state(&self) -> bool {
        self.cf_gway_sjb_diag_state_raw()
    }
    
    /// Get raw value of CF_Gway_SJBDiagState
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_sjb_diag_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_SJBDiagState
    #[inline(always)]
    pub fn set_cf_gway_sjb_diag_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_IPMDiagState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_ipm_diag_state(&self) -> bool {
        self.cf_gway_ipm_diag_state_raw()
    }
    
    /// Get raw value of CF_Gway_IPMDiagState
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ipm_diag_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_IPMDiagState
    #[inline(always)]
    pub fn set_cf_gway_ipm_diag_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_LDMFail
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, LDWS_LKAS, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_ldm_fail(&self) -> u8 {
        self.cf_gway_ldm_fail_raw()
    }
    
    /// Get raw value of CF_Gway_LDMFail
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ldm_fail_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_LDMFail
    #[inline(always)]
    pub fn set_cf_gway_ldm_fail(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1363 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_CLUSwGuiCtrl
    ///
    /// - Min: 0
    /// - Max: 63
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_clu_sw_gui_ctrl(&self) -> u8 {
        self.cf_gway_clu_sw_gui_ctrl_raw()
    }
    
    /// Get raw value of CF_Gway_CLUSwGuiCtrl
    ///
    /// - Start bit: 10
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_clu_sw_gui_ctrl_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_CLUSwGuiCtrl
    #[inline(always)]
    pub fn set_cf_gway_clu_sw_gui_ctrl(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 63_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1363 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..13].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_CLUSwGroup
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_clu_sw_group(&self) -> bool {
        self.cf_gway_clu_sw_group_raw()
    }
    
    /// Get raw value of CF_Gway_CLUSwGroup
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_clu_sw_group_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_CLUSwGroup
    #[inline(always)]
    pub fn set_cf_gway_clu_sw_group(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[13..14].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_CLUSwMode
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_clu_sw_mode(&self) -> bool {
        self.cf_gway_clu_sw_mode_raw()
    }
    
    /// Get raw value of CF_Gway_CLUSwMode
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_clu_sw_mode_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_CLUSwMode
    #[inline(always)]
    pub fn set_cf_gway_clu_sw_mode(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[14..15].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_CLUSwEnter
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_clu_sw_enter(&self) -> bool {
        self.cf_gway_clu_sw_enter_raw()
    }
    
    /// Get raw value of CF_Gway_CLUSwEnter
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_clu_sw_enter_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_CLUSwEnter
    #[inline(always)]
    pub fn set_cf_gway_clu_sw_enter(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[15..16].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_AutoLightValue
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LCA, LCA
    #[inline(always)]
    pub fn cf_gway_auto_light_value(&self) -> bool {
        self.cf_gway_auto_light_value_raw()
    }
    
    /// Get raw value of CF_Gway_AutoLightValue
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_auto_light_value_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_AutoLightValue
    #[inline(always)]
    pub fn set_cf_gway_auto_light_value(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[16..17].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_BrakeFluidSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_brake_fluid_sw(&self) -> bool {
        self.cf_gway_brake_fluid_sw_raw()
    }
    
    /// Get raw value of CF_Gway_BrakeFluidSw
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_brake_fluid_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_BrakeFluidSw
    #[inline(always)]
    pub fn set_cf_gway_brake_fluid_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[17..18].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_DrvSeatBeltInd
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_drv_seat_belt_ind(&self) -> u8 {
        self.cf_gway_drv_seat_belt_ind_raw()
    }
    
    /// Get raw value of CF_Gway_DrvSeatBeltInd
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_drv_seat_belt_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_DrvSeatBeltInd
    #[inline(always)]
    pub fn set_cf_gway_drv_seat_belt_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1363 });
        }
        self.raw.view_bits_mut::<Lsb0>()[18..20].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_AvTail
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, SNV, SNV
    #[inline(always)]
    pub fn cf_gway_av_tail(&self) -> bool {
        self.cf_gway_av_tail_raw()
    }
    
    /// Get raw value of CF_Gway_AvTail
    ///
    /// - Start bit: 20
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_av_tail_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[20..21].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_AvTail
    #[inline(always)]
    pub fn set_cf_gway_av_tail(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[20..21].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RearFogAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_rear_fog_act(&self) -> bool {
        self.cf_gway_rear_fog_act_raw()
    }
    
    /// Get raw value of CF_Gway_RearFogAct
    ///
    /// - Start bit: 21
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rear_fog_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[21..22].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_RearFogAct
    #[inline(always)]
    pub fn set_cf_gway_rear_fog_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[21..22].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_ExtTailAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: AVM, CLU, LCA, PGS, SPAS, AVM, LCA, PGS, SPAS
    #[inline(always)]
    pub fn cf_gway_ext_tail_act(&self) -> bool {
        self.cf_gway_ext_tail_act_raw()
    }
    
    /// Get raw value of CF_Gway_ExtTailAct
    ///
    /// - Start bit: 22
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ext_tail_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[22..23].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_ExtTailAct
    #[inline(always)]
    pub fn set_cf_gway_ext_tail_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[22..23].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RRDrSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_rr_dr_sw(&self) -> bool {
        self.cf_gway_rr_dr_sw_raw()
    }
    
    /// Get raw value of CF_Gway_RRDrSw
    ///
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rr_dr_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[23..24].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_RRDrSw
    #[inline(always)]
    pub fn set_cf_gway_rr_dr_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[23..24].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RLDrSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_rl_dr_sw(&self) -> bool {
        self.cf_gway_rl_dr_sw_raw()
    }
    
    /// Get raw value of CF_Gway_RLDrSw
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rl_dr_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_RLDrSw
    #[inline(always)]
    pub fn set_cf_gway_rl_dr_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[24..25].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_IntTailAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_int_tail_act(&self) -> bool {
        self.cf_gway_int_tail_act_raw()
    }
    
    /// Get raw value of CF_Gway_IntTailAct
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_int_tail_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_IntTailAct
    #[inline(always)]
    pub fn set_cf_gway_int_tail_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[25..26].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_CountryCfg
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU, PGS, Dummy
    #[inline(always)]
    pub fn cf_gway_country_cfg(&self) -> u8 {
        self.cf_gway_country_cfg_raw()
    }
    
    /// Get raw value of CF_Gway_CountryCfg
    ///
    /// - Start bit: 26
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_country_cfg_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[26..29].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_CountryCfg
    #[inline(always)]
    pub fn set_cf_gway_country_cfg(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1363 });
        }
        self.raw.view_bits_mut::<Lsb0>()[26..29].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_WiperParkPosition
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: AFLS, EMS, LDWS_LKAS, AFLS, EMS, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_wiper_park_position(&self) -> bool {
        self.cf_gway_wiper_park_position_raw()
    }
    
    /// Get raw value of CF_Gway_WiperParkPosition
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_wiper_park_position_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_WiperParkPosition
    #[inline(always)]
    pub fn set_cf_gway_wiper_park_position(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[32..33].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_HLLowLHFail
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS, SNV, LDWS_LKAS, SNV
    #[inline(always)]
    pub fn cf_gway_hl_low_lh_fail(&self) -> bool {
        self.cf_gway_hl_low_lh_fail_raw()
    }
    
    /// Get raw value of CF_Gway_HLLowLHFail
    ///
    /// - Start bit: 33
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_hl_low_lh_fail_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[33..34].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_HLLowLHFail
    #[inline(always)]
    pub fn set_cf_gway_hl_low_lh_fail(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[33..34].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_HLLowRHFail
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS, SNV, LDWS_LKAS, SNV
    #[inline(always)]
    pub fn cf_gway_hl_low_rh_fail(&self) -> bool {
        self.cf_gway_hl_low_rh_fail_raw()
    }
    
    /// Get raw value of CF_Gway_HLLowRHFail
    ///
    /// - Start bit: 34
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_hl_low_rh_fail_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[34..35].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_HLLowRHFail
    #[inline(always)]
    pub fn set_cf_gway_hl_low_rh_fail(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[34..35].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_ESCLFailWarn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_escl_fail_warn(&self) -> bool {
        self.cf_gway_escl_fail_warn_raw()
    }
    
    /// Get raw value of CF_Gway_ESCLFailWarn
    ///
    /// - Start bit: 35
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_escl_fail_warn_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[35..36].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_ESCLFailWarn
    #[inline(always)]
    pub fn set_cf_gway_escl_fail_warn(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[35..36].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_ESCLNotLockedWarn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_escl_not_locked_warn(&self) -> bool {
        self.cf_gway_escl_not_locked_warn_raw()
    }
    
    /// Get raw value of CF_Gway_ESCLNotLockedWarn
    ///
    /// - Start bit: 36
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_escl_not_locked_warn_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[36..37].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_ESCLNotLockedWarn
    #[inline(always)]
    pub fn set_cf_gway_escl_not_locked_warn(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[36..37].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_ESCLNotUnlockWarn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_escl_not_unlock_warn(&self) -> bool {
        self.cf_gway_escl_not_unlock_warn_raw()
    }
    
    /// Get raw value of CF_Gway_ESCLNotUnlockWarn
    ///
    /// - Start bit: 37
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_escl_not_unlock_warn_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[37..38].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_ESCLNotUnlockWarn
    #[inline(always)]
    pub fn set_cf_gway_escl_not_unlock_warn(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[37..38].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_IDoutWarn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_i_dout_warn(&self) -> bool {
        self.cf_gway_i_dout_warn_raw()
    }
    
    /// Get raw value of CF_Gway_IDoutWarn
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_i_dout_warn_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_IDoutWarn
    #[inline(always)]
    pub fn set_cf_gway_i_dout_warn(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[38..39].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_ImmoLp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_immo_lp(&self) -> bool {
        self.cf_gway_immo_lp_raw()
    }
    
    /// Get raw value of CF_Gway_ImmoLp
    ///
    /// - Start bit: 40
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_immo_lp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[40..41].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_ImmoLp
    #[inline(always)]
    pub fn set_cf_gway_immo_lp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[40..41].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_BCMRKEID
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_bcmrkeid(&self) -> u8 {
        self.cf_gway_bcmrkeid_raw()
    }
    
    /// Get raw value of CF_Gway_BCMRKEID
    ///
    /// - Start bit: 41
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_bcmrkeid_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[41..44].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_BCMRKEID
    #[inline(always)]
    pub fn set_cf_gway_bcmrkeid(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1363 });
        }
        self.raw.view_bits_mut::<Lsb0>()[41..44].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_VehicleNotPWarn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_vehicle_not_p_warn(&self) -> bool {
        self.cf_gway_vehicle_not_p_warn_raw()
    }
    
    /// Get raw value of CF_Gway_VehicleNotPWarn
    ///
    /// - Start bit: 44
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_vehicle_not_p_warn_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[44..45].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_VehicleNotPWarn
    #[inline(always)]
    pub fn set_cf_gway_vehicle_not_p_warn(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[44..45].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_DeactivationWarn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_deactivation_warn(&self) -> bool {
        self.cf_gway_deactivation_warn_raw()
    }
    
    /// Get raw value of CF_Gway_DeactivationWarn
    ///
    /// - Start bit: 45
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_deactivation_warn_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[45..46].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_DeactivationWarn
    #[inline(always)]
    pub fn set_cf_gway_deactivation_warn(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[45..46].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_KeyBATDischargeWarn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_key_bat_discharge_warn(&self) -> bool {
        self.cf_gway_key_bat_discharge_warn_raw()
    }
    
    /// Get raw value of CF_Gway_KeyBATDischargeWarn
    ///
    /// - Start bit: 46
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_key_bat_discharge_warn_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[46..47].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_KeyBATDischargeWarn
    #[inline(always)]
    pub fn set_cf_gway_key_bat_discharge_warn(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[46..47].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_SSBWarn
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_ssb_warn(&self) -> bool {
        self.cf_gway_ssb_warn_raw()
    }
    
    /// Get raw value of CF_Gway_SSBWarn
    ///
    /// - Start bit: 47
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ssb_warn_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[47..48].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_SSBWarn
    #[inline(always)]
    pub fn set_cf_gway_ssb_warn(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[47..48].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_SMKFobID
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_smk_fob_id(&self) -> u8 {
        self.cf_gway_smk_fob_id_raw()
    }
    
    /// Get raw value of CF_Gway_SMKFobID
    ///
    /// - Start bit: 48
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_smk_fob_id_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..51].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_SMKFobID
    #[inline(always)]
    pub fn set_cf_gway_smk_fob_id(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1363 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..51].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_SMKRKECmd
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_smkrke_cmd(&self) -> u8 {
        self.cf_gway_smkrke_cmd_raw()
    }
    
    /// Get raw value of CF_Gway_SMKRKECmd
    ///
    /// - Start bit: 51
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_smkrke_cmd_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[51..54].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_SMKRKECmd
    #[inline(always)]
    pub fn set_cf_gway_smkrke_cmd(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1363 });
        }
        self.raw.view_bits_mut::<Lsb0>()[51..54].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_AutoLightOption
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_auto_light_option(&self) -> bool {
        self.cf_gway_auto_light_option_raw()
    }
    
    /// Get raw value of CF_Gway_AutoLightOption
    ///
    /// - Start bit: 54
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_auto_light_option_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[54..55].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_AutoLightOption
    #[inline(always)]
    pub fn set_cf_gway_auto_light_option(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[54..55].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_SJBDeliveryMode
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_sjb_delivery_mode(&self) -> bool {
        self.cf_gway_sjb_delivery_mode_raw()
    }
    
    /// Get raw value of CF_Gway_SJBDeliveryMode
    ///
    /// - Start bit: 55
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_sjb_delivery_mode_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[55..56].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_SJBDeliveryMode
    #[inline(always)]
    pub fn set_cf_gway_sjb_delivery_mode(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[55..56].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_KeyoutLp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_keyout_lp(&self) -> bool {
        self.cf_gway_keyout_lp_raw()
    }
    
    /// Get raw value of CF_Gway_KeyoutLp
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_keyout_lp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_KeyoutLp
    #[inline(always)]
    pub fn set_cf_gway_keyout_lp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[56..57].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_SMKDispWarn
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_smk_disp_warn(&self) -> u8 {
        self.cf_gway_smk_disp_warn_raw()
    }
    
    /// Get raw value of CF_Gway_SMKDispWarn
    ///
    /// - Start bit: 57
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_smk_disp_warn_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[57..61].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_SMKDispWarn
    #[inline(always)]
    pub fn set_cf_gway_smk_disp_warn(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1363 });
        }
        self.raw.view_bits_mut::<Lsb0>()[57..61].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_WngBuz
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_wng_buz(&self) -> u8 {
        self.cf_gway_wng_buz_raw()
    }
    
    /// Get raw value of CF_Gway_WngBuz
    ///
    /// - Start bit: 61
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_wng_buz_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[61..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_WngBuz
    #[inline(always)]
    pub fn set_cf_gway_wng_buz(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1363 });
        }
        self.raw.view_bits_mut::<Lsb0>()[61..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Cgw2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Cgw2 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Cgw2")
                .field("cf_gway_gway_diag_state", &self.cf_gway_gway_diag_state())
                .field("cf_gway_ddm_diag_state", &self.cf_gway_ddm_diag_state())
                .field("cf_gway_scm_diag_state", &self.cf_gway_scm_diag_state())
                .field("cf_gway_psm_diag_state", &self.cf_gway_psm_diag_state())
                .field("cf_gway_sjb_diag_state", &self.cf_gway_sjb_diag_state())
                .field("cf_gway_ipm_diag_state", &self.cf_gway_ipm_diag_state())
                .field("cf_gway_ldm_fail", &self.cf_gway_ldm_fail())
                .field("cf_gway_clu_sw_gui_ctrl", &self.cf_gway_clu_sw_gui_ctrl())
                .field("cf_gway_clu_sw_group", &self.cf_gway_clu_sw_group())
                .field("cf_gway_clu_sw_mode", &self.cf_gway_clu_sw_mode())
                .field("cf_gway_clu_sw_enter", &self.cf_gway_clu_sw_enter())
                .field("cf_gway_auto_light_value", &self.cf_gway_auto_light_value())
                .field("cf_gway_brake_fluid_sw", &self.cf_gway_brake_fluid_sw())
                .field("cf_gway_drv_seat_belt_ind", &self.cf_gway_drv_seat_belt_ind())
                .field("cf_gway_av_tail", &self.cf_gway_av_tail())
                .field("cf_gway_rear_fog_act", &self.cf_gway_rear_fog_act())
                .field("cf_gway_ext_tail_act", &self.cf_gway_ext_tail_act())
                .field("cf_gway_rr_dr_sw", &self.cf_gway_rr_dr_sw())
                .field("cf_gway_rl_dr_sw", &self.cf_gway_rl_dr_sw())
                .field("cf_gway_int_tail_act", &self.cf_gway_int_tail_act())
                .field("cf_gway_country_cfg", &self.cf_gway_country_cfg())
                .field("cf_gway_wiper_park_position", &self.cf_gway_wiper_park_position())
                .field("cf_gway_hl_low_lh_fail", &self.cf_gway_hl_low_lh_fail())
                .field("cf_gway_hl_low_rh_fail", &self.cf_gway_hl_low_rh_fail())
                .field("cf_gway_escl_fail_warn", &self.cf_gway_escl_fail_warn())
                .field("cf_gway_escl_not_locked_warn", &self.cf_gway_escl_not_locked_warn())
                .field("cf_gway_escl_not_unlock_warn", &self.cf_gway_escl_not_unlock_warn())
                .field("cf_gway_i_dout_warn", &self.cf_gway_i_dout_warn())
                .field("cf_gway_immo_lp", &self.cf_gway_immo_lp())
                .field("cf_gway_bcmrkeid", &self.cf_gway_bcmrkeid())
                .field("cf_gway_vehicle_not_p_warn", &self.cf_gway_vehicle_not_p_warn())
                .field("cf_gway_deactivation_warn", &self.cf_gway_deactivation_warn())
                .field("cf_gway_key_bat_discharge_warn", &self.cf_gway_key_bat_discharge_warn())
                .field("cf_gway_ssb_warn", &self.cf_gway_ssb_warn())
                .field("cf_gway_smk_fob_id", &self.cf_gway_smk_fob_id())
                .field("cf_gway_smkrke_cmd", &self.cf_gway_smkrke_cmd())
                .field("cf_gway_auto_light_option", &self.cf_gway_auto_light_option())
                .field("cf_gway_sjb_delivery_mode", &self.cf_gway_sjb_delivery_mode())
                .field("cf_gway_keyout_lp", &self.cf_gway_keyout_lp())
                .field("cf_gway_smk_disp_warn", &self.cf_gway_smk_disp_warn())
                .field("cf_gway_wng_buz", &self.cf_gway_wng_buz())
            .finish()
        } else {
            f.debug_tuple("Cgw2").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Cgw2 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_gway_gway_diag_state = u.int_in_range(0..=1)? == 1;
        let cf_gway_ddm_diag_state = u.int_in_range(0..=1)? == 1;
        let cf_gway_scm_diag_state = u.int_in_range(0..=1)? == 1;
        let cf_gway_psm_diag_state = u.int_in_range(0..=1)? == 1;
        let cf_gway_sjb_diag_state = u.int_in_range(0..=1)? == 1;
        let cf_gway_ipm_diag_state = u.int_in_range(0..=1)? == 1;
        let cf_gway_ldm_fail = u.int_in_range(0..=3)?;
        let cf_gway_clu_sw_gui_ctrl = u.int_in_range(0..=63)?;
        let cf_gway_clu_sw_group = u.int_in_range(0..=1)? == 1;
        let cf_gway_clu_sw_mode = u.int_in_range(0..=1)? == 1;
        let cf_gway_clu_sw_enter = u.int_in_range(0..=1)? == 1;
        let cf_gway_auto_light_value = u.int_in_range(0..=1)? == 1;
        let cf_gway_brake_fluid_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_drv_seat_belt_ind = u.int_in_range(0..=3)?;
        let cf_gway_av_tail = u.int_in_range(0..=1)? == 1;
        let cf_gway_rear_fog_act = u.int_in_range(0..=1)? == 1;
        let cf_gway_ext_tail_act = u.int_in_range(0..=1)? == 1;
        let cf_gway_rr_dr_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_rl_dr_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_int_tail_act = u.int_in_range(0..=1)? == 1;
        let cf_gway_country_cfg = u.int_in_range(0..=7)?;
        let cf_gway_wiper_park_position = u.int_in_range(0..=1)? == 1;
        let cf_gway_hl_low_lh_fail = u.int_in_range(0..=1)? == 1;
        let cf_gway_hl_low_rh_fail = u.int_in_range(0..=1)? == 1;
        let cf_gway_escl_fail_warn = u.int_in_range(0..=1)? == 1;
        let cf_gway_escl_not_locked_warn = u.int_in_range(0..=1)? == 1;
        let cf_gway_escl_not_unlock_warn = u.int_in_range(0..=1)? == 1;
        let cf_gway_i_dout_warn = u.int_in_range(0..=1)? == 1;
        let cf_gway_immo_lp = u.int_in_range(0..=1)? == 1;
        let cf_gway_bcmrkeid = u.int_in_range(0..=7)?;
        let cf_gway_vehicle_not_p_warn = u.int_in_range(0..=1)? == 1;
        let cf_gway_deactivation_warn = u.int_in_range(0..=1)? == 1;
        let cf_gway_key_bat_discharge_warn = u.int_in_range(0..=1)? == 1;
        let cf_gway_ssb_warn = u.int_in_range(0..=1)? == 1;
        let cf_gway_smk_fob_id = u.int_in_range(0..=7)?;
        let cf_gway_smkrke_cmd = u.int_in_range(0..=7)?;
        let cf_gway_auto_light_option = u.int_in_range(0..=1)? == 1;
        let cf_gway_sjb_delivery_mode = u.int_in_range(0..=1)? == 1;
        let cf_gway_keyout_lp = u.int_in_range(0..=1)? == 1;
        let cf_gway_smk_disp_warn = u.int_in_range(0..=15)?;
        let cf_gway_wng_buz = u.int_in_range(0..=7)?;
        Cgw2::new(cf_gway_gway_diag_state,cf_gway_ddm_diag_state,cf_gway_scm_diag_state,cf_gway_psm_diag_state,cf_gway_sjb_diag_state,cf_gway_ipm_diag_state,cf_gway_ldm_fail,cf_gway_clu_sw_gui_ctrl,cf_gway_clu_sw_group,cf_gway_clu_sw_mode,cf_gway_clu_sw_enter,cf_gway_auto_light_value,cf_gway_brake_fluid_sw,cf_gway_drv_seat_belt_ind,cf_gway_av_tail,cf_gway_rear_fog_act,cf_gway_ext_tail_act,cf_gway_rr_dr_sw,cf_gway_rl_dr_sw,cf_gway_int_tail_act,cf_gway_country_cfg,cf_gway_wiper_park_position,cf_gway_hl_low_lh_fail,cf_gway_hl_low_rh_fail,cf_gway_escl_fail_warn,cf_gway_escl_not_locked_warn,cf_gway_escl_not_unlock_warn,cf_gway_i_dout_warn,cf_gway_immo_lp,cf_gway_bcmrkeid,cf_gway_vehicle_not_p_warn,cf_gway_deactivation_warn,cf_gway_key_bat_discharge_warn,cf_gway_ssb_warn,cf_gway_smk_fob_id,cf_gway_smkrke_cmd,cf_gway_auto_light_option,cf_gway_sjb_delivery_mode,cf_gway_keyout_lp,cf_gway_smk_disp_warn,cf_gway_wng_buz).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// TCS11
///
/// - ID: 339 (0x153)
/// - Size: 8 bytes
/// - Transmitter: ESC
#[derive(Clone, Copy)]
pub struct Tcs11 {
    raw: [u8; 8],
}

impl Tcs11 {
    pub const MESSAGE_ID: u32 = 339;
    
    pub const CF_ESC_LIMO_INFO_MIN: u8 = 0_u8;
    pub const CF_ESC_LIMO_INFO_MAX: u8 = 3_u8;
    pub const ESS_STAT_MIN: u8 = 0_u8;
    pub const ESS_STAT_MAX: u8 = 3_u8;
    pub const TQI_TCS_MIN: f32 = 0_f32;
    pub const TQI_TCS_MAX: f32 = 99.609375_f32;
    pub const TQI_MSR_MIN: f32 = 0_f32;
    pub const TQI_MSR_MAX: f32 = 99.609375_f32;
    pub const TQI_SLW_TCS_MIN: f32 = 0_f32;
    pub const TQI_SLW_TCS_MAX: f32 = 99.609375_f32;
    pub const BLA_CTL_MIN: u8 = 0_u8;
    pub const BLA_CTL_MAX: u8 = 3_u8;
    pub const ALIVE_COUNTER_TCS1_MIN: u8 = 0_u8;
    pub const ALIVE_COUNTER_TCS1_MAX: u8 = 14_u8;
    pub const CHECK_SUM_TCS1_MIN: u8 = 0_u8;
    pub const CHECK_SUM_TCS1_MAX: u8 = 255_u8;
    
    /// Construct new TCS11 from values
    pub fn new(tcs_req: bool, msr_c_req: bool, tcs_pas: bool, tcs_gsc: bool, cf_esc_limo_info: u8, abs_diag: bool, abs_def: bool, tcs_def: bool, tcs_ctl: bool, abs_act: bool, ebd_def: bool, esp_pas: bool, esp_def: bool, esp_ctl: bool, tcs_mfrn: bool, dbc_ctl: bool, dbc_pas: bool, dbc_def: bool, hac_ctl: bool, hac_pas: bool, hac_def: bool, ess_stat: u8, tqi_tcs: f32, tqi_msr: f32, tqi_slw_tcs: f32, cf_esc_brk_ctl: bool, bla_ctl: u8, alive_counter_tcs1: u8, check_sum_tcs1: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_tcs_req(tcs_req)?;
        res.set_msr_c_req(msr_c_req)?;
        res.set_tcs_pas(tcs_pas)?;
        res.set_tcs_gsc(tcs_gsc)?;
        res.set_cf_esc_limo_info(cf_esc_limo_info)?;
        res.set_abs_diag(abs_diag)?;
        res.set_abs_def(abs_def)?;
        res.set_tcs_def(tcs_def)?;
        res.set_tcs_ctl(tcs_ctl)?;
        res.set_abs_act(abs_act)?;
        res.set_ebd_def(ebd_def)?;
        res.set_esp_pas(esp_pas)?;
        res.set_esp_def(esp_def)?;
        res.set_esp_ctl(esp_ctl)?;
        res.set_tcs_mfrn(tcs_mfrn)?;
        res.set_dbc_ctl(dbc_ctl)?;
        res.set_dbc_pas(dbc_pas)?;
        res.set_dbc_def(dbc_def)?;
        res.set_hac_ctl(hac_ctl)?;
        res.set_hac_pas(hac_pas)?;
        res.set_hac_def(hac_def)?;
        res.set_ess_stat(ess_stat)?;
        res.set_tqi_tcs(tqi_tcs)?;
        res.set_tqi_msr(tqi_msr)?;
        res.set_tqi_slw_tcs(tqi_slw_tcs)?;
        res.set_cf_esc_brk_ctl(cf_esc_brk_ctl)?;
        res.set_bla_ctl(bla_ctl)?;
        res.set_alive_counter_tcs1(alive_counter_tcs1)?;
        res.set_check_sum_tcs1(check_sum_tcs1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// TCS_REQ
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, EPB, TCU
    #[inline(always)]
    pub fn tcs_req(&self) -> bool {
        self.tcs_req_raw()
    }
    
    /// Get raw value of TCS_REQ
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tcs_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of TCS_REQ
    #[inline(always)]
    pub fn set_tcs_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// MSR_C_REQ
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, EPB, SCC, TCU
    #[inline(always)]
    pub fn msr_c_req(&self) -> bool {
        self.msr_c_req_raw()
    }
    
    /// Get raw value of MSR_C_REQ
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn msr_c_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of MSR_C_REQ
    #[inline(always)]
    pub fn set_msr_c_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// TCS_PAS
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, CLU, EMS, SCC, SPAS, TCU
    #[inline(always)]
    pub fn tcs_pas(&self) -> bool {
        self.tcs_pas_raw()
    }
    
    /// Get raw value of TCS_PAS
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tcs_pas_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of TCS_PAS
    #[inline(always)]
    pub fn set_tcs_pas(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// TCS_GSC
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, TCU
    #[inline(always)]
    pub fn tcs_gsc(&self) -> bool {
        self.tcs_gsc_raw()
    }
    
    /// Get raw value of TCS_GSC
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tcs_gsc_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of TCS_GSC
    #[inline(always)]
    pub fn set_tcs_gsc(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// CF_Esc_LimoInfo
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: _4WD, SCC
    #[inline(always)]
    pub fn cf_esc_limo_info(&self) -> u8 {
        self.cf_esc_limo_info_raw()
    }
    
    /// Get raw value of CF_Esc_LimoInfo
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_esc_limo_info_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Esc_LimoInfo
    #[inline(always)]
    pub fn set_cf_esc_limo_info(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 339 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
    /// ABS_DIAG
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, CLU, EMS, EPB
    #[inline(always)]
    pub fn abs_diag(&self) -> bool {
        self.abs_diag_raw()
    }
    
    /// Get raw value of ABS_DIAG
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn abs_diag_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ABS_DIAG
    #[inline(always)]
    pub fn set_abs_diag(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[6..7].store_le(value);
        Ok(())
    }
    
    /// ABS_DEF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ACU, ECS, EMS, EPB, SCC, SPAS, TCU
    #[inline(always)]
    pub fn abs_def(&self) -> bool {
        self.abs_def_raw()
    }
    
    /// Get raw value of ABS_DEF
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn abs_def_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ABS_DEF
    #[inline(always)]
    pub fn set_abs_def(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// TCS_DEF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, EPB, SCC, SPAS, TCU
    #[inline(always)]
    pub fn tcs_def(&self) -> bool {
        self.tcs_def_raw()
    }
    
    /// Get raw value of TCS_DEF
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tcs_def_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of TCS_DEF
    #[inline(always)]
    pub fn set_tcs_def(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[8..9].store_le(value);
        Ok(())
    }
    
    /// TCS_CTL
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, EPB, SCC, SPAS, TCU
    #[inline(always)]
    pub fn tcs_ctl(&self) -> bool {
        self.tcs_ctl_raw()
    }
    
    /// Get raw value of TCS_CTL
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tcs_ctl_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of TCS_CTL
    #[inline(always)]
    pub fn set_tcs_ctl(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[9..10].store_le(value);
        Ok(())
    }
    
    /// ABS_ACT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ACU, ECS, EMS, EPB, LDWS_LKAS, SCC, SPAS, TCU
    #[inline(always)]
    pub fn abs_act(&self) -> bool {
        self.abs_act_raw()
    }
    
    /// Get raw value of ABS_ACT
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn abs_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ABS_ACT
    #[inline(always)]
    pub fn set_abs_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[10..11].store_le(value);
        Ok(())
    }
    
    /// EBD_DEF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, EPB, SPAS, TCU
    #[inline(always)]
    pub fn ebd_def(&self) -> bool {
        self.ebd_def_raw()
    }
    
    /// Get raw value of EBD_DEF
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ebd_def_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of EBD_DEF
    #[inline(always)]
    pub fn set_ebd_def(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[11..12].store_le(value);
        Ok(())
    }
    
    /// ESP_PAS
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ACU, CLU, EMS, EPB, LDWS_LKAS, SCC, TCU
    #[inline(always)]
    pub fn esp_pas(&self) -> bool {
        self.esp_pas_raw()
    }
    
    /// Get raw value of ESP_PAS
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_pas_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_PAS
    #[inline(always)]
    pub fn set_esp_pas(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[12..13].store_le(value);
        Ok(())
    }
    
    /// ESP_DEF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ACU, ECS, EMS, EPB, LDWS_LKAS, SCC, TCU
    #[inline(always)]
    pub fn esp_def(&self) -> bool {
        self.esp_def_raw()
    }
    
    /// Get raw value of ESP_DEF
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_def_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_DEF
    #[inline(always)]
    pub fn set_esp_def(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[13..14].store_le(value);
        Ok(())
    }
    
    /// ESP_CTL
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ACU, ECS, EMS, EPB, LDWS_LKAS, SCC, SPAS, TCU
    #[inline(always)]
    pub fn esp_ctl(&self) -> bool {
        self.esp_ctl_raw()
    }
    
    /// Get raw value of ESP_CTL
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp_ctl_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ESP_CTL
    #[inline(always)]
    pub fn set_esp_ctl(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[14..15].store_le(value);
        Ok(())
    }
    
    /// TCS_MFRN
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, EPB, TCU
    #[inline(always)]
    pub fn tcs_mfrn(&self) -> bool {
        self.tcs_mfrn_raw()
    }
    
    /// Get raw value of TCS_MFRN
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tcs_mfrn_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of TCS_MFRN
    #[inline(always)]
    pub fn set_tcs_mfrn(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[15..16].store_le(value);
        Ok(())
    }
    
    /// DBC_CTL
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, EPB
    #[inline(always)]
    pub fn dbc_ctl(&self) -> bool {
        self.dbc_ctl_raw()
    }
    
    /// Get raw value of DBC_CTL
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dbc_ctl_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DBC_CTL
    #[inline(always)]
    pub fn set_dbc_ctl(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[16..17].store_le(value);
        Ok(())
    }
    
    /// DBC_PAS
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, EPB
    #[inline(always)]
    pub fn dbc_pas(&self) -> bool {
        self.dbc_pas_raw()
    }
    
    /// Get raw value of DBC_PAS
    ///
    /// - Start bit: 17
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dbc_pas_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[17..18].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DBC_PAS
    #[inline(always)]
    pub fn set_dbc_pas(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[17..18].store_le(value);
        Ok(())
    }
    
    /// DBC_DEF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, EPB
    #[inline(always)]
    pub fn dbc_def(&self) -> bool {
        self.dbc_def_raw()
    }
    
    /// Get raw value of DBC_DEF
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dbc_def_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DBC_DEF
    #[inline(always)]
    pub fn set_dbc_def(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[18..19].store_le(value);
        Ok(())
    }
    
    /// HAC_CTL
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, CLU, EMS, EPB, TCU
    #[inline(always)]
    pub fn hac_ctl(&self) -> bool {
        self.hac_ctl_raw()
    }
    
    /// Get raw value of HAC_CTL
    ///
    /// - Start bit: 19
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hac_ctl_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[19..20].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HAC_CTL
    #[inline(always)]
    pub fn set_hac_ctl(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[19..20].store_le(value);
        Ok(())
    }
    
    /// HAC_PAS
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, CLU, EMS, EPB, TCU
    #[inline(always)]
    pub fn hac_pas(&self) -> bool {
        self.hac_pas_raw()
    }
    
    /// Get raw value of HAC_PAS
    ///
    /// - Start bit: 20
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hac_pas_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[20..21].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HAC_PAS
    #[inline(always)]
    pub fn set_hac_pas(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[20..21].store_le(value);
        Ok(())
    }
    
    /// HAC_DEF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, CLU, EMS, EPB, TCU
    #[inline(always)]
    pub fn hac_def(&self) -> bool {
        self.hac_def_raw()
    }
    
    /// Get raw value of HAC_DEF
    ///
    /// - Start bit: 21
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hac_def_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[21..22].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HAC_DEF
    #[inline(always)]
    pub fn set_hac_def(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[21..22].store_le(value);
        Ok(())
    }
    
    /// ESS_STAT
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: _4WD, BCM, CLU, EMS, EPB
    #[inline(always)]
    pub fn ess_stat(&self) -> u8 {
        self.ess_stat_raw()
    }
    
    /// Get raw value of ESS_STAT
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ess_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESS_STAT
    #[inline(always)]
    pub fn set_ess_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 339 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
    /// TQI_TCS
    ///
    /// - Min: 0
    /// - Max: 99.609375
    /// - Unit: "%"
    /// - Receivers: EMS, EPB, TCU
    #[inline(always)]
    pub fn tqi_tcs(&self) -> f32 {
        self.tqi_tcs_raw()
    }
    
    /// Get raw value of TQI_TCS
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_tcs_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI_TCS
    #[inline(always)]
    pub fn set_tqi_tcs(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.609375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 339 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// TQI_MSR
    ///
    /// - Min: 0
    /// - Max: 99.609375
    /// - Unit: "%"
    /// - Receivers: EMS, EPB, TCU
    #[inline(always)]
    pub fn tqi_msr(&self) -> f32 {
        self.tqi_msr_raw()
    }
    
    /// Get raw value of TQI_MSR
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_msr_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI_MSR
    #[inline(always)]
    pub fn set_tqi_msr(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.609375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 339 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// TQI_SLW_TCS
    ///
    /// - Min: 0
    /// - Max: 99.609375
    /// - Unit: "%"
    /// - Receivers: EMS, EPB, TCU
    #[inline(always)]
    pub fn tqi_slw_tcs(&self) -> f32 {
        self.tqi_slw_tcs_raw()
    }
    
    /// Get raw value of TQI_SLW_TCS
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_slw_tcs_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI_SLW_TCS
    #[inline(always)]
    pub fn set_tqi_slw_tcs(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.609375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 339 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// CF_Esc_BrkCtl
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_esc_brk_ctl(&self) -> bool {
        self.cf_esc_brk_ctl_raw()
    }
    
    /// Get raw value of CF_Esc_BrkCtl
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_esc_brk_ctl_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Esc_BrkCtl
    #[inline(always)]
    pub fn set_cf_esc_brk_ctl(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[48..49].store_le(value);
        Ok(())
    }
    
    /// BLA_CTL
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CGW, CLU
    #[inline(always)]
    pub fn bla_ctl(&self) -> u8 {
        self.bla_ctl_raw()
    }
    
    /// Get raw value of BLA_CTL
    ///
    /// - Start bit: 49
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bla_ctl_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[49..51].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BLA_CTL
    #[inline(always)]
    pub fn set_bla_ctl(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 339 });
        }
        self.raw.view_bits_mut::<Lsb0>()[49..51].store_le(value);
        Ok(())
    }
    
    /// AliveCounter_TCS1
    ///
    /// - Min: 0
    /// - Max: 14
    /// - Unit: ""
    /// - Receivers: EMS, EPB, LDWS_LKAS
    #[inline(always)]
    pub fn alive_counter_tcs1(&self) -> u8 {
        self.alive_counter_tcs1_raw()
    }
    
    /// Get raw value of AliveCounter_TCS1
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn alive_counter_tcs1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AliveCounter_TCS1
    #[inline(always)]
    pub fn set_alive_counter_tcs1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 14_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 339 });
        }
        self.raw.view_bits_mut::<Lsb0>()[52..56].store_le(value);
        Ok(())
    }
    
    /// CheckSum_TCS1
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS, EPB, LDWS_LKAS
    #[inline(always)]
    pub fn check_sum_tcs1(&self) -> u8 {
        self.check_sum_tcs1_raw()
    }
    
    /// Get raw value of CheckSum_TCS1
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn check_sum_tcs1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CheckSum_TCS1
    #[inline(always)]
    pub fn set_check_sum_tcs1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 339 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Tcs11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Tcs11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Tcs11")
                .field("tcs_req", &self.tcs_req())
                .field("msr_c_req", &self.msr_c_req())
                .field("tcs_pas", &self.tcs_pas())
                .field("tcs_gsc", &self.tcs_gsc())
                .field("cf_esc_limo_info", &self.cf_esc_limo_info())
                .field("abs_diag", &self.abs_diag())
                .field("abs_def", &self.abs_def())
                .field("tcs_def", &self.tcs_def())
                .field("tcs_ctl", &self.tcs_ctl())
                .field("abs_act", &self.abs_act())
                .field("ebd_def", &self.ebd_def())
                .field("esp_pas", &self.esp_pas())
                .field("esp_def", &self.esp_def())
                .field("esp_ctl", &self.esp_ctl())
                .field("tcs_mfrn", &self.tcs_mfrn())
                .field("dbc_ctl", &self.dbc_ctl())
                .field("dbc_pas", &self.dbc_pas())
                .field("dbc_def", &self.dbc_def())
                .field("hac_ctl", &self.hac_ctl())
                .field("hac_pas", &self.hac_pas())
                .field("hac_def", &self.hac_def())
                .field("ess_stat", &self.ess_stat())
                .field("tqi_tcs", &self.tqi_tcs())
                .field("tqi_msr", &self.tqi_msr())
                .field("tqi_slw_tcs", &self.tqi_slw_tcs())
                .field("cf_esc_brk_ctl", &self.cf_esc_brk_ctl())
                .field("bla_ctl", &self.bla_ctl())
                .field("alive_counter_tcs1", &self.alive_counter_tcs1())
                .field("check_sum_tcs1", &self.check_sum_tcs1())
            .finish()
        } else {
            f.debug_tuple("Tcs11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Tcs11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let tcs_req = u.int_in_range(0..=1)? == 1;
        let msr_c_req = u.int_in_range(0..=1)? == 1;
        let tcs_pas = u.int_in_range(0..=1)? == 1;
        let tcs_gsc = u.int_in_range(0..=1)? == 1;
        let cf_esc_limo_info = u.int_in_range(0..=3)?;
        let abs_diag = u.int_in_range(0..=1)? == 1;
        let abs_def = u.int_in_range(0..=1)? == 1;
        let tcs_def = u.int_in_range(0..=1)? == 1;
        let tcs_ctl = u.int_in_range(0..=1)? == 1;
        let abs_act = u.int_in_range(0..=1)? == 1;
        let ebd_def = u.int_in_range(0..=1)? == 1;
        let esp_pas = u.int_in_range(0..=1)? == 1;
        let esp_def = u.int_in_range(0..=1)? == 1;
        let esp_ctl = u.int_in_range(0..=1)? == 1;
        let tcs_mfrn = u.int_in_range(0..=1)? == 1;
        let dbc_ctl = u.int_in_range(0..=1)? == 1;
        let dbc_pas = u.int_in_range(0..=1)? == 1;
        let dbc_def = u.int_in_range(0..=1)? == 1;
        let hac_ctl = u.int_in_range(0..=1)? == 1;
        let hac_pas = u.int_in_range(0..=1)? == 1;
        let hac_def = u.int_in_range(0..=1)? == 1;
        let ess_stat = u.int_in_range(0..=3)?;
        let tqi_tcs = u.float_in_range(0_f32..=99.609375_f32)?;
        let tqi_msr = u.float_in_range(0_f32..=99.609375_f32)?;
        let tqi_slw_tcs = u.float_in_range(0_f32..=99.609375_f32)?;
        let cf_esc_brk_ctl = u.int_in_range(0..=1)? == 1;
        let bla_ctl = u.int_in_range(0..=3)?;
        let alive_counter_tcs1 = u.int_in_range(0..=14)?;
        let check_sum_tcs1 = u.int_in_range(0..=255)?;
        Tcs11::new(tcs_req,msr_c_req,tcs_pas,tcs_gsc,cf_esc_limo_info,abs_diag,abs_def,tcs_def,tcs_ctl,abs_act,ebd_def,esp_pas,esp_def,esp_ctl,tcs_mfrn,dbc_ctl,dbc_pas,dbc_def,hac_ctl,hac_pas,hac_def,ess_stat,tqi_tcs,tqi_msr,tqi_slw_tcs,cf_esc_brk_ctl,bla_ctl,alive_counter_tcs1,check_sum_tcs1).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// SNV11
///
/// - ID: 1362 (0x552)
/// - Size: 4 bytes
/// - Transmitter: SNV
#[derive(Clone, Copy)]
pub struct Snv11 {
    raw: [u8; 4],
}

impl Snv11 {
    pub const MESSAGE_ID: u32 = 1362;
    
    pub const CF_SNV_DISPLAY_CONTROL_MIN: u8 = 0_u8;
    pub const CF_SNV_DISPLAY_CONTROL_MAX: u8 = 3_u8;
    pub const CF_SNV_BEEP_WARNING_MIN: u8 = 0_u8;
    pub const CF_SNV_BEEP_WARNING_MAX: u8 = 3_u8;
    pub const CF_SNV_WARNING_MESSAGE_MIN: u8 = 0_u8;
    pub const CF_SNV_WARNING_MESSAGE_MAX: u8 = 7_u8;
    pub const CF_SNV_PEDESTRIAN_DETECT_MIN: u8 = 0_u8;
    pub const CF_SNV_PEDESTRIAN_DETECT_MAX: u8 = 3_u8;
    pub const CF_SNV_IR_LAMP_CONTROL_MIN: u8 = 0_u8;
    pub const CF_SNV_IR_LAMP_CONTROL_MAX: u8 = 3_u8;
    
    /// Construct new SNV11 from values
    pub fn new(cf_snv_display_control: u8, cf_snv_beep_warning: u8, cf_snv_warning_message: u8, cf_snv_detection_enable: bool, cf_snv_pedestrian_detect: u8, cf_snv_ir_lamp_control: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_cf_snv_display_control(cf_snv_display_control)?;
        res.set_cf_snv_beep_warning(cf_snv_beep_warning)?;
        res.set_cf_snv_warning_message(cf_snv_warning_message)?;
        res.set_cf_snv_detection_enable(cf_snv_detection_enable)?;
        res.set_cf_snv_pedestrian_detect(cf_snv_pedestrian_detect)?;
        res.set_cf_snv_ir_lamp_control(cf_snv_ir_lamp_control)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 4] {
        &self.raw
    }
    
    /// CF_SNV_DisplayControl
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, HUD
    #[inline(always)]
    pub fn cf_snv_display_control(&self) -> u8 {
        self.cf_snv_display_control_raw()
    }
    
    /// Get raw value of CF_SNV_DisplayControl
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_snv_display_control_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_SNV_DisplayControl
    #[inline(always)]
    pub fn set_cf_snv_display_control(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1362 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// CF_Snv_BeepWarning
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, HUD
    #[inline(always)]
    pub fn cf_snv_beep_warning(&self) -> u8 {
        self.cf_snv_beep_warning_raw()
    }
    
    /// Get raw value of CF_Snv_BeepWarning
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_snv_beep_warning_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Snv_BeepWarning
    #[inline(always)]
    pub fn set_cf_snv_beep_warning(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1362 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// CF_Snv_WarningMessage
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, HUD
    #[inline(always)]
    pub fn cf_snv_warning_message(&self) -> u8 {
        self.cf_snv_warning_message_raw()
    }
    
    /// Get raw value of CF_Snv_WarningMessage
    ///
    /// - Start bit: 4
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_snv_warning_message_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Snv_WarningMessage
    #[inline(always)]
    pub fn set_cf_snv_warning_message(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1362 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..7].store_le(value);
        Ok(())
    }
    
    /// CF_Snv_DetectionEnable
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM, CLU, HUD
    #[inline(always)]
    pub fn cf_snv_detection_enable(&self) -> bool {
        self.cf_snv_detection_enable_raw()
    }
    
    /// Get raw value of CF_Snv_DetectionEnable
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_snv_detection_enable_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Snv_DetectionEnable
    #[inline(always)]
    pub fn set_cf_snv_detection_enable(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// CF_Snv_PedestrianDetect
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CLU, HUD
    #[inline(always)]
    pub fn cf_snv_pedestrian_detect(&self) -> u8 {
        self.cf_snv_pedestrian_detect_raw()
    }
    
    /// Get raw value of CF_Snv_PedestrianDetect
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_snv_pedestrian_detect_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Snv_PedestrianDetect
    #[inline(always)]
    pub fn set_cf_snv_pedestrian_detect(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1362 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// CF_Snv_IRLampControl
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CLU, HUD
    #[inline(always)]
    pub fn cf_snv_ir_lamp_control(&self) -> u8 {
        self.cf_snv_ir_lamp_control_raw()
    }
    
    /// Get raw value of CF_Snv_IRLampControl
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_snv_ir_lamp_control_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Snv_IRLampControl
    #[inline(always)]
    pub fn set_cf_snv_ir_lamp_control(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1362 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..12].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Snv11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Snv11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Snv11")
                .field("cf_snv_display_control", &self.cf_snv_display_control())
                .field("cf_snv_beep_warning", &self.cf_snv_beep_warning())
                .field("cf_snv_warning_message", &self.cf_snv_warning_message())
                .field("cf_snv_detection_enable", &self.cf_snv_detection_enable())
                .field("cf_snv_pedestrian_detect", &self.cf_snv_pedestrian_detect())
                .field("cf_snv_ir_lamp_control", &self.cf_snv_ir_lamp_control())
            .finish()
        } else {
            f.debug_tuple("Snv11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Snv11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_snv_display_control = u.int_in_range(0..=3)?;
        let cf_snv_beep_warning = u.int_in_range(0..=3)?;
        let cf_snv_warning_message = u.int_in_range(0..=7)?;
        let cf_snv_detection_enable = u.int_in_range(0..=1)? == 1;
        let cf_snv_pedestrian_detect = u.int_in_range(0..=3)?;
        let cf_snv_ir_lamp_control = u.int_in_range(0..=3)?;
        Snv11::new(cf_snv_display_control,cf_snv_beep_warning,cf_snv_warning_message,cf_snv_detection_enable,cf_snv_pedestrian_detect,cf_snv_ir_lamp_control).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// MDPS12
///
/// - ID: 593 (0x251)
/// - Size: 8 bytes
/// - Transmitter: MDPS
#[derive(Clone, Copy)]
pub struct Mdps12 {
    raw: [u8; 8],
}

impl Mdps12 {
    pub const MESSAGE_ID: u32 = 593;
    
    pub const CR_MDPS_STR_COL_TQ_MIN: f32 = -1024_f32;
    pub const CR_MDPS_STR_COL_TQ_MAX: f32 = 1024_f32;
    pub const CF_MDPS_MSG_COUNT2_MIN: u8 = 0_u8;
    pub const CF_MDPS_MSG_COUNT2_MAX: u8 = 255_u8;
    pub const CF_MDPS_CHKSUM2_MIN: u8 = 0_u8;
    pub const CF_MDPS_CHKSUM2_MAX: u8 = 255_u8;
    pub const CR_MDPS_STR_TQ_MIN: f32 = -20.48_f32;
    pub const CR_MDPS_STR_TQ_MAX: f32 = 20.47_f32;
    pub const CR_MDPS_OUT_TQ_MIN: f32 = -204.8_f32;
    pub const CR_MDPS_OUT_TQ_MAX: f32 = 204.7_f32;
    
    /// Construct new MDPS12 from values
    pub fn new(cr_mdps_str_col_tq: f32, cf_mdps_def: bool, cf_mdps_toi_unavail: bool, cf_mdps_toi_active: bool, cf_mdps_toi_flt: bool, cf_mdps_fail_stat: bool, cf_mdps_msg_count2: u8, cf_mdps_chksum2: u8, cf_mdps_s_err: bool, cr_mdps_str_tq: f32, cr_mdps_out_tq: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cr_mdps_str_col_tq(cr_mdps_str_col_tq)?;
        res.set_cf_mdps_def(cf_mdps_def)?;
        res.set_cf_mdps_toi_unavail(cf_mdps_toi_unavail)?;
        res.set_cf_mdps_toi_active(cf_mdps_toi_active)?;
        res.set_cf_mdps_toi_flt(cf_mdps_toi_flt)?;
        res.set_cf_mdps_fail_stat(cf_mdps_fail_stat)?;
        res.set_cf_mdps_msg_count2(cf_mdps_msg_count2)?;
        res.set_cf_mdps_chksum2(cf_mdps_chksum2)?;
        res.set_cf_mdps_s_err(cf_mdps_s_err)?;
        res.set_cr_mdps_str_tq(cr_mdps_str_tq)?;
        res.set_cr_mdps_out_tq(cr_mdps_out_tq)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CR_Mdps_StrColTq
    ///
    /// - Min: -1024
    /// - Max: 1024
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS
    #[inline(always)]
    pub fn cr_mdps_str_col_tq(&self) -> f32 {
        self.cr_mdps_str_col_tq_raw()
    }
    
    /// Get raw value of CR_Mdps_StrColTq
    ///
    /// - Start bit: 0
    /// - Signal size: 11 bits
    /// - Factor: 1
    /// - Offset: -1024
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_mdps_str_col_tq_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..11].load_le::<u16>();
        
        let factor = 1_f32;
        let offset = -1024_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Mdps_StrColTq
    #[inline(always)]
    pub fn set_cr_mdps_str_col_tq(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1024_f32 || 1024_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 593 });
        }
        let factor = 1_f32;
        let offset = -1024_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..11].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_Def
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cf_mdps_def(&self) -> bool {
        self.cf_mdps_def_raw()
    }
    
    /// Get raw value of CF_Mdps_Def
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_def_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Mdps_Def
    #[inline(always)]
    pub fn set_cf_mdps_def(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[11..12].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_ToiUnavail
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS
    #[inline(always)]
    pub fn cf_mdps_toi_unavail(&self) -> bool {
        self.cf_mdps_toi_unavail_raw()
    }
    
    /// Get raw value of CF_Mdps_ToiUnavail
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_toi_unavail_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Mdps_ToiUnavail
    #[inline(always)]
    pub fn set_cf_mdps_toi_unavail(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[12..13].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_ToiActive
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS
    #[inline(always)]
    pub fn cf_mdps_toi_active(&self) -> bool {
        self.cf_mdps_toi_active_raw()
    }
    
    /// Get raw value of CF_Mdps_ToiActive
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_toi_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Mdps_ToiActive
    #[inline(always)]
    pub fn set_cf_mdps_toi_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[13..14].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_ToiFlt
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS
    #[inline(always)]
    pub fn cf_mdps_toi_flt(&self) -> bool {
        self.cf_mdps_toi_flt_raw()
    }
    
    /// Get raw value of CF_Mdps_ToiFlt
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_toi_flt_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Mdps_ToiFlt
    #[inline(always)]
    pub fn set_cf_mdps_toi_flt(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[14..15].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_FailStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS
    #[inline(always)]
    pub fn cf_mdps_fail_stat(&self) -> bool {
        self.cf_mdps_fail_stat_raw()
    }
    
    /// Get raw value of CF_Mdps_FailStat
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_fail_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Mdps_FailStat
    #[inline(always)]
    pub fn set_cf_mdps_fail_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[15..16].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_MsgCount2
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: ESC, LDWS_LKAS
    #[inline(always)]
    pub fn cf_mdps_msg_count2(&self) -> u8 {
        self.cf_mdps_msg_count2_raw()
    }
    
    /// Get raw value of CF_Mdps_MsgCount2
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_msg_count2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Mdps_MsgCount2
    #[inline(always)]
    pub fn set_cf_mdps_msg_count2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 593 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_Chksum2
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: ESC, LDWS_LKAS
    #[inline(always)]
    pub fn cf_mdps_chksum2(&self) -> u8 {
        self.cf_mdps_chksum2_raw()
    }
    
    /// Get raw value of CF_Mdps_Chksum2
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_chksum2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Mdps_Chksum2
    #[inline(always)]
    pub fn set_cf_mdps_chksum2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 593 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_SErr
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cf_mdps_s_err(&self) -> bool {
        self.cf_mdps_s_err_raw()
    }
    
    /// Get raw value of CF_Mdps_SErr
    ///
    /// - Start bit: 37
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_s_err_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[37..38].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Mdps_SErr
    #[inline(always)]
    pub fn set_cf_mdps_s_err(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[37..38].store_le(value);
        Ok(())
    }
    
    /// CR_Mdps_StrTq
    ///
    /// - Min: -20.48
    /// - Max: 20.47
    /// - Unit: "Nm"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cr_mdps_str_tq(&self) -> f32 {
        self.cr_mdps_str_tq_raw()
    }
    
    /// Get raw value of CR_Mdps_StrTq
    ///
    /// - Start bit: 40
    /// - Signal size: 12 bits
    /// - Factor: 0.01
    /// - Offset: -20.48
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_mdps_str_tq_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..52].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = -20.48_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Mdps_StrTq
    #[inline(always)]
    pub fn set_cr_mdps_str_tq(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20.48_f32 || 20.47_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 593 });
        }
        let factor = 0.01_f32;
        let offset = -20.48_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[40..52].store_le(value);
        Ok(())
    }
    
    /// CR_Mdps_OutTq
    ///
    /// - Min: -204.8
    /// - Max: 204.7
    /// - Unit: ""
    /// - Receivers: ESC, LDWS_LKAS
    #[inline(always)]
    pub fn cr_mdps_out_tq(&self) -> f32 {
        self.cr_mdps_out_tq_raw()
    }
    
    /// Get raw value of CR_Mdps_OutTq
    ///
    /// - Start bit: 52
    /// - Signal size: 12 bits
    /// - Factor: 0.1
    /// - Offset: -204.8
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_mdps_out_tq_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[52..64].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = -204.8_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Mdps_OutTq
    #[inline(always)]
    pub fn set_cr_mdps_out_tq(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -204.8_f32 || 204.7_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 593 });
        }
        let factor = 0.1_f32;
        let offset = -204.8_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[52..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Mdps12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Mdps12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Mdps12")
                .field("cr_mdps_str_col_tq", &self.cr_mdps_str_col_tq())
                .field("cf_mdps_def", &self.cf_mdps_def())
                .field("cf_mdps_toi_unavail", &self.cf_mdps_toi_unavail())
                .field("cf_mdps_toi_active", &self.cf_mdps_toi_active())
                .field("cf_mdps_toi_flt", &self.cf_mdps_toi_flt())
                .field("cf_mdps_fail_stat", &self.cf_mdps_fail_stat())
                .field("cf_mdps_msg_count2", &self.cf_mdps_msg_count2())
                .field("cf_mdps_chksum2", &self.cf_mdps_chksum2())
                .field("cf_mdps_s_err", &self.cf_mdps_s_err())
                .field("cr_mdps_str_tq", &self.cr_mdps_str_tq())
                .field("cr_mdps_out_tq", &self.cr_mdps_out_tq())
            .finish()
        } else {
            f.debug_tuple("Mdps12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Mdps12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cr_mdps_str_col_tq = u.float_in_range(-1024_f32..=1024_f32)?;
        let cf_mdps_def = u.int_in_range(0..=1)? == 1;
        let cf_mdps_toi_unavail = u.int_in_range(0..=1)? == 1;
        let cf_mdps_toi_active = u.int_in_range(0..=1)? == 1;
        let cf_mdps_toi_flt = u.int_in_range(0..=1)? == 1;
        let cf_mdps_fail_stat = u.int_in_range(0..=1)? == 1;
        let cf_mdps_msg_count2 = u.int_in_range(0..=255)?;
        let cf_mdps_chksum2 = u.int_in_range(0..=255)?;
        let cf_mdps_s_err = u.int_in_range(0..=1)? == 1;
        let cr_mdps_str_tq = u.float_in_range(-20.48_f32..=20.47_f32)?;
        let cr_mdps_out_tq = u.float_in_range(-204.8_f32..=204.7_f32)?;
        Mdps12::new(cr_mdps_str_col_tq,cf_mdps_def,cf_mdps_toi_unavail,cf_mdps_toi_active,cf_mdps_toi_flt,cf_mdps_fail_stat,cf_mdps_msg_count2,cf_mdps_chksum2,cf_mdps_s_err,cr_mdps_str_tq,cr_mdps_out_tq).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// IAP11
///
/// - ID: 1360 (0x550)
/// - Size: 3 bytes
/// - Transmitter: IAP
#[derive(Clone, Copy)]
pub struct Iap11 {
    raw: [u8; 3],
}

impl Iap11 {
    pub const MESSAGE_ID: u32 = 1360;
    
    pub const CF_IAP_REQ_WARN_MIN: u8 = 0_u8;
    pub const CF_IAP_REQ_WARN_MAX: u8 = 3_u8;
    
    /// Construct new IAP11 from values
    pub fn new(cf_iap_eco_pmod_swi: bool, cf_iap_eco_pmod_act: bool, cf_iap_req_warn: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_cf_iap_eco_pmod_swi(cf_iap_eco_pmod_swi)?;
        res.set_cf_iap_eco_pmod_act(cf_iap_eco_pmod_act)?;
        res.set_cf_iap_req_warn(cf_iap_req_warn)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// CF_Iap_EcoPmodSwi
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_iap_eco_pmod_swi(&self) -> bool {
        self.cf_iap_eco_pmod_swi_raw()
    }
    
    /// Get raw value of CF_Iap_EcoPmodSwi
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_iap_eco_pmod_swi_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Iap_EcoPmodSwi
    #[inline(always)]
    pub fn set_cf_iap_eco_pmod_swi(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// CF_Iap_EcoPmodAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_iap_eco_pmod_act(&self) -> bool {
        self.cf_iap_eco_pmod_act_raw()
    }
    
    /// Get raw value of CF_Iap_EcoPmodAct
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_iap_eco_pmod_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Iap_EcoPmodAct
    #[inline(always)]
    pub fn set_cf_iap_eco_pmod_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// CF_Iap_ReqWarn
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_iap_req_warn(&self) -> u8 {
        self.cf_iap_req_warn_raw()
    }
    
    /// Get raw value of CF_Iap_ReqWarn
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_iap_req_warn_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Iap_ReqWarn
    #[inline(always)]
    pub fn set_cf_iap_req_warn(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1360 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Iap11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Iap11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Iap11")
                .field("cf_iap_eco_pmod_swi", &self.cf_iap_eco_pmod_swi())
                .field("cf_iap_eco_pmod_act", &self.cf_iap_eco_pmod_act())
                .field("cf_iap_req_warn", &self.cf_iap_req_warn())
            .finish()
        } else {
            f.debug_tuple("Iap11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Iap11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_iap_eco_pmod_swi = u.int_in_range(0..=1)? == 1;
        let cf_iap_eco_pmod_act = u.int_in_range(0..=1)? == 1;
        let cf_iap_req_warn = u.int_in_range(0..=3)?;
        Iap11::new(cf_iap_eco_pmod_swi,cf_iap_eco_pmod_act,cf_iap_req_warn).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// TCU_DCT14
///
/// - ID: 1356 (0x54c)
/// - Size: 8 bytes
/// - Transmitter: TCU
#[derive(Clone, Copy)]
pub struct TcuDct14 {
    raw: [u8; 8],
}

impl TcuDct14 {
    pub const MESSAGE_ID: u32 = 1356;
    
    pub const VEHICLE_STOP_TIME_MIN: u8 = 0_u8;
    pub const VEHICLE_STOP_TIME_MAX: u8 = 0_u8;
    
    /// Construct new TCU_DCT14 from values
    pub fn new(vehicle_stop_time: u8, hill_hold_warning: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_vehicle_stop_time(vehicle_stop_time)?;
        res.set_hill_hold_warning(hill_hold_warning)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Vehicle_Stop_Time
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn vehicle_stop_time(&self) -> u8 {
        self.vehicle_stop_time_raw()
    }
    
    /// Get raw value of Vehicle_Stop_Time
    ///
    /// - Start bit: 0
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vehicle_stop_time_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Vehicle_Stop_Time
    #[inline(always)]
    pub fn set_vehicle_stop_time(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1356 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..5].store_le(value);
        Ok(())
    }
    
    /// HILL_HOLD_WARNING
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn hill_hold_warning(&self) -> bool {
        self.hill_hold_warning_raw()
    }
    
    /// Get raw value of HILL_HOLD_WARNING
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hill_hold_warning_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HILL_HOLD_WARNING
    #[inline(always)]
    pub fn set_hill_hold_warning(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for TcuDct14 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for TcuDct14 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("TcuDct14")
                .field("vehicle_stop_time", &self.vehicle_stop_time())
                .field("hill_hold_warning", &self.hill_hold_warning())
            .finish()
        } else {
            f.debug_tuple("TcuDct14").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for TcuDct14 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vehicle_stop_time = u.int_in_range(0..=0)?;
        let hill_hold_warning = u.int_in_range(0..=1)? == 1;
        TcuDct14::new(vehicle_stop_time,hill_hold_warning).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// BAT11
///
/// - ID: 1353 (0x549)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct Bat11 {
    raw: [u8; 8],
}

impl Bat11 {
    pub const MESSAGE_ID: u32 = 1353;
    
    pub const BAT_SNSR_I_MIN: f32 = -327_f32;
    pub const BAT_SNSR_I_MAX: f32 = 328_f32;
    pub const BAT_SOC_MIN: u8 = 0_u8;
    pub const BAT_SOC_MAX: u8 = 100_u8;
    pub const BAT_SNSR_V_MIN: f32 = 6_f32;
    pub const BAT_SNSR_V_MAX: f32 = 18_f32;
    pub const BAT_SNSR_TEMP_MIN: f32 = -40_f32;
    pub const BAT_SNSR_TEMP_MAX: f32 = 125_f32;
    pub const BAT_SOH_MIN: u8 = 0_u8;
    pub const BAT_SOH_MAX: u8 = 100_u8;
    pub const BAT_SOF_MIN: f32 = 0_f32;
    pub const BAT_SOF_MAX: f32 = 12_f32;
    
    /// Construct new BAT11 from values
    pub fn new(bat_snsr_i: f32, bat_soc: u8, bat_snsr_v: f32, bat_snsr_temp: f32, bat_snsr_state: bool, bat_soh: u8, bat_snsr_invalid: bool, bat_sof: f32, bat_snsr_error: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_bat_snsr_i(bat_snsr_i)?;
        res.set_bat_soc(bat_soc)?;
        res.set_bat_snsr_v(bat_snsr_v)?;
        res.set_bat_snsr_temp(bat_snsr_temp)?;
        res.set_bat_snsr_state(bat_snsr_state)?;
        res.set_bat_soh(bat_soh)?;
        res.set_bat_snsr_invalid(bat_snsr_invalid)?;
        res.set_bat_sof(bat_sof)?;
        res.set_bat_snsr_error(bat_snsr_error)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// BAT_SNSR_I
    ///
    /// - Min: -327
    /// - Max: 328
    /// - Unit: "A"
    /// - Receivers: CGW, CUBIS, IBOX, TMU
    #[inline(always)]
    pub fn bat_snsr_i(&self) -> f32 {
        self.bat_snsr_i_raw()
    }
    
    /// Get raw value of BAT_SNSR_I
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: -327
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bat_snsr_i_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = -327_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of BAT_SNSR_I
    #[inline(always)]
    pub fn set_bat_snsr_i(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -327_f32 || 328_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1353 });
        }
        let factor = 0.01_f32;
        let offset = -327_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
    /// BAT_SOC
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: CGW, CUBIS, IBOX, TMU
    #[inline(always)]
    pub fn bat_soc(&self) -> u8 {
        self.bat_soc_raw()
    }
    
    /// Get raw value of BAT_SOC
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bat_soc_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BAT_SOC
    #[inline(always)]
    pub fn set_bat_soc(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1353 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// BAT_SNSR_V
    ///
    /// - Min: 6
    /// - Max: 18
    /// - Unit: "V"
    /// - Receivers: CGW, CUBIS, IBOX, TMU
    #[inline(always)]
    pub fn bat_snsr_v(&self) -> f32 {
        self.bat_snsr_v_raw()
    }
    
    /// Get raw value of BAT_SNSR_V
    ///
    /// - Start bit: 24
    /// - Signal size: 14 bits
    /// - Factor: 0.001
    /// - Offset: 6
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bat_snsr_v_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..38].load_le::<u16>();
        
        let factor = 0.001_f32;
        let offset = 6_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of BAT_SNSR_V
    #[inline(always)]
    pub fn set_bat_snsr_v(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 6_f32 || 18_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1353 });
        }
        let factor = 0.001_f32;
        let offset = 6_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[24..38].store_le(value);
        Ok(())
    }
    
    /// BAT_SNSR_Temp
    ///
    /// - Min: -40
    /// - Max: 125
    /// - Unit: "deg"
    /// - Receivers: CGW, CUBIS, IBOX, TMU
    #[inline(always)]
    pub fn bat_snsr_temp(&self) -> f32 {
        self.bat_snsr_temp_raw()
    }
    
    /// Get raw value of BAT_SNSR_Temp
    ///
    /// - Start bit: 38
    /// - Signal size: 9 bits
    /// - Factor: 0.5
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn bat_snsr_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[38..47].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.5_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of BAT_SNSR_Temp
    #[inline(always)]
    pub fn set_bat_snsr_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 125_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1353 });
        }
        let factor = 0.5_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[38..47].store_le(value);
        Ok(())
    }
    
    /// BAT_SNSR_State
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CGW, CUBIS, IBOX, TMU
    #[inline(always)]
    pub fn bat_snsr_state(&self) -> bool {
        self.bat_snsr_state_raw()
    }
    
    /// Get raw value of BAT_SNSR_State
    ///
    /// - Start bit: 47
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bat_snsr_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[47..48].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BAT_SNSR_State
    #[inline(always)]
    pub fn set_bat_snsr_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[47..48].store_le(value);
        Ok(())
    }
    
    /// BAT_SOH
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: CGW, CUBIS, IBOX, TMU
    #[inline(always)]
    pub fn bat_soh(&self) -> u8 {
        self.bat_soh_raw()
    }
    
    /// Get raw value of BAT_SOH
    ///
    /// - Start bit: 48
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bat_soh_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..55].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BAT_SOH
    #[inline(always)]
    pub fn set_bat_soh(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1353 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..55].store_le(value);
        Ok(())
    }
    
    /// BAT_SNSR_Invalid
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CGW, CUBIS, IBOX, TMU
    #[inline(always)]
    pub fn bat_snsr_invalid(&self) -> bool {
        self.bat_snsr_invalid_raw()
    }
    
    /// Get raw value of BAT_SNSR_Invalid
    ///
    /// - Start bit: 55
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bat_snsr_invalid_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[55..56].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BAT_SNSR_Invalid
    #[inline(always)]
    pub fn set_bat_snsr_invalid(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[55..56].store_le(value);
        Ok(())
    }
    
    /// BAT_SOF
    ///
    /// - Min: 0
    /// - Max: 12
    /// - Unit: "V"
    /// - Receivers: CGW, CUBIS, IBOX, TMU
    #[inline(always)]
    pub fn bat_sof(&self) -> f32 {
        self.bat_sof_raw()
    }
    
    /// Get raw value of BAT_SOF
    ///
    /// - Start bit: 56
    /// - Signal size: 7 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bat_sof_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[56..63].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of BAT_SOF
    #[inline(always)]
    pub fn set_bat_sof(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 12_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1353 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[56..63].store_le(value);
        Ok(())
    }
    
    /// BAT_SNSR_Error
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CGW, CUBIS, IBOX, TMU
    #[inline(always)]
    pub fn bat_snsr_error(&self) -> bool {
        self.bat_snsr_error_raw()
    }
    
    /// Get raw value of BAT_SNSR_Error
    ///
    /// - Start bit: 63
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bat_snsr_error_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[63..64].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BAT_SNSR_Error
    #[inline(always)]
    pub fn set_bat_snsr_error(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[63..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Bat11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Bat11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Bat11")
                .field("bat_snsr_i", &self.bat_snsr_i())
                .field("bat_soc", &self.bat_soc())
                .field("bat_snsr_v", &self.bat_snsr_v())
                .field("bat_snsr_temp", &self.bat_snsr_temp())
                .field("bat_snsr_state", &self.bat_snsr_state())
                .field("bat_soh", &self.bat_soh())
                .field("bat_snsr_invalid", &self.bat_snsr_invalid())
                .field("bat_sof", &self.bat_sof())
                .field("bat_snsr_error", &self.bat_snsr_error())
            .finish()
        } else {
            f.debug_tuple("Bat11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Bat11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let bat_snsr_i = u.float_in_range(-327_f32..=328_f32)?;
        let bat_soc = u.int_in_range(0..=100)?;
        let bat_snsr_v = u.float_in_range(6_f32..=18_f32)?;
        let bat_snsr_temp = u.float_in_range(-40_f32..=125_f32)?;
        let bat_snsr_state = u.int_in_range(0..=1)? == 1;
        let bat_soh = u.int_in_range(0..=100)?;
        let bat_snsr_invalid = u.int_in_range(0..=1)? == 1;
        let bat_sof = u.float_in_range(0_f32..=12_f32)?;
        let bat_snsr_error = u.int_in_range(0..=1)? == 1;
        Bat11::new(bat_snsr_i,bat_soc,bat_snsr_v,bat_snsr_temp,bat_snsr_state,bat_soh,bat_snsr_invalid,bat_sof,bat_snsr_error).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EMS15
///
/// - ID: 1351 (0x547)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct Ems15 {
    raw: [u8; 8],
}

impl Ems15 {
    pub const MESSAGE_ID: u32 = 1351;
    
    pub const FA_PV_CAN_MIN: f32 = 0_f32;
    pub const FA_PV_CAN_MAX: f32 = 99.2_f32;
    pub const INT_AIR_TEMP_MIN: f32 = -48_f32;
    pub const INT_AIR_TEMP_MAX: f32 = 143.25_f32;
    pub const STATE_DC_OBD_MIN: u8 = 0_u8;
    pub const STATE_DC_OBD_MAX: u8 = 127_u8;
    pub const CTR_IG_CYC_OBD_MIN: u16 = 0_u16;
    pub const CTR_IG_CYC_OBD_MAX: u16 = 65535_u16;
    pub const CTR_CDN_OBD_MIN: u16 = 0_u16;
    pub const CTR_CDN_OBD_MAX: u16 = 65535_u16;
    
    /// Construct new EMS15 from values
    pub fn new(ecgp_ovrd: bool, qecacc: bool, ec_fail: bool, switch_off_cond_ext: bool, blec_fail: bool, cf_ems_isa_act: bool, fa_pv_can: f32, int_air_temp: f32, state_dc_obd: u8, inh_dc_obd: bool, ctr_ig_cyc_obd: u16, ctr_cdn_obd: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ecgp_ovrd(ecgp_ovrd)?;
        res.set_qecacc(qecacc)?;
        res.set_ec_fail(ec_fail)?;
        res.set_switch_off_cond_ext(switch_off_cond_ext)?;
        res.set_blec_fail(blec_fail)?;
        res.set_cf_ems_isa_act(cf_ems_isa_act)?;
        res.set_fa_pv_can(fa_pv_can)?;
        res.set_int_air_temp(int_air_temp)?;
        res.set_state_dc_obd(state_dc_obd)?;
        res.set_inh_dc_obd(inh_dc_obd)?;
        res.set_ctr_ig_cyc_obd(ctr_ig_cyc_obd)?;
        res.set_ctr_cdn_obd(ctr_cdn_obd)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// ECGPOvrd
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC, IBOX, SCC
    #[inline(always)]
    pub fn ecgp_ovrd(&self) -> bool {
        self.ecgp_ovrd_raw()
    }
    
    /// Get raw value of ECGPOvrd
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ecgp_ovrd_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ECGPOvrd
    #[inline(always)]
    pub fn set_ecgp_ovrd(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// QECACC
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC, IBOX
    #[inline(always)]
    pub fn qecacc(&self) -> bool {
        self.qecacc_raw()
    }
    
    /// Get raw value of QECACC
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn qecacc_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of QECACC
    #[inline(always)]
    pub fn set_qecacc(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// ECFail
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC, IBOX
    #[inline(always)]
    pub fn ec_fail(&self) -> bool {
        self.ec_fail_raw()
    }
    
    /// Get raw value of ECFail
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ec_fail_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ECFail
    #[inline(always)]
    pub fn set_ec_fail(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// SwitchOffCondExt
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC, IBOX
    #[inline(always)]
    pub fn switch_off_cond_ext(&self) -> bool {
        self.switch_off_cond_ext_raw()
    }
    
    /// Get raw value of SwitchOffCondExt
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn switch_off_cond_ext_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of SwitchOffCondExt
    #[inline(always)]
    pub fn set_switch_off_cond_ext(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// BLECFail
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC, IBOX
    #[inline(always)]
    pub fn blec_fail(&self) -> bool {
        self.blec_fail_raw()
    }
    
    /// Get raw value of BLECFail
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn blec_fail_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of BLECFail
    #[inline(always)]
    pub fn set_blec_fail(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_IsaAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_ems_isa_act(&self) -> bool {
        self.cf_ems_isa_act_raw()
    }
    
    /// Get raw value of CF_Ems_IsaAct
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_isa_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ems_IsaAct
    #[inline(always)]
    pub fn set_cf_ems_isa_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// FA_PV_CAN
    ///
    /// - Min: 0
    /// - Max: 99.2
    /// - Unit: "%"
    /// - Receivers: IBOX, LDWS_LKAS, TCU
    #[inline(always)]
    pub fn fa_pv_can(&self) -> f32 {
        self.fa_pv_can_raw()
    }
    
    /// Get raw value of FA_PV_CAN
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.3906
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fa_pv_can_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 0.3906_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of FA_PV_CAN
    #[inline(always)]
    pub fn set_fa_pv_can(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.2_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1351 });
        }
        let factor = 0.3906_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// IntAirTemp
    ///
    /// - Min: -48
    /// - Max: 143.25
    /// - Unit: "deg"
    /// - Receivers: _4WD, ECS, EPB, IBOX, TCU
    #[inline(always)]
    pub fn int_air_temp(&self) -> f32 {
        self.int_air_temp_raw()
    }
    
    /// Get raw value of IntAirTemp
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.75
    /// - Offset: -48
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn int_air_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 0.75_f32;
        let offset = -48_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IntAirTemp
    #[inline(always)]
    pub fn set_int_air_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -48_f32 || 143.25_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1351 });
        }
        let factor = 0.75_f32;
        let offset = -48_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// STATE_DC_OBD
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: ""
    /// - Receivers: IBOX, TCU
    #[inline(always)]
    pub fn state_dc_obd(&self) -> u8 {
        self.state_dc_obd_raw()
    }
    
    /// Get raw value of STATE_DC_OBD
    ///
    /// - Start bit: 24
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn state_dc_obd_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..31].load_le::<u8>();
        
        signal
    }
    
    /// Set value of STATE_DC_OBD
    #[inline(always)]
    pub fn set_state_dc_obd(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1351 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..31].store_le(value);
        Ok(())
    }
    
    /// INH_DC_OBD
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: IBOX, TCU
    #[inline(always)]
    pub fn inh_dc_obd(&self) -> bool {
        self.inh_dc_obd_raw()
    }
    
    /// Get raw value of INH_DC_OBD
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn inh_dc_obd_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of INH_DC_OBD
    #[inline(always)]
    pub fn set_inh_dc_obd(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[31..32].store_le(value);
        Ok(())
    }
    
    /// CTR_IG_CYC_OBD
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: ACU, IBOX, TCU
    #[inline(always)]
    pub fn ctr_ig_cyc_obd(&self) -> u16 {
        self.ctr_ig_cyc_obd_raw()
    }
    
    /// Get raw value of CTR_IG_CYC_OBD
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ctr_ig_cyc_obd_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<u16>();
        
        signal
    }
    
    /// Set value of CTR_IG_CYC_OBD
    #[inline(always)]
    pub fn set_ctr_ig_cyc_obd(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1351 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// CTR_CDN_OBD
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: IBOX, TCU
    #[inline(always)]
    pub fn ctr_cdn_obd(&self) -> u16 {
        self.ctr_cdn_obd_raw()
    }
    
    /// Get raw value of CTR_CDN_OBD
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ctr_cdn_obd_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<u16>();
        
        signal
    }
    
    /// Set value of CTR_CDN_OBD
    #[inline(always)]
    pub fn set_ctr_cdn_obd(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1351 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ems15 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ems15 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ems15")
                .field("ecgp_ovrd", &self.ecgp_ovrd())
                .field("qecacc", &self.qecacc())
                .field("ec_fail", &self.ec_fail())
                .field("switch_off_cond_ext", &self.switch_off_cond_ext())
                .field("blec_fail", &self.blec_fail())
                .field("cf_ems_isa_act", &self.cf_ems_isa_act())
                .field("fa_pv_can", &self.fa_pv_can())
                .field("int_air_temp", &self.int_air_temp())
                .field("state_dc_obd", &self.state_dc_obd())
                .field("inh_dc_obd", &self.inh_dc_obd())
                .field("ctr_ig_cyc_obd", &self.ctr_ig_cyc_obd())
                .field("ctr_cdn_obd", &self.ctr_cdn_obd())
            .finish()
        } else {
            f.debug_tuple("Ems15").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ems15 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ecgp_ovrd = u.int_in_range(0..=1)? == 1;
        let qecacc = u.int_in_range(0..=1)? == 1;
        let ec_fail = u.int_in_range(0..=1)? == 1;
        let switch_off_cond_ext = u.int_in_range(0..=1)? == 1;
        let blec_fail = u.int_in_range(0..=1)? == 1;
        let cf_ems_isa_act = u.int_in_range(0..=1)? == 1;
        let fa_pv_can = u.float_in_range(0_f32..=99.2_f32)?;
        let int_air_temp = u.float_in_range(-48_f32..=143.25_f32)?;
        let state_dc_obd = u.int_in_range(0..=127)?;
        let inh_dc_obd = u.int_in_range(0..=1)? == 1;
        let ctr_ig_cyc_obd = u.int_in_range(0..=65535)?;
        let ctr_cdn_obd = u.int_in_range(0..=65535)?;
        Ems15::new(ecgp_ovrd,qecacc,ec_fail,switch_off_cond_ext,blec_fail,cf_ems_isa_act,fa_pv_can,int_air_temp,state_dc_obd,inh_dc_obd,ctr_ig_cyc_obd,ctr_cdn_obd).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// DI_BOX12
///
/// - ID: 1350 (0x546)
/// - Size: 8 bytes
/// - Transmitter: DI_BOX
#[derive(Clone, Copy)]
pub struct DiBox12 {
    raw: [u8; 8],
}

impl DiBox12 {
    pub const MESSAGE_ID: u32 = 1350;
    
    pub const CF_DI_BOX_FRT_INJ_V_DIAG_REG0_MIN: u8 = 0_u8;
    pub const CF_DI_BOX_FRT_INJ_V_DIAG_REG0_MAX: u8 = 255_u8;
    pub const CF_DI_BOX_FRT_INJ_V_DIAG_REG1_MIN: u8 = 0_u8;
    pub const CF_DI_BOX_FRT_INJ_V_DIAG_REG1_MAX: u8 = 255_u8;
    pub const CF_DI_BOX_FRT_INJ_V_DIAG_REG2_MIN: u8 = 0_u8;
    pub const CF_DI_BOX_FRT_INJ_V_DIAG_REG2_MAX: u8 = 255_u8;
    pub const CF_DI_BOX_SED_INJ_V_DIAG_REG0_MIN: u8 = 0_u8;
    pub const CF_DI_BOX_SED_INJ_V_DIAG_REG0_MAX: u8 = 255_u8;
    pub const CF_DI_BOX_SED_INJ_V_DIAG_REG1_MIN: u8 = 0_u8;
    pub const CF_DI_BOX_SED_INJ_V_DIAG_REG1_MAX: u8 = 255_u8;
    pub const CF_DI_BOX_SED_INJ_V_DIAG_REG2_MIN: u8 = 0_u8;
    pub const CF_DI_BOX_SED_INJ_V_DIAG_REG2_MAX: u8 = 255_u8;
    pub const CR_DI_BOX_BAT_VOL_MIN: f32 = 0_f32;
    pub const CR_DI_BOX_BAT_VOL_MAX: f32 = 25.5_f32;
    
    /// Construct new DI_BOX12 from values
    pub fn new(cf_di_box_frt_inj_v_diag_reg0: u8, cf_di_box_frt_inj_v_diag_reg1: u8, cf_di_box_frt_inj_v_diag_reg2: u8, cf_di_box_sed_inj_v_diag_reg0: u8, cf_di_box_sed_inj_v_diag_reg1: u8, cf_di_box_sed_inj_v_diag_reg2: u8, cr_di_box_bat_vol: f32, cf_di_box_sed_inj_v_chg: bool, cf_di_box_frt_inj_v_chg: bool, cf_di_box_sed_inj_v_err_spi: bool, cf_di_box_frt_inj_v_err_spi: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_di_box_frt_inj_v_diag_reg0(cf_di_box_frt_inj_v_diag_reg0)?;
        res.set_cf_di_box_frt_inj_v_diag_reg1(cf_di_box_frt_inj_v_diag_reg1)?;
        res.set_cf_di_box_frt_inj_v_diag_reg2(cf_di_box_frt_inj_v_diag_reg2)?;
        res.set_cf_di_box_sed_inj_v_diag_reg0(cf_di_box_sed_inj_v_diag_reg0)?;
        res.set_cf_di_box_sed_inj_v_diag_reg1(cf_di_box_sed_inj_v_diag_reg1)?;
        res.set_cf_di_box_sed_inj_v_diag_reg2(cf_di_box_sed_inj_v_diag_reg2)?;
        res.set_cr_di_box_bat_vol(cr_di_box_bat_vol)?;
        res.set_cf_di_box_sed_inj_v_chg(cf_di_box_sed_inj_v_chg)?;
        res.set_cf_di_box_frt_inj_v_chg(cf_di_box_frt_inj_v_chg)?;
        res.set_cf_di_box_sed_inj_v_err_spi(cf_di_box_sed_inj_v_err_spi)?;
        res.set_cf_di_box_frt_inj_v_err_spi(cf_di_box_frt_inj_v_err_spi)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_DiBox_FrtInjVDiagReg0
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_frt_inj_v_diag_reg0(&self) -> u8 {
        self.cf_di_box_frt_inj_v_diag_reg0_raw()
    }
    
    /// Get raw value of CF_DiBox_FrtInjVDiagReg0
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_frt_inj_v_diag_reg0_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_DiBox_FrtInjVDiagReg0
    #[inline(always)]
    pub fn set_cf_di_box_frt_inj_v_diag_reg0(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1350 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_FrtInjVDiagReg1
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_frt_inj_v_diag_reg1(&self) -> u8 {
        self.cf_di_box_frt_inj_v_diag_reg1_raw()
    }
    
    /// Get raw value of CF_DiBox_FrtInjVDiagReg1
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_frt_inj_v_diag_reg1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_DiBox_FrtInjVDiagReg1
    #[inline(always)]
    pub fn set_cf_di_box_frt_inj_v_diag_reg1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1350 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_FrtInjVDiagReg2
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_frt_inj_v_diag_reg2(&self) -> u8 {
        self.cf_di_box_frt_inj_v_diag_reg2_raw()
    }
    
    /// Get raw value of CF_DiBox_FrtInjVDiagReg2
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_frt_inj_v_diag_reg2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_DiBox_FrtInjVDiagReg2
    #[inline(always)]
    pub fn set_cf_di_box_frt_inj_v_diag_reg2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1350 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_SedInjVDiagReg0
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_sed_inj_v_diag_reg0(&self) -> u8 {
        self.cf_di_box_sed_inj_v_diag_reg0_raw()
    }
    
    /// Get raw value of CF_DiBox_SedInjVDiagReg0
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_sed_inj_v_diag_reg0_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_DiBox_SedInjVDiagReg0
    #[inline(always)]
    pub fn set_cf_di_box_sed_inj_v_diag_reg0(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1350 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_SedInjVDiagReg1
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_sed_inj_v_diag_reg1(&self) -> u8 {
        self.cf_di_box_sed_inj_v_diag_reg1_raw()
    }
    
    /// Get raw value of CF_DiBox_SedInjVDiagReg1
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_sed_inj_v_diag_reg1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_DiBox_SedInjVDiagReg1
    #[inline(always)]
    pub fn set_cf_di_box_sed_inj_v_diag_reg1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1350 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_SedInjVDiagReg2
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_sed_inj_v_diag_reg2(&self) -> u8 {
        self.cf_di_box_sed_inj_v_diag_reg2_raw()
    }
    
    /// Get raw value of CF_DiBox_SedInjVDiagReg2
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_sed_inj_v_diag_reg2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_DiBox_SedInjVDiagReg2
    #[inline(always)]
    pub fn set_cf_di_box_sed_inj_v_diag_reg2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1350 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// CR_DiBox_BatVol
    ///
    /// - Min: 0
    /// - Max: 25.5
    /// - Unit: "V"
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cr_di_box_bat_vol(&self) -> f32 {
        self.cr_di_box_bat_vol_raw()
    }
    
    /// Get raw value of CR_DiBox_BatVol
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_di_box_bat_vol_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_DiBox_BatVol
    #[inline(always)]
    pub fn set_cr_di_box_bat_vol(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 25.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1350 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_SedInjVChg
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_sed_inj_v_chg(&self) -> bool {
        self.cf_di_box_sed_inj_v_chg_raw()
    }
    
    /// Get raw value of CF_DiBox_SedInjVChg
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_sed_inj_v_chg_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_DiBox_SedInjVChg
    #[inline(always)]
    pub fn set_cf_di_box_sed_inj_v_chg(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[56..57].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_FrtInjVChg
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_frt_inj_v_chg(&self) -> bool {
        self.cf_di_box_frt_inj_v_chg_raw()
    }
    
    /// Get raw value of CF_DiBox_FrtInjVChg
    ///
    /// - Start bit: 57
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_frt_inj_v_chg_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[57..58].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_DiBox_FrtInjVChg
    #[inline(always)]
    pub fn set_cf_di_box_frt_inj_v_chg(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[57..58].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_SedInjVErrSPI
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_sed_inj_v_err_spi(&self) -> bool {
        self.cf_di_box_sed_inj_v_err_spi_raw()
    }
    
    /// Get raw value of CF_DiBox_SedInjVErrSPI
    ///
    /// - Start bit: 58
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_sed_inj_v_err_spi_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[58..59].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_DiBox_SedInjVErrSPI
    #[inline(always)]
    pub fn set_cf_di_box_sed_inj_v_err_spi(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[58..59].store_le(value);
        Ok(())
    }
    
    /// CF_DiBox_FrtInjVErrSPI
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_di_box_frt_inj_v_err_spi(&self) -> bool {
        self.cf_di_box_frt_inj_v_err_spi_raw()
    }
    
    /// Get raw value of CF_DiBox_FrtInjVErrSPI
    ///
    /// - Start bit: 59
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_di_box_frt_inj_v_err_spi_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[59..60].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_DiBox_FrtInjVErrSPI
    #[inline(always)]
    pub fn set_cf_di_box_frt_inj_v_err_spi(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[59..60].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for DiBox12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for DiBox12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("DiBox12")
                .field("cf_di_box_frt_inj_v_diag_reg0", &self.cf_di_box_frt_inj_v_diag_reg0())
                .field("cf_di_box_frt_inj_v_diag_reg1", &self.cf_di_box_frt_inj_v_diag_reg1())
                .field("cf_di_box_frt_inj_v_diag_reg2", &self.cf_di_box_frt_inj_v_diag_reg2())
                .field("cf_di_box_sed_inj_v_diag_reg0", &self.cf_di_box_sed_inj_v_diag_reg0())
                .field("cf_di_box_sed_inj_v_diag_reg1", &self.cf_di_box_sed_inj_v_diag_reg1())
                .field("cf_di_box_sed_inj_v_diag_reg2", &self.cf_di_box_sed_inj_v_diag_reg2())
                .field("cr_di_box_bat_vol", &self.cr_di_box_bat_vol())
                .field("cf_di_box_sed_inj_v_chg", &self.cf_di_box_sed_inj_v_chg())
                .field("cf_di_box_frt_inj_v_chg", &self.cf_di_box_frt_inj_v_chg())
                .field("cf_di_box_sed_inj_v_err_spi", &self.cf_di_box_sed_inj_v_err_spi())
                .field("cf_di_box_frt_inj_v_err_spi", &self.cf_di_box_frt_inj_v_err_spi())
            .finish()
        } else {
            f.debug_tuple("DiBox12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for DiBox12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_di_box_frt_inj_v_diag_reg0 = u.int_in_range(0..=255)?;
        let cf_di_box_frt_inj_v_diag_reg1 = u.int_in_range(0..=255)?;
        let cf_di_box_frt_inj_v_diag_reg2 = u.int_in_range(0..=255)?;
        let cf_di_box_sed_inj_v_diag_reg0 = u.int_in_range(0..=255)?;
        let cf_di_box_sed_inj_v_diag_reg1 = u.int_in_range(0..=255)?;
        let cf_di_box_sed_inj_v_diag_reg2 = u.int_in_range(0..=255)?;
        let cr_di_box_bat_vol = u.float_in_range(0_f32..=25.5_f32)?;
        let cf_di_box_sed_inj_v_chg = u.int_in_range(0..=1)? == 1;
        let cf_di_box_frt_inj_v_chg = u.int_in_range(0..=1)? == 1;
        let cf_di_box_sed_inj_v_err_spi = u.int_in_range(0..=1)? == 1;
        let cf_di_box_frt_inj_v_err_spi = u.int_in_range(0..=1)? == 1;
        DiBox12::new(cf_di_box_frt_inj_v_diag_reg0,cf_di_box_frt_inj_v_diag_reg1,cf_di_box_frt_inj_v_diag_reg2,cf_di_box_sed_inj_v_diag_reg0,cf_di_box_sed_inj_v_diag_reg1,cf_di_box_sed_inj_v_diag_reg2,cr_di_box_bat_vol,cf_di_box_sed_inj_v_chg,cf_di_box_frt_inj_v_chg,cf_di_box_sed_inj_v_err_spi,cf_di_box_frt_inj_v_err_spi).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EMS14
///
/// - ID: 1349 (0x545)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct Ems14 {
    raw: [u8; 8],
}

impl Ems14 {
    pub const MESSAGE_ID: u32 = 1349;
    
    pub const AMP_CAN_MIN: f32 = 458.98_f32;
    pub const AMP_CAN_MAX: f32 = 791.660003_f32;
    pub const BAT_ALT_FR_DUTY_MIN: f32 = 0_f32;
    pub const BAT_ALT_FR_DUTY_MAX: f32 = 100_f32;
    pub const VB_MIN: f32 = 0_f32;
    pub const VB_MAX: f32 = 25.8984375_f32;
    pub const EMS_VS_MIN: f32 = 0_f32;
    pub const EMS_VS_MAX: f32 = 255.875_f32;
    pub const TEMP_FUEL_MIN: f32 = -48_f32;
    pub const TEMP_FUEL_MAX: f32 = 143.25_f32;
    
    /// Construct new EMS14 from values
    pub fn new(immo_lamp_stat: bool, l_mil: bool, im_stat: bool, amp_can: f32, bat_alt_fr_duty: f32, vb: f32, ems_vs: f32, temp_fuel: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_immo_lamp_stat(immo_lamp_stat)?;
        res.set_l_mil(l_mil)?;
        res.set_im_stat(im_stat)?;
        res.set_amp_can(amp_can)?;
        res.set_bat_alt_fr_duty(bat_alt_fr_duty)?;
        res.set_vb(vb)?;
        res.set_ems_vs(ems_vs)?;
        res.set_temp_fuel(temp_fuel)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// IMMO_LAMP_STAT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn immo_lamp_stat(&self) -> bool {
        self.immo_lamp_stat_raw()
    }
    
    /// Get raw value of IMMO_LAMP_STAT
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn immo_lamp_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of IMMO_LAMP_STAT
    #[inline(always)]
    pub fn set_immo_lamp_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// L_MIL
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, CUBIS, IBOX
    #[inline(always)]
    pub fn l_mil(&self) -> bool {
        self.l_mil_raw()
    }
    
    /// Get raw value of L_MIL
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn l_mil_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of L_MIL
    #[inline(always)]
    pub fn set_l_mil(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// IM_STAT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn im_stat(&self) -> bool {
        self.im_stat_raw()
    }
    
    /// Get raw value of IM_STAT
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn im_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of IM_STAT
    #[inline(always)]
    pub fn set_im_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// AMP_CAN
    ///
    /// - Min: 458.98
    /// - Max: 791.660003
    /// - Unit: "mmHg"
    /// - Receivers: CLU, IBOX, TCU, TPMS
    #[inline(always)]
    pub fn amp_can(&self) -> f32 {
        self.amp_can_raw()
    }
    
    /// Get raw value of AMP_CAN
    ///
    /// - Start bit: 3
    /// - Signal size: 5 bits
    /// - Factor: 10.731613
    /// - Offset: 458.98
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn amp_can_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[3..8].load_le::<u8>();
        
        let factor = 10.731613_f32;
        let offset = 458.98_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AMP_CAN
    #[inline(always)]
    pub fn set_amp_can(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 458.98_f32 || 791.660003_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1349 });
        }
        let factor = 10.731613_f32;
        let offset = 458.98_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[3..8].store_le(value);
        Ok(())
    }
    
    /// BAT_Alt_FR_Duty
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: CGW, CUBIS, IBOX, TMU
    #[inline(always)]
    pub fn bat_alt_fr_duty(&self) -> f32 {
        self.bat_alt_fr_duty_raw()
    }
    
    /// Get raw value of BAT_Alt_FR_Duty
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.4
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bat_alt_fr_duty_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 0.4_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of BAT_Alt_FR_Duty
    #[inline(always)]
    pub fn set_bat_alt_fr_duty(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1349 });
        }
        let factor = 0.4_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// VB
    ///
    /// - Min: 0
    /// - Max: 25.8984375
    /// - Unit: "V"
    /// - Receivers: CLU, CUBIS, DATC, EPB, FPCM, IBOX
    #[inline(always)]
    pub fn vb(&self) -> f32 {
        self.vb_raw()
    }
    
    /// Get raw value of VB
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.1015625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vb_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 0.1015625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VB
    #[inline(always)]
    pub fn set_vb(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 25.8984375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1349 });
        }
        let factor = 0.1015625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// EMS_VS
    ///
    /// - Min: 0
    /// - Max: 255.875
    /// - Unit: "km/h"
    /// - Receivers: CLU
    #[inline(always)]
    pub fn ems_vs(&self) -> f32 {
        self.ems_vs_raw()
    }
    
    /// Get raw value of EMS_VS
    ///
    /// - Start bit: 32
    /// - Signal size: 12 bits
    /// - Factor: 0.0625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ems_vs_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..44].load_le::<u16>();
        
        let factor = 0.0625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of EMS_VS
    #[inline(always)]
    pub fn set_ems_vs(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 255.875_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1349 });
        }
        let factor = 0.0625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[32..44].store_le(value);
        Ok(())
    }
    
    /// TEMP_FUEL
    ///
    /// - Min: -48
    /// - Max: 143.25
    /// - Unit: "deg"
    /// - Receivers: FPCM
    #[inline(always)]
    pub fn temp_fuel(&self) -> f32 {
        self.temp_fuel_raw()
    }
    
    /// Get raw value of TEMP_FUEL
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 0.75
    /// - Offset: -48
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn temp_fuel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        let factor = 0.75_f32;
        let offset = -48_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TEMP_FUEL
    #[inline(always)]
    pub fn set_temp_fuel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -48_f32 || 143.25_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1349 });
        }
        let factor = 0.75_f32;
        let offset = -48_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ems14 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ems14 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ems14")
                .field("immo_lamp_stat", &self.immo_lamp_stat())
                .field("l_mil", &self.l_mil())
                .field("im_stat", &self.im_stat())
                .field("amp_can", &self.amp_can())
                .field("bat_alt_fr_duty", &self.bat_alt_fr_duty())
                .field("vb", &self.vb())
                .field("ems_vs", &self.ems_vs())
                .field("temp_fuel", &self.temp_fuel())
            .finish()
        } else {
            f.debug_tuple("Ems14").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ems14 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let immo_lamp_stat = u.int_in_range(0..=1)? == 1;
        let l_mil = u.int_in_range(0..=1)? == 1;
        let im_stat = u.int_in_range(0..=1)? == 1;
        let amp_can = u.float_in_range(458.98_f32..=791.660003_f32)?;
        let bat_alt_fr_duty = u.float_in_range(0_f32..=100_f32)?;
        let vb = u.float_in_range(0_f32..=25.8984375_f32)?;
        let ems_vs = u.float_in_range(0_f32..=255.875_f32)?;
        let temp_fuel = u.float_in_range(-48_f32..=143.25_f32)?;
        Ems14::new(immo_lamp_stat,l_mil,im_stat,amp_can,bat_alt_fr_duty,vb,ems_vs,temp_fuel).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// DATC11
///
/// - ID: 68 (0x44)
/// - Size: 8 bytes
/// - Transmitter: DATC
#[derive(Clone, Copy)]
pub struct Datc11 {
    raw: [u8; 8],
}

impl Datc11 {
    pub const MESSAGE_ID: u32 = 68;
    
    pub const CF_DATC_TYPE_MIN: u8 = 0_u8;
    pub const CF_DATC_TYPE_MAX: u8 = 255_u8;
    pub const CF_DATC_VER_MAJ_MIN: u8 = 0_u8;
    pub const CF_DATC_VER_MAJ_MAX: u8 = 255_u8;
    pub const CF_DATC_VER_MIN_MIN: u8 = 0_u8;
    pub const CF_DATC_VER_MIN_MAX: u8 = 255_u8;
    pub const CR_DATC_OUT_TEMP_C_MIN: f32 = -41_f32;
    pub const CR_DATC_OUT_TEMP_C_MAX: f32 = 86.5_f32;
    pub const CR_DATC_OUT_TEMP_F_MIN: f32 = -42_f32;
    pub const CR_DATC_OUT_TEMP_F_MAX: f32 = 213_f32;
    pub const CF_DATC_INCAR_TEMP_MIN: f32 = -40_f32;
    pub const CF_DATC_INCAR_TEMP_MAX: f32 = 60_f32;
    
    /// Construct new DATC11 from values
    pub fn new(cf_datc_type: u8, cf_datc_ver_maj: u8, cf_datc_ver_min: u8, cr_datc_out_temp_c: f32, cr_datc_out_temp_f: f32, cf_datc_incar_temp: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_datc_type(cf_datc_type)?;
        res.set_cf_datc_ver_maj(cf_datc_ver_maj)?;
        res.set_cf_datc_ver_min(cf_datc_ver_min)?;
        res.set_cr_datc_out_temp_c(cr_datc_out_temp_c)?;
        res.set_cr_datc_out_temp_f(cr_datc_out_temp_f)?;
        res.set_cf_datc_incar_temp(cf_datc_incar_temp)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Datc_Type
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_type(&self) -> u8 {
        self.cf_datc_type_raw()
    }
    
    /// Get raw value of CF_Datc_Type
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_Type
    #[inline(always)]
    pub fn set_cf_datc_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 68 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_VerMaj
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_ver_maj(&self) -> u8 {
        self.cf_datc_ver_maj_raw()
    }
    
    /// Get raw value of CF_Datc_VerMaj
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_ver_maj_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_VerMaj
    #[inline(always)]
    pub fn set_cf_datc_ver_maj(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 68 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_VerMin
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_ver_min(&self) -> u8 {
        self.cf_datc_ver_min_raw()
    }
    
    /// Get raw value of CF_Datc_VerMin
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_ver_min_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_VerMin
    #[inline(always)]
    pub fn set_cf_datc_ver_min(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 68 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// CR_Datc_OutTempC
    ///
    /// - Min: -41
    /// - Max: 86.5
    /// - Unit: "deg"
    /// - Receivers: CLU, FPCM
    #[inline(always)]
    pub fn cr_datc_out_temp_c(&self) -> f32 {
        self.cr_datc_out_temp_c_raw()
    }
    
    /// Get raw value of CR_Datc_OutTempC
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -41
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_datc_out_temp_c_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -41_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Datc_OutTempC
    #[inline(always)]
    pub fn set_cr_datc_out_temp_c(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -41_f32 || 86.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 68 });
        }
        let factor = 0.5_f32;
        let offset = -41_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CR_Datc_OutTempF
    ///
    /// - Min: -42
    /// - Max: 213
    /// - Unit: "deg"
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cr_datc_out_temp_f(&self) -> f32 {
        self.cr_datc_out_temp_f_raw()
    }
    
    /// Get raw value of CR_Datc_OutTempF
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -42
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_datc_out_temp_f_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -42_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Datc_OutTempF
    #[inline(always)]
    pub fn set_cr_datc_out_temp_f(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -42_f32 || 213_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 68 });
        }
        let factor = 1_f32;
        let offset = -42_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_IncarTemp
    ///
    /// - Min: -40
    /// - Max: 60
    /// - Unit: "deg"
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_datc_incar_temp(&self) -> f32 {
        self.cf_datc_incar_temp_raw()
    }
    
    /// Get raw value of CF_Datc_IncarTemp
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_incar_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CF_Datc_IncarTemp
    #[inline(always)]
    pub fn set_cf_datc_incar_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 60_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 68 });
        }
        let factor = 0.5_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Datc11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Datc11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Datc11")
                .field("cf_datc_type", &self.cf_datc_type())
                .field("cf_datc_ver_maj", &self.cf_datc_ver_maj())
                .field("cf_datc_ver_min", &self.cf_datc_ver_min())
                .field("cr_datc_out_temp_c", &self.cr_datc_out_temp_c())
                .field("cr_datc_out_temp_f", &self.cr_datc_out_temp_f())
                .field("cf_datc_incar_temp", &self.cf_datc_incar_temp())
            .finish()
        } else {
            f.debug_tuple("Datc11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Datc11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_datc_type = u.int_in_range(0..=255)?;
        let cf_datc_ver_maj = u.int_in_range(0..=255)?;
        let cf_datc_ver_min = u.int_in_range(0..=255)?;
        let cr_datc_out_temp_c = u.float_in_range(-41_f32..=86.5_f32)?;
        let cr_datc_out_temp_f = u.float_in_range(-42_f32..=213_f32)?;
        let cf_datc_incar_temp = u.float_in_range(-40_f32..=60_f32)?;
        Datc11::new(cf_datc_type,cf_datc_ver_maj,cf_datc_ver_min,cr_datc_out_temp_c,cr_datc_out_temp_f,cf_datc_incar_temp).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// DATC13
///
/// - ID: 67 (0x43)
/// - Size: 8 bytes
/// - Transmitter: DATC
#[derive(Clone, Copy)]
pub struct Datc13 {
    raw: [u8; 8],
}

impl Datc13 {
    pub const MESSAGE_ID: u32 = 67;
    
    pub const CF_DATC_TEMP_DISP_UNIT_MIN: u8 = 0_u8;
    pub const CF_DATC_TEMP_DISP_UNIT_MAX: u8 = 3_u8;
    pub const CF_DATC_MOD_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_MOD_DISP_MAX: u8 = 15_u8;
    pub const CF_DATC_ION_CLEAN_MIN: u8 = 0_u8;
    pub const CF_DATC_ION_CLEAN_MAX: u8 = 3_u8;
    pub const CF_DATC_CHG_REQ_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_CHG_REQ_DISP_MAX: u8 = 3_u8;
    pub const CF_DATC_INTAKE_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_INTAKE_DISP_MAX: u8 = 3_u8;
    pub const CF_DATC_AUTO_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_AUTO_DISP_MAX: u8 = 3_u8;
    pub const CF_DATC_FR_DEF_LED_MIN: u8 = 0_u8;
    pub const CF_DATC_FR_DEF_LED_MAX: u8 = 3_u8;
    pub const CF_DATC_AUTO_DEFOG_BLINK_MIN: u8 = 0_u8;
    pub const CF_DATC_AUTO_DEFOG_BLINK_MAX: u8 = 3_u8;
    pub const CF_DATC_CLM_SCAN_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_CLM_SCAN_DISP_MAX: u8 = 3_u8;
    pub const CF_DATC_AQS_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_AQS_DISP_MAX: u8 = 3_u8;
    pub const CF_DATC_AC_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_AC_DISP_MAX: u8 = 3_u8;
    pub const CF_DATC_OP_STS_MIN: u8 = 0_u8;
    pub const CF_DATC_OP_STS_MAX: u8 = 7_u8;
    pub const CF_MTC_MAX_AC_DISP_MIN: u8 = 0_u8;
    pub const CF_MTC_MAX_AC_DISP_MAX: u8 = 3_u8;
    pub const CF_DATC_DUAL_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_DUAL_DISP_MAX: u8 = 3_u8;
    pub const CF_DATC_PWR_INF_MIN: u8 = 0_u8;
    pub const CF_DATC_PWR_INF_MAX: u8 = 15_u8;
    pub const CF_DATC_REAR_MANUAL_MIN: u8 = 0_u8;
    pub const CF_DATC_REAR_MANUAL_MAX: u8 = 3_u8;
    pub const CF_DATC_REAR_AUTO_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_REAR_AUTO_DISP_MAX: u8 = 1_u8;
    pub const CF_DATC_REAR_OFF_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_REAR_OFF_DISP_MAX: u8 = 3_u8;
    pub const CF_DATC_REAR_CLIMATE_SCN_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_REAR_CLIMATE_SCN_DISP_MAX: u8 = 3_u8;
    pub const CF_DATC_REAR_CHG_REQ_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_REAR_CHG_REQ_DISP_MAX: u8 = 3_u8;
    pub const CF_DATC_REAR_MOD_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_REAR_MOD_DISP_MAX: u8 = 15_u8;
    pub const CF_DATC_REAR_BLW_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_REAR_BLW_DISP_MAX: u8 = 15_u8;
    pub const CF_DATC_PS_MOD_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_PS_MOD_DISP_MAX: u8 = 15_u8;
    pub const CF_DATC_FRONT_BLW_DISP_MIN: u8 = 0_u8;
    pub const CF_DATC_FRONT_BLW_DISP_MAX: u8 = 15_u8;
    
    /// Construct new DATC13 from values
    pub fn new(cf_datc_temp_disp_unit: u8, cf_datc_mod_disp: u8, cf_datc_ion_clean: u8, cf_datc_chg_req_disp: u8, cf_datc_intake_disp: u8, cf_datc_auto_disp: u8, cf_datc_fr_def_led: u8, cf_datc_auto_defog_blink: u8, cf_datc_clm_scan_disp: u8, cf_datc_aqs_disp: u8, cf_datc_ac_disp: u8, cf_datc_op_sts: u8, cf_mtc_max_ac_disp: u8, cf_datc_dual_disp: u8, cf_datc_pwr_inf: u8, cf_datc_rear_manual: u8, cf_datc_rear_auto_disp: u8, cf_datc_rear_off_disp: u8, cf_datc_rear_climate_scn_disp: u8, cf_datc_rear_chg_req_disp: u8, cf_datc_rear_mod_disp: u8, cf_datc_rear_blw_disp: u8, cf_datc_ps_mod_disp: u8, cf_datc_front_blw_disp: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_datc_temp_disp_unit(cf_datc_temp_disp_unit)?;
        res.set_cf_datc_mod_disp(cf_datc_mod_disp)?;
        res.set_cf_datc_ion_clean(cf_datc_ion_clean)?;
        res.set_cf_datc_chg_req_disp(cf_datc_chg_req_disp)?;
        res.set_cf_datc_intake_disp(cf_datc_intake_disp)?;
        res.set_cf_datc_auto_disp(cf_datc_auto_disp)?;
        res.set_cf_datc_fr_def_led(cf_datc_fr_def_led)?;
        res.set_cf_datc_auto_defog_blink(cf_datc_auto_defog_blink)?;
        res.set_cf_datc_clm_scan_disp(cf_datc_clm_scan_disp)?;
        res.set_cf_datc_aqs_disp(cf_datc_aqs_disp)?;
        res.set_cf_datc_ac_disp(cf_datc_ac_disp)?;
        res.set_cf_datc_op_sts(cf_datc_op_sts)?;
        res.set_cf_mtc_max_ac_disp(cf_mtc_max_ac_disp)?;
        res.set_cf_datc_dual_disp(cf_datc_dual_disp)?;
        res.set_cf_datc_pwr_inf(cf_datc_pwr_inf)?;
        res.set_cf_datc_rear_manual(cf_datc_rear_manual)?;
        res.set_cf_datc_rear_auto_disp(cf_datc_rear_auto_disp)?;
        res.set_cf_datc_rear_off_disp(cf_datc_rear_off_disp)?;
        res.set_cf_datc_rear_climate_scn_disp(cf_datc_rear_climate_scn_disp)?;
        res.set_cf_datc_rear_chg_req_disp(cf_datc_rear_chg_req_disp)?;
        res.set_cf_datc_rear_mod_disp(cf_datc_rear_mod_disp)?;
        res.set_cf_datc_rear_blw_disp(cf_datc_rear_blw_disp)?;
        res.set_cf_datc_ps_mod_disp(cf_datc_ps_mod_disp)?;
        res.set_cf_datc_front_blw_disp(cf_datc_front_blw_disp)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Datc_TempDispUnit
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_datc_temp_disp_unit(&self) -> u8 {
        self.cf_datc_temp_disp_unit_raw()
    }
    
    /// Get raw value of CF_Datc_TempDispUnit
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_temp_disp_unit_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_TempDispUnit
    #[inline(always)]
    pub fn set_cf_datc_temp_disp_unit(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_ModDisp
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_mod_disp(&self) -> u8 {
        self.cf_datc_mod_disp_raw()
    }
    
    /// Get raw value of CF_Datc_ModDisp
    ///
    /// - Start bit: 2
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_mod_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_ModDisp
    #[inline(always)]
    pub fn set_cf_datc_mod_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..6].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_IonClean
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_ion_clean(&self) -> u8 {
        self.cf_datc_ion_clean_raw()
    }
    
    /// Get raw value of CF_Datc_IonClean
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_ion_clean_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_IonClean
    #[inline(always)]
    pub fn set_cf_datc_ion_clean(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_ChgReqDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_chg_req_disp(&self) -> u8 {
        self.cf_datc_chg_req_disp_raw()
    }
    
    /// Get raw value of CF_Datc_ChgReqDisp
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_chg_req_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_ChgReqDisp
    #[inline(always)]
    pub fn set_cf_datc_chg_req_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_IntakeDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_intake_disp(&self) -> u8 {
        self.cf_datc_intake_disp_raw()
    }
    
    /// Get raw value of CF_Datc_IntakeDisp
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_intake_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_IntakeDisp
    #[inline(always)]
    pub fn set_cf_datc_intake_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..12].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_AutoDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_auto_disp(&self) -> u8 {
        self.cf_datc_auto_disp_raw()
    }
    
    /// Get raw value of CF_Datc_AutoDisp
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_auto_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_AutoDisp
    #[inline(always)]
    pub fn set_cf_datc_auto_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..14].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_FrDefLed
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_datc_fr_def_led(&self) -> u8 {
        self.cf_datc_fr_def_led_raw()
    }
    
    /// Get raw value of CF_Datc_FrDefLed
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_fr_def_led_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_FrDefLed
    #[inline(always)]
    pub fn set_cf_datc_fr_def_led(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_AutoDefogBlink
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_auto_defog_blink(&self) -> u8 {
        self.cf_datc_auto_defog_blink_raw()
    }
    
    /// Get raw value of CF_Datc_AutoDefogBlink
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_auto_defog_blink_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_AutoDefogBlink
    #[inline(always)]
    pub fn set_cf_datc_auto_defog_blink(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..18].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_ClmScanDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_clm_scan_disp(&self) -> u8 {
        self.cf_datc_clm_scan_disp_raw()
    }
    
    /// Get raw value of CF_Datc_ClmScanDisp
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_clm_scan_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_ClmScanDisp
    #[inline(always)]
    pub fn set_cf_datc_clm_scan_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[18..20].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_AqsDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_aqs_disp(&self) -> u8 {
        self.cf_datc_aqs_disp_raw()
    }
    
    /// Get raw value of CF_Datc_AqsDisp
    ///
    /// - Start bit: 20
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_aqs_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_AqsDisp
    #[inline(always)]
    pub fn set_cf_datc_aqs_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..22].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_AcDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_ac_disp(&self) -> u8 {
        self.cf_datc_ac_disp_raw()
    }
    
    /// Get raw value of CF_Datc_AcDisp
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_ac_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_AcDisp
    #[inline(always)]
    pub fn set_cf_datc_ac_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_OpSts
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_op_sts(&self) -> u8 {
        self.cf_datc_op_sts_raw()
    }
    
    /// Get raw value of CF_Datc_OpSts
    ///
    /// - Start bit: 25
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_op_sts_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[25..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_OpSts
    #[inline(always)]
    pub fn set_cf_datc_op_sts(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[25..28].store_le(value);
        Ok(())
    }
    
    /// CF_Mtc_MaxAcDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_mtc_max_ac_disp(&self) -> u8 {
        self.cf_mtc_max_ac_disp_raw()
    }
    
    /// Get raw value of CF_Mtc_MaxAcDisp
    ///
    /// - Start bit: 28
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mtc_max_ac_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[28..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Mtc_MaxAcDisp
    #[inline(always)]
    pub fn set_cf_mtc_max_ac_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[28..30].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_DualDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_dual_disp(&self) -> u8 {
        self.cf_datc_dual_disp_raw()
    }
    
    /// Get raw value of CF_Datc_DualDisp
    ///
    /// - Start bit: 30
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_dual_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[30..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_DualDisp
    #[inline(always)]
    pub fn set_cf_datc_dual_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[30..32].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_PwrInf
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_pwr_inf(&self) -> u8 {
        self.cf_datc_pwr_inf_raw()
    }
    
    /// Get raw value of CF_Datc_PwrInf
    ///
    /// - Start bit: 32
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_pwr_inf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_PwrInf
    #[inline(always)]
    pub fn set_cf_datc_pwr_inf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..36].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_RearManual
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_rear_manual(&self) -> u8 {
        self.cf_datc_rear_manual_raw()
    }
    
    /// Get raw value of CF_Datc_RearManual
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_rear_manual_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_RearManual
    #[inline(always)]
    pub fn set_cf_datc_rear_manual(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[38..40].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_RearAutoDisp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_rear_auto_disp(&self) -> u8 {
        self.cf_datc_rear_auto_disp_raw()
    }
    
    /// Get raw value of CF_Datc_RearAutoDisp
    ///
    /// - Start bit: 40
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_rear_auto_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..42].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_RearAutoDisp
    #[inline(always)]
    pub fn set_cf_datc_rear_auto_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 1_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..42].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_RearOffDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_rear_off_disp(&self) -> u8 {
        self.cf_datc_rear_off_disp_raw()
    }
    
    /// Get raw value of CF_Datc_RearOffDisp
    ///
    /// - Start bit: 42
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_rear_off_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[42..44].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_RearOffDisp
    #[inline(always)]
    pub fn set_cf_datc_rear_off_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[42..44].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_RearClimateScnDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_rear_climate_scn_disp(&self) -> u8 {
        self.cf_datc_rear_climate_scn_disp_raw()
    }
    
    /// Get raw value of CF_Datc_RearClimateScnDisp
    ///
    /// - Start bit: 44
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_rear_climate_scn_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[44..46].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_RearClimateScnDisp
    #[inline(always)]
    pub fn set_cf_datc_rear_climate_scn_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[44..46].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_RearChgReqDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_rear_chg_req_disp(&self) -> u8 {
        self.cf_datc_rear_chg_req_disp_raw()
    }
    
    /// Get raw value of CF_Datc_RearChgReqDisp
    ///
    /// - Start bit: 46
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_rear_chg_req_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[46..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_RearChgReqDisp
    #[inline(always)]
    pub fn set_cf_datc_rear_chg_req_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[46..48].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_RearModDisp
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_rear_mod_disp(&self) -> u8 {
        self.cf_datc_rear_mod_disp_raw()
    }
    
    /// Get raw value of CF_Datc_RearModDisp
    ///
    /// - Start bit: 48
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_rear_mod_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_RearModDisp
    #[inline(always)]
    pub fn set_cf_datc_rear_mod_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..52].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_RearBlwDisp
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_rear_blw_disp(&self) -> u8 {
        self.cf_datc_rear_blw_disp_raw()
    }
    
    /// Get raw value of CF_Datc_RearBlwDisp
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_rear_blw_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_RearBlwDisp
    #[inline(always)]
    pub fn set_cf_datc_rear_blw_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[52..56].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_PSModDisp
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_ps_mod_disp(&self) -> u8 {
        self.cf_datc_ps_mod_disp_raw()
    }
    
    /// Get raw value of CF_Datc_PSModDisp
    ///
    /// - Start bit: 56
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_ps_mod_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_PSModDisp
    #[inline(always)]
    pub fn set_cf_datc_ps_mod_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..60].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_FrontBlwDisp
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_datc_front_blw_disp(&self) -> u8 {
        self.cf_datc_front_blw_disp_raw()
    }
    
    /// Get raw value of CF_Datc_FrontBlwDisp
    ///
    /// - Start bit: 60
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_front_blw_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_FrontBlwDisp
    #[inline(always)]
    pub fn set_cf_datc_front_blw_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 67 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Datc13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Datc13 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Datc13")
                .field("cf_datc_temp_disp_unit", &self.cf_datc_temp_disp_unit())
                .field("cf_datc_mod_disp", &self.cf_datc_mod_disp())
                .field("cf_datc_ion_clean", &self.cf_datc_ion_clean())
                .field("cf_datc_chg_req_disp", &self.cf_datc_chg_req_disp())
                .field("cf_datc_intake_disp", &self.cf_datc_intake_disp())
                .field("cf_datc_auto_disp", &self.cf_datc_auto_disp())
                .field("cf_datc_fr_def_led", &self.cf_datc_fr_def_led())
                .field("cf_datc_auto_defog_blink", &self.cf_datc_auto_defog_blink())
                .field("cf_datc_clm_scan_disp", &self.cf_datc_clm_scan_disp())
                .field("cf_datc_aqs_disp", &self.cf_datc_aqs_disp())
                .field("cf_datc_ac_disp", &self.cf_datc_ac_disp())
                .field("cf_datc_op_sts", &self.cf_datc_op_sts())
                .field("cf_mtc_max_ac_disp", &self.cf_mtc_max_ac_disp())
                .field("cf_datc_dual_disp", &self.cf_datc_dual_disp())
                .field("cf_datc_pwr_inf", &self.cf_datc_pwr_inf())
                .field("cf_datc_rear_manual", &self.cf_datc_rear_manual())
                .field("cf_datc_rear_auto_disp", &self.cf_datc_rear_auto_disp())
                .field("cf_datc_rear_off_disp", &self.cf_datc_rear_off_disp())
                .field("cf_datc_rear_climate_scn_disp", &self.cf_datc_rear_climate_scn_disp())
                .field("cf_datc_rear_chg_req_disp", &self.cf_datc_rear_chg_req_disp())
                .field("cf_datc_rear_mod_disp", &self.cf_datc_rear_mod_disp())
                .field("cf_datc_rear_blw_disp", &self.cf_datc_rear_blw_disp())
                .field("cf_datc_ps_mod_disp", &self.cf_datc_ps_mod_disp())
                .field("cf_datc_front_blw_disp", &self.cf_datc_front_blw_disp())
            .finish()
        } else {
            f.debug_tuple("Datc13").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Datc13 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_datc_temp_disp_unit = u.int_in_range(0..=3)?;
        let cf_datc_mod_disp = u.int_in_range(0..=15)?;
        let cf_datc_ion_clean = u.int_in_range(0..=3)?;
        let cf_datc_chg_req_disp = u.int_in_range(0..=3)?;
        let cf_datc_intake_disp = u.int_in_range(0..=3)?;
        let cf_datc_auto_disp = u.int_in_range(0..=3)?;
        let cf_datc_fr_def_led = u.int_in_range(0..=3)?;
        let cf_datc_auto_defog_blink = u.int_in_range(0..=3)?;
        let cf_datc_clm_scan_disp = u.int_in_range(0..=3)?;
        let cf_datc_aqs_disp = u.int_in_range(0..=3)?;
        let cf_datc_ac_disp = u.int_in_range(0..=3)?;
        let cf_datc_op_sts = u.int_in_range(0..=7)?;
        let cf_mtc_max_ac_disp = u.int_in_range(0..=3)?;
        let cf_datc_dual_disp = u.int_in_range(0..=3)?;
        let cf_datc_pwr_inf = u.int_in_range(0..=15)?;
        let cf_datc_rear_manual = u.int_in_range(0..=3)?;
        let cf_datc_rear_auto_disp = u.int_in_range(0..=1)?;
        let cf_datc_rear_off_disp = u.int_in_range(0..=3)?;
        let cf_datc_rear_climate_scn_disp = u.int_in_range(0..=3)?;
        let cf_datc_rear_chg_req_disp = u.int_in_range(0..=3)?;
        let cf_datc_rear_mod_disp = u.int_in_range(0..=15)?;
        let cf_datc_rear_blw_disp = u.int_in_range(0..=15)?;
        let cf_datc_ps_mod_disp = u.int_in_range(0..=15)?;
        let cf_datc_front_blw_disp = u.int_in_range(0..=15)?;
        Datc13::new(cf_datc_temp_disp_unit,cf_datc_mod_disp,cf_datc_ion_clean,cf_datc_chg_req_disp,cf_datc_intake_disp,cf_datc_auto_disp,cf_datc_fr_def_led,cf_datc_auto_defog_blink,cf_datc_clm_scan_disp,cf_datc_aqs_disp,cf_datc_ac_disp,cf_datc_op_sts,cf_mtc_max_ac_disp,cf_datc_dual_disp,cf_datc_pwr_inf,cf_datc_rear_manual,cf_datc_rear_auto_disp,cf_datc_rear_off_disp,cf_datc_rear_climate_scn_disp,cf_datc_rear_chg_req_disp,cf_datc_rear_mod_disp,cf_datc_rear_blw_disp,cf_datc_ps_mod_disp,cf_datc_front_blw_disp).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// DATC12
///
/// - ID: 66 (0x42)
/// - Size: 8 bytes
/// - Transmitter: DATC
#[derive(Clone, Copy)]
pub struct Datc12 {
    raw: [u8; 8],
}

impl Datc12 {
    pub const MESSAGE_ID: u32 = 66;
    
    pub const CR_DATC_DR_TEMP_DISP_C_MIN: f32 = 15_f32;
    pub const CR_DATC_DR_TEMP_DISP_C_MAX: f32 = 32_f32;
    pub const CR_DATC_DR_TEMP_DISP_F_MIN: f32 = 58_f32;
    pub const CR_DATC_DR_TEMP_DISP_F_MAX: f32 = 90_f32;
    pub const CR_DATC_PS_TEMP_DISP_C_MIN: f32 = 15_f32;
    pub const CR_DATC_PS_TEMP_DISP_C_MAX: f32 = 32_f32;
    pub const CR_DATC_PS_TEMP_DISP_F_MIN: f32 = 58_f32;
    pub const CR_DATC_PS_TEMP_DISP_F_MAX: f32 = 90_f32;
    pub const CR_DATC_REAR_DR_TEMP_DISP_C_MIN: f32 = 15_f32;
    pub const CR_DATC_REAR_DR_TEMP_DISP_C_MAX: f32 = 32_f32;
    pub const CR_DATC_REAR_DR_TEMP_DISP_F_MIN: f32 = 58_f32;
    pub const CR_DATC_REAR_DR_TEMP_DISP_F_MAX: f32 = 90_f32;
    pub const CF_DATC_CO2_WARNING_MIN: u8 = 0_u8;
    pub const CF_DATC_CO2_WARNING_MAX: u8 = 3_u8;
    
    /// Construct new DATC12 from values
    pub fn new(cr_datc_dr_temp_disp_c: f32, cr_datc_dr_temp_disp_f: f32, cr_datc_ps_temp_disp_c: f32, cr_datc_ps_temp_disp_f: f32, cr_datc_rear_dr_temp_disp_c: f32, cr_datc_rear_dr_temp_disp_f: f32, cf_datc_co2_warning: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cr_datc_dr_temp_disp_c(cr_datc_dr_temp_disp_c)?;
        res.set_cr_datc_dr_temp_disp_f(cr_datc_dr_temp_disp_f)?;
        res.set_cr_datc_ps_temp_disp_c(cr_datc_ps_temp_disp_c)?;
        res.set_cr_datc_ps_temp_disp_f(cr_datc_ps_temp_disp_f)?;
        res.set_cr_datc_rear_dr_temp_disp_c(cr_datc_rear_dr_temp_disp_c)?;
        res.set_cr_datc_rear_dr_temp_disp_f(cr_datc_rear_dr_temp_disp_f)?;
        res.set_cf_datc_co2_warning(cf_datc_co2_warning)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CR_Datc_DrTempDispC
    ///
    /// - Min: 15
    /// - Max: 32
    /// - Unit: "deg"
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cr_datc_dr_temp_disp_c(&self) -> f32 {
        self.cr_datc_dr_temp_disp_c_raw()
    }
    
    /// Get raw value of CR_Datc_DrTempDispC
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 14
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_datc_dr_temp_disp_c_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 14_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Datc_DrTempDispC
    #[inline(always)]
    pub fn set_cr_datc_dr_temp_disp_c(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 15_f32 || 32_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 66 });
        }
        let factor = 0.5_f32;
        let offset = 14_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CR_Datc_DrTempDispF
    ///
    /// - Min: 58
    /// - Max: 90
    /// - Unit: "deg"
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cr_datc_dr_temp_disp_f(&self) -> f32 {
        self.cr_datc_dr_temp_disp_f_raw()
    }
    
    /// Get raw value of CR_Datc_DrTempDispF
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 56
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_datc_dr_temp_disp_f_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = 56_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Datc_DrTempDispF
    #[inline(always)]
    pub fn set_cr_datc_dr_temp_disp_f(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 58_f32 || 90_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 66 });
        }
        let factor = 1_f32;
        let offset = 56_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CR_Datc_PsTempDispC
    ///
    /// - Min: 15
    /// - Max: 32
    /// - Unit: "deg"
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cr_datc_ps_temp_disp_c(&self) -> f32 {
        self.cr_datc_ps_temp_disp_c_raw()
    }
    
    /// Get raw value of CR_Datc_PsTempDispC
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 14
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_datc_ps_temp_disp_c_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 14_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Datc_PsTempDispC
    #[inline(always)]
    pub fn set_cr_datc_ps_temp_disp_c(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 15_f32 || 32_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 66 });
        }
        let factor = 0.5_f32;
        let offset = 14_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// CR_Datc_PsTempDispF
    ///
    /// - Min: 58
    /// - Max: 90
    /// - Unit: "deg"
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cr_datc_ps_temp_disp_f(&self) -> f32 {
        self.cr_datc_ps_temp_disp_f_raw()
    }
    
    /// Get raw value of CR_Datc_PsTempDispF
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 56
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_datc_ps_temp_disp_f_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = 56_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Datc_PsTempDispF
    #[inline(always)]
    pub fn set_cr_datc_ps_temp_disp_f(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 58_f32 || 90_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 66 });
        }
        let factor = 1_f32;
        let offset = 56_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CR_Datc_RearDrTempDispC
    ///
    /// - Min: 15
    /// - Max: 32
    /// - Unit: "deg"
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cr_datc_rear_dr_temp_disp_c(&self) -> f32 {
        self.cr_datc_rear_dr_temp_disp_c_raw()
    }
    
    /// Get raw value of CR_Datc_RearDrTempDispC
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: 14
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_datc_rear_dr_temp_disp_c_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = 14_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Datc_RearDrTempDispC
    #[inline(always)]
    pub fn set_cr_datc_rear_dr_temp_disp_c(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 15_f32 || 32_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 66 });
        }
        let factor = 0.5_f32;
        let offset = 14_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// CR_Datc_RearDrTempDispF
    ///
    /// - Min: 58
    /// - Max: 90
    /// - Unit: "deg"
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cr_datc_rear_dr_temp_disp_f(&self) -> f32 {
        self.cr_datc_rear_dr_temp_disp_f_raw()
    }
    
    /// Get raw value of CR_Datc_RearDrTempDispF
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 58
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_datc_rear_dr_temp_disp_f_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = 58_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Datc_RearDrTempDispF
    #[inline(always)]
    pub fn set_cr_datc_rear_dr_temp_disp_f(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 58_f32 || 90_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 66 });
        }
        let factor = 1_f32;
        let offset = 58_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_CO2_Warning
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_co2_warning(&self) -> u8 {
        self.cf_datc_co2_warning_raw()
    }
    
    /// Get raw value of CF_Datc_CO2_Warning
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_co2_warning_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_CO2_Warning
    #[inline(always)]
    pub fn set_cf_datc_co2_warning(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 66 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Datc12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Datc12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Datc12")
                .field("cr_datc_dr_temp_disp_c", &self.cr_datc_dr_temp_disp_c())
                .field("cr_datc_dr_temp_disp_f", &self.cr_datc_dr_temp_disp_f())
                .field("cr_datc_ps_temp_disp_c", &self.cr_datc_ps_temp_disp_c())
                .field("cr_datc_ps_temp_disp_f", &self.cr_datc_ps_temp_disp_f())
                .field("cr_datc_rear_dr_temp_disp_c", &self.cr_datc_rear_dr_temp_disp_c())
                .field("cr_datc_rear_dr_temp_disp_f", &self.cr_datc_rear_dr_temp_disp_f())
                .field("cf_datc_co2_warning", &self.cf_datc_co2_warning())
            .finish()
        } else {
            f.debug_tuple("Datc12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Datc12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cr_datc_dr_temp_disp_c = u.float_in_range(15_f32..=32_f32)?;
        let cr_datc_dr_temp_disp_f = u.float_in_range(58_f32..=90_f32)?;
        let cr_datc_ps_temp_disp_c = u.float_in_range(15_f32..=32_f32)?;
        let cr_datc_ps_temp_disp_f = u.float_in_range(58_f32..=90_f32)?;
        let cr_datc_rear_dr_temp_disp_c = u.float_in_range(15_f32..=32_f32)?;
        let cr_datc_rear_dr_temp_disp_f = u.float_in_range(58_f32..=90_f32)?;
        let cf_datc_co2_warning = u.int_in_range(0..=3)?;
        Datc12::new(cr_datc_dr_temp_disp_c,cr_datc_dr_temp_disp_f,cr_datc_ps_temp_disp_c,cr_datc_ps_temp_disp_f,cr_datc_rear_dr_temp_disp_c,cr_datc_rear_dr_temp_disp_f,cf_datc_co2_warning).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// CGW1
///
/// - ID: 1345 (0x541)
/// - Size: 8 bytes
/// - Transmitter: BCM
#[derive(Clone, Copy)]
pub struct Cgw1 {
    raw: [u8; 8],
}

impl Cgw1 {
    pub const MESSAGE_ID: u32 = 1345;
    
    pub const CF_GWAY_IGN_SW_MIN: u8 = 0_u8;
    pub const CF_GWAY_IGN_SW_MAX: u8 = 7_u8;
    pub const CF_GWAY_RKE_CMD_MIN: u8 = 0_u8;
    pub const CF_GWAY_RKE_CMD_MAX: u8 = 7_u8;
    pub const CF_GWAY_DRV_DR_SW_MIN: u8 = 0_u8;
    pub const CF_GWAY_DRV_DR_SW_MAX: u8 = 3_u8;
    pub const CF_GWAY_DRV_SEAT_BELT_SW_MIN: u8 = 0_u8;
    pub const CF_GWAY_DRV_SEAT_BELT_SW_MAX: u8 = 3_u8;
    pub const CF_GWAY_TRUNK_TG_SW_MIN: u8 = 0_u8;
    pub const CF_GWAY_TRUNK_TG_SW_MAX: u8 = 3_u8;
    pub const CF_GWAY_AST_SEAT_BELT_SW_MIN: u8 = 0_u8;
    pub const CF_GWAY_AST_SEAT_BELT_SW_MAX: u8 = 3_u8;
    pub const CF_GWAY_HOOD_SW_MIN: u8 = 0_u8;
    pub const CF_GWAY_HOOD_SW_MAX: u8 = 3_u8;
    pub const CF_GWAY_TURN_SIG_LH_MIN: u8 = 0_u8;
    pub const CF_GWAY_TURN_SIG_LH_MAX: u8 = 3_u8;
    pub const CF_GWAY_WIPER_INT_T_MIN: u8 = 0_u8;
    pub const CF_GWAY_WIPER_INT_T_MAX: u8 = 7_u8;
    pub const CF_GWAY_RAIN_SNS_STATE_MIN: u8 = 0_u8;
    pub const CF_GWAY_RAIN_SNS_STATE_MAX: u8 = 7_u8;
    pub const CF_GWAY_HAZARD_SW_MIN: u8 = 0_u8;
    pub const CF_GWAY_HAZARD_SW_MAX: u8 = 3_u8;
    pub const CF_GWAY_LIGHT_SW_STATE_MIN: u8 = 0_u8;
    pub const CF_GWAY_LIGHT_SW_STATE_MAX: u8 = 3_u8;
    pub const CF_GWAY_PASSIVE_ACCESS_LOCK_MIN: u8 = 0_u8;
    pub const CF_GWAY_PASSIVE_ACCESS_LOCK_MAX: u8 = 7_u8;
    pub const CF_GWAY_PASSIVE_ACCESS_UNLOCK_MIN: u8 = 0_u8;
    pub const CF_GWAY_PASSIVE_ACCESS_UNLOCK_MAX: u8 = 7_u8;
    pub const CF_GWAY_INHIBIT_RMT_MIN: u8 = 0_u8;
    pub const CF_GWAY_INHIBIT_RMT_MAX: u8 = 3_u8;
    pub const CF_GWAY_PARK_BRAKE_SW_MIN: u8 = 0_u8;
    pub const CF_GWAY_PARK_BRAKE_SW_MAX: u8 = 3_u8;
    pub const CF_GWAY_TURN_SIG_RH_MIN: u8 = 0_u8;
    pub const CF_GWAY_TURN_SIG_RH_MAX: u8 = 3_u8;
    
    /// Construct new CGW1 from values
    pub fn new(cf_gway_ign_sw: u8, cf_gway_rke_cmd: u8, cf_gway_drv_key_lock_sw: bool, cf_gway_drv_key_unlock_sw: bool, cf_gway_drv_dr_sw: u8, cf_gway_drv_seat_belt_sw: u8, cf_gway_trunk_tg_sw: u8, cf_gway_ast_seat_belt_sw: u8, cf_gway_smk_option: bool, cf_gway_hood_sw: u8, cf_gway_turn_sig_lh: u8, cf_gway_wiper_int_t: u8, cf_gway_wiper_int_sw: bool, cf_gway_wiper_low_sw: bool, cf_gway_wiper_high_sw: bool, cf_gway_wiper_auto_sw: bool, cf_gway_rain_sns_state: u8, cf_gway_head_lamp_low: bool, cf_gway_head_lamp_high: bool, cf_gway_hazard_sw: u8, cf_gway_ast_dr_sw: bool, cf_gway_defogger_rly: bool, cf_gway_a_light_stat: bool, cf_gway_light_sw_state: u8, cf_gway_frt_fog_act: bool, cf_gway_t_sig_rh_sw: bool, cf_gway_t_sig_lh_sw: bool, cf_gway_drive_type_option: bool, cf_gway_starter_rly_state: bool, cf_gway_passive_access_lock: u8, cf_gway_wiper_mist_sw: bool, cf_gway_passive_access_unlock: u8, cf_gway_rr_sun_roof_open_state: bool, cf_gway_passing_sw: bool, cf_gway_hba_control_mode: bool, cf_gway_h_lp_high_sw: bool, cf_gway_inhibit_rmt: u8, cf_gway_rain_sns_option: bool, c_sun_roof_open_state: bool, cf_gway_ign1: bool, cf_gway_ign2: bool, cf_gway_park_brake_sw: u8, cf_gway_turn_sig_rh: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_gway_ign_sw(cf_gway_ign_sw)?;
        res.set_cf_gway_rke_cmd(cf_gway_rke_cmd)?;
        res.set_cf_gway_drv_key_lock_sw(cf_gway_drv_key_lock_sw)?;
        res.set_cf_gway_drv_key_unlock_sw(cf_gway_drv_key_unlock_sw)?;
        res.set_cf_gway_drv_dr_sw(cf_gway_drv_dr_sw)?;
        res.set_cf_gway_drv_seat_belt_sw(cf_gway_drv_seat_belt_sw)?;
        res.set_cf_gway_trunk_tg_sw(cf_gway_trunk_tg_sw)?;
        res.set_cf_gway_ast_seat_belt_sw(cf_gway_ast_seat_belt_sw)?;
        res.set_cf_gway_smk_option(cf_gway_smk_option)?;
        res.set_cf_gway_hood_sw(cf_gway_hood_sw)?;
        res.set_cf_gway_turn_sig_lh(cf_gway_turn_sig_lh)?;
        res.set_cf_gway_wiper_int_t(cf_gway_wiper_int_t)?;
        res.set_cf_gway_wiper_int_sw(cf_gway_wiper_int_sw)?;
        res.set_cf_gway_wiper_low_sw(cf_gway_wiper_low_sw)?;
        res.set_cf_gway_wiper_high_sw(cf_gway_wiper_high_sw)?;
        res.set_cf_gway_wiper_auto_sw(cf_gway_wiper_auto_sw)?;
        res.set_cf_gway_rain_sns_state(cf_gway_rain_sns_state)?;
        res.set_cf_gway_head_lamp_low(cf_gway_head_lamp_low)?;
        res.set_cf_gway_head_lamp_high(cf_gway_head_lamp_high)?;
        res.set_cf_gway_hazard_sw(cf_gway_hazard_sw)?;
        res.set_cf_gway_ast_dr_sw(cf_gway_ast_dr_sw)?;
        res.set_cf_gway_defogger_rly(cf_gway_defogger_rly)?;
        res.set_cf_gway_a_light_stat(cf_gway_a_light_stat)?;
        res.set_cf_gway_light_sw_state(cf_gway_light_sw_state)?;
        res.set_cf_gway_frt_fog_act(cf_gway_frt_fog_act)?;
        res.set_cf_gway_t_sig_rh_sw(cf_gway_t_sig_rh_sw)?;
        res.set_cf_gway_t_sig_lh_sw(cf_gway_t_sig_lh_sw)?;
        res.set_cf_gway_drive_type_option(cf_gway_drive_type_option)?;
        res.set_cf_gway_starter_rly_state(cf_gway_starter_rly_state)?;
        res.set_cf_gway_passive_access_lock(cf_gway_passive_access_lock)?;
        res.set_cf_gway_wiper_mist_sw(cf_gway_wiper_mist_sw)?;
        res.set_cf_gway_passive_access_unlock(cf_gway_passive_access_unlock)?;
        res.set_cf_gway_rr_sun_roof_open_state(cf_gway_rr_sun_roof_open_state)?;
        res.set_cf_gway_passing_sw(cf_gway_passing_sw)?;
        res.set_cf_gway_hba_control_mode(cf_gway_hba_control_mode)?;
        res.set_cf_gway_h_lp_high_sw(cf_gway_h_lp_high_sw)?;
        res.set_cf_gway_inhibit_rmt(cf_gway_inhibit_rmt)?;
        res.set_cf_gway_rain_sns_option(cf_gway_rain_sns_option)?;
        res.set_c_sun_roof_open_state(c_sun_roof_open_state)?;
        res.set_cf_gway_ign1(cf_gway_ign1)?;
        res.set_cf_gway_ign2(cf_gway_ign2)?;
        res.set_cf_gway_park_brake_sw(cf_gway_park_brake_sw)?;
        res.set_cf_gway_turn_sig_rh(cf_gway_turn_sig_rh)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Gway_IGNSw
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU, ECS, EMS, EPB, ESC, IBOX, LVR, MDPS, SAS, SCC, ECS, EMS, EPB, ESC, IBOX, LVR, MDPS, SAS, SCC
    #[inline(always)]
    pub fn cf_gway_ign_sw(&self) -> u8 {
        self.cf_gway_ign_sw_raw()
    }
    
    /// Get raw value of CF_Gway_IGNSw
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ign_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_IGNSw
    #[inline(always)]
    pub fn set_cf_gway_ign_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..3].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RKECmd
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, ECS, EMS, IBOX, ECS, EMS, IBOX
    #[inline(always)]
    pub fn cf_gway_rke_cmd(&self) -> u8 {
        self.cf_gway_rke_cmd_raw()
    }
    
    /// Get raw value of CF_Gway_RKECmd
    ///
    /// - Start bit: 3
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rke_cmd_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[3..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_RKECmd
    #[inline(always)]
    pub fn set_cf_gway_rke_cmd(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[3..6].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_DrvKeyLockSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ECS, EMS, IBOX, ECS, EMS, IBOX
    #[inline(always)]
    pub fn cf_gway_drv_key_lock_sw(&self) -> bool {
        self.cf_gway_drv_key_lock_sw_raw()
    }
    
    /// Get raw value of CF_Gway_DrvKeyLockSw
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_drv_key_lock_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_DrvKeyLockSw
    #[inline(always)]
    pub fn set_cf_gway_drv_key_lock_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[6..7].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_DrvKeyUnlockSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ECS, EMS, IBOX, ECS, EMS, IBOX
    #[inline(always)]
    pub fn cf_gway_drv_key_unlock_sw(&self) -> bool {
        self.cf_gway_drv_key_unlock_sw_raw()
    }
    
    /// Get raw value of CF_Gway_DrvKeyUnlockSw
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_drv_key_unlock_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_DrvKeyUnlockSw
    #[inline(always)]
    pub fn set_cf_gway_drv_key_unlock_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_DrvDrSw
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, ECS, EMS, EPB, ESC, IBOX, SCC, TCU, ECS, EMS, EPB, ESC, IBOX, SCC, TCU
    #[inline(always)]
    pub fn cf_gway_drv_dr_sw(&self) -> u8 {
        self.cf_gway_drv_dr_sw_raw()
    }
    
    /// Get raw value of CF_Gway_DrvDrSw
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_drv_dr_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_DrvDrSw
    #[inline(always)]
    pub fn set_cf_gway_drv_dr_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_DrvSeatBeltSw
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, EPB, ESC, IBOX, PSB, TCU, EMS, EPB, ESC, IBOX, PSB, TCU
    #[inline(always)]
    pub fn cf_gway_drv_seat_belt_sw(&self) -> u8 {
        self.cf_gway_drv_seat_belt_sw_raw()
    }
    
    /// Get raw value of CF_Gway_DrvSeatBeltSw
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_drv_seat_belt_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_DrvSeatBeltSw
    #[inline(always)]
    pub fn set_cf_gway_drv_seat_belt_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..12].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_TrunkTgSw
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, ECS, EMS, EPB, ESC, IBOX, ECS, EMS, EPB, ESC, IBOX
    #[inline(always)]
    pub fn cf_gway_trunk_tg_sw(&self) -> u8 {
        self.cf_gway_trunk_tg_sw_raw()
    }
    
    /// Get raw value of CF_Gway_TrunkTgSw
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_trunk_tg_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_TrunkTgSw
    #[inline(always)]
    pub fn set_cf_gway_trunk_tg_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..14].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_AstSeatBeltSw
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: IBOX, PSB, IBOX, PSB
    #[inline(always)]
    pub fn cf_gway_ast_seat_belt_sw(&self) -> u8 {
        self.cf_gway_ast_seat_belt_sw_raw()
    }
    
    /// Get raw value of CF_Gway_AstSeatBeltSw
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ast_seat_belt_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_AstSeatBeltSw
    #[inline(always)]
    pub fn set_cf_gway_ast_seat_belt_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_SMKOption
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, EMS, IBOX, EMS, IBOX, SMK
    #[inline(always)]
    pub fn cf_gway_smk_option(&self) -> bool {
        self.cf_gway_smk_option_raw()
    }
    
    /// Get raw value of CF_Gway_SMKOption
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_smk_option_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_SMKOption
    #[inline(always)]
    pub fn set_cf_gway_smk_option(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[16..17].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_HoodSw
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, EMS, EPB, ESC, IBOX, EMS, EPB, ESC, IBOX
    #[inline(always)]
    pub fn cf_gway_hood_sw(&self) -> u8 {
        self.cf_gway_hood_sw_raw()
    }
    
    /// Get raw value of CF_Gway_HoodSw
    ///
    /// - Start bit: 17
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_hood_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[17..19].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_HoodSw
    #[inline(always)]
    pub fn set_cf_gway_hood_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[17..19].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_TurnSigLh
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, EMS, IBOX, LCA, LDWS_LKAS, SCC, EMS, IBOX, LCA, LDWS_LKAS, SCC
    #[inline(always)]
    pub fn cf_gway_turn_sig_lh(&self) -> u8 {
        self.cf_gway_turn_sig_lh_raw()
    }
    
    /// Get raw value of CF_Gway_TurnSigLh
    ///
    /// - Start bit: 19
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_turn_sig_lh_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[19..21].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_TurnSigLh
    #[inline(always)]
    pub fn set_cf_gway_turn_sig_lh(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[19..21].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_WiperIntT
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, EMS, IBOX, LDWS_LKAS, EMS, ESC, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_wiper_int_t(&self) -> u8 {
        self.cf_gway_wiper_int_t_raw()
    }
    
    /// Get raw value of CF_Gway_WiperIntT
    ///
    /// - Start bit: 21
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_wiper_int_t_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[21..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_WiperIntT
    #[inline(always)]
    pub fn set_cf_gway_wiper_int_t(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[21..24].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_WiperIntSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, EMS, IBOX, LDWS_LKAS, EMS, ESC, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_wiper_int_sw(&self) -> bool {
        self.cf_gway_wiper_int_sw_raw()
    }
    
    /// Get raw value of CF_Gway_WiperIntSw
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_wiper_int_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_WiperIntSw
    #[inline(always)]
    pub fn set_cf_gway_wiper_int_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[24..25].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_WiperLowSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, EMS, IBOX, LDWS_LKAS, EMS, ESC, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_wiper_low_sw(&self) -> bool {
        self.cf_gway_wiper_low_sw_raw()
    }
    
    /// Get raw value of CF_Gway_WiperLowSw
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_wiper_low_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_WiperLowSw
    #[inline(always)]
    pub fn set_cf_gway_wiper_low_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[25..26].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_WiperHighSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, EMS, IBOX, LDWS_LKAS, EMS, ESC, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_wiper_high_sw(&self) -> bool {
        self.cf_gway_wiper_high_sw_raw()
    }
    
    /// Get raw value of CF_Gway_WiperHighSw
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_wiper_high_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_WiperHighSw
    #[inline(always)]
    pub fn set_cf_gway_wiper_high_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[26..27].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_WiperAutoSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, EMS, IBOX, LDWS_LKAS, EMS, ESC, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_wiper_auto_sw(&self) -> bool {
        self.cf_gway_wiper_auto_sw_raw()
    }
    
    /// Get raw value of CF_Gway_WiperAutoSw
    ///
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_wiper_auto_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[27..28].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_WiperAutoSw
    #[inline(always)]
    pub fn set_cf_gway_wiper_auto_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[27..28].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RainSnsState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AFLS, EMS, IBOX, LDWS_LKAS, AFLS, EMS, ESC, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_rain_sns_state(&self) -> u8 {
        self.cf_gway_rain_sns_state_raw()
    }
    
    /// Get raw value of CF_Gway_RainSnsState
    ///
    /// - Start bit: 28
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rain_sns_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[28..31].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_RainSnsState
    #[inline(always)]
    pub fn set_cf_gway_rain_sns_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[28..31].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_HeadLampLow
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: AFLS, CLU, EMS, IBOX, LDWS_LKAS, SNV, AFLS, EMS, IBOX, LDWS_LKAS, SNV
    #[inline(always)]
    pub fn cf_gway_head_lamp_low(&self) -> bool {
        self.cf_gway_head_lamp_low_raw()
    }
    
    /// Get raw value of CF_Gway_HeadLampLow
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_head_lamp_low_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_HeadLampLow
    #[inline(always)]
    pub fn set_cf_gway_head_lamp_low(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[31..32].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_HeadLampHigh
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: AFLS, CLU, EMS, IBOX, LDWS_LKAS, AFLS, EMS, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_head_lamp_high(&self) -> bool {
        self.cf_gway_head_lamp_high_raw()
    }
    
    /// Get raw value of CF_Gway_HeadLampHigh
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_head_lamp_high_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_HeadLampHigh
    #[inline(always)]
    pub fn set_cf_gway_head_lamp_high(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[32..33].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_HazardSw
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: ABS, EMS, ESC, IBOX, LCA, LDWS_LKAS, ABS, EMS, ESC, IBOX, LCA, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_hazard_sw(&self) -> u8 {
        self.cf_gway_hazard_sw_raw()
    }
    
    /// Get raw value of CF_Gway_HazardSw
    ///
    /// - Start bit: 33
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_hazard_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[33..35].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_HazardSw
    #[inline(always)]
    pub fn set_cf_gway_hazard_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[33..35].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_AstDrSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX, IBOX
    #[inline(always)]
    pub fn cf_gway_ast_dr_sw(&self) -> bool {
        self.cf_gway_ast_dr_sw_raw()
    }
    
    /// Get raw value of CF_Gway_AstDrSw
    ///
    /// - Start bit: 35
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ast_dr_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[35..36].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_AstDrSw
    #[inline(always)]
    pub fn set_cf_gway_ast_dr_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[35..36].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_DefoggerRly
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX, EMS, IBOX
    #[inline(always)]
    pub fn cf_gway_defogger_rly(&self) -> bool {
        self.cf_gway_defogger_rly_raw()
    }
    
    /// Get raw value of CF_Gway_DefoggerRly
    ///
    /// - Start bit: 36
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_defogger_rly_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[36..37].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_DefoggerRly
    #[inline(always)]
    pub fn set_cf_gway_defogger_rly(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[36..37].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_ALightStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: AFLS, IBOX, LDWS_LKAS, AFLS, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_a_light_stat(&self) -> bool {
        self.cf_gway_a_light_stat_raw()
    }
    
    /// Get raw value of CF_Gway_ALightStat
    ///
    /// - Start bit: 37
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_a_light_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[37..38].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_ALightStat
    #[inline(always)]
    pub fn set_cf_gway_a_light_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[37..38].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_LightSwState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: AFLS, IBOX, LDWS_LKAS, AFLS, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_light_sw_state(&self) -> u8 {
        self.cf_gway_light_sw_state_raw()
    }
    
    /// Get raw value of CF_Gway_LightSwState
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_light_sw_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_LightSwState
    #[inline(always)]
    pub fn set_cf_gway_light_sw_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[38..40].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_Frt_Fog_Act
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: AFLS, CLU, IBOX, LDWS_LKAS, AFLS, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_frt_fog_act(&self) -> bool {
        self.cf_gway_frt_fog_act_raw()
    }
    
    /// Get raw value of CF_Gway_Frt_Fog_Act
    ///
    /// - Start bit: 40
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_frt_fog_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[40..41].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_Frt_Fog_Act
    #[inline(always)]
    pub fn set_cf_gway_frt_fog_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[40..41].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_TSigRHSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: IBOX, LDWS_LKAS, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_t_sig_rh_sw(&self) -> bool {
        self.cf_gway_t_sig_rh_sw_raw()
    }
    
    /// Get raw value of CF_Gway_TSigRHSw
    ///
    /// - Start bit: 41
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_t_sig_rh_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[41..42].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_TSigRHSw
    #[inline(always)]
    pub fn set_cf_gway_t_sig_rh_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[41..42].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_TSigLHSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: IBOX, LDWS_LKAS, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_t_sig_lh_sw(&self) -> bool {
        self.cf_gway_t_sig_lh_sw_raw()
    }
    
    /// Get raw value of CF_Gway_TSigLHSw
    ///
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_t_sig_lh_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[42..43].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_TSigLHSw
    #[inline(always)]
    pub fn set_cf_gway_t_sig_lh_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[42..43].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_DriveTypeOption
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX, LDWS_LKAS, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_drive_type_option(&self) -> bool {
        self.cf_gway_drive_type_option_raw()
    }
    
    /// Get raw value of CF_Gway_DriveTypeOption
    ///
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_drive_type_option_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[43..44].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_DriveTypeOption
    #[inline(always)]
    pub fn set_cf_gway_drive_type_option(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[43..44].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_StarterRlyState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX, EMS, IBOX, SMK
    #[inline(always)]
    pub fn cf_gway_starter_rly_state(&self) -> bool {
        self.cf_gway_starter_rly_state_raw()
    }
    
    /// Get raw value of CF_Gway_StarterRlyState
    ///
    /// - Start bit: 44
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_starter_rly_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[44..45].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_StarterRlyState
    #[inline(always)]
    pub fn set_cf_gway_starter_rly_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[44..45].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PassiveAccessLock
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, ECS, EMS, IBOX, ECS, EMS, IBOX, SMK
    #[inline(always)]
    pub fn cf_gway_passive_access_lock(&self) -> u8 {
        self.cf_gway_passive_access_lock_raw()
    }
    
    /// Get raw value of CF_Gway_PassiveAccessLock
    ///
    /// - Start bit: 45
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_passive_access_lock_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[45..47].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PassiveAccessLock
    #[inline(always)]
    pub fn set_cf_gway_passive_access_lock(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[45..47].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_WiperMistSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, EMS, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_wiper_mist_sw(&self) -> bool {
        self.cf_gway_wiper_mist_sw_raw()
    }
    
    /// Get raw value of CF_Gway_WiperMistSw
    ///
    /// - Start bit: 47
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_wiper_mist_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[47..48].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_WiperMistSw
    #[inline(always)]
    pub fn set_cf_gway_wiper_mist_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[47..48].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PassiveAccessUnlock
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, ECS, EMS, IBOX, ECS, EMS, IBOX, SMK
    #[inline(always)]
    pub fn cf_gway_passive_access_unlock(&self) -> u8 {
        self.cf_gway_passive_access_unlock_raw()
    }
    
    /// Get raw value of CF_Gway_PassiveAccessUnlock
    ///
    /// - Start bit: 48
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_passive_access_unlock_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..50].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PassiveAccessUnlock
    #[inline(always)]
    pub fn set_cf_gway_passive_access_unlock(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..50].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RrSunRoofOpenState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, DATC, IBOX
    #[inline(always)]
    pub fn cf_gway_rr_sun_roof_open_state(&self) -> bool {
        self.cf_gway_rr_sun_roof_open_state_raw()
    }
    
    /// Get raw value of CF_Gway_RrSunRoofOpenState
    ///
    /// - Start bit: 50
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rr_sun_roof_open_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[50..51].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_RrSunRoofOpenState
    #[inline(always)]
    pub fn set_cf_gway_rr_sun_roof_open_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[50..51].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PassingSW
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: AFLS, IBOX, LDWS_LKAS, AFLS, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_passing_sw(&self) -> bool {
        self.cf_gway_passing_sw_raw()
    }
    
    /// Get raw value of CF_Gway_PassingSW
    ///
    /// - Start bit: 51
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_passing_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[51..52].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_PassingSW
    #[inline(always)]
    pub fn set_cf_gway_passing_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[51..52].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_HBAControlMode
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: IBOX, LDWS_LKAS, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_hba_control_mode(&self) -> bool {
        self.cf_gway_hba_control_mode_raw()
    }
    
    /// Get raw value of CF_Gway_HBAControlMode
    ///
    /// - Start bit: 52
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_hba_control_mode_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[52..53].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_HBAControlMode
    #[inline(always)]
    pub fn set_cf_gway_hba_control_mode(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[52..53].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_HLpHighSw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: IBOX, LDWS_LKAS, IBOX, LDWS_LKAS
    #[inline(always)]
    pub fn cf_gway_h_lp_high_sw(&self) -> bool {
        self.cf_gway_h_lp_high_sw_raw()
    }
    
    /// Get raw value of CF_Gway_HLpHighSw
    ///
    /// - Start bit: 53
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_h_lp_high_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[53..54].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_HLpHighSw
    #[inline(always)]
    pub fn set_cf_gway_h_lp_high_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[53..54].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_InhibitRMT
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, EPB, ESC, IBOX, LCA, LDWS_LKAS, MDPS, PGS, SCC, SPAS, TPMS, EPB, ESC, IBOX, LCA, LDWS_LKAS, PGS, SCC, SPAS, TPMS
    #[inline(always)]
    pub fn cf_gway_inhibit_rmt(&self) -> u8 {
        self.cf_gway_inhibit_rmt_raw()
    }
    
    /// Get raw value of CF_Gway_InhibitRMT
    ///
    /// - Start bit: 54
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_inhibit_rmt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[54..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_InhibitRMT
    #[inline(always)]
    pub fn set_cf_gway_inhibit_rmt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[54..56].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RainSnsOption
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_rain_sns_option(&self) -> bool {
        self.cf_gway_rain_sns_option_raw()
    }
    
    /// Get raw value of CF_Gway_RainSnsOption
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rain_sns_option_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_RainSnsOption
    #[inline(always)]
    pub fn set_cf_gway_rain_sns_option(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[56..57].store_le(value);
        Ok(())
    }
    
    /// C_SunRoofOpenState
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, DATC, IBOX, DATC, IBOX
    #[inline(always)]
    pub fn c_sun_roof_open_state(&self) -> bool {
        self.c_sun_roof_open_state_raw()
    }
    
    /// Get raw value of C_SunRoofOpenState
    ///
    /// - Start bit: 57
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_sun_roof_open_state_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[57..58].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of C_SunRoofOpenState
    #[inline(always)]
    pub fn set_c_sun_roof_open_state(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[57..58].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_Ign1
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_ign1(&self) -> bool {
        self.cf_gway_ign1_raw()
    }
    
    /// Get raw value of CF_Gway_Ign1
    ///
    /// - Start bit: 58
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ign1_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[58..59].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_Ign1
    #[inline(always)]
    pub fn set_cf_gway_ign1(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[58..59].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_Ign2
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_ign2(&self) -> bool {
        self.cf_gway_ign2_raw()
    }
    
    /// Get raw value of CF_Gway_Ign2
    ///
    /// - Start bit: 59
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ign2_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[59..60].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_Ign2
    #[inline(always)]
    pub fn set_cf_gway_ign2(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[59..60].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_ParkBrakeSw
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, ESC, IBOX, SCC, ESC, IBOX, SCC
    #[inline(always)]
    pub fn cf_gway_park_brake_sw(&self) -> u8 {
        self.cf_gway_park_brake_sw_raw()
    }
    
    /// Get raw value of CF_Gway_ParkBrakeSw
    ///
    /// - Start bit: 60
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_park_brake_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..62].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_ParkBrakeSw
    #[inline(always)]
    pub fn set_cf_gway_park_brake_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..62].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_TurnSigRh
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, EMS, IBOX, LCA, LDWS_LKAS, SCC, EMS, IBOX, LCA, LDWS_LKAS, SCC
    #[inline(always)]
    pub fn cf_gway_turn_sig_rh(&self) -> u8 {
        self.cf_gway_turn_sig_rh_raw()
    }
    
    /// Get raw value of CF_Gway_TurnSigRh
    ///
    /// - Start bit: 62
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_turn_sig_rh_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[62..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_TurnSigRh
    #[inline(always)]
    pub fn set_cf_gway_turn_sig_rh(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1345 });
        }
        self.raw.view_bits_mut::<Lsb0>()[62..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Cgw1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Cgw1 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Cgw1")
                .field("cf_gway_ign_sw", &self.cf_gway_ign_sw())
                .field("cf_gway_rke_cmd", &self.cf_gway_rke_cmd())
                .field("cf_gway_drv_key_lock_sw", &self.cf_gway_drv_key_lock_sw())
                .field("cf_gway_drv_key_unlock_sw", &self.cf_gway_drv_key_unlock_sw())
                .field("cf_gway_drv_dr_sw", &self.cf_gway_drv_dr_sw())
                .field("cf_gway_drv_seat_belt_sw", &self.cf_gway_drv_seat_belt_sw())
                .field("cf_gway_trunk_tg_sw", &self.cf_gway_trunk_tg_sw())
                .field("cf_gway_ast_seat_belt_sw", &self.cf_gway_ast_seat_belt_sw())
                .field("cf_gway_smk_option", &self.cf_gway_smk_option())
                .field("cf_gway_hood_sw", &self.cf_gway_hood_sw())
                .field("cf_gway_turn_sig_lh", &self.cf_gway_turn_sig_lh())
                .field("cf_gway_wiper_int_t", &self.cf_gway_wiper_int_t())
                .field("cf_gway_wiper_int_sw", &self.cf_gway_wiper_int_sw())
                .field("cf_gway_wiper_low_sw", &self.cf_gway_wiper_low_sw())
                .field("cf_gway_wiper_high_sw", &self.cf_gway_wiper_high_sw())
                .field("cf_gway_wiper_auto_sw", &self.cf_gway_wiper_auto_sw())
                .field("cf_gway_rain_sns_state", &self.cf_gway_rain_sns_state())
                .field("cf_gway_head_lamp_low", &self.cf_gway_head_lamp_low())
                .field("cf_gway_head_lamp_high", &self.cf_gway_head_lamp_high())
                .field("cf_gway_hazard_sw", &self.cf_gway_hazard_sw())
                .field("cf_gway_ast_dr_sw", &self.cf_gway_ast_dr_sw())
                .field("cf_gway_defogger_rly", &self.cf_gway_defogger_rly())
                .field("cf_gway_a_light_stat", &self.cf_gway_a_light_stat())
                .field("cf_gway_light_sw_state", &self.cf_gway_light_sw_state())
                .field("cf_gway_frt_fog_act", &self.cf_gway_frt_fog_act())
                .field("cf_gway_t_sig_rh_sw", &self.cf_gway_t_sig_rh_sw())
                .field("cf_gway_t_sig_lh_sw", &self.cf_gway_t_sig_lh_sw())
                .field("cf_gway_drive_type_option", &self.cf_gway_drive_type_option())
                .field("cf_gway_starter_rly_state", &self.cf_gway_starter_rly_state())
                .field("cf_gway_passive_access_lock", &self.cf_gway_passive_access_lock())
                .field("cf_gway_wiper_mist_sw", &self.cf_gway_wiper_mist_sw())
                .field("cf_gway_passive_access_unlock", &self.cf_gway_passive_access_unlock())
                .field("cf_gway_rr_sun_roof_open_state", &self.cf_gway_rr_sun_roof_open_state())
                .field("cf_gway_passing_sw", &self.cf_gway_passing_sw())
                .field("cf_gway_hba_control_mode", &self.cf_gway_hba_control_mode())
                .field("cf_gway_h_lp_high_sw", &self.cf_gway_h_lp_high_sw())
                .field("cf_gway_inhibit_rmt", &self.cf_gway_inhibit_rmt())
                .field("cf_gway_rain_sns_option", &self.cf_gway_rain_sns_option())
                .field("c_sun_roof_open_state", &self.c_sun_roof_open_state())
                .field("cf_gway_ign1", &self.cf_gway_ign1())
                .field("cf_gway_ign2", &self.cf_gway_ign2())
                .field("cf_gway_park_brake_sw", &self.cf_gway_park_brake_sw())
                .field("cf_gway_turn_sig_rh", &self.cf_gway_turn_sig_rh())
            .finish()
        } else {
            f.debug_tuple("Cgw1").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Cgw1 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_gway_ign_sw = u.int_in_range(0..=7)?;
        let cf_gway_rke_cmd = u.int_in_range(0..=7)?;
        let cf_gway_drv_key_lock_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_drv_key_unlock_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_drv_dr_sw = u.int_in_range(0..=3)?;
        let cf_gway_drv_seat_belt_sw = u.int_in_range(0..=3)?;
        let cf_gway_trunk_tg_sw = u.int_in_range(0..=3)?;
        let cf_gway_ast_seat_belt_sw = u.int_in_range(0..=3)?;
        let cf_gway_smk_option = u.int_in_range(0..=1)? == 1;
        let cf_gway_hood_sw = u.int_in_range(0..=3)?;
        let cf_gway_turn_sig_lh = u.int_in_range(0..=3)?;
        let cf_gway_wiper_int_t = u.int_in_range(0..=7)?;
        let cf_gway_wiper_int_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_wiper_low_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_wiper_high_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_wiper_auto_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_rain_sns_state = u.int_in_range(0..=7)?;
        let cf_gway_head_lamp_low = u.int_in_range(0..=1)? == 1;
        let cf_gway_head_lamp_high = u.int_in_range(0..=1)? == 1;
        let cf_gway_hazard_sw = u.int_in_range(0..=3)?;
        let cf_gway_ast_dr_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_defogger_rly = u.int_in_range(0..=1)? == 1;
        let cf_gway_a_light_stat = u.int_in_range(0..=1)? == 1;
        let cf_gway_light_sw_state = u.int_in_range(0..=3)?;
        let cf_gway_frt_fog_act = u.int_in_range(0..=1)? == 1;
        let cf_gway_t_sig_rh_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_t_sig_lh_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_drive_type_option = u.int_in_range(0..=1)? == 1;
        let cf_gway_starter_rly_state = u.int_in_range(0..=1)? == 1;
        let cf_gway_passive_access_lock = u.int_in_range(0..=7)?;
        let cf_gway_wiper_mist_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_passive_access_unlock = u.int_in_range(0..=7)?;
        let cf_gway_rr_sun_roof_open_state = u.int_in_range(0..=1)? == 1;
        let cf_gway_passing_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_hba_control_mode = u.int_in_range(0..=1)? == 1;
        let cf_gway_h_lp_high_sw = u.int_in_range(0..=1)? == 1;
        let cf_gway_inhibit_rmt = u.int_in_range(0..=3)?;
        let cf_gway_rain_sns_option = u.int_in_range(0..=1)? == 1;
        let c_sun_roof_open_state = u.int_in_range(0..=1)? == 1;
        let cf_gway_ign1 = u.int_in_range(0..=1)? == 1;
        let cf_gway_ign2 = u.int_in_range(0..=1)? == 1;
        let cf_gway_park_brake_sw = u.int_in_range(0..=3)?;
        let cf_gway_turn_sig_rh = u.int_in_range(0..=3)?;
        Cgw1::new(cf_gway_ign_sw,cf_gway_rke_cmd,cf_gway_drv_key_lock_sw,cf_gway_drv_key_unlock_sw,cf_gway_drv_dr_sw,cf_gway_drv_seat_belt_sw,cf_gway_trunk_tg_sw,cf_gway_ast_seat_belt_sw,cf_gway_smk_option,cf_gway_hood_sw,cf_gway_turn_sig_lh,cf_gway_wiper_int_t,cf_gway_wiper_int_sw,cf_gway_wiper_low_sw,cf_gway_wiper_high_sw,cf_gway_wiper_auto_sw,cf_gway_rain_sns_state,cf_gway_head_lamp_low,cf_gway_head_lamp_high,cf_gway_hazard_sw,cf_gway_ast_dr_sw,cf_gway_defogger_rly,cf_gway_a_light_stat,cf_gway_light_sw_state,cf_gway_frt_fog_act,cf_gway_t_sig_rh_sw,cf_gway_t_sig_lh_sw,cf_gway_drive_type_option,cf_gway_starter_rly_state,cf_gway_passive_access_lock,cf_gway_wiper_mist_sw,cf_gway_passive_access_unlock,cf_gway_rr_sun_roof_open_state,cf_gway_passing_sw,cf_gway_hba_control_mode,cf_gway_h_lp_high_sw,cf_gway_inhibit_rmt,cf_gway_rain_sns_option,c_sun_roof_open_state,cf_gway_ign1,cf_gway_ign2,cf_gway_park_brake_sw,cf_gway_turn_sig_rh).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// DATC14
///
/// - ID: 64 (0x40)
/// - Size: 8 bytes
/// - Transmitter: DATC
#[derive(Clone, Copy)]
pub struct Datc14 {
    raw: [u8; 8],
}

impl Datc14 {
    pub const MESSAGE_ID: u32 = 64;
    
    pub const CF_DATC_AQS_LEVEL_OUT_MIN: u8 = 0_u8;
    pub const CF_DATC_AQS_LEVEL_OUT_MAX: u8 = 3_u8;
    pub const CF_DATC_DIAG_MODE_MIN: u8 = 0_u8;
    pub const CF_DATC_DIAG_MODE_MAX: u8 = 3_u8;
    pub const CR_DATC_SELF_DIAG_CODE_MIN: f32 = 0_f32;
    pub const CR_DATC_SELF_DIAG_CODE_MAX: f32 = 254_f32;
    pub const DATC_SYNC_DISP_MIN: u8 = 0_u8;
    pub const DATC_SYNC_DISP_MAX: u8 = 3_u8;
    pub const DATC_OFF_DISP_MIN: u8 = 0_u8;
    pub const DATC_OFF_DISP_MAX: u8 = 3_u8;
    pub const DATC_SMART_VENT_DISP_MIN: u8 = 0_u8;
    pub const DATC_SMART_VENT_DISP_MAX: u8 = 3_u8;
    pub const DATC_SMART_VENT_ON_OFF_STATUS_MIN: u8 = 0_u8;
    pub const DATC_SMART_VENT_ON_OFF_STATUS_MAX: u8 = 3_u8;
    pub const DATC_AUTO_DEFOG_SYS_OFF_DISP_MIN: u8 = 0_u8;
    pub const DATC_AUTO_DEFOG_SYS_OFF_DISP_MAX: u8 = 3_u8;
    pub const DATC_ADS_DISP_MIN: u8 = 0_u8;
    pub const DATC_ADS_DISP_MAX: u8 = 3_u8;
    
    /// Construct new DATC14 from values
    pub fn new(cf_datc_aqs_level_out: u8, cf_datc_diag_mode: u8, cr_datc_self_diag_code: f32, datc_sync_disp: u8, datc_off_disp: u8, datc_smart_vent_disp: u8, datc_smart_vent_on_off_status: u8, datc_auto_defog_sys_off_disp: u8, datc_ads_disp: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_datc_aqs_level_out(cf_datc_aqs_level_out)?;
        res.set_cf_datc_diag_mode(cf_datc_diag_mode)?;
        res.set_cr_datc_self_diag_code(cr_datc_self_diag_code)?;
        res.set_datc_sync_disp(datc_sync_disp)?;
        res.set_datc_off_disp(datc_off_disp)?;
        res.set_datc_smart_vent_disp(datc_smart_vent_disp)?;
        res.set_datc_smart_vent_on_off_status(datc_smart_vent_on_off_status)?;
        res.set_datc_auto_defog_sys_off_disp(datc_auto_defog_sys_off_disp)?;
        res.set_datc_ads_disp(datc_ads_disp)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Datc_AqsLevelOut
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_aqs_level_out(&self) -> u8 {
        self.cf_datc_aqs_level_out_raw()
    }
    
    /// Get raw value of CF_Datc_AqsLevelOut
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_aqs_level_out_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_AqsLevelOut
    #[inline(always)]
    pub fn set_cf_datc_aqs_level_out(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 64 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..4].store_le(value);
        Ok(())
    }
    
    /// CF_Datc_DiagMode
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_datc_diag_mode(&self) -> u8 {
        self.cf_datc_diag_mode_raw()
    }
    
    /// Get raw value of CF_Datc_DiagMode
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_datc_diag_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Datc_DiagMode
    #[inline(always)]
    pub fn set_cf_datc_diag_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 64 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// CR_Datc_SelfDiagCode
    ///
    /// - Min: 0
    /// - Max: 254
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cr_datc_self_diag_code(&self) -> f32 {
        self.cr_datc_self_diag_code_raw()
    }
    
    /// Get raw value of CR_Datc_SelfDiagCode
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -1
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_datc_self_diag_code_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -1_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Datc_SelfDiagCode
    #[inline(always)]
    pub fn set_cr_datc_self_diag_code(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 254_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 64 });
        }
        let factor = 1_f32;
        let offset = -1_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// DATC_SyncDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn datc_sync_disp(&self) -> u8 {
        self.datc_sync_disp_raw()
    }
    
    /// Get raw value of DATC_SyncDisp
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn datc_sync_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DATC_SyncDisp
    #[inline(always)]
    pub fn set_datc_sync_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 64 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..20].store_le(value);
        Ok(())
    }
    
    /// DATC_OffDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn datc_off_disp(&self) -> u8 {
        self.datc_off_disp_raw()
    }
    
    /// Get raw value of DATC_OffDisp
    ///
    /// - Start bit: 20
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn datc_off_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DATC_OffDisp
    #[inline(always)]
    pub fn set_datc_off_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 64 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..22].store_le(value);
        Ok(())
    }
    
    /// DATC_SmartVentDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn datc_smart_vent_disp(&self) -> u8 {
        self.datc_smart_vent_disp_raw()
    }
    
    /// Get raw value of DATC_SmartVentDisp
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn datc_smart_vent_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DATC_SmartVentDisp
    #[inline(always)]
    pub fn set_datc_smart_vent_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 64 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
    /// DATC_SmartVentOnOffStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn datc_smart_vent_on_off_status(&self) -> u8 {
        self.datc_smart_vent_on_off_status_raw()
    }
    
    /// Get raw value of DATC_SmartVentOnOffStatus
    ///
    /// - Start bit: 24
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn datc_smart_vent_on_off_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..26].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DATC_SmartVentOnOffStatus
    #[inline(always)]
    pub fn set_datc_smart_vent_on_off_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 64 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..26].store_le(value);
        Ok(())
    }
    
    /// DATC_AutoDefogSysOff_Disp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn datc_auto_defog_sys_off_disp(&self) -> u8 {
        self.datc_auto_defog_sys_off_disp_raw()
    }
    
    /// Get raw value of DATC_AutoDefogSysOff_Disp
    ///
    /// - Start bit: 26
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn datc_auto_defog_sys_off_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[26..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DATC_AutoDefogSysOff_Disp
    #[inline(always)]
    pub fn set_datc_auto_defog_sys_off_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 64 });
        }
        self.raw.view_bits_mut::<Lsb0>()[26..28].store_le(value);
        Ok(())
    }
    
    /// DATC_ADSDisp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn datc_ads_disp(&self) -> u8 {
        self.datc_ads_disp_raw()
    }
    
    /// Get raw value of DATC_ADSDisp
    ///
    /// - Start bit: 28
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn datc_ads_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[28..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DATC_ADSDisp
    #[inline(always)]
    pub fn set_datc_ads_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 64 });
        }
        self.raw.view_bits_mut::<Lsb0>()[28..30].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Datc14 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Datc14 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Datc14")
                .field("cf_datc_aqs_level_out", &self.cf_datc_aqs_level_out())
                .field("cf_datc_diag_mode", &self.cf_datc_diag_mode())
                .field("cr_datc_self_diag_code", &self.cr_datc_self_diag_code())
                .field("datc_sync_disp", &self.datc_sync_disp())
                .field("datc_off_disp", &self.datc_off_disp())
                .field("datc_smart_vent_disp", &self.datc_smart_vent_disp())
                .field("datc_smart_vent_on_off_status", &self.datc_smart_vent_on_off_status())
                .field("datc_auto_defog_sys_off_disp", &self.datc_auto_defog_sys_off_disp())
                .field("datc_ads_disp", &self.datc_ads_disp())
            .finish()
        } else {
            f.debug_tuple("Datc14").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Datc14 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_datc_aqs_level_out = u.int_in_range(0..=3)?;
        let cf_datc_diag_mode = u.int_in_range(0..=3)?;
        let cr_datc_self_diag_code = u.float_in_range(0_f32..=254_f32)?;
        let datc_sync_disp = u.int_in_range(0..=3)?;
        let datc_off_disp = u.int_in_range(0..=3)?;
        let datc_smart_vent_disp = u.int_in_range(0..=3)?;
        let datc_smart_vent_on_off_status = u.int_in_range(0..=3)?;
        let datc_auto_defog_sys_off_disp = u.int_in_range(0..=3)?;
        let datc_ads_disp = u.int_in_range(0..=3)?;
        Datc14::new(cf_datc_aqs_level_out,cf_datc_diag_mode,cr_datc_self_diag_code,datc_sync_disp,datc_off_disp,datc_smart_vent_disp,datc_smart_vent_on_off_status,datc_auto_defog_sys_off_disp,datc_ads_disp).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// LKAS11
///
/// - ID: 832 (0x340)
/// - Size: 8 bytes
/// - Transmitter: LDWS_LKAS
#[derive(Clone, Copy)]
pub struct Lkas11 {
    raw: [u8; 8],
}

impl Lkas11 {
    pub const MESSAGE_ID: u32 = 832;
    
    pub const CF_LKAS_LDWS_ACTIVEMODE_MIN: u8 = 0_u8;
    pub const CF_LKAS_LDWS_ACTIVEMODE_MAX: u8 = 3_u8;
    pub const CF_LKAS_LDWS_SYS_STATE_MIN: u8 = 0_u8;
    pub const CF_LKAS_LDWS_SYS_STATE_MAX: u8 = 15_u8;
    pub const CF_LKAS_SYS_WARNING_MIN: u8 = 0_u8;
    pub const CF_LKAS_SYS_WARNING_MAX: u8 = 15_u8;
    pub const CF_LKAS_LDWS_LH_WARNING_MIN: u8 = 0_u8;
    pub const CF_LKAS_LDWS_LH_WARNING_MAX: u8 = 3_u8;
    pub const CF_LKAS_LDWS_RH_WARNING_MIN: u8 = 0_u8;
    pub const CF_LKAS_LDWS_RH_WARNING_MAX: u8 = 3_u8;
    pub const CR_LKAS_STR_TOQ_REQ_MIN: f32 = -1024_f32;
    pub const CR_LKAS_STR_TOQ_REQ_MAX: f32 = 1024_f32;
    pub const CF_LKAS_HBA_SYS_STATE_MIN: u8 = 0_u8;
    pub const CF_LKAS_HBA_SYS_STATE_MAX: u8 = 7_u8;
    pub const CF_LKAS_FCW_OPT_MIN: u8 = 0_u8;
    pub const CF_LKAS_FCW_OPT_MAX: u8 = 3_u8;
    pub const CF_LKAS_HBA_OPT_MIN: u8 = 0_u8;
    pub const CF_LKAS_HBA_OPT_MAX: u8 = 1_u8;
    pub const CF_LKAS_MSG_COUNT_MIN: u8 = 0_u8;
    pub const CF_LKAS_MSG_COUNT_MAX: u8 = 15_u8;
    pub const CF_LKAS_FCW_SYS_STATE_MIN: u8 = 0_u8;
    pub const CF_LKAS_FCW_SYS_STATE_MAX: u8 = 7_u8;
    pub const CF_LKAS_FCW_COLLISION_WARNING_MIN: u8 = 0_u8;
    pub const CF_LKAS_FCW_COLLISION_WARNING_MAX: u8 = 3_u8;
    pub const CF_LKAS_FUSION_STATE_MIN: u8 = 0_u8;
    pub const CF_LKAS_FUSION_STATE_MAX: u8 = 3_u8;
    pub const CF_LKAS_CHKSUM_MIN: u8 = 0_u8;
    pub const CF_LKAS_CHKSUM_MAX: u8 = 255_u8;
    pub const CF_LKAS_FCW_OPT_USM_MIN: u8 = 0_u8;
    pub const CF_LKAS_FCW_OPT_USM_MAX: u8 = 7_u8;
    pub const CF_LKAS_LDWS_OPT_USM_MIN: u8 = 0_u8;
    pub const CF_LKAS_LDWS_OPT_USM_MAX: u8 = 7_u8;
    pub const CF_LKAS_UNKNOWN2_MIN: u8 = 0_u8;
    pub const CF_LKAS_UNKNOWN2_MAX: u8 = 1_u8;
    
    /// Construct new LKAS11 from values
    pub fn new(cf_lkas_ldws_activemode: u8, cf_lkas_ldws_sys_state: u8, cf_lkas_sys_warning: u8, cf_lkas_ldws_lh_warning: u8, cf_lkas_ldws_rh_warning: u8, cf_lkas_hba_lamp: bool, cf_lkas_fcw_bas_req: bool, cr_lkas_str_toq_req: f32, cf_lkas_act_toi: bool, cf_lkas_toi_flt: bool, cf_lkas_hba_sys_state: u8, cf_lkas_fcw_opt: u8, cf_lkas_hba_opt: u8, cf_lkas_msg_count: u8, cf_lkas_fcw_sys_state: u8, cf_lkas_fcw_collision_warning: u8, cf_lkas_fusion_state: u8, cf_lkas_unknown1: bool, cf_lkas_chksum: u8, cf_lkas_fcw_opt_usm: u8, cf_lkas_ldws_opt_usm: u8, cf_lkas_unknown2: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_lkas_ldws_activemode(cf_lkas_ldws_activemode)?;
        res.set_cf_lkas_ldws_sys_state(cf_lkas_ldws_sys_state)?;
        res.set_cf_lkas_sys_warning(cf_lkas_sys_warning)?;
        res.set_cf_lkas_ldws_lh_warning(cf_lkas_ldws_lh_warning)?;
        res.set_cf_lkas_ldws_rh_warning(cf_lkas_ldws_rh_warning)?;
        res.set_cf_lkas_hba_lamp(cf_lkas_hba_lamp)?;
        res.set_cf_lkas_fcw_bas_req(cf_lkas_fcw_bas_req)?;
        res.set_cr_lkas_str_toq_req(cr_lkas_str_toq_req)?;
        res.set_cf_lkas_act_toi(cf_lkas_act_toi)?;
        res.set_cf_lkas_toi_flt(cf_lkas_toi_flt)?;
        res.set_cf_lkas_hba_sys_state(cf_lkas_hba_sys_state)?;
        res.set_cf_lkas_fcw_opt(cf_lkas_fcw_opt)?;
        res.set_cf_lkas_hba_opt(cf_lkas_hba_opt)?;
        res.set_cf_lkas_msg_count(cf_lkas_msg_count)?;
        res.set_cf_lkas_fcw_sys_state(cf_lkas_fcw_sys_state)?;
        res.set_cf_lkas_fcw_collision_warning(cf_lkas_fcw_collision_warning)?;
        res.set_cf_lkas_fusion_state(cf_lkas_fusion_state)?;
        res.set_cf_lkas_unknown1(cf_lkas_unknown1)?;
        res.set_cf_lkas_chksum(cf_lkas_chksum)?;
        res.set_cf_lkas_fcw_opt_usm(cf_lkas_fcw_opt_usm)?;
        res.set_cf_lkas_ldws_opt_usm(cf_lkas_ldws_opt_usm)?;
        res.set_cf_lkas_unknown2(cf_lkas_unknown2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Lkas_LdwsActivemode
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, IBOX, PSB
    #[inline(always)]
    pub fn cf_lkas_ldws_activemode(&self) -> u8 {
        self.cf_lkas_ldws_activemode_raw()
    }
    
    /// Get raw value of CF_Lkas_LdwsActivemode
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_ldws_activemode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_LdwsActivemode
    #[inline(always)]
    pub fn set_cf_lkas_ldws_activemode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_LdwsSysState
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU, IBOX, PSB
    #[inline(always)]
    pub fn cf_lkas_ldws_sys_state(&self) -> u8 {
        self.cf_lkas_ldws_sys_state_raw()
    }
    
    /// Get raw value of CF_Lkas_LdwsSysState
    ///
    /// - Start bit: 2
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_ldws_sys_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_LdwsSysState
    #[inline(always)]
    pub fn set_cf_lkas_ldws_sys_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..6].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_SysWarning
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_lkas_sys_warning(&self) -> u8 {
        self.cf_lkas_sys_warning_raw()
    }
    
    /// Get raw value of CF_Lkas_SysWarning
    ///
    /// - Start bit: 6
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_sys_warning_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_SysWarning
    #[inline(always)]
    pub fn set_cf_lkas_sys_warning(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..10].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_LdwsLHWarning
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CLU, PSB
    #[inline(always)]
    pub fn cf_lkas_ldws_lh_warning(&self) -> u8 {
        self.cf_lkas_ldws_lh_warning_raw()
    }
    
    /// Get raw value of CF_Lkas_LdwsLHWarning
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_ldws_lh_warning_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_LdwsLHWarning
    #[inline(always)]
    pub fn set_cf_lkas_ldws_lh_warning(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..12].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_LdwsRHWarning
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CLU, PSB
    #[inline(always)]
    pub fn cf_lkas_ldws_rh_warning(&self) -> u8 {
        self.cf_lkas_ldws_rh_warning_raw()
    }
    
    /// Get raw value of CF_Lkas_LdwsRHWarning
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_ldws_rh_warning_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_LdwsRHWarning
    #[inline(always)]
    pub fn set_cf_lkas_ldws_rh_warning(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..14].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_HbaLamp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_lkas_hba_lamp(&self) -> bool {
        self.cf_lkas_hba_lamp_raw()
    }
    
    /// Get raw value of CF_Lkas_HbaLamp
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_hba_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Lkas_HbaLamp
    #[inline(always)]
    pub fn set_cf_lkas_hba_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[14..15].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_FcwBasReq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ABS, ESC
    #[inline(always)]
    pub fn cf_lkas_fcw_bas_req(&self) -> bool {
        self.cf_lkas_fcw_bas_req_raw()
    }
    
    /// Get raw value of CF_Lkas_FcwBasReq
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_fcw_bas_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Lkas_FcwBasReq
    #[inline(always)]
    pub fn set_cf_lkas_fcw_bas_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[15..16].store_le(value);
        Ok(())
    }
    
    /// CR_Lkas_StrToqReq
    ///
    /// - Min: -1024
    /// - Max: 1024
    /// - Unit: ""
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn cr_lkas_str_toq_req(&self) -> f32 {
        self.cr_lkas_str_toq_req_raw()
    }
    
    /// Get raw value of CR_Lkas_StrToqReq
    ///
    /// - Start bit: 16
    /// - Signal size: 11 bits
    /// - Factor: 1
    /// - Offset: -1024
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_lkas_str_toq_req_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..27].load_le::<u16>();
        
        let factor = 1_f32;
        let offset = -1024_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Lkas_StrToqReq
    #[inline(always)]
    pub fn set_cr_lkas_str_toq_req(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -1024_f32 || 1024_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        let factor = 1_f32;
        let offset = -1024_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[16..27].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_ActToi
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn cf_lkas_act_toi(&self) -> bool {
        self.cf_lkas_act_toi_raw()
    }
    
    /// Get raw value of CF_Lkas_ActToi
    ///
    /// - Start bit: 27
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_act_toi_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[27..28].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Lkas_ActToi
    #[inline(always)]
    pub fn set_cf_lkas_act_toi(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[27..28].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_ToiFlt
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn cf_lkas_toi_flt(&self) -> bool {
        self.cf_lkas_toi_flt_raw()
    }
    
    /// Get raw value of CF_Lkas_ToiFlt
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_toi_flt_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Lkas_ToiFlt
    #[inline(always)]
    pub fn set_cf_lkas_toi_flt(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[28..29].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_HbaSysState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_lkas_hba_sys_state(&self) -> u8 {
        self.cf_lkas_hba_sys_state_raw()
    }
    
    /// Get raw value of CF_Lkas_HbaSysState
    ///
    /// - Start bit: 29
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_hba_sys_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[29..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_HbaSysState
    #[inline(always)]
    pub fn set_cf_lkas_hba_sys_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[29..32].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_FcwOpt
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_lkas_fcw_opt(&self) -> u8 {
        self.cf_lkas_fcw_opt_raw()
    }
    
    /// Get raw value of CF_Lkas_FcwOpt
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_fcw_opt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_FcwOpt
    #[inline(always)]
    pub fn set_cf_lkas_fcw_opt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..34].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_HbaOpt
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM, CGW
    #[inline(always)]
    pub fn cf_lkas_hba_opt(&self) -> u8 {
        self.cf_lkas_hba_opt_raw()
    }
    
    /// Get raw value of CF_Lkas_HbaOpt
    ///
    /// - Start bit: 34
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_hba_opt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[34..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_HbaOpt
    #[inline(always)]
    pub fn set_cf_lkas_hba_opt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 1_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[34..36].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_MsgCount
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU, MDPS
    #[inline(always)]
    pub fn cf_lkas_msg_count(&self) -> u8 {
        self.cf_lkas_msg_count_raw()
    }
    
    /// Get raw value of CF_Lkas_MsgCount
    ///
    /// - Start bit: 36
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_msg_count_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[36..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_MsgCount
    #[inline(always)]
    pub fn set_cf_lkas_msg_count(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[36..40].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_FcwSysState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_lkas_fcw_sys_state(&self) -> u8 {
        self.cf_lkas_fcw_sys_state_raw()
    }
    
    /// Get raw value of CF_Lkas_FcwSysState
    ///
    /// - Start bit: 40
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_fcw_sys_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..43].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_FcwSysState
    #[inline(always)]
    pub fn set_cf_lkas_fcw_sys_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..43].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_FcwCollisionWarning
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_lkas_fcw_collision_warning(&self) -> u8 {
        self.cf_lkas_fcw_collision_warning_raw()
    }
    
    /// Get raw value of CF_Lkas_FcwCollisionWarning
    ///
    /// - Start bit: 43
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_fcw_collision_warning_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[43..45].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_FcwCollisionWarning
    #[inline(always)]
    pub fn set_cf_lkas_fcw_collision_warning(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[43..45].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_FusionState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: SCC
    #[inline(always)]
    pub fn cf_lkas_fusion_state(&self) -> u8 {
        self.cf_lkas_fusion_state_raw()
    }
    
    /// Get raw value of CF_Lkas_FusionState
    ///
    /// - Start bit: 45
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_fusion_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[45..47].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_FusionState
    #[inline(always)]
    pub fn set_cf_lkas_fusion_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[45..47].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_Unknown1
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_lkas_unknown1(&self) -> bool {
        self.cf_lkas_unknown1_raw()
    }
    
    /// Get raw value of CF_Lkas_Unknown1
    ///
    /// - Start bit: 47
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_unknown1_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[47..48].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Lkas_Unknown1
    #[inline(always)]
    pub fn set_cf_lkas_unknown1(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[47..48].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_Chksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn cf_lkas_chksum(&self) -> u8 {
        self.cf_lkas_chksum_raw()
    }
    
    /// Get raw value of CF_Lkas_Chksum
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_chksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_Chksum
    #[inline(always)]
    pub fn set_cf_lkas_chksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_FcwOpt_USM
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_lkas_fcw_opt_usm(&self) -> u8 {
        self.cf_lkas_fcw_opt_usm_raw()
    }
    
    /// Get raw value of CF_Lkas_FcwOpt_USM
    ///
    /// - Start bit: 56
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_fcw_opt_usm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..59].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_FcwOpt_USM
    #[inline(always)]
    pub fn set_cf_lkas_fcw_opt_usm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..59].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_LdwsOpt_USM
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, MDPS
    #[inline(always)]
    pub fn cf_lkas_ldws_opt_usm(&self) -> u8 {
        self.cf_lkas_ldws_opt_usm_raw()
    }
    
    /// Get raw value of CF_Lkas_LdwsOpt_USM
    ///
    /// - Start bit: 59
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_ldws_opt_usm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[59..62].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_LdwsOpt_USM
    #[inline(always)]
    pub fn set_cf_lkas_ldws_opt_usm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[59..62].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_Unknown2
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_lkas_unknown2(&self) -> u8 {
        self.cf_lkas_unknown2_raw()
    }
    
    /// Get raw value of CF_Lkas_Unknown2
    ///
    /// - Start bit: 62
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_unknown2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[62..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_Unknown2
    #[inline(always)]
    pub fn set_cf_lkas_unknown2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 1_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 832 });
        }
        self.raw.view_bits_mut::<Lsb0>()[62..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Lkas11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Lkas11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Lkas11")
                .field("cf_lkas_ldws_activemode", &self.cf_lkas_ldws_activemode())
                .field("cf_lkas_ldws_sys_state", &self.cf_lkas_ldws_sys_state())
                .field("cf_lkas_sys_warning", &self.cf_lkas_sys_warning())
                .field("cf_lkas_ldws_lh_warning", &self.cf_lkas_ldws_lh_warning())
                .field("cf_lkas_ldws_rh_warning", &self.cf_lkas_ldws_rh_warning())
                .field("cf_lkas_hba_lamp", &self.cf_lkas_hba_lamp())
                .field("cf_lkas_fcw_bas_req", &self.cf_lkas_fcw_bas_req())
                .field("cr_lkas_str_toq_req", &self.cr_lkas_str_toq_req())
                .field("cf_lkas_act_toi", &self.cf_lkas_act_toi())
                .field("cf_lkas_toi_flt", &self.cf_lkas_toi_flt())
                .field("cf_lkas_hba_sys_state", &self.cf_lkas_hba_sys_state())
                .field("cf_lkas_fcw_opt", &self.cf_lkas_fcw_opt())
                .field("cf_lkas_hba_opt", &self.cf_lkas_hba_opt())
                .field("cf_lkas_msg_count", &self.cf_lkas_msg_count())
                .field("cf_lkas_fcw_sys_state", &self.cf_lkas_fcw_sys_state())
                .field("cf_lkas_fcw_collision_warning", &self.cf_lkas_fcw_collision_warning())
                .field("cf_lkas_fusion_state", &self.cf_lkas_fusion_state())
                .field("cf_lkas_unknown1", &self.cf_lkas_unknown1())
                .field("cf_lkas_chksum", &self.cf_lkas_chksum())
                .field("cf_lkas_fcw_opt_usm", &self.cf_lkas_fcw_opt_usm())
                .field("cf_lkas_ldws_opt_usm", &self.cf_lkas_ldws_opt_usm())
                .field("cf_lkas_unknown2", &self.cf_lkas_unknown2())
            .finish()
        } else {
            f.debug_tuple("Lkas11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Lkas11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_lkas_ldws_activemode = u.int_in_range(0..=3)?;
        let cf_lkas_ldws_sys_state = u.int_in_range(0..=15)?;
        let cf_lkas_sys_warning = u.int_in_range(0..=15)?;
        let cf_lkas_ldws_lh_warning = u.int_in_range(0..=3)?;
        let cf_lkas_ldws_rh_warning = u.int_in_range(0..=3)?;
        let cf_lkas_hba_lamp = u.int_in_range(0..=1)? == 1;
        let cf_lkas_fcw_bas_req = u.int_in_range(0..=1)? == 1;
        let cr_lkas_str_toq_req = u.float_in_range(-1024_f32..=1024_f32)?;
        let cf_lkas_act_toi = u.int_in_range(0..=1)? == 1;
        let cf_lkas_toi_flt = u.int_in_range(0..=1)? == 1;
        let cf_lkas_hba_sys_state = u.int_in_range(0..=7)?;
        let cf_lkas_fcw_opt = u.int_in_range(0..=3)?;
        let cf_lkas_hba_opt = u.int_in_range(0..=1)?;
        let cf_lkas_msg_count = u.int_in_range(0..=15)?;
        let cf_lkas_fcw_sys_state = u.int_in_range(0..=7)?;
        let cf_lkas_fcw_collision_warning = u.int_in_range(0..=3)?;
        let cf_lkas_fusion_state = u.int_in_range(0..=3)?;
        let cf_lkas_unknown1 = u.int_in_range(0..=1)? == 1;
        let cf_lkas_chksum = u.int_in_range(0..=255)?;
        let cf_lkas_fcw_opt_usm = u.int_in_range(0..=7)?;
        let cf_lkas_ldws_opt_usm = u.int_in_range(0..=7)?;
        let cf_lkas_unknown2 = u.int_in_range(0..=1)?;
        Lkas11::new(cf_lkas_ldws_activemode,cf_lkas_ldws_sys_state,cf_lkas_sys_warning,cf_lkas_ldws_lh_warning,cf_lkas_ldws_rh_warning,cf_lkas_hba_lamp,cf_lkas_fcw_bas_req,cr_lkas_str_toq_req,cf_lkas_act_toi,cf_lkas_toi_flt,cf_lkas_hba_sys_state,cf_lkas_fcw_opt,cf_lkas_hba_opt,cf_lkas_msg_count,cf_lkas_fcw_sys_state,cf_lkas_fcw_collision_warning,cf_lkas_fusion_state,cf_lkas_unknown1,cf_lkas_chksum,cf_lkas_fcw_opt_usm,cf_lkas_ldws_opt_usm,cf_lkas_unknown2).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// LKAS12
///
/// - ID: 1342 (0x53e)
/// - Size: 6 bytes
/// - Transmitter: LDWS_LKAS
#[derive(Clone, Copy)]
pub struct Lkas12 {
    raw: [u8; 6],
}

impl Lkas12 {
    pub const MESSAGE_ID: u32 = 1342;
    
    pub const CF_LKAS_TSR_SLIF_OPT_MIN: u8 = 0_u8;
    pub const CF_LKAS_TSR_SLIF_OPT_MAX: u8 = 3_u8;
    pub const CF_LKAS_TSR_STATUS_MIN: u8 = 0_u8;
    pub const CF_LKAS_TSR_STATUS_MAX: u8 = 3_u8;
    pub const CF_LKAS_TSR_SPEED_DISPLAY_CLU_MIN: u8 = 0_u8;
    pub const CF_LKAS_TSR_SPEED_DISPLAY_CLU_MAX: u8 = 255_u8;
    pub const CF_LKAS_TSR_SPEED_DISPLAY_NAVI_MIN: u8 = 0_u8;
    pub const CF_LKAS_TSR_SPEED_DISPLAY_NAVI_MAX: u8 = 255_u8;
    pub const CF_LKAS_TSR_ADDINFO_DISPLAY_MIN: u8 = 0_u8;
    pub const CF_LKAS_TSR_ADDINFO_DISPLAY_MAX: u8 = 3_u8;
    pub const CF_LKAS_DAW_STATUS_MIN: u8 = 0_u8;
    pub const CF_LKAS_DAW_STATUS_MAX: u8 = 7_u8;
    pub const CF_LKAS_DAW_USM_MIN: u8 = 0_u8;
    pub const CF_LKAS_DAW_USM_MAX: u8 = 7_u8;
    
    /// Construct new LKAS12 from values
    pub fn new(cf_lkas_tsr_slif_opt: u8, cf_lkas_tsr_status: u8, cf_lkas_tsr_speed_display_clu: u8, cf_lkas_tsr_speed_display_navi: u8, cf_lkas_tsr_addinfo_display: u8, cf_lkas_daw_status: u8, cf_lkas_daw_usm: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 6] };
        res.set_cf_lkas_tsr_slif_opt(cf_lkas_tsr_slif_opt)?;
        res.set_cf_lkas_tsr_status(cf_lkas_tsr_status)?;
        res.set_cf_lkas_tsr_speed_display_clu(cf_lkas_tsr_speed_display_clu)?;
        res.set_cf_lkas_tsr_speed_display_navi(cf_lkas_tsr_speed_display_navi)?;
        res.set_cf_lkas_tsr_addinfo_display(cf_lkas_tsr_addinfo_display)?;
        res.set_cf_lkas_daw_status(cf_lkas_daw_status)?;
        res.set_cf_lkas_daw_usm(cf_lkas_daw_usm)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 6] {
        &self.raw
    }
    
    /// CF_Lkas_TsrSlifOpt
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_lkas_tsr_slif_opt(&self) -> u8 {
        self.cf_lkas_tsr_slif_opt_raw()
    }
    
    /// Get raw value of CF_Lkas_TsrSlifOpt
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_tsr_slif_opt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_TsrSlifOpt
    #[inline(always)]
    pub fn set_cf_lkas_tsr_slif_opt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1342 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..12].store_le(value);
        Ok(())
    }
    
    /// CF_LkasTsrStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_lkas_tsr_status(&self) -> u8 {
        self.cf_lkas_tsr_status_raw()
    }
    
    /// Get raw value of CF_LkasTsrStatus
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_tsr_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_LkasTsrStatus
    #[inline(always)]
    pub fn set_cf_lkas_tsr_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1342 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..14].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_TsrSpeed_Display_Clu
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_lkas_tsr_speed_display_clu(&self) -> u8 {
        self.cf_lkas_tsr_speed_display_clu_raw()
    }
    
    /// Get raw value of CF_Lkas_TsrSpeed_Display_Clu
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_tsr_speed_display_clu_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_TsrSpeed_Display_Clu
    #[inline(always)]
    pub fn set_cf_lkas_tsr_speed_display_clu(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1342 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// CF_LkasTsrSpeed_Display_Navi
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_lkas_tsr_speed_display_navi(&self) -> u8 {
        self.cf_lkas_tsr_speed_display_navi_raw()
    }
    
    /// Get raw value of CF_LkasTsrSpeed_Display_Navi
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_tsr_speed_display_navi_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_LkasTsrSpeed_Display_Navi
    #[inline(always)]
    pub fn set_cf_lkas_tsr_speed_display_navi(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1342 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_TsrAddinfo_Display
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_lkas_tsr_addinfo_display(&self) -> u8 {
        self.cf_lkas_tsr_addinfo_display_raw()
    }
    
    /// Get raw value of CF_Lkas_TsrAddinfo_Display
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_tsr_addinfo_display_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_TsrAddinfo_Display
    #[inline(always)]
    pub fn set_cf_lkas_tsr_addinfo_display(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1342 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..34].store_le(value);
        Ok(())
    }
    
    /// CF_LkasDawStatus
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_lkas_daw_status(&self) -> u8 {
        self.cf_lkas_daw_status_raw()
    }
    
    /// Get raw value of CF_LkasDawStatus
    ///
    /// - Start bit: 40
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_daw_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..43].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_LkasDawStatus
    #[inline(always)]
    pub fn set_cf_lkas_daw_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1342 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..43].store_le(value);
        Ok(())
    }
    
    /// CF_Lkas_Daw_USM
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_lkas_daw_usm(&self) -> u8 {
        self.cf_lkas_daw_usm_raw()
    }
    
    /// Get raw value of CF_Lkas_Daw_USM
    ///
    /// - Start bit: 37
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_lkas_daw_usm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[37..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Lkas_Daw_USM
    #[inline(always)]
    pub fn set_cf_lkas_daw_usm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1342 });
        }
        self.raw.view_bits_mut::<Lsb0>()[37..40].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Lkas12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 6 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 6];
        raw.copy_from_slice(&payload[..6]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Lkas12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Lkas12")
                .field("cf_lkas_tsr_slif_opt", &self.cf_lkas_tsr_slif_opt())
                .field("cf_lkas_tsr_status", &self.cf_lkas_tsr_status())
                .field("cf_lkas_tsr_speed_display_clu", &self.cf_lkas_tsr_speed_display_clu())
                .field("cf_lkas_tsr_speed_display_navi", &self.cf_lkas_tsr_speed_display_navi())
                .field("cf_lkas_tsr_addinfo_display", &self.cf_lkas_tsr_addinfo_display())
                .field("cf_lkas_daw_status", &self.cf_lkas_daw_status())
                .field("cf_lkas_daw_usm", &self.cf_lkas_daw_usm())
            .finish()
        } else {
            f.debug_tuple("Lkas12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Lkas12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_lkas_tsr_slif_opt = u.int_in_range(0..=3)?;
        let cf_lkas_tsr_status = u.int_in_range(0..=3)?;
        let cf_lkas_tsr_speed_display_clu = u.int_in_range(0..=255)?;
        let cf_lkas_tsr_speed_display_navi = u.int_in_range(0..=255)?;
        let cf_lkas_tsr_addinfo_display = u.int_in_range(0..=3)?;
        let cf_lkas_daw_status = u.int_in_range(0..=7)?;
        let cf_lkas_daw_usm = u.int_in_range(0..=7)?;
        Lkas12::new(cf_lkas_tsr_slif_opt,cf_lkas_tsr_status,cf_lkas_tsr_speed_display_clu,cf_lkas_tsr_speed_display_navi,cf_lkas_tsr_addinfo_display,cf_lkas_daw_status,cf_lkas_daw_usm).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// TMU_GW_E_01
///
/// - ID: 1338 (0x53a)
/// - Size: 8 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct TmuGwE01 {
    raw: [u8; 8],
}

impl TmuGwE01 {
    pub const MESSAGE_ID: u32 = 1338;
    
    pub const CF_GWAY_TELE_REQ_DR_LOCK_MIN: u8 = 0_u8;
    pub const CF_GWAY_TELE_REQ_DR_LOCK_MAX: u8 = 3_u8;
    pub const CF_GWAY_TELE_REQ_DR_UNLOCK_MIN: u8 = 0_u8;
    pub const CF_GWAY_TELE_REQ_DR_UNLOCK_MAX: u8 = 3_u8;
    pub const CF_GWAY_TELE_REQ_HAZARD_MIN: u8 = 0_u8;
    pub const CF_GWAY_TELE_REQ_HAZARD_MAX: u8 = 3_u8;
    pub const CF_GWAY_TELE_REQ_HORN_MIN: u8 = 0_u8;
    pub const CF_GWAY_TELE_REQ_HORN_MAX: u8 = 3_u8;
    pub const CF_GWAY_TELE_REQ_ENGINE_OPERATE_MIN: u8 = 0_u8;
    pub const CF_GWAY_TELE_REQ_ENGINE_OPERATE_MAX: u8 = 3_u8;
    
    /// Construct new TMU_GW_E_01 from values
    pub fn new(cf_gway_tele_req_dr_lock: u8, cf_gway_tele_req_dr_unlock: u8, cf_gway_tele_req_hazard: u8, cf_gway_tele_req_horn: u8, cf_gway_tele_req_engine_operate: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_gway_tele_req_dr_lock(cf_gway_tele_req_dr_lock)?;
        res.set_cf_gway_tele_req_dr_unlock(cf_gway_tele_req_dr_unlock)?;
        res.set_cf_gway_tele_req_hazard(cf_gway_tele_req_hazard)?;
        res.set_cf_gway_tele_req_horn(cf_gway_tele_req_horn)?;
        res.set_cf_gway_tele_req_engine_operate(cf_gway_tele_req_engine_operate)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Gway_TeleReqDrLock
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_gway_tele_req_dr_lock(&self) -> u8 {
        self.cf_gway_tele_req_dr_lock_raw()
    }
    
    /// Get raw value of CF_Gway_TeleReqDrLock
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_tele_req_dr_lock_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_TeleReqDrLock
    #[inline(always)]
    pub fn set_cf_gway_tele_req_dr_lock(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1338 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_TeleReqDrUnlock
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_gway_tele_req_dr_unlock(&self) -> u8 {
        self.cf_gway_tele_req_dr_unlock_raw()
    }
    
    /// Get raw value of CF_Gway_TeleReqDrUnlock
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_tele_req_dr_unlock_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_TeleReqDrUnlock
    #[inline(always)]
    pub fn set_cf_gway_tele_req_dr_unlock(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1338 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_TeleReqHazard
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_gway_tele_req_hazard(&self) -> u8 {
        self.cf_gway_tele_req_hazard_raw()
    }
    
    /// Get raw value of CF_Gway_TeleReqHazard
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_tele_req_hazard_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_TeleReqHazard
    #[inline(always)]
    pub fn set_cf_gway_tele_req_hazard(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1338 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_TeleReqHorn
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_gway_tele_req_horn(&self) -> u8 {
        self.cf_gway_tele_req_horn_raw()
    }
    
    /// Get raw value of CF_Gway_TeleReqHorn
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_tele_req_horn_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_TeleReqHorn
    #[inline(always)]
    pub fn set_cf_gway_tele_req_horn(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1338 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_TeleReqEngineOperate
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_gway_tele_req_engine_operate(&self) -> u8 {
        self.cf_gway_tele_req_engine_operate_raw()
    }
    
    /// Get raw value of CF_Gway_TeleReqEngineOperate
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_tele_req_engine_operate_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_TeleReqEngineOperate
    #[inline(always)]
    pub fn set_cf_gway_tele_req_engine_operate(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1338 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for TmuGwE01 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for TmuGwE01 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("TmuGwE01")
                .field("cf_gway_tele_req_dr_lock", &self.cf_gway_tele_req_dr_lock())
                .field("cf_gway_tele_req_dr_unlock", &self.cf_gway_tele_req_dr_unlock())
                .field("cf_gway_tele_req_hazard", &self.cf_gway_tele_req_hazard())
                .field("cf_gway_tele_req_horn", &self.cf_gway_tele_req_horn())
                .field("cf_gway_tele_req_engine_operate", &self.cf_gway_tele_req_engine_operate())
            .finish()
        } else {
            f.debug_tuple("TmuGwE01").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for TmuGwE01 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_gway_tele_req_dr_lock = u.int_in_range(0..=3)?;
        let cf_gway_tele_req_dr_unlock = u.int_in_range(0..=3)?;
        let cf_gway_tele_req_hazard = u.int_in_range(0..=3)?;
        let cf_gway_tele_req_horn = u.int_in_range(0..=3)?;
        let cf_gway_tele_req_engine_operate = u.int_in_range(0..=3)?;
        TmuGwE01::new(cf_gway_tele_req_dr_lock,cf_gway_tele_req_dr_unlock,cf_gway_tele_req_hazard,cf_gway_tele_req_horn,cf_gway_tele_req_engine_operate).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// PAS11
///
/// - ID: 1078 (0x436)
/// - Size: 4 bytes
/// - Transmitter: BCM
#[derive(Clone, Copy)]
pub struct Pas11 {
    raw: [u8; 4],
}

impl Pas11 {
    pub const MESSAGE_ID: u32 = 1078;
    
    pub const CF_GWAY_PAS_DISPLAY_FLH_MIN: u8 = 0_u8;
    pub const CF_GWAY_PAS_DISPLAY_FLH_MAX: u8 = 7_u8;
    pub const CF_GWAY_PAS_DISPLAY_FRH_MIN: u8 = 0_u8;
    pub const CF_GWAY_PAS_DISPLAY_FRH_MAX: u8 = 7_u8;
    pub const CF_GWAY_PAS_RSOUND_MIN: u8 = 0_u8;
    pub const CF_GWAY_PAS_RSOUND_MAX: u8 = 3_u8;
    pub const CF_GWAY_PAS_DISPLAY_FCTR_MIN: u8 = 0_u8;
    pub const CF_GWAY_PAS_DISPLAY_FCTR_MAX: u8 = 7_u8;
    pub const CF_GWAY_PAS_DISPLAY_RCTR_MIN: u8 = 0_u8;
    pub const CF_GWAY_PAS_DISPLAY_RCTR_MAX: u8 = 7_u8;
    pub const CF_GWAY_PAS_FSOUND_MIN: u8 = 0_u8;
    pub const CF_GWAY_PAS_FSOUND_MAX: u8 = 3_u8;
    pub const CF_GWAY_PAS_DISPLAY_RLH_MIN: u8 = 0_u8;
    pub const CF_GWAY_PAS_DISPLAY_RLH_MAX: u8 = 7_u8;
    pub const CF_GWAY_PAS_DISPLAY_RRH_MIN: u8 = 0_u8;
    pub const CF_GWAY_PAS_DISPLAY_RRH_MAX: u8 = 7_u8;
    pub const CF_GWAY_PAS_CHECK_SOUND_MIN: u8 = 0_u8;
    pub const CF_GWAY_PAS_CHECK_SOUND_MAX: u8 = 3_u8;
    pub const CF_GWAY_PAS_SYSTEM_ON_MIN: u8 = 0_u8;
    pub const CF_GWAY_PAS_SYSTEM_ON_MAX: u8 = 3_u8;
    pub const CF_GWAY_PAS_OPTION_MIN: u8 = 0_u8;
    pub const CF_GWAY_PAS_OPTION_MAX: u8 = 3_u8;
    
    /// Construct new PAS11 from values
    pub fn new(cf_gway_pas_display_flh: u8, cf_gway_pas_display_frh: u8, cf_gway_pas_rsound: u8, cf_gway_pas_display_fctr: u8, cf_gway_pas_display_rctr: u8, cf_gway_pas_fsound: u8, cf_gway_pas_display_rlh: u8, cf_gway_pas_display_rrh: u8, cf_gway_pas_check_sound: u8, cf_gway_pas_system_on: u8, cf_gway_pas_option: u8, cf_gway_pas_distance: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_cf_gway_pas_display_flh(cf_gway_pas_display_flh)?;
        res.set_cf_gway_pas_display_frh(cf_gway_pas_display_frh)?;
        res.set_cf_gway_pas_rsound(cf_gway_pas_rsound)?;
        res.set_cf_gway_pas_display_fctr(cf_gway_pas_display_fctr)?;
        res.set_cf_gway_pas_display_rctr(cf_gway_pas_display_rctr)?;
        res.set_cf_gway_pas_fsound(cf_gway_pas_fsound)?;
        res.set_cf_gway_pas_display_rlh(cf_gway_pas_display_rlh)?;
        res.set_cf_gway_pas_display_rrh(cf_gway_pas_display_rrh)?;
        res.set_cf_gway_pas_check_sound(cf_gway_pas_check_sound)?;
        res.set_cf_gway_pas_system_on(cf_gway_pas_system_on)?;
        res.set_cf_gway_pas_option(cf_gway_pas_option)?;
        res.set_cf_gway_pas_distance(cf_gway_pas_distance)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 4] {
        &self.raw
    }
    
    /// CF_Gway_PASDisplayFLH
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU, AVM
    #[inline(always)]
    pub fn cf_gway_pas_display_flh(&self) -> u8 {
        self.cf_gway_pas_display_flh_raw()
    }
    
    /// Get raw value of CF_Gway_PASDisplayFLH
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pas_display_flh_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PASDisplayFLH
    #[inline(always)]
    pub fn set_cf_gway_pas_display_flh(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1078 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..3].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PASDisplayFRH
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU, AVM
    #[inline(always)]
    pub fn cf_gway_pas_display_frh(&self) -> u8 {
        self.cf_gway_pas_display_frh_raw()
    }
    
    /// Get raw value of CF_Gway_PASDisplayFRH
    ///
    /// - Start bit: 3
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pas_display_frh_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[3..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PASDisplayFRH
    #[inline(always)]
    pub fn set_cf_gway_pas_display_frh(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1078 });
        }
        self.raw.view_bits_mut::<Lsb0>()[3..6].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PASRsound
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_pas_rsound(&self) -> u8 {
        self.cf_gway_pas_rsound_raw()
    }
    
    /// Get raw value of CF_Gway_PASRsound
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pas_rsound_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PASRsound
    #[inline(always)]
    pub fn set_cf_gway_pas_rsound(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1078 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PASDisplayFCTR
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU, AVM
    #[inline(always)]
    pub fn cf_gway_pas_display_fctr(&self) -> u8 {
        self.cf_gway_pas_display_fctr_raw()
    }
    
    /// Get raw value of CF_Gway_PASDisplayFCTR
    ///
    /// - Start bit: 8
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pas_display_fctr_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PASDisplayFCTR
    #[inline(always)]
    pub fn set_cf_gway_pas_display_fctr(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1078 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..11].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PASDisplayRCTR
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU, PGS, AVM
    #[inline(always)]
    pub fn cf_gway_pas_display_rctr(&self) -> u8 {
        self.cf_gway_pas_display_rctr_raw()
    }
    
    /// Get raw value of CF_Gway_PASDisplayRCTR
    ///
    /// - Start bit: 11
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pas_display_rctr_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[11..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PASDisplayRCTR
    #[inline(always)]
    pub fn set_cf_gway_pas_display_rctr(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1078 });
        }
        self.raw.view_bits_mut::<Lsb0>()[11..14].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PASFsound
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_pas_fsound(&self) -> u8 {
        self.cf_gway_pas_fsound_raw()
    }
    
    /// Get raw value of CF_Gway_PASFsound
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pas_fsound_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PASFsound
    #[inline(always)]
    pub fn set_cf_gway_pas_fsound(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1078 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PASDisplayRLH
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU, PGS, AVM
    #[inline(always)]
    pub fn cf_gway_pas_display_rlh(&self) -> u8 {
        self.cf_gway_pas_display_rlh_raw()
    }
    
    /// Get raw value of CF_Gway_PASDisplayRLH
    ///
    /// - Start bit: 16
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pas_display_rlh_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..19].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PASDisplayRLH
    #[inline(always)]
    pub fn set_cf_gway_pas_display_rlh(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1078 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..19].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PASDisplayRRH
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: AVM, CLU, PGS, AVM
    #[inline(always)]
    pub fn cf_gway_pas_display_rrh(&self) -> u8 {
        self.cf_gway_pas_display_rrh_raw()
    }
    
    /// Get raw value of CF_Gway_PASDisplayRRH
    ///
    /// - Start bit: 19
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pas_display_rrh_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[19..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PASDisplayRRH
    #[inline(always)]
    pub fn set_cf_gway_pas_display_rrh(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1078 });
        }
        self.raw.view_bits_mut::<Lsb0>()[19..22].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PASCheckSound
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_pas_check_sound(&self) -> u8 {
        self.cf_gway_pas_check_sound_raw()
    }
    
    /// Get raw value of CF_Gway_PASCheckSound
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pas_check_sound_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PASCheckSound
    #[inline(always)]
    pub fn set_cf_gway_pas_check_sound(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1078 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PASSystemOn
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, Dummy
    #[inline(always)]
    pub fn cf_gway_pas_system_on(&self) -> u8 {
        self.cf_gway_pas_system_on_raw()
    }
    
    /// Get raw value of CF_Gway_PASSystemOn
    ///
    /// - Start bit: 24
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pas_system_on_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..26].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PASSystemOn
    #[inline(always)]
    pub fn set_cf_gway_pas_system_on(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1078 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..26].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PASOption
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_pas_option(&self) -> u8 {
        self.cf_gway_pas_option_raw()
    }
    
    /// Get raw value of CF_Gway_PASOption
    ///
    /// - Start bit: 26
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pas_option_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[26..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PASOption
    #[inline(always)]
    pub fn set_cf_gway_pas_option(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1078 });
        }
        self.raw.view_bits_mut::<Lsb0>()[26..28].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PASDistance
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_pas_distance(&self) -> bool {
        self.cf_gway_pas_distance_raw()
    }
    
    /// Get raw value of CF_Gway_PASDistance
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pas_distance_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Gway_PASDistance
    #[inline(always)]
    pub fn set_cf_gway_pas_distance(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[28..29].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Pas11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Pas11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Pas11")
                .field("cf_gway_pas_display_flh", &self.cf_gway_pas_display_flh())
                .field("cf_gway_pas_display_frh", &self.cf_gway_pas_display_frh())
                .field("cf_gway_pas_rsound", &self.cf_gway_pas_rsound())
                .field("cf_gway_pas_display_fctr", &self.cf_gway_pas_display_fctr())
                .field("cf_gway_pas_display_rctr", &self.cf_gway_pas_display_rctr())
                .field("cf_gway_pas_fsound", &self.cf_gway_pas_fsound())
                .field("cf_gway_pas_display_rlh", &self.cf_gway_pas_display_rlh())
                .field("cf_gway_pas_display_rrh", &self.cf_gway_pas_display_rrh())
                .field("cf_gway_pas_check_sound", &self.cf_gway_pas_check_sound())
                .field("cf_gway_pas_system_on", &self.cf_gway_pas_system_on())
                .field("cf_gway_pas_option", &self.cf_gway_pas_option())
                .field("cf_gway_pas_distance", &self.cf_gway_pas_distance())
            .finish()
        } else {
            f.debug_tuple("Pas11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Pas11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_gway_pas_display_flh = u.int_in_range(0..=7)?;
        let cf_gway_pas_display_frh = u.int_in_range(0..=7)?;
        let cf_gway_pas_rsound = u.int_in_range(0..=3)?;
        let cf_gway_pas_display_fctr = u.int_in_range(0..=7)?;
        let cf_gway_pas_display_rctr = u.int_in_range(0..=7)?;
        let cf_gway_pas_fsound = u.int_in_range(0..=3)?;
        let cf_gway_pas_display_rlh = u.int_in_range(0..=7)?;
        let cf_gway_pas_display_rrh = u.int_in_range(0..=7)?;
        let cf_gway_pas_check_sound = u.int_in_range(0..=3)?;
        let cf_gway_pas_system_on = u.int_in_range(0..=3)?;
        let cf_gway_pas_option = u.int_in_range(0..=3)?;
        let cf_gway_pas_distance = u.int_in_range(0..=1)? == 1;
        Pas11::new(cf_gway_pas_display_flh,cf_gway_pas_display_frh,cf_gway_pas_rsound,cf_gway_pas_display_fctr,cf_gway_pas_display_rctr,cf_gway_pas_fsound,cf_gway_pas_display_rlh,cf_gway_pas_display_rrh,cf_gway_pas_check_sound,cf_gway_pas_system_on,cf_gway_pas_option,cf_gway_pas_distance).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EMS18
///
/// - ID: 48 (0x30)
/// - Size: 6 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct Ems18 {
    raw: [u8; 6],
}

impl Ems18 {
    pub const MESSAGE_ID: u32 = 48;
    
    pub const CF_EMS_DC1_NUM_PER_MSV_MIN: u8 = 0_u8;
    pub const CF_EMS_DC1_NUM_PER_MSV_MAX: u8 = 255_u8;
    pub const CF_EMS_DC2_NUM_PER_MSV_MIN: u16 = 0_u16;
    pub const CF_EMS_DC2_NUM_PER_MSV_MAX: u16 = 65535_u16;
    pub const CR_EMS_DUTY_CYC1_MSV_MIN: f32 = 0_f32;
    pub const CR_EMS_DUTY_CYC1_MSV_MAX: f32 = 49.8_f32;
    pub const CR_EMS_DUTY_CYC2_MSV_MIN: f32 = 0_f32;
    pub const CR_EMS_DUTY_CYC2_MSV_MAX: f32 = 35_f32;
    pub const CR_EMS_DUTY_CYC3_MSV_MIN: f32 = 0_f32;
    pub const CR_EMS_DUTY_CYC3_MSV_MAX: f32 = 100_f32;
    
    /// Construct new EMS18 from values
    pub fn new(cf_ems_dc1_num_per_msv: u8, cf_ems_dc2_num_per_msv: u16, cr_ems_duty_cyc1_msv: f32, cr_ems_duty_cyc2_msv: f32, cr_ems_duty_cyc3_msv: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 6] };
        res.set_cf_ems_dc1_num_per_msv(cf_ems_dc1_num_per_msv)?;
        res.set_cf_ems_dc2_num_per_msv(cf_ems_dc2_num_per_msv)?;
        res.set_cr_ems_duty_cyc1_msv(cr_ems_duty_cyc1_msv)?;
        res.set_cr_ems_duty_cyc2_msv(cr_ems_duty_cyc2_msv)?;
        res.set_cr_ems_duty_cyc3_msv(cr_ems_duty_cyc3_msv)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 6] {
        &self.raw
    }
    
    /// CF_Ems_DC1NumPerMSV
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cf_ems_dc1_num_per_msv(&self) -> u8 {
        self.cf_ems_dc1_num_per_msv_raw()
    }
    
    /// Get raw value of CF_Ems_DC1NumPerMSV
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_dc1_num_per_msv_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ems_DC1NumPerMSV
    #[inline(always)]
    pub fn set_cf_ems_dc1_num_per_msv(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 48 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_DC2NumPerMSV
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cf_ems_dc2_num_per_msv(&self) -> u16 {
        self.cf_ems_dc2_num_per_msv_raw()
    }
    
    /// Get raw value of CF_Ems_DC2NumPerMSV
    ///
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_dc2_num_per_msv_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[8..24].load_le::<u16>();
        
        signal
    }
    
    /// Set value of CF_Ems_DC2NumPerMSV
    #[inline(always)]
    pub fn set_cf_ems_dc2_num_per_msv(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 48 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..24].store_le(value);
        Ok(())
    }
    
    /// CR_Ems_DutyCyc1MSV
    ///
    /// - Min: 0
    /// - Max: 49.8
    /// - Unit: "%"
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cr_ems_duty_cyc1_msv(&self) -> f32 {
        self.cr_ems_duty_cyc1_msv_raw()
    }
    
    /// Get raw value of CR_Ems_DutyCyc1MSV
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.1953
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ems_duty_cyc1_msv_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 0.1953_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Ems_DutyCyc1MSV
    #[inline(always)]
    pub fn set_cr_ems_duty_cyc1_msv(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 49.8_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 48 });
        }
        let factor = 0.1953_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// CR_Ems_DutyCyc2MSV
    ///
    /// - Min: 0
    /// - Max: 35
    /// - Unit: "%"
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cr_ems_duty_cyc2_msv(&self) -> f32 {
        self.cr_ems_duty_cyc2_msv_raw()
    }
    
    /// Get raw value of CR_Ems_DutyCyc2MSV
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.13725
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ems_duty_cyc2_msv_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 0.13725_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Ems_DutyCyc2MSV
    #[inline(always)]
    pub fn set_cr_ems_duty_cyc2_msv(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 35_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 48 });
        }
        let factor = 0.13725_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CR_Ems_DutyCyc3MSV
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: DI_BOX
    #[inline(always)]
    pub fn cr_ems_duty_cyc3_msv(&self) -> f32 {
        self.cr_ems_duty_cyc3_msv_raw()
    }
    
    /// Get raw value of CR_Ems_DutyCyc3MSV
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.392
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ems_duty_cyc3_msv_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 0.392_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Ems_DutyCyc3MSV
    #[inline(always)]
    pub fn set_cr_ems_duty_cyc3_msv(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 100_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 48 });
        }
        let factor = 0.392_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ems18 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 6 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 6];
        raw.copy_from_slice(&payload[..6]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ems18 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ems18")
                .field("cf_ems_dc1_num_per_msv", &self.cf_ems_dc1_num_per_msv())
                .field("cf_ems_dc2_num_per_msv", &self.cf_ems_dc2_num_per_msv())
                .field("cr_ems_duty_cyc1_msv", &self.cr_ems_duty_cyc1_msv())
                .field("cr_ems_duty_cyc2_msv", &self.cr_ems_duty_cyc2_msv())
                .field("cr_ems_duty_cyc3_msv", &self.cr_ems_duty_cyc3_msv())
            .finish()
        } else {
            f.debug_tuple("Ems18").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ems18 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_ems_dc1_num_per_msv = u.int_in_range(0..=255)?;
        let cf_ems_dc2_num_per_msv = u.int_in_range(0..=65535)?;
        let cr_ems_duty_cyc1_msv = u.float_in_range(0_f32..=49.8_f32)?;
        let cr_ems_duty_cyc2_msv = u.float_in_range(0_f32..=35_f32)?;
        let cr_ems_duty_cyc3_msv = u.float_in_range(0_f32..=100_f32)?;
        Ems18::new(cf_ems_dc1_num_per_msv,cf_ems_dc2_num_per_msv,cr_ems_duty_cyc1_msv,cr_ems_duty_cyc2_msv,cr_ems_duty_cyc3_msv).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// CLU15
///
/// - ID: 1322 (0x52a)
/// - Size: 8 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct Clu15 {
    raw: [u8; 8],
}

impl Clu15 {
    pub const MESSAGE_ID: u32 = 1322;
    
    pub const CF_CLU_VEHICLE_SPEED_MIN: u8 = 0_u8;
    pub const CF_CLU_VEHICLE_SPEED_MAX: u8 = 255_u8;
    pub const CF_CLU_GEAR_MIN: u8 = 0_u8;
    pub const CF_CLU_GEAR_MAX: u8 = 15_u8;
    pub const CF_CLU_HUD_INFO_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_HUD_INFO_SET_MAX: u8 = 127_u8;
    pub const CF_CLU_HUD_FONT_COLOR_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_HUD_FONT_COLOR_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_HUD_BRIGHT_UP_SW_MIN: u8 = 0_u8;
    pub const CF_CLU_HUD_BRIGHT_UP_SW_MAX: u8 = 3_u8;
    pub const CF_CLU_HUD_BRIGHT_DN_SW_MIN: u8 = 0_u8;
    pub const CF_CLU_HUD_BRIGHT_DN_SW_MAX: u8 = 3_u8;
    pub const CF_CLU_HUD_HEIGHT_UP_SW_MIN: u8 = 0_u8;
    pub const CF_CLU_HUD_HEIGHT_UP_SW_MAX: u8 = 3_u8;
    pub const CF_CLU_HUD_HEIGHT_DN_SW_MIN: u8 = 0_u8;
    pub const CF_CLU_HUD_HEIGHT_DN_SW_MAX: u8 = 3_u8;
    pub const CF_CLU_HUD_FONT_SIZE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_HUD_FONT_SIZE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_LANGUAGE_INFO_MIN: u8 = 0_u8;
    pub const CF_CLU_LANGUAGE_INFO_MAX: u8 = 31_u8;
    pub const CF_CLU_VEHICLE_SPEED2_MIN: u8 = 0_u8;
    pub const CF_CLU_VEHICLE_SPEED2_MAX: u8 = 255_u8;
    
    /// Construct new CLU15 from values
    pub fn new(cf_clu_vehicle_speed: u8, cf_clu_gear: u8, cf_clu_hud_info_set: u8, cf_clu_hud_font_color_set: u8, cf_clu_hud_bright_up_sw: u8, cf_clu_hud_bright_dn_sw: u8, cf_clu_hud_height_up_sw: u8, cf_clu_hud_height_dn_sw: u8, cf_clu_hud_set: bool, cf_clu_hud_font_size_set: u8, cf_clu_language_info: u8, cf_clu_cluster_sound: bool, cf_clu_vehicle_speed2: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_clu_vehicle_speed(cf_clu_vehicle_speed)?;
        res.set_cf_clu_gear(cf_clu_gear)?;
        res.set_cf_clu_hud_info_set(cf_clu_hud_info_set)?;
        res.set_cf_clu_hud_font_color_set(cf_clu_hud_font_color_set)?;
        res.set_cf_clu_hud_bright_up_sw(cf_clu_hud_bright_up_sw)?;
        res.set_cf_clu_hud_bright_dn_sw(cf_clu_hud_bright_dn_sw)?;
        res.set_cf_clu_hud_height_up_sw(cf_clu_hud_height_up_sw)?;
        res.set_cf_clu_hud_height_dn_sw(cf_clu_hud_height_dn_sw)?;
        res.set_cf_clu_hud_set(cf_clu_hud_set)?;
        res.set_cf_clu_hud_font_size_set(cf_clu_hud_font_size_set)?;
        res.set_cf_clu_language_info(cf_clu_language_info)?;
        res.set_cf_clu_cluster_sound(cf_clu_cluster_sound)?;
        res.set_cf_clu_vehicle_speed2(cf_clu_vehicle_speed2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Clu_VehicleSpeed
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_vehicle_speed(&self) -> u8 {
        self.cf_clu_vehicle_speed_raw()
    }
    
    /// Get raw value of CF_Clu_VehicleSpeed
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_vehicle_speed_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_VehicleSpeed
    #[inline(always)]
    pub fn set_cf_clu_vehicle_speed(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1322 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_Gear
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_gear(&self) -> Clu15CfCluGear {
        let signal = self.raw.view_bits::<Lsb0>()[9..13].load_le::<u8>();
        
        match signal {
            1 => Clu15CfCluGear::P,
            2 => Clu15CfCluGear::R,
            4 => Clu15CfCluGear::N,
            8 => Clu15CfCluGear::D,
            _ => Clu15CfCluGear::_Other(self.cf_clu_gear_raw()),
        }
    }
    
    /// Get raw value of CF_Clu_Gear
    ///
    /// - Start bit: 9
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_gear_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[9..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_Gear
    #[inline(always)]
    pub fn set_cf_clu_gear(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1322 });
        }
        self.raw.view_bits_mut::<Lsb0>()[9..13].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_HudInfoSet
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: ""
    /// - Receivers: HUD
    #[inline(always)]
    pub fn cf_clu_hud_info_set(&self) -> u8 {
        self.cf_clu_hud_info_set_raw()
    }
    
    /// Get raw value of CF_Clu_HudInfoSet
    ///
    /// - Start bit: 13
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_hud_info_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[13..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_HudInfoSet
    #[inline(always)]
    pub fn set_cf_clu_hud_info_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1322 });
        }
        self.raw.view_bits_mut::<Lsb0>()[13..20].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_HudFontColorSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: HUD
    #[inline(always)]
    pub fn cf_clu_hud_font_color_set(&self) -> u8 {
        self.cf_clu_hud_font_color_set_raw()
    }
    
    /// Get raw value of CF_Clu_HudFontColorSet
    ///
    /// - Start bit: 20
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_hud_font_color_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_HudFontColorSet
    #[inline(always)]
    pub fn set_cf_clu_hud_font_color_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1322 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..22].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_HudBrightUpSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: HUD
    #[inline(always)]
    pub fn cf_clu_hud_bright_up_sw(&self) -> u8 {
        self.cf_clu_hud_bright_up_sw_raw()
    }
    
    /// Get raw value of CF_Clu_HudBrightUpSW
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_hud_bright_up_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_HudBrightUpSW
    #[inline(always)]
    pub fn set_cf_clu_hud_bright_up_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1322 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_HudBrightDnSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: HUD
    #[inline(always)]
    pub fn cf_clu_hud_bright_dn_sw(&self) -> u8 {
        self.cf_clu_hud_bright_dn_sw_raw()
    }
    
    /// Get raw value of CF_Clu_HudBrightDnSW
    ///
    /// - Start bit: 24
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_hud_bright_dn_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..26].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_HudBrightDnSW
    #[inline(always)]
    pub fn set_cf_clu_hud_bright_dn_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1322 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..26].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_HudHeightUpSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: HUD
    #[inline(always)]
    pub fn cf_clu_hud_height_up_sw(&self) -> u8 {
        self.cf_clu_hud_height_up_sw_raw()
    }
    
    /// Get raw value of CF_Clu_HudHeightUpSW
    ///
    /// - Start bit: 26
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_hud_height_up_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[26..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_HudHeightUpSW
    #[inline(always)]
    pub fn set_cf_clu_hud_height_up_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1322 });
        }
        self.raw.view_bits_mut::<Lsb0>()[26..28].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_HudHeightDnSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: HUD
    #[inline(always)]
    pub fn cf_clu_hud_height_dn_sw(&self) -> u8 {
        self.cf_clu_hud_height_dn_sw_raw()
    }
    
    /// Get raw value of CF_Clu_HudHeightDnSW
    ///
    /// - Start bit: 28
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_hud_height_dn_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[28..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_HudHeightDnSW
    #[inline(always)]
    pub fn set_cf_clu_hud_height_dn_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1322 });
        }
        self.raw.view_bits_mut::<Lsb0>()[28..30].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_HudSet
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: HUD
    #[inline(always)]
    pub fn cf_clu_hud_set(&self) -> bool {
        self.cf_clu_hud_set_raw()
    }
    
    /// Get raw value of CF_Clu_HudSet
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_hud_set_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_HudSet
    #[inline(always)]
    pub fn set_cf_clu_hud_set(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[30..31].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_HudFontSizeSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: HUD
    #[inline(always)]
    pub fn cf_clu_hud_font_size_set(&self) -> u8 {
        self.cf_clu_hud_font_size_set_raw()
    }
    
    /// Get raw value of CF_Clu_HudFontSizeSet
    ///
    /// - Start bit: 31
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_hud_font_size_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[31..33].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_HudFontSizeSet
    #[inline(always)]
    pub fn set_cf_clu_hud_font_size_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1322 });
        }
        self.raw.view_bits_mut::<Lsb0>()[31..33].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_LanguageInfo
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: ""
    /// - Receivers: BCM, PGS
    #[inline(always)]
    pub fn cf_clu_language_info(&self) -> u8 {
        self.cf_clu_language_info_raw()
    }
    
    /// Get raw value of CF_Clu_LanguageInfo
    ///
    /// - Start bit: 33
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_language_info_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[33..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_LanguageInfo
    #[inline(always)]
    pub fn set_cf_clu_language_info(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 31_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1322 });
        }
        self.raw.view_bits_mut::<Lsb0>()[33..38].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_ClusterSound
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: BCM, CGW, FATC
    #[inline(always)]
    pub fn cf_clu_cluster_sound(&self) -> bool {
        self.cf_clu_cluster_sound_raw()
    }
    
    /// Get raw value of CF_Clu_ClusterSound
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn cf_clu_cluster_sound_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[38..39].load_le::<u8>();
        
        let signal  = i8::from_ne_bytes(signal.to_ne_bytes());
        signal == 1
    }
    
    /// Set value of CF_Clu_ClusterSound
    #[inline(always)]
    pub fn set_cf_clu_cluster_sound(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        let value = u8::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[38..39].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_VehicleSpeed2
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_clu_vehicle_speed2(&self) -> u8 {
        self.cf_clu_vehicle_speed2_raw()
    }
    
    /// Get raw value of CF_Clu_VehicleSpeed2
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_vehicle_speed2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_VehicleSpeed2
    #[inline(always)]
    pub fn set_cf_clu_vehicle_speed2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1322 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Clu15 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Clu15 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Clu15")
                .field("cf_clu_vehicle_speed", &self.cf_clu_vehicle_speed())
                .field("cf_clu_gear", &self.cf_clu_gear())
                .field("cf_clu_hud_info_set", &self.cf_clu_hud_info_set())
                .field("cf_clu_hud_font_color_set", &self.cf_clu_hud_font_color_set())
                .field("cf_clu_hud_bright_up_sw", &self.cf_clu_hud_bright_up_sw())
                .field("cf_clu_hud_bright_dn_sw", &self.cf_clu_hud_bright_dn_sw())
                .field("cf_clu_hud_height_up_sw", &self.cf_clu_hud_height_up_sw())
                .field("cf_clu_hud_height_dn_sw", &self.cf_clu_hud_height_dn_sw())
                .field("cf_clu_hud_set", &self.cf_clu_hud_set())
                .field("cf_clu_hud_font_size_set", &self.cf_clu_hud_font_size_set())
                .field("cf_clu_language_info", &self.cf_clu_language_info())
                .field("cf_clu_cluster_sound", &self.cf_clu_cluster_sound())
                .field("cf_clu_vehicle_speed2", &self.cf_clu_vehicle_speed2())
            .finish()
        } else {
            f.debug_tuple("Clu15").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Clu15 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_clu_vehicle_speed = u.int_in_range(0..=255)?;
        let cf_clu_gear = u.int_in_range(0..=15)?;
        let cf_clu_hud_info_set = u.int_in_range(0..=127)?;
        let cf_clu_hud_font_color_set = u.int_in_range(0..=3)?;
        let cf_clu_hud_bright_up_sw = u.int_in_range(0..=3)?;
        let cf_clu_hud_bright_dn_sw = u.int_in_range(0..=3)?;
        let cf_clu_hud_height_up_sw = u.int_in_range(0..=3)?;
        let cf_clu_hud_height_dn_sw = u.int_in_range(0..=3)?;
        let cf_clu_hud_set = u.int_in_range(0..=1)? == 1;
        let cf_clu_hud_font_size_set = u.int_in_range(0..=3)?;
        let cf_clu_language_info = u.int_in_range(0..=31)?;
        let cf_clu_cluster_sound = u.int_in_range(0..=1)? == 1;
        let cf_clu_vehicle_speed2 = u.int_in_range(0..=255)?;
        Clu15::new(cf_clu_vehicle_speed,cf_clu_gear,cf_clu_hud_info_set,cf_clu_hud_font_color_set,cf_clu_hud_bright_up_sw,cf_clu_hud_bright_dn_sw,cf_clu_hud_height_up_sw,cf_clu_hud_height_dn_sw,cf_clu_hud_set,cf_clu_hud_font_size_set,cf_clu_language_info,cf_clu_cluster_sound,cf_clu_vehicle_speed2).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for CF_Clu_Gear
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Clu15CfCluGear {
    P,
    R,
    N,
    D,
    _Other(u8),
}

impl From<Clu15CfCluGear> for u8 {
    fn from(val: Clu15CfCluGear) -> u8 {
        match val {
            Clu15CfCluGear::P => 1,
            Clu15CfCluGear::R => 2,
            Clu15CfCluGear::N => 4,
            Clu15CfCluGear::D => 8,
            Clu15CfCluGear::_Other(x) => x,
        }
    }
}


/// _4WD13
///
/// - ID: 1066 (0x42a)
/// - Size: 6 bytes
/// - Transmitter: _4WD
#[derive(Clone, Copy)]
pub struct X4wd13 {
    raw: [u8; 6],
}

impl X4wd13 {
    pub const MESSAGE_ID: u32 = 1066;
    
    pub const X4WD_CURRENT_MIN: f32 = -50_f32;
    pub const X4WD_CURRENT_MAX: f32 = 50_f32;
    pub const X4WD_POSITION_MIN: f32 = -180_f32;
    pub const X4WD_POSITION_MAX: f32 = 180_f32;
    pub const X4WD_CLU_THERM_STR_MIN: u8 = 0_u8;
    pub const X4WD_CLU_THERM_STR_MAX: u8 = 100_u8;
    pub const X4WD_STATUS_MIN: u8 = 0_u8;
    pub const X4WD_STATUS_MAX: u8 = 15_u8;
    
    /// Construct new _4WD13 from values
    pub fn new(x4wd_current: f32, x4wd_position: f32, x4wd_clu_therm_str: u8, x4wd_status: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 6] };
        res.set_x4wd_current(x4wd_current)?;
        res.set_x4wd_position(x4wd_position)?;
        res.set_x4wd_clu_therm_str(x4wd_clu_therm_str)?;
        res.set_x4wd_status(x4wd_status)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 6] {
        &self.raw
    }
    
    /// _4WD_CURRENT
    ///
    /// - Min: -50
    /// - Max: 50
    /// - Unit: "A"
    /// - Receivers: TCU
    #[inline(always)]
    pub fn x4wd_current(&self) -> f32 {
        self.x4wd_current_raw()
    }
    
    /// Get raw value of _4WD_CURRENT
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4wd_current_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of _4WD_CURRENT
    #[inline(always)]
    pub fn set_x4wd_current(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -50_f32 || 50_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1066 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// _4WD_POSITION
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "Deg"
    /// - Receivers: TCU
    #[inline(always)]
    pub fn x4wd_position(&self) -> f32 {
        self.x4wd_position_raw()
    }
    
    /// Get raw value of _4WD_POSITION
    ///
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 0.015625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4wd_position_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..24].load_le::<u16>();
        
        let factor = 0.015625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of _4WD_POSITION
    #[inline(always)]
    pub fn set_x4wd_position(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1066 });
        }
        let factor = 0.015625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[8..24].store_le(value);
        Ok(())
    }
    
    /// _4WD_CLU_THERM_STR
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: TCU
    #[inline(always)]
    pub fn x4wd_clu_therm_str(&self) -> u8 {
        self.x4wd_clu_therm_str_raw()
    }
    
    /// Get raw value of _4WD_CLU_THERM_STR
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4wd_clu_therm_str_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of _4WD_CLU_THERM_STR
    #[inline(always)]
    pub fn set_x4wd_clu_therm_str(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 100_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1066 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// _4WD_STATUS
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: ESC, TCU
    #[inline(always)]
    pub fn x4wd_status(&self) -> u8 {
        self.x4wd_status_raw()
    }
    
    /// Get raw value of _4WD_STATUS
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4wd_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of _4WD_STATUS
    #[inline(always)]
    pub fn set_x4wd_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1066 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for X4wd13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 6 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 6];
        raw.copy_from_slice(&payload[..6]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for X4wd13 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("X4wd13")
                .field("x4wd_current", &self.x4wd_current())
                .field("x4wd_position", &self.x4wd_position())
                .field("x4wd_clu_therm_str", &self.x4wd_clu_therm_str())
                .field("x4wd_status", &self.x4wd_status())
            .finish()
        } else {
            f.debug_tuple("X4wd13").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for X4wd13 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let x4wd_current = u.float_in_range(-50_f32..=50_f32)?;
        let x4wd_position = u.float_in_range(-180_f32..=180_f32)?;
        let x4wd_clu_therm_str = u.int_in_range(0..=100)?;
        let x4wd_status = u.int_in_range(0..=15)?;
        X4wd13::new(x4wd_current,x4wd_position,x4wd_clu_therm_str,x4wd_status).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// _4WD12
///
/// - ID: 1065 (0x429)
/// - Size: 8 bytes
/// - Transmitter: _4WD
#[derive(Clone, Copy)]
pub struct X4wd12 {
    raw: [u8; 8],
}

impl X4wd12 {
    pub const MESSAGE_ID: u32 = 1065;
    
    pub const STER_POS_MIN: f32 = -600_f32;
    pub const STER_POS_MAX: f32 = 600_f32;
    pub const FRSS_MIN: u8 = 0_u8;
    pub const FRSS_MAX: u8 = 254_u8;
    pub const FLSS_MIN: u8 = 0_u8;
    pub const FLSS_MAX: u8 = 254_u8;
    pub const RRSS_MIN: u8 = 0_u8;
    pub const RRSS_MAX: u8 = 254_u8;
    pub const RLSS_MIN: u8 = 0_u8;
    pub const RLSS_MAX: u8 = 254_u8;
    pub const CLU_PRES_MIN: f32 = -50_f32;
    pub const CLU_PRES_MAX: f32 = 50_f32;
    
    /// Construct new _4WD12 from values
    pub fn new(ster_pos: f32, frss: u8, flss: u8, rrss: u8, rlss: u8, clu_pres: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ster_pos(ster_pos)?;
        res.set_frss(frss)?;
        res.set_flss(flss)?;
        res.set_rrss(rrss)?;
        res.set_rlss(rlss)?;
        res.set_clu_pres(clu_pres)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Ster_Pos
    ///
    /// - Min: -600
    /// - Max: 600
    /// - Unit: "Deg"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn ster_pos(&self) -> f32 {
        self.ster_pos_raw()
    }
    
    /// Get raw value of Ster_Pos
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: -600
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ster_pos_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 1_f32;
        let offset = -600_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Ster_Pos
    #[inline(always)]
    pub fn set_ster_pos(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -600_f32 || 600_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1065 });
        }
        let factor = 1_f32;
        let offset = -600_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
    /// FRSS
    ///
    /// - Min: 0
    /// - Max: 254
    /// - Unit: "km/h"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn frss(&self) -> u8 {
        self.frss_raw()
    }
    
    /// Get raw value of FRSS
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn frss_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of FRSS
    #[inline(always)]
    pub fn set_frss(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 254_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1065 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// FLSS
    ///
    /// - Min: 0
    /// - Max: 254
    /// - Unit: "km/h"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn flss(&self) -> u8 {
        self.flss_raw()
    }
    
    /// Get raw value of FLSS
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn flss_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of FLSS
    #[inline(always)]
    pub fn set_flss(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 254_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1065 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// RRSS
    ///
    /// - Min: 0
    /// - Max: 254
    /// - Unit: "km/h"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn rrss(&self) -> u8 {
        self.rrss_raw()
    }
    
    /// Get raw value of RRSS
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rrss_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of RRSS
    #[inline(always)]
    pub fn set_rrss(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 254_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1065 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// RLSS
    ///
    /// - Min: 0
    /// - Max: 254
    /// - Unit: "km/h"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn rlss(&self) -> u8 {
        self.rlss_raw()
    }
    
    /// Get raw value of RLSS
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rlss_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of RLSS
    #[inline(always)]
    pub fn set_rlss(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 254_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1065 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// CLU_PRES
    ///
    /// - Min: -50
    /// - Max: 50
    /// - Unit: "Bar"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn clu_pres(&self) -> f32 {
        self.clu_pres_raw()
    }
    
    /// Get raw value of CLU_PRES
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.0625
    /// - Offset: -50
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn clu_pres_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<u16>();
        
        let factor = 0.0625_f32;
        let offset = -50_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CLU_PRES
    #[inline(always)]
    pub fn set_clu_pres(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -50_f32 || 50_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1065 });
        }
        let factor = 0.0625_f32;
        let offset = -50_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for X4wd12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for X4wd12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("X4wd12")
                .field("ster_pos", &self.ster_pos())
                .field("frss", &self.frss())
                .field("flss", &self.flss())
                .field("rrss", &self.rrss())
                .field("rlss", &self.rlss())
                .field("clu_pres", &self.clu_pres())
            .finish()
        } else {
            f.debug_tuple("X4wd12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for X4wd12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ster_pos = u.float_in_range(-600_f32..=600_f32)?;
        let frss = u.int_in_range(0..=254)?;
        let flss = u.int_in_range(0..=254)?;
        let rrss = u.int_in_range(0..=254)?;
        let rlss = u.int_in_range(0..=254)?;
        let clu_pres = u.float_in_range(-50_f32..=50_f32)?;
        X4wd12::new(ster_pos,frss,flss,rrss,rlss,clu_pres).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EMS12
///
/// - ID: 809 (0x329)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct Ems12 {
    raw: [u8; 8],
}

impl Ems12 {
    pub const MESSAGE_ID: u32 = 809;
    
    pub const CONF_TCU_MIN: u8 = 0_u8;
    pub const CONF_TCU_MAX: u8 = 63_u8;
    pub const CAN_VERS_MIN: u8 = 0_u8;
    pub const CAN_VERS_MAX: u8 = 8_u8;
    pub const TQ_STND_MIN: f32 = 0_f32;
    pub const TQ_STND_MAX: f32 = 630_f32;
    pub const OBD_FRF_ACK_MIN: u8 = 0_u8;
    pub const OBD_FRF_ACK_MAX: u8 = 63_u8;
    pub const MUL_CODE_MIN: u8 = 0_u8;
    pub const MUL_CODE_MAX: u8 = 3_u8;
    pub const TEMP_ENG_MIN: f32 = -48_f32;
    pub const TEMP_ENG_MAX: f32 = 143.25_f32;
    pub const MAF_FAC_ALTI_MMV_MIN: f32 = 0_f32;
    pub const MAF_FAC_ALTI_MMV_MAX: f32 = 1.99155_f32;
    pub const CONF_MIL_FMY_MIN: u8 = 0_u8;
    pub const CONF_MIL_FMY_MAX: u8 = 7_u8;
    pub const BRAKE_ACT_MIN: u8 = 0_u8;
    pub const BRAKE_ACT_MAX: u8 = 3_u8;
    pub const ENG_CHR_MIN: u8 = 0_u8;
    pub const ENG_CHR_MAX: u8 = 15_u8;
    pub const GP_CTL_MIN: u8 = 0_u8;
    pub const GP_CTL_MAX: u8 = 3_u8;
    pub const TPS_MIN: f32 = -15.0234742_f32;
    pub const TPS_MAX: f32 = 104.6948357_f32;
    pub const PV_AV_CAN_MIN: f32 = 0_f32;
    pub const PV_AV_CAN_MAX: f32 = 99.603_f32;
    pub const ENG_VOL_MIN: f32 = 0_f32;
    pub const ENG_VOL_MAX: f32 = 25.5_f32;
    
    /// Construct new EMS12 from values
    pub fn new(mul_code: u8, temp_eng: f32, maf_fac_alti_mmv: f32, vb_off_act: bool, ack_es: bool, conf_mil_fmy: u8, od_off_req: bool, acc_act: bool, clu_ack: bool, brake_act: u8, eng_chr: u8, gp_ctl: u8, tps: f32, pv_av_can: f32, eng_vol: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_mul_code(mul_code)?;
        res.set_temp_eng(temp_eng)?;
        res.set_maf_fac_alti_mmv(maf_fac_alti_mmv)?;
        res.set_vb_off_act(vb_off_act)?;
        res.set_ack_es(ack_es)?;
        res.set_conf_mil_fmy(conf_mil_fmy)?;
        res.set_od_off_req(od_off_req)?;
        res.set_acc_act(acc_act)?;
        res.set_clu_ack(clu_ack)?;
        res.set_brake_act(brake_act)?;
        res.set_eng_chr(eng_chr)?;
        res.set_gp_ctl(gp_ctl)?;
        res.set_tps(tps)?;
        res.set_pv_av_can(pv_av_can)?;
        res.set_eng_vol(eng_vol)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Get raw value of MUL_CODE
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn mul_code_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    pub fn mul_code(&mut self) -> Result<Ems12MulCode, CanError> {
        match self.mul_code_raw() {
            0 => Ok(Ems12MulCode::M0(Ems12MulCodeM0{ raw: self.raw })),
            1 => Ok(Ems12MulCode::M1(Ems12MulCodeM1{ raw: self.raw })),
            2 => Ok(Ems12MulCode::M2(Ems12MulCodeM2{ raw: self.raw })),
            3 => Ok(Ems12MulCode::M3(Ems12MulCodeM3{ raw: self.raw })),
            multiplexor => Err(CanError::InvalidMultiplexor { message_id: 809, multiplexor: multiplexor.into() }),
        }
    }
    /// Set value of MUL_CODE
    #[inline(always)]
    fn set_mul_code(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 809 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// Set value of MUL_CODE
    #[inline(always)]
    pub fn set_m0(&mut self, value: Ems12MulCodeM0) -> Result<(), CanError> {
        let b0 = BitArray::<_, LocalBits>::new(self.raw);
        let b1 = BitArray::<_, LocalBits>::new(value.raw);
        self.raw = b0.bitor(b1).into_inner();
        self.set_mul_code(0)?;
        Ok(())
    }
    
    /// Set value of MUL_CODE
    #[inline(always)]
    pub fn set_m1(&mut self, value: Ems12MulCodeM1) -> Result<(), CanError> {
        let b0 = BitArray::<_, LocalBits>::new(self.raw);
        let b1 = BitArray::<_, LocalBits>::new(value.raw);
        self.raw = b0.bitor(b1).into_inner();
        self.set_mul_code(1)?;
        Ok(())
    }
    
    /// Set value of MUL_CODE
    #[inline(always)]
    pub fn set_m2(&mut self, value: Ems12MulCodeM2) -> Result<(), CanError> {
        let b0 = BitArray::<_, LocalBits>::new(self.raw);
        let b1 = BitArray::<_, LocalBits>::new(value.raw);
        self.raw = b0.bitor(b1).into_inner();
        self.set_mul_code(2)?;
        Ok(())
    }
    
    /// Set value of MUL_CODE
    #[inline(always)]
    pub fn set_m3(&mut self, value: Ems12MulCodeM3) -> Result<(), CanError> {
        let b0 = BitArray::<_, LocalBits>::new(self.raw);
        let b1 = BitArray::<_, LocalBits>::new(value.raw);
        self.raw = b0.bitor(b1).into_inner();
        self.set_mul_code(3)?;
        Ok(())
    }
    
    /// TEMP_ENG
    ///
    /// - Min: -48
    /// - Max: 143.25
    /// - Unit: "deg"
    /// - Receivers: _4WD, BCM, CLU, DATC, EPB, ESC, IBOX, SMK, TCU
    #[inline(always)]
    pub fn temp_eng(&self) -> f32 {
        self.temp_eng_raw()
    }
    
    /// Get raw value of TEMP_ENG
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.75
    /// - Offset: -48
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn temp_eng_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 0.75_f32;
        let offset = -48_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TEMP_ENG
    #[inline(always)]
    pub fn set_temp_eng(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -48_f32 || 143.25_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 809 });
        }
        let factor = 0.75_f32;
        let offset = -48_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// MAF_FAC_ALTI_MMV
    ///
    /// - Min: 0
    /// - Max: 1.99155
    /// - Unit: ""
    /// - Receivers: IBOX, TCU
    #[inline(always)]
    pub fn maf_fac_alti_mmv(&self) -> f32 {
        self.maf_fac_alti_mmv_raw()
    }
    
    /// Get raw value of MAF_FAC_ALTI_MMV
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.00781
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn maf_fac_alti_mmv_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 0.00781_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of MAF_FAC_ALTI_MMV
    #[inline(always)]
    pub fn set_maf_fac_alti_mmv(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1.99155_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 809 });
        }
        let factor = 0.00781_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// VB_OFF_ACT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: IBOX, TCU
    #[inline(always)]
    pub fn vb_off_act(&self) -> bool {
        self.vb_off_act_raw()
    }
    
    /// Get raw value of VB_OFF_ACT
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vb_off_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of VB_OFF_ACT
    #[inline(always)]
    pub fn set_vb_off_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[24..25].store_le(value);
        Ok(())
    }
    
    /// ACK_ES
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ACU, IBOX
    #[inline(always)]
    pub fn ack_es(&self) -> bool {
        self.ack_es_raw()
    }
    
    /// Get raw value of ACK_ES
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ack_es_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ACK_ES
    #[inline(always)]
    pub fn set_ack_es(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[25..26].store_le(value);
        Ok(())
    }
    
    /// CONF_MIL_FMY
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: ESC, IBOX, TCU
    #[inline(always)]
    pub fn conf_mil_fmy(&self) -> u8 {
        self.conf_mil_fmy_raw()
    }
    
    /// Get raw value of CONF_MIL_FMY
    ///
    /// - Start bit: 26
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn conf_mil_fmy_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[26..29].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CONF_MIL_FMY
    #[inline(always)]
    pub fn set_conf_mil_fmy(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 809 });
        }
        self.raw.view_bits_mut::<Lsb0>()[26..29].store_le(value);
        Ok(())
    }
    
    /// OD_OFF_REQ
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: IBOX, TCU
    #[inline(always)]
    pub fn od_off_req(&self) -> bool {
        self.od_off_req_raw()
    }
    
    /// Get raw value of OD_OFF_REQ
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn od_off_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of OD_OFF_REQ
    #[inline(always)]
    pub fn set_od_off_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[29..30].store_le(value);
        Ok(())
    }
    
    /// ACC_ACT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ABS, CLU, ESC, IAP, IBOX, SCC, TCU
    #[inline(always)]
    pub fn acc_act(&self) -> bool {
        self.acc_act_raw()
    }
    
    /// Get raw value of ACC_ACT
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn acc_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ACC_ACT
    #[inline(always)]
    pub fn set_acc_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[30..31].store_le(value);
        Ok(())
    }
    
    /// CLU_ACK
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, EPB, ESC, IBOX
    #[inline(always)]
    pub fn clu_ack(&self) -> bool {
        self.clu_ack_raw()
    }
    
    /// Get raw value of CLU_ACK
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn clu_ack_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CLU_ACK
    #[inline(always)]
    pub fn set_clu_ack(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[31..32].store_le(value);
        Ok(())
    }
    
    /// BRAKE_ACT
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: _4WD, ABS, ACU, AFLS, CLU, DATC, ECS, EPB, ESC, IBOX, LDWS_LKAS, TCU
    #[inline(always)]
    pub fn brake_act(&self) -> u8 {
        self.brake_act_raw()
    }
    
    /// Get raw value of BRAKE_ACT
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn brake_act_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of BRAKE_ACT
    #[inline(always)]
    pub fn set_brake_act(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 809 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..34].store_le(value);
        Ok(())
    }
    
    /// ENG_CHR
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: _4WD, ABS, ACU, CLU, DATC, EPB, ESC, FATC, IBOX, SCC, SMK, TCU
    #[inline(always)]
    pub fn eng_chr(&self) -> u8 {
        self.eng_chr_raw()
    }
    
    /// Get raw value of ENG_CHR
    ///
    /// - Start bit: 34
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn eng_chr_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[34..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ENG_CHR
    #[inline(always)]
    pub fn set_eng_chr(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 809 });
        }
        self.raw.view_bits_mut::<Lsb0>()[34..38].store_le(value);
        Ok(())
    }
    
    /// GP_CTL
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: IBOX
    #[inline(always)]
    pub fn gp_ctl(&self) -> u8 {
        self.gp_ctl_raw()
    }
    
    /// Get raw value of GP_CTL
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gp_ctl_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of GP_CTL
    #[inline(always)]
    pub fn set_gp_ctl(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 809 });
        }
        self.raw.view_bits_mut::<Lsb0>()[38..40].store_le(value);
        Ok(())
    }
    
    /// TPS
    ///
    /// - Min: -15.0234742
    /// - Max: 104.6948357
    /// - Unit: "%"
    /// - Receivers: _4WD, ABS, ACU, CLU, DATC, ECS, EPB, ESC, IBOX, TCU
    #[inline(always)]
    pub fn tps(&self) -> f32 {
        self.tps_raw()
    }
    
    /// Get raw value of TPS
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.4694836
    /// - Offset: -15.0234742
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tps_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 0.4694836_f32;
        let offset = -15.0234742_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TPS
    #[inline(always)]
    pub fn set_tps(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -15.0234742_f32 || 104.6948357_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 809 });
        }
        let factor = 0.4694836_f32;
        let offset = -15.0234742_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// PV_AV_CAN
    ///
    /// - Min: 0
    /// - Max: 99.603
    /// - Unit: "%"
    /// - Receivers: _4WD, AAF, ABS, ACU, AFLS, CLU, DATC, EPB, ESC, IAP, IBOX, LDWS_LKAS, SCC, TCU
    #[inline(always)]
    pub fn pv_av_can(&self) -> f32 {
        self.pv_av_can_raw()
    }
    
    /// Get raw value of PV_AV_CAN
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 0.3906
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pv_av_can_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        let factor = 0.3906_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of PV_AV_CAN
    #[inline(always)]
    pub fn set_pv_av_can(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.603_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 809 });
        }
        let factor = 0.3906_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// ENG_VOL
    ///
    /// - Min: 0
    /// - Max: 25.5
    /// - Unit: "liter"
    /// - Receivers: _4WD, ABS, ACU, BCM, CLU, DATC, EPB, ESC, IBOX, LDWS_LKAS, SCC, SMK
    #[inline(always)]
    pub fn eng_vol(&self) -> f32 {
        self.eng_vol_raw()
    }
    
    /// Get raw value of ENG_VOL
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn eng_vol_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of ENG_VOL
    #[inline(always)]
    pub fn set_eng_vol(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 25.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 809 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ems12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ems12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ems12")
                .field("temp_eng", &self.temp_eng())
                .field("maf_fac_alti_mmv", &self.maf_fac_alti_mmv())
                .field("vb_off_act", &self.vb_off_act())
                .field("ack_es", &self.ack_es())
                .field("conf_mil_fmy", &self.conf_mil_fmy())
                .field("od_off_req", &self.od_off_req())
                .field("acc_act", &self.acc_act())
                .field("clu_ack", &self.clu_ack())
                .field("brake_act", &self.brake_act())
                .field("eng_chr", &self.eng_chr())
                .field("gp_ctl", &self.gp_ctl())
                .field("tps", &self.tps())
                .field("pv_av_can", &self.pv_av_can())
                .field("eng_vol", &self.eng_vol())
            .finish()
        } else {
            f.debug_tuple("Ems12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ems12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let mul_code = u.int_in_range(0..=3)?;
        let temp_eng = u.float_in_range(-48_f32..=143.25_f32)?;
        let maf_fac_alti_mmv = u.float_in_range(0_f32..=1.99155_f32)?;
        let vb_off_act = u.int_in_range(0..=1)? == 1;
        let ack_es = u.int_in_range(0..=1)? == 1;
        let conf_mil_fmy = u.int_in_range(0..=7)?;
        let od_off_req = u.int_in_range(0..=1)? == 1;
        let acc_act = u.int_in_range(0..=1)? == 1;
        let clu_ack = u.int_in_range(0..=1)? == 1;
        let brake_act = u.int_in_range(0..=3)?;
        let eng_chr = u.int_in_range(0..=15)?;
        let gp_ctl = u.int_in_range(0..=3)?;
        let tps = u.float_in_range(-15.0234742_f32..=104.6948357_f32)?;
        let pv_av_can = u.float_in_range(0_f32..=99.603_f32)?;
        let eng_vol = u.float_in_range(0_f32..=25.5_f32)?;
        Ems12::new(mul_code,temp_eng,maf_fac_alti_mmv,vb_off_act,ack_es,conf_mil_fmy,od_off_req,acc_act,clu_ack,brake_act,eng_chr,gp_ctl,tps,pv_av_can,eng_vol).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for multiplexed signal EMS12
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Ems12MulCode {
    M0(Ems12MulCodeM0),
    M1(Ems12MulCodeM1),
    M2(Ems12MulCodeM2),
    M3(Ems12MulCodeM3),
}

#[derive(Default)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Ems12MulCodeM0 { raw: [u8; 8] }

impl Ems12MulCodeM0 {
pub fn new() -> Self { Self { raw: [0u8; 8] } }
/// CAN_VERS
///
/// - Min: 0
/// - Max: 8
/// - Unit: ""
/// - Receivers: _4WD, ABS, ESC, IBOX
#[inline(always)]
pub fn can_vers(&self) -> u8 {
    self.can_vers_raw()
}

/// Get raw value of CAN_VERS
///
/// - Start bit: 0
/// - Signal size: 6 bits
/// - Factor: 1
/// - Offset: 0
/// - Byte order: LittleEndian
/// - Value type: Unsigned
#[inline(always)]
pub fn can_vers_raw(&self) -> u8 {
    let signal = self.raw.view_bits::<Lsb0>()[0..6].load_le::<u8>();
    
    signal
}

/// Set value of CAN_VERS
#[inline(always)]
pub fn set_can_vers(&mut self, value: u8) -> Result<(), CanError> {
    #[cfg(feature = "range_checked")]
    if value < 0_u8 || 8_u8 < value {
        return Err(CanError::ParameterOutOfRange { message_id: 809 });
    }
    self.raw.view_bits_mut::<Lsb0>()[0..6].store_le(value);
    Ok(())
}

}

#[derive(Default)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Ems12MulCodeM1 { raw: [u8; 8] }

impl Ems12MulCodeM1 {
pub fn new() -> Self { Self { raw: [0u8; 8] } }
/// CONF_TCU
///
/// - Min: 0
/// - Max: 63
/// - Unit: ""
/// - Receivers: _4WD, ACU, BCM, CLU, DATC, EPB, ESC, IBOX, LCA, SMK
#[inline(always)]
pub fn conf_tcu(&self) -> u8 {
    self.conf_tcu_raw()
}

/// Get raw value of CONF_TCU
///
/// - Start bit: 0
/// - Signal size: 6 bits
/// - Factor: 1
/// - Offset: 0
/// - Byte order: LittleEndian
/// - Value type: Unsigned
#[inline(always)]
pub fn conf_tcu_raw(&self) -> u8 {
    let signal = self.raw.view_bits::<Lsb0>()[0..6].load_le::<u8>();
    
    signal
}

/// Set value of CONF_TCU
#[inline(always)]
pub fn set_conf_tcu(&mut self, value: u8) -> Result<(), CanError> {
    #[cfg(feature = "range_checked")]
    if value < 0_u8 || 63_u8 < value {
        return Err(CanError::ParameterOutOfRange { message_id: 809 });
    }
    self.raw.view_bits_mut::<Lsb0>()[0..6].store_le(value);
    Ok(())
}

}

#[derive(Default)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Ems12MulCodeM2 { raw: [u8; 8] }

impl Ems12MulCodeM2 {
pub fn new() -> Self { Self { raw: [0u8; 8] } }
/// OBD_FRF_ACK
///
/// - Min: 0
/// - Max: 63
/// - Unit: ""
/// - Receivers: _4WD, ESC, IBOX
#[inline(always)]
pub fn obd_frf_ack(&self) -> u8 {
    self.obd_frf_ack_raw()
}

/// Get raw value of OBD_FRF_ACK
///
/// - Start bit: 0
/// - Signal size: 6 bits
/// - Factor: 1
/// - Offset: 0
/// - Byte order: LittleEndian
/// - Value type: Unsigned
#[inline(always)]
pub fn obd_frf_ack_raw(&self) -> u8 {
    let signal = self.raw.view_bits::<Lsb0>()[0..6].load_le::<u8>();
    
    signal
}

/// Set value of OBD_FRF_ACK
#[inline(always)]
pub fn set_obd_frf_ack(&mut self, value: u8) -> Result<(), CanError> {
    #[cfg(feature = "range_checked")]
    if value < 0_u8 || 63_u8 < value {
        return Err(CanError::ParameterOutOfRange { message_id: 809 });
    }
    self.raw.view_bits_mut::<Lsb0>()[0..6].store_le(value);
    Ok(())
}

}

#[derive(Default)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub struct Ems12MulCodeM3 { raw: [u8; 8] }

impl Ems12MulCodeM3 {
pub fn new() -> Self { Self { raw: [0u8; 8] } }
/// TQ_STND
///
/// - Min: 0
/// - Max: 630
/// - Unit: "Nm"
/// - Receivers: _4WD, DATC, ECS, EPB, ESC, FATC, IBOX
#[inline(always)]
pub fn tq_stnd(&self) -> f32 {
    self.tq_stnd_raw()
}

/// Get raw value of TQ_STND
///
/// - Start bit: 0
/// - Signal size: 6 bits
/// - Factor: 10
/// - Offset: 0
/// - Byte order: LittleEndian
/// - Value type: Unsigned
#[inline(always)]
pub fn tq_stnd_raw(&self) -> f32 {
    let signal = self.raw.view_bits::<Lsb0>()[0..6].load_le::<u8>();
    
    let factor = 10_f32;
    let offset = 0_f32;
    (signal as f32) * factor + offset
}

/// Set value of TQ_STND
#[inline(always)]
pub fn set_tq_stnd(&mut self, value: f32) -> Result<(), CanError> {
    #[cfg(feature = "range_checked")]
    if value < 0_f32 || 630_f32 < value {
        return Err(CanError::ParameterOutOfRange { message_id: 809 });
    }
    let factor = 10_f32;
    let offset = 0_f32;
    let value = ((value - offset) / factor) as u8;
    
    self.raw.view_bits_mut::<Lsb0>()[0..6].store_le(value);
    Ok(())
}

}


/// _4WD11
///
/// - ID: 1064 (0x428)
/// - Size: 8 bytes
/// - Transmitter: _4WD
#[derive(Clone, Copy)]
pub struct X4wd11 {
    raw: [u8; 8],
}

impl X4wd11 {
    pub const MESSAGE_ID: u32 = 1064;
    
    pub const X4WD_TYPE_MIN: u8 = 0_u8;
    pub const X4WD_TYPE_MAX: u8 = 3_u8;
    pub const X4WD_SUPPORT_MIN: u8 = 0_u8;
    pub const X4WD_SUPPORT_MAX: u8 = 3_u8;
    pub const X4WD_ERR_MIN: u8 = 0_u8;
    pub const X4WD_ERR_MAX: u8 = 255_u8;
    pub const CLU_DUTY_MIN: u8 = 0_u8;
    pub const CLU_DUTY_MAX: u8 = 64_u8;
    pub const R_TIRE_MIN: f32 = 200_f32;
    pub const R_TIRE_MAX: f32 = 455_f32;
    pub const X4WD_SW_MIN: u8 = 0_u8;
    pub const X4WD_SW_MAX: u8 = 10_u8;
    pub const X4WD_TQC_CUR_MIN: u16 = 0_u16;
    pub const X4WD_TQC_CUR_MAX: u16 = 65535_u16;
    
    /// Construct new _4WD11 from values
    pub fn new(x4wd_type: u8, x4wd_support: u8, x4wd_err: u8, clu_duty: u8, r_tire: f32, x4wd_sw: u8, x2h_act: bool, x4h_act: bool, low_act: bool, auto_act: bool, lock_act: bool, x4wd_tqc_cur: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_x4wd_type(x4wd_type)?;
        res.set_x4wd_support(x4wd_support)?;
        res.set_x4wd_err(x4wd_err)?;
        res.set_clu_duty(clu_duty)?;
        res.set_r_tire(r_tire)?;
        res.set_x4wd_sw(x4wd_sw)?;
        res.set_x2h_act(x2h_act)?;
        res.set_x4h_act(x4h_act)?;
        res.set_low_act(low_act)?;
        res.set_auto_act(auto_act)?;
        res.set_lock_act(lock_act)?;
        res.set_x4wd_tqc_cur(x4wd_tqc_cur)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// _4WD_TYPE
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: ACU, ESC, TPMS
    #[inline(always)]
    pub fn x4wd_type(&self) -> u8 {
        self.x4wd_type_raw()
    }
    
    /// Get raw value of _4WD_TYPE
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4wd_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of _4WD_TYPE
    #[inline(always)]
    pub fn set_x4wd_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1064 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// _4WD_SUPPORT
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: ABS, ESC, TPMS
    #[inline(always)]
    pub fn x4wd_support(&self) -> u8 {
        self.x4wd_support_raw()
    }
    
    /// Get raw value of _4WD_SUPPORT
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4wd_support_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of _4WD_SUPPORT
    #[inline(always)]
    pub fn set_x4wd_support(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1064 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// _4WD_ERR
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU, ESC
    #[inline(always)]
    pub fn x4wd_err(&self) -> u8 {
        self.x4wd_err_raw()
    }
    
    /// Get raw value of _4WD_ERR
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4wd_err_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of _4WD_ERR
    #[inline(always)]
    pub fn set_x4wd_err(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1064 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// CLU_DUTY
    ///
    /// - Min: 0
    /// - Max: 64
    /// - Unit: "%"
    /// - Receivers: ABS, ESC
    #[inline(always)]
    pub fn clu_duty(&self) -> u8 {
        self.clu_duty_raw()
    }
    
    /// Get raw value of CLU_DUTY
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn clu_duty_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CLU_DUTY
    #[inline(always)]
    pub fn set_clu_duty(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 64_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1064 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// R_TIRE
    ///
    /// - Min: 200
    /// - Max: 455
    /// - Unit: "mm"
    /// - Receivers: ABS, ESC, TPMS
    #[inline(always)]
    pub fn r_tire(&self) -> f32 {
        self.r_tire_raw()
    }
    
    /// Get raw value of R_TIRE
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 200
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn r_tire_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = 200_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of R_TIRE
    #[inline(always)]
    pub fn set_r_tire(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 200_f32 || 455_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1064 });
        }
        let factor = 1_f32;
        let offset = 200_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// _4WD_SW
    ///
    /// - Min: 0
    /// - Max: 10
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn x4wd_sw(&self) -> u8 {
        self.x4wd_sw_raw()
    }
    
    /// Get raw value of _4WD_SW
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4wd_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of _4WD_SW
    #[inline(always)]
    pub fn set_x4wd_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 10_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1064 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// _2H_ACT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ABS, ESC
    #[inline(always)]
    pub fn x2h_act(&self) -> bool {
        self.x2h_act_raw()
    }
    
    /// Get raw value of _2H_ACT
    ///
    /// - Start bit: 40
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x2h_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[40..41].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of _2H_ACT
    #[inline(always)]
    pub fn set_x2h_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[40..41].store_le(value);
        Ok(())
    }
    
    /// _4H_ACT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ABS, CLU, ESC, TPMS
    #[inline(always)]
    pub fn x4h_act(&self) -> bool {
        self.x4h_act_raw()
    }
    
    /// Get raw value of _4H_ACT
    ///
    /// - Start bit: 41
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4h_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[41..42].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of _4H_ACT
    #[inline(always)]
    pub fn set_x4h_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[41..42].store_le(value);
        Ok(())
    }
    
    /// LOW_ACT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ABS, ESC, TCU, TPMS
    #[inline(always)]
    pub fn low_act(&self) -> bool {
        self.low_act_raw()
    }
    
    /// Get raw value of LOW_ACT
    ///
    /// - Start bit: 42
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn low_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[42..43].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LOW_ACT
    #[inline(always)]
    pub fn set_low_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[42..43].store_le(value);
        Ok(())
    }
    
    /// AUTO_ACT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ABS, ESC, TPMS
    #[inline(always)]
    pub fn auto_act(&self) -> bool {
        self.auto_act_raw()
    }
    
    /// Get raw value of AUTO_ACT
    ///
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn auto_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[43..44].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of AUTO_ACT
    #[inline(always)]
    pub fn set_auto_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[43..44].store_le(value);
        Ok(())
    }
    
    /// LOCK_ACT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ABS, CLU, ESC, TPMS
    #[inline(always)]
    pub fn lock_act(&self) -> bool {
        self.lock_act_raw()
    }
    
    /// Get raw value of LOCK_ACT
    ///
    /// - Start bit: 44
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lock_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[44..45].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LOCK_ACT
    #[inline(always)]
    pub fn set_lock_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[44..45].store_le(value);
        Ok(())
    }
    
    /// _4WD_TQC_CUR
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: "Nm"
    /// - Receivers: ABS, ESC
    #[inline(always)]
    pub fn x4wd_tqc_cur(&self) -> u16 {
        self.x4wd_tqc_cur_raw()
    }
    
    /// Get raw value of _4WD_TQC_CUR
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn x4wd_tqc_cur_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<u16>();
        
        signal
    }
    
    /// Set value of _4WD_TQC_CUR
    #[inline(always)]
    pub fn set_x4wd_tqc_cur(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65535_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1064 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for X4wd11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for X4wd11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("X4wd11")
                .field("x4wd_type", &self.x4wd_type())
                .field("x4wd_support", &self.x4wd_support())
                .field("x4wd_err", &self.x4wd_err())
                .field("clu_duty", &self.clu_duty())
                .field("r_tire", &self.r_tire())
                .field("x4wd_sw", &self.x4wd_sw())
                .field("x2h_act", &self.x2h_act())
                .field("x4h_act", &self.x4h_act())
                .field("low_act", &self.low_act())
                .field("auto_act", &self.auto_act())
                .field("lock_act", &self.lock_act())
                .field("x4wd_tqc_cur", &self.x4wd_tqc_cur())
            .finish()
        } else {
            f.debug_tuple("X4wd11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for X4wd11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let x4wd_type = u.int_in_range(0..=3)?;
        let x4wd_support = u.int_in_range(0..=3)?;
        let x4wd_err = u.int_in_range(0..=255)?;
        let clu_duty = u.int_in_range(0..=64)?;
        let r_tire = u.float_in_range(200_f32..=455_f32)?;
        let x4wd_sw = u.int_in_range(0..=10)?;
        let x2h_act = u.int_in_range(0..=1)? == 1;
        let x4h_act = u.int_in_range(0..=1)? == 1;
        let low_act = u.int_in_range(0..=1)? == 1;
        let auto_act = u.int_in_range(0..=1)? == 1;
        let lock_act = u.int_in_range(0..=1)? == 1;
        let x4wd_tqc_cur = u.int_in_range(0..=65535)?;
        X4wd11::new(x4wd_type,x4wd_support,x4wd_err,clu_duty,r_tire,x4wd_sw,x2h_act,x4h_act,low_act,auto_act,lock_act,x4wd_tqc_cur).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// HU_GW_E_01
///
/// - ID: 1319 (0x527)
/// - Size: 8 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct HuGwE01 {
    raw: [u8; 8],
}

impl HuGwE01 {
    pub const MESSAGE_ID: u32 = 1319;
    
    pub const C_A_DR_LN_VALUE_SET_MIN: u8 = 0_u8;
    pub const C_A_DR_LN_VALUE_SET_MAX: u8 = 7_u8;
    pub const C_A_DR_UN_VALUE_SET_MIN: u8 = 0_u8;
    pub const C_A_DR_UN_VALUE_SET_MAX: u8 = 7_u8;
    pub const C_TW_UN_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const C_TW_UN_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const C_A_BUZZER_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const C_A_BUZZER_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const C_ARM_W_KEY_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const C_ARM_W_KEY_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const C_PSMN_VALUE_SET_MIN: u8 = 0_u8;
    pub const C_PSMN_VALUE_SET_MAX: u8 = 3_u8;
    pub const C_SCMN_VALUE_SET_MIN: u8 = 0_u8;
    pub const C_SCMN_VALUE_SET_MAX: u8 = 3_u8;
    pub const C_HL_ESCORT_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const C_HL_ESCORT_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const C_WELN_VALUE_SET_MIN: u8 = 0_u8;
    pub const C_WELN_VALUE_SET_MAX: u8 = 3_u8;
    pub const C_TRI_TURN_LN_VALUE_SET_MIN: u8 = 0_u8;
    pub const C_TRI_TURN_LN_VALUE_SET_MAX: u8 = 3_u8;
    pub const C_SNV_WARN_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const C_SNV_WARN_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const C_LKAS_WARN_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const C_LKAS_WARN_N_VALUE_SET_MAX: u8 = 3_u8;
    
    /// Construct new HU_GW_E_01 from values
    pub fn new(c_a_dr_ln_value_set: u8, c_a_dr_un_value_set: u8, c_tw_un_n_value_set: u8, c_a_buzzer_n_value_set: u8, c_arm_w_key_n_value_set: u8, c_psmn_value_set: u8, c_scmn_value_set: u8, c_hl_escort_n_value_set: u8, c_weln_value_set: u8, c_tri_turn_ln_value_set: u8, c_snv_warn_n_value_set: u8, c_lkas_warn_n_value_set: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_c_a_dr_ln_value_set(c_a_dr_ln_value_set)?;
        res.set_c_a_dr_un_value_set(c_a_dr_un_value_set)?;
        res.set_c_tw_un_n_value_set(c_tw_un_n_value_set)?;
        res.set_c_a_buzzer_n_value_set(c_a_buzzer_n_value_set)?;
        res.set_c_arm_w_key_n_value_set(c_arm_w_key_n_value_set)?;
        res.set_c_psmn_value_set(c_psmn_value_set)?;
        res.set_c_scmn_value_set(c_scmn_value_set)?;
        res.set_c_hl_escort_n_value_set(c_hl_escort_n_value_set)?;
        res.set_c_weln_value_set(c_weln_value_set)?;
        res.set_c_tri_turn_ln_value_set(c_tri_turn_ln_value_set)?;
        res.set_c_snv_warn_n_value_set(c_snv_warn_n_value_set)?;
        res.set_c_lkas_warn_n_value_set(c_lkas_warn_n_value_set)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// C_ADrLNValueSet
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_a_dr_ln_value_set(&self) -> u8 {
        self.c_a_dr_ln_value_set_raw()
    }
    
    /// Get raw value of C_ADrLNValueSet
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_a_dr_ln_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_ADrLNValueSet
    #[inline(always)]
    pub fn set_c_a_dr_ln_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1319 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..3].store_le(value);
        Ok(())
    }
    
    /// C_ADrUNValueSet
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_a_dr_un_value_set(&self) -> u8 {
        self.c_a_dr_un_value_set_raw()
    }
    
    /// Get raw value of C_ADrUNValueSet
    ///
    /// - Start bit: 4
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_a_dr_un_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_ADrUNValueSet
    #[inline(always)]
    pub fn set_c_a_dr_un_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1319 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..7].store_le(value);
        Ok(())
    }
    
    /// C_TwUnNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_tw_un_n_value_set(&self) -> u8 {
        self.c_tw_un_n_value_set_raw()
    }
    
    /// Get raw value of C_TwUnNValueSet
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_tw_un_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_TwUnNValueSet
    #[inline(always)]
    pub fn set_c_tw_un_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1319 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// C_ABuzzerNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_a_buzzer_n_value_set(&self) -> u8 {
        self.c_a_buzzer_n_value_set_raw()
    }
    
    /// Get raw value of C_ABuzzerNValueSet
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_a_buzzer_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_ABuzzerNValueSet
    #[inline(always)]
    pub fn set_c_a_buzzer_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1319 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..12].store_le(value);
        Ok(())
    }
    
    /// C_ArmWKeyNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_arm_w_key_n_value_set(&self) -> u8 {
        self.c_arm_w_key_n_value_set_raw()
    }
    
    /// Get raw value of C_ArmWKeyNValueSet
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_arm_w_key_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_ArmWKeyNValueSet
    #[inline(always)]
    pub fn set_c_arm_w_key_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1319 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..14].store_le(value);
        Ok(())
    }
    
    /// C_PSMNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_psmn_value_set(&self) -> u8 {
        self.c_psmn_value_set_raw()
    }
    
    /// Get raw value of C_PSMNValueSet
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_psmn_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_PSMNValueSet
    #[inline(always)]
    pub fn set_c_psmn_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1319 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
    /// C_SCMNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_scmn_value_set(&self) -> u8 {
        self.c_scmn_value_set_raw()
    }
    
    /// Get raw value of C_SCMNValueSet
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_scmn_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_SCMNValueSet
    #[inline(always)]
    pub fn set_c_scmn_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1319 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..18].store_le(value);
        Ok(())
    }
    
    /// C_HLEscortNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_hl_escort_n_value_set(&self) -> u8 {
        self.c_hl_escort_n_value_set_raw()
    }
    
    /// Get raw value of C_HLEscortNValueSet
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_hl_escort_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_HLEscortNValueSet
    #[inline(always)]
    pub fn set_c_hl_escort_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1319 });
        }
        self.raw.view_bits_mut::<Lsb0>()[18..20].store_le(value);
        Ok(())
    }
    
    /// C_WELNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_weln_value_set(&self) -> u8 {
        self.c_weln_value_set_raw()
    }
    
    /// Get raw value of C_WELNValueSet
    ///
    /// - Start bit: 20
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_weln_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_WELNValueSet
    #[inline(always)]
    pub fn set_c_weln_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1319 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..22].store_le(value);
        Ok(())
    }
    
    /// C_TriTurnLNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_tri_turn_ln_value_set(&self) -> u8 {
        self.c_tri_turn_ln_value_set_raw()
    }
    
    /// Get raw value of C_TriTurnLNValueSet
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_tri_turn_ln_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_TriTurnLNValueSet
    #[inline(always)]
    pub fn set_c_tri_turn_ln_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1319 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
    /// C_SNVWarnNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_snv_warn_n_value_set(&self) -> u8 {
        self.c_snv_warn_n_value_set_raw()
    }
    
    /// Get raw value of C_SNVWarnNValueSet
    ///
    /// - Start bit: 24
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_snv_warn_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..26].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_SNVWarnNValueSet
    #[inline(always)]
    pub fn set_c_snv_warn_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1319 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..26].store_le(value);
        Ok(())
    }
    
    /// C_LkasWarnNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_lkas_warn_n_value_set(&self) -> u8 {
        self.c_lkas_warn_n_value_set_raw()
    }
    
    /// Get raw value of C_LkasWarnNValueSet
    ///
    /// - Start bit: 26
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_lkas_warn_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[26..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_LkasWarnNValueSet
    #[inline(always)]
    pub fn set_c_lkas_warn_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1319 });
        }
        self.raw.view_bits_mut::<Lsb0>()[26..28].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for HuGwE01 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for HuGwE01 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("HuGwE01")
                .field("c_a_dr_ln_value_set", &self.c_a_dr_ln_value_set())
                .field("c_a_dr_un_value_set", &self.c_a_dr_un_value_set())
                .field("c_tw_un_n_value_set", &self.c_tw_un_n_value_set())
                .field("c_a_buzzer_n_value_set", &self.c_a_buzzer_n_value_set())
                .field("c_arm_w_key_n_value_set", &self.c_arm_w_key_n_value_set())
                .field("c_psmn_value_set", &self.c_psmn_value_set())
                .field("c_scmn_value_set", &self.c_scmn_value_set())
                .field("c_hl_escort_n_value_set", &self.c_hl_escort_n_value_set())
                .field("c_weln_value_set", &self.c_weln_value_set())
                .field("c_tri_turn_ln_value_set", &self.c_tri_turn_ln_value_set())
                .field("c_snv_warn_n_value_set", &self.c_snv_warn_n_value_set())
                .field("c_lkas_warn_n_value_set", &self.c_lkas_warn_n_value_set())
            .finish()
        } else {
            f.debug_tuple("HuGwE01").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for HuGwE01 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let c_a_dr_ln_value_set = u.int_in_range(0..=7)?;
        let c_a_dr_un_value_set = u.int_in_range(0..=7)?;
        let c_tw_un_n_value_set = u.int_in_range(0..=3)?;
        let c_a_buzzer_n_value_set = u.int_in_range(0..=3)?;
        let c_arm_w_key_n_value_set = u.int_in_range(0..=3)?;
        let c_psmn_value_set = u.int_in_range(0..=3)?;
        let c_scmn_value_set = u.int_in_range(0..=3)?;
        let c_hl_escort_n_value_set = u.int_in_range(0..=3)?;
        let c_weln_value_set = u.int_in_range(0..=3)?;
        let c_tri_turn_ln_value_set = u.int_in_range(0..=3)?;
        let c_snv_warn_n_value_set = u.int_in_range(0..=3)?;
        let c_lkas_warn_n_value_set = u.int_in_range(0..=3)?;
        HuGwE01::new(c_a_dr_ln_value_set,c_a_dr_un_value_set,c_tw_un_n_value_set,c_a_buzzer_n_value_set,c_arm_w_key_n_value_set,c_psmn_value_set,c_scmn_value_set,c_hl_escort_n_value_set,c_weln_value_set,c_tri_turn_ln_value_set,c_snv_warn_n_value_set,c_lkas_warn_n_value_set).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// HU_GW_E_00
///
/// - ID: 1318 (0x526)
/// - Size: 8 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct HuGwE00 {
    raw: [u8; 8],
}

impl HuGwE00 {
    pub const MESSAGE_ID: u32 = 1318;
    
    pub const C_A_DR_LUR_VALUE_REQ_MIN: u8 = 0_u8;
    pub const C_A_DR_LUR_VALUE_REQ_MAX: u8 = 3_u8;
    pub const C_TW_UN_R_VALUE_REQ_MIN: u8 = 0_u8;
    pub const C_TW_UN_R_VALUE_REQ_MAX: u8 = 3_u8;
    pub const C_ALARM_R_VALUE_REQ_MIN: u8 = 0_u8;
    pub const C_ALARM_R_VALUE_REQ_MAX: u8 = 3_u8;
    pub const C_IMSR_VALUE_REQ_MIN: u8 = 0_u8;
    pub const C_IMSR_VALUE_REQ_MAX: u8 = 3_u8;
    pub const C_HL_ESCORT_R_VALUE_REQ_MIN: u8 = 0_u8;
    pub const C_HL_ESCORT_R_VALUE_REQ_MAX: u8 = 3_u8;
    pub const C_WELR_VALUE_REQ_MIN: u8 = 0_u8;
    pub const C_WELR_VALUE_REQ_MAX: u8 = 3_u8;
    pub const C_TRI_TURN_LR_VALUE_REQ_MIN: u8 = 0_u8;
    pub const C_TRI_TURN_LR_VALUE_REQ_MAX: u8 = 3_u8;
    pub const C_SNV_WARN_R_VALUE_REQ_MIN: u8 = 0_u8;
    pub const C_SNV_WARN_R_VALUE_REQ_MAX: u8 = 3_u8;
    pub const C_LKAS_WARN_R_VALUE_REQ_MIN: u8 = 0_u8;
    pub const C_LKAS_WARN_R_VALUE_REQ_MAX: u8 = 3_u8;
    
    /// Construct new HU_GW_E_00 from values
    pub fn new(c_a_dr_lur_value_req: u8, c_tw_un_r_value_req: u8, c_alarm_r_value_req: u8, c_imsr_value_req: u8, c_hl_escort_r_value_req: u8, c_welr_value_req: u8, c_tri_turn_lr_value_req: u8, c_snv_warn_r_value_req: u8, c_lkas_warn_r_value_req: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_c_a_dr_lur_value_req(c_a_dr_lur_value_req)?;
        res.set_c_tw_un_r_value_req(c_tw_un_r_value_req)?;
        res.set_c_alarm_r_value_req(c_alarm_r_value_req)?;
        res.set_c_imsr_value_req(c_imsr_value_req)?;
        res.set_c_hl_escort_r_value_req(c_hl_escort_r_value_req)?;
        res.set_c_welr_value_req(c_welr_value_req)?;
        res.set_c_tri_turn_lr_value_req(c_tri_turn_lr_value_req)?;
        res.set_c_snv_warn_r_value_req(c_snv_warn_r_value_req)?;
        res.set_c_lkas_warn_r_value_req(c_lkas_warn_r_value_req)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// C_ADrLURValueReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_a_dr_lur_value_req(&self) -> u8 {
        self.c_a_dr_lur_value_req_raw()
    }
    
    /// Get raw value of C_ADrLURValueReq
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_a_dr_lur_value_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_ADrLURValueReq
    #[inline(always)]
    pub fn set_c_a_dr_lur_value_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1318 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// C_TwUnRValueReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_tw_un_r_value_req(&self) -> u8 {
        self.c_tw_un_r_value_req_raw()
    }
    
    /// Get raw value of C_TwUnRValueReq
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_tw_un_r_value_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_TwUnRValueReq
    #[inline(always)]
    pub fn set_c_tw_un_r_value_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1318 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// C_AlarmRValueReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_alarm_r_value_req(&self) -> u8 {
        self.c_alarm_r_value_req_raw()
    }
    
    /// Get raw value of C_AlarmRValueReq
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_alarm_r_value_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_AlarmRValueReq
    #[inline(always)]
    pub fn set_c_alarm_r_value_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1318 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
    /// C_IMSRValueReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_imsr_value_req(&self) -> u8 {
        self.c_imsr_value_req_raw()
    }
    
    /// Get raw value of C_IMSRValueReq
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_imsr_value_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_IMSRValueReq
    #[inline(always)]
    pub fn set_c_imsr_value_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1318 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// C_HLEscortRValueReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_hl_escort_r_value_req(&self) -> u8 {
        self.c_hl_escort_r_value_req_raw()
    }
    
    /// Get raw value of C_HLEscortRValueReq
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_hl_escort_r_value_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_HLEscortRValueReq
    #[inline(always)]
    pub fn set_c_hl_escort_r_value_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1318 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// C_WELRValueReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_welr_value_req(&self) -> u8 {
        self.c_welr_value_req_raw()
    }
    
    /// Get raw value of C_WELRValueReq
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_welr_value_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_WELRValueReq
    #[inline(always)]
    pub fn set_c_welr_value_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1318 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..12].store_le(value);
        Ok(())
    }
    
    /// C_TriTurnLRValueReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_tri_turn_lr_value_req(&self) -> u8 {
        self.c_tri_turn_lr_value_req_raw()
    }
    
    /// Get raw value of C_TriTurnLRValueReq
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_tri_turn_lr_value_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_TriTurnLRValueReq
    #[inline(always)]
    pub fn set_c_tri_turn_lr_value_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1318 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..14].store_le(value);
        Ok(())
    }
    
    /// C_SNVWarnRValueReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_snv_warn_r_value_req(&self) -> u8 {
        self.c_snv_warn_r_value_req_raw()
    }
    
    /// Get raw value of C_SNVWarnRValueReq
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_snv_warn_r_value_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_SNVWarnRValueReq
    #[inline(always)]
    pub fn set_c_snv_warn_r_value_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1318 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
    /// C_LkasWarnRValueReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn c_lkas_warn_r_value_req(&self) -> u8 {
        self.c_lkas_warn_r_value_req_raw()
    }
    
    /// Get raw value of C_LkasWarnRValueReq
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_lkas_warn_r_value_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_LkasWarnRValueReq
    #[inline(always)]
    pub fn set_c_lkas_warn_r_value_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1318 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..18].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for HuGwE00 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for HuGwE00 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("HuGwE00")
                .field("c_a_dr_lur_value_req", &self.c_a_dr_lur_value_req())
                .field("c_tw_un_r_value_req", &self.c_tw_un_r_value_req())
                .field("c_alarm_r_value_req", &self.c_alarm_r_value_req())
                .field("c_imsr_value_req", &self.c_imsr_value_req())
                .field("c_hl_escort_r_value_req", &self.c_hl_escort_r_value_req())
                .field("c_welr_value_req", &self.c_welr_value_req())
                .field("c_tri_turn_lr_value_req", &self.c_tri_turn_lr_value_req())
                .field("c_snv_warn_r_value_req", &self.c_snv_warn_r_value_req())
                .field("c_lkas_warn_r_value_req", &self.c_lkas_warn_r_value_req())
            .finish()
        } else {
            f.debug_tuple("HuGwE00").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for HuGwE00 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let c_a_dr_lur_value_req = u.int_in_range(0..=3)?;
        let c_tw_un_r_value_req = u.int_in_range(0..=3)?;
        let c_alarm_r_value_req = u.int_in_range(0..=3)?;
        let c_imsr_value_req = u.int_in_range(0..=3)?;
        let c_hl_escort_r_value_req = u.int_in_range(0..=3)?;
        let c_welr_value_req = u.int_in_range(0..=3)?;
        let c_tri_turn_lr_value_req = u.int_in_range(0..=3)?;
        let c_snv_warn_r_value_req = u.int_in_range(0..=3)?;
        let c_lkas_warn_r_value_req = u.int_in_range(0..=3)?;
        HuGwE00::new(c_a_dr_lur_value_req,c_tw_un_r_value_req,c_alarm_r_value_req,c_imsr_value_req,c_hl_escort_r_value_req,c_welr_value_req,c_tri_turn_lr_value_req,c_snv_warn_r_value_req,c_lkas_warn_r_value_req).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// GW_HU_E_01
///
/// - ID: 1317 (0x525)
/// - Size: 8 bytes
/// - Transmitter: BCM
#[derive(Clone, Copy)]
pub struct GwHuE01 {
    raw: [u8; 8],
}

impl GwHuE01 {
    pub const MESSAGE_ID: u32 = 1317;
    
    pub const C_A_DR_LR_VALUE_MIN: u8 = 0_u8;
    pub const C_A_DR_LR_VALUE_MAX: u8 = 7_u8;
    pub const C_A_DR_UR_VALUE_MIN: u8 = 0_u8;
    pub const C_A_DR_UR_VALUE_MAX: u8 = 7_u8;
    pub const C_TW_UN_R_VALUE_MIN: u8 = 0_u8;
    pub const C_TW_UN_R_VALUE_MAX: u8 = 3_u8;
    pub const C_A_BUZZER_R_VALUE_MIN: u8 = 0_u8;
    pub const C_A_BUZZER_R_VALUE_MAX: u8 = 3_u8;
    pub const C_ARM_W_KEY_R_VALUE_MIN: u8 = 0_u8;
    pub const C_ARM_W_KEY_R_VALUE_MAX: u8 = 3_u8;
    pub const C_PSMR_VALUE_MIN: u8 = 0_u8;
    pub const C_PSMR_VALUE_MAX: u8 = 3_u8;
    pub const C_SCMR_VALUE_MIN: u8 = 0_u8;
    pub const C_SCMR_VALUE_MAX: u8 = 3_u8;
    pub const C_HL_ESCORT_R_VALUE_MIN: u8 = 0_u8;
    pub const C_HL_ESCORT_R_VALUE_MAX: u8 = 3_u8;
    pub const C_WELR_VALUE_MIN: u8 = 0_u8;
    pub const C_WELR_VALUE_MAX: u8 = 3_u8;
    pub const C_TRI_TURN_LR_VALUE_MIN: u8 = 0_u8;
    pub const C_TRI_TURN_LR_VALUE_MAX: u8 = 3_u8;
    
    /// Construct new GW_HU_E_01 from values
    pub fn new(c_a_dr_lr_value: u8, c_a_dr_ur_value: u8, c_tw_un_r_value: u8, c_a_buzzer_r_value: u8, c_arm_w_key_r_value: u8, c_psmr_value: u8, c_scmr_value: u8, c_hl_escort_r_value: u8, c_welr_value: u8, c_tri_turn_lr_value: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_c_a_dr_lr_value(c_a_dr_lr_value)?;
        res.set_c_a_dr_ur_value(c_a_dr_ur_value)?;
        res.set_c_tw_un_r_value(c_tw_un_r_value)?;
        res.set_c_a_buzzer_r_value(c_a_buzzer_r_value)?;
        res.set_c_arm_w_key_r_value(c_arm_w_key_r_value)?;
        res.set_c_psmr_value(c_psmr_value)?;
        res.set_c_scmr_value(c_scmr_value)?;
        res.set_c_hl_escort_r_value(c_hl_escort_r_value)?;
        res.set_c_welr_value(c_welr_value)?;
        res.set_c_tri_turn_lr_value(c_tri_turn_lr_value)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// C_ADrLRValue
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_a_dr_lr_value(&self) -> u8 {
        self.c_a_dr_lr_value_raw()
    }
    
    /// Get raw value of C_ADrLRValue
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_a_dr_lr_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_ADrLRValue
    #[inline(always)]
    pub fn set_c_a_dr_lr_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1317 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..3].store_le(value);
        Ok(())
    }
    
    /// C_ADrURValue
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_a_dr_ur_value(&self) -> u8 {
        self.c_a_dr_ur_value_raw()
    }
    
    /// Get raw value of C_ADrURValue
    ///
    /// - Start bit: 4
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_a_dr_ur_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_ADrURValue
    #[inline(always)]
    pub fn set_c_a_dr_ur_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1317 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..7].store_le(value);
        Ok(())
    }
    
    /// C_TwUnRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_tw_un_r_value(&self) -> u8 {
        self.c_tw_un_r_value_raw()
    }
    
    /// Get raw value of C_TwUnRValue
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_tw_un_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_TwUnRValue
    #[inline(always)]
    pub fn set_c_tw_un_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1317 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// C_ABuzzerRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_a_buzzer_r_value(&self) -> u8 {
        self.c_a_buzzer_r_value_raw()
    }
    
    /// Get raw value of C_ABuzzerRValue
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_a_buzzer_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_ABuzzerRValue
    #[inline(always)]
    pub fn set_c_a_buzzer_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1317 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..12].store_le(value);
        Ok(())
    }
    
    /// C_ArmWKeyRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_arm_w_key_r_value(&self) -> u8 {
        self.c_arm_w_key_r_value_raw()
    }
    
    /// Get raw value of C_ArmWKeyRValue
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_arm_w_key_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_ArmWKeyRValue
    #[inline(always)]
    pub fn set_c_arm_w_key_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1317 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..14].store_le(value);
        Ok(())
    }
    
    /// C_PSMRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_psmr_value(&self) -> u8 {
        self.c_psmr_value_raw()
    }
    
    /// Get raw value of C_PSMRValue
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_psmr_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_PSMRValue
    #[inline(always)]
    pub fn set_c_psmr_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1317 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
    /// C_SCMRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_scmr_value(&self) -> u8 {
        self.c_scmr_value_raw()
    }
    
    /// Get raw value of C_SCMRValue
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_scmr_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_SCMRValue
    #[inline(always)]
    pub fn set_c_scmr_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1317 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..18].store_le(value);
        Ok(())
    }
    
    /// C_HLEscortRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_hl_escort_r_value(&self) -> u8 {
        self.c_hl_escort_r_value_raw()
    }
    
    /// Get raw value of C_HLEscortRValue
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_hl_escort_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_HLEscortRValue
    #[inline(always)]
    pub fn set_c_hl_escort_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1317 });
        }
        self.raw.view_bits_mut::<Lsb0>()[18..20].store_le(value);
        Ok(())
    }
    
    /// C_WELRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_welr_value(&self) -> u8 {
        self.c_welr_value_raw()
    }
    
    /// Get raw value of C_WELRValue
    ///
    /// - Start bit: 20
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_welr_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_WELRValue
    #[inline(always)]
    pub fn set_c_welr_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1317 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..22].store_le(value);
        Ok(())
    }
    
    /// C_TriTurnLRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_tri_turn_lr_value(&self) -> u8 {
        self.c_tri_turn_lr_value_raw()
    }
    
    /// Get raw value of C_TriTurnLRValue
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_tri_turn_lr_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_TriTurnLRValue
    #[inline(always)]
    pub fn set_c_tri_turn_lr_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1317 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for GwHuE01 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for GwHuE01 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("GwHuE01")
                .field("c_a_dr_lr_value", &self.c_a_dr_lr_value())
                .field("c_a_dr_ur_value", &self.c_a_dr_ur_value())
                .field("c_tw_un_r_value", &self.c_tw_un_r_value())
                .field("c_a_buzzer_r_value", &self.c_a_buzzer_r_value())
                .field("c_arm_w_key_r_value", &self.c_arm_w_key_r_value())
                .field("c_psmr_value", &self.c_psmr_value())
                .field("c_scmr_value", &self.c_scmr_value())
                .field("c_hl_escort_r_value", &self.c_hl_escort_r_value())
                .field("c_welr_value", &self.c_welr_value())
                .field("c_tri_turn_lr_value", &self.c_tri_turn_lr_value())
            .finish()
        } else {
            f.debug_tuple("GwHuE01").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for GwHuE01 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let c_a_dr_lr_value = u.int_in_range(0..=7)?;
        let c_a_dr_ur_value = u.int_in_range(0..=7)?;
        let c_tw_un_r_value = u.int_in_range(0..=3)?;
        let c_a_buzzer_r_value = u.int_in_range(0..=3)?;
        let c_arm_w_key_r_value = u.int_in_range(0..=3)?;
        let c_psmr_value = u.int_in_range(0..=3)?;
        let c_scmr_value = u.int_in_range(0..=3)?;
        let c_hl_escort_r_value = u.int_in_range(0..=3)?;
        let c_welr_value = u.int_in_range(0..=3)?;
        let c_tri_turn_lr_value = u.int_in_range(0..=3)?;
        GwHuE01::new(c_a_dr_lr_value,c_a_dr_ur_value,c_tw_un_r_value,c_a_buzzer_r_value,c_arm_w_key_r_value,c_psmr_value,c_scmr_value,c_hl_escort_r_value,c_welr_value,c_tri_turn_lr_value).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// GW_HU_E_00
///
/// - ID: 1316 (0x524)
/// - Size: 8 bytes
/// - Transmitter: BCM
#[derive(Clone, Copy)]
pub struct GwHuE00 {
    raw: [u8; 8],
}

impl GwHuE00 {
    pub const MESSAGE_ID: u32 = 1316;
    
    pub const C_A_DR_LUN_VALUE_CONF_MIN: u8 = 0_u8;
    pub const C_A_DR_LUN_VALUE_CONF_MAX: u8 = 3_u8;
    pub const C_TW_UN_N_VALUE_CONF_MIN: u8 = 0_u8;
    pub const C_TW_UN_N_VALUE_CONF_MAX: u8 = 3_u8;
    pub const C_ALARM_N_VALUE_CONF_MIN: u8 = 0_u8;
    pub const C_ALARM_N_VALUE_CONF_MAX: u8 = 3_u8;
    pub const C_PSMN_VALUE_CONF_MIN: u8 = 0_u8;
    pub const C_PSMN_VALUE_CONF_MAX: u8 = 3_u8;
    pub const C_SCMN_VALUE_CONF_MIN: u8 = 0_u8;
    pub const C_SCMN_VALUE_CONF_MAX: u8 = 3_u8;
    pub const C_HL_ESCORT_N_VALUE_CONF_MIN: u8 = 0_u8;
    pub const C_HL_ESCORT_N_VALUE_CONF_MAX: u8 = 3_u8;
    pub const C_WELN_VALUE_CONF_MIN: u8 = 0_u8;
    pub const C_WELN_VALUE_CONF_MAX: u8 = 3_u8;
    pub const C_TRI_TURN_LN_VALUE_CONF_MIN: u8 = 0_u8;
    pub const C_TRI_TURN_LN_VALUE_CONF_MAX: u8 = 3_u8;
    
    /// Construct new GW_HU_E_00 from values
    pub fn new(c_a_dr_lun_value_conf: u8, c_tw_un_n_value_conf: u8, c_alarm_n_value_conf: u8, c_psmn_value_conf: u8, c_scmn_value_conf: u8, c_hl_escort_n_value_conf: u8, c_weln_value_conf: u8, c_tri_turn_ln_value_conf: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_c_a_dr_lun_value_conf(c_a_dr_lun_value_conf)?;
        res.set_c_tw_un_n_value_conf(c_tw_un_n_value_conf)?;
        res.set_c_alarm_n_value_conf(c_alarm_n_value_conf)?;
        res.set_c_psmn_value_conf(c_psmn_value_conf)?;
        res.set_c_scmn_value_conf(c_scmn_value_conf)?;
        res.set_c_hl_escort_n_value_conf(c_hl_escort_n_value_conf)?;
        res.set_c_weln_value_conf(c_weln_value_conf)?;
        res.set_c_tri_turn_ln_value_conf(c_tri_turn_ln_value_conf)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// C_ADrLUNValueConf
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_a_dr_lun_value_conf(&self) -> u8 {
        self.c_a_dr_lun_value_conf_raw()
    }
    
    /// Get raw value of C_ADrLUNValueConf
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_a_dr_lun_value_conf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_ADrLUNValueConf
    #[inline(always)]
    pub fn set_c_a_dr_lun_value_conf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1316 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// C_TwUnNValueConf
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_tw_un_n_value_conf(&self) -> u8 {
        self.c_tw_un_n_value_conf_raw()
    }
    
    /// Get raw value of C_TwUnNValueConf
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_tw_un_n_value_conf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_TwUnNValueConf
    #[inline(always)]
    pub fn set_c_tw_un_n_value_conf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1316 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// C_AlarmNValueConf
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_alarm_n_value_conf(&self) -> u8 {
        self.c_alarm_n_value_conf_raw()
    }
    
    /// Get raw value of C_AlarmNValueConf
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_alarm_n_value_conf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_AlarmNValueConf
    #[inline(always)]
    pub fn set_c_alarm_n_value_conf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1316 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
    /// C_PSMNValueConf
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_psmn_value_conf(&self) -> u8 {
        self.c_psmn_value_conf_raw()
    }
    
    /// Get raw value of C_PSMNValueConf
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_psmn_value_conf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_PSMNValueConf
    #[inline(always)]
    pub fn set_c_psmn_value_conf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1316 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// C_SCMNValueConf
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_scmn_value_conf(&self) -> u8 {
        self.c_scmn_value_conf_raw()
    }
    
    /// Get raw value of C_SCMNValueConf
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_scmn_value_conf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_SCMNValueConf
    #[inline(always)]
    pub fn set_c_scmn_value_conf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1316 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// C_HLEscortNValueConf
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_hl_escort_n_value_conf(&self) -> u8 {
        self.c_hl_escort_n_value_conf_raw()
    }
    
    /// Get raw value of C_HLEscortNValueConf
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_hl_escort_n_value_conf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_HLEscortNValueConf
    #[inline(always)]
    pub fn set_c_hl_escort_n_value_conf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1316 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..12].store_le(value);
        Ok(())
    }
    
    /// C_WELNValueConf
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_weln_value_conf(&self) -> u8 {
        self.c_weln_value_conf_raw()
    }
    
    /// Get raw value of C_WELNValueConf
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_weln_value_conf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_WELNValueConf
    #[inline(always)]
    pub fn set_c_weln_value_conf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1316 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..14].store_le(value);
        Ok(())
    }
    
    /// C_TriTurnLNValueConf
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_tri_turn_ln_value_conf(&self) -> u8 {
        self.c_tri_turn_ln_value_conf_raw()
    }
    
    /// Get raw value of C_TriTurnLNValueConf
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_tri_turn_ln_value_conf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_TriTurnLNValueConf
    #[inline(always)]
    pub fn set_c_tri_turn_ln_value_conf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1316 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for GwHuE00 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for GwHuE00 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("GwHuE00")
                .field("c_a_dr_lun_value_conf", &self.c_a_dr_lun_value_conf())
                .field("c_tw_un_n_value_conf", &self.c_tw_un_n_value_conf())
                .field("c_alarm_n_value_conf", &self.c_alarm_n_value_conf())
                .field("c_psmn_value_conf", &self.c_psmn_value_conf())
                .field("c_scmn_value_conf", &self.c_scmn_value_conf())
                .field("c_hl_escort_n_value_conf", &self.c_hl_escort_n_value_conf())
                .field("c_weln_value_conf", &self.c_weln_value_conf())
                .field("c_tri_turn_ln_value_conf", &self.c_tri_turn_ln_value_conf())
            .finish()
        } else {
            f.debug_tuple("GwHuE00").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for GwHuE00 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let c_a_dr_lun_value_conf = u.int_in_range(0..=3)?;
        let c_tw_un_n_value_conf = u.int_in_range(0..=3)?;
        let c_alarm_n_value_conf = u.int_in_range(0..=3)?;
        let c_psmn_value_conf = u.int_in_range(0..=3)?;
        let c_scmn_value_conf = u.int_in_range(0..=3)?;
        let c_hl_escort_n_value_conf = u.int_in_range(0..=3)?;
        let c_weln_value_conf = u.int_in_range(0..=3)?;
        let c_tri_turn_ln_value_conf = u.int_in_range(0..=3)?;
        GwHuE00::new(c_a_dr_lun_value_conf,c_tw_un_n_value_conf,c_alarm_n_value_conf,c_psmn_value_conf,c_scmn_value_conf,c_hl_escort_n_value_conf,c_weln_value_conf,c_tri_turn_ln_value_conf).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// GW_SWRC_PE
///
/// - ID: 1315 (0x523)
/// - Size: 8 bytes
/// - Transmitter: BCM
#[derive(Clone, Copy)]
pub struct GwSwrcPe {
    raw: [u8; 8],
}

impl GwSwrcPe {
    pub const MESSAGE_ID: u32 = 1315;
    
    pub const C_MODE_SW_MIN: u8 = 0_u8;
    pub const C_MODE_SW_MAX: u8 = 3_u8;
    pub const C_MUTE_SW_MIN: u8 = 0_u8;
    pub const C_MUTE_SW_MAX: u8 = 3_u8;
    pub const C_SEEK_DN_SW_MIN: u8 = 0_u8;
    pub const C_SEEK_DN_SW_MAX: u8 = 3_u8;
    pub const C_SEEK_UP_SW_MIN: u8 = 0_u8;
    pub const C_SEEK_UP_SW_MAX: u8 = 3_u8;
    pub const C_BT_PHONE_CALL_SW_MIN: u8 = 0_u8;
    pub const C_BT_PHONE_CALL_SW_MAX: u8 = 3_u8;
    pub const C_BT_PHONE_HANG_UP_SW_MIN: u8 = 0_u8;
    pub const C_BT_PHONE_HANG_UP_SW_MAX: u8 = 3_u8;
    pub const C_DISC_DOWN_SW_MIN: u8 = 0_u8;
    pub const C_DISC_DOWN_SW_MAX: u8 = 3_u8;
    pub const C_DISC_UP_SW_MIN: u8 = 0_u8;
    pub const C_DISC_UP_SW_MAX: u8 = 3_u8;
    pub const C_SDS_SW_MIN: u8 = 0_u8;
    pub const C_SDS_SW_MAX: u8 = 3_u8;
    pub const C_MTSSW_MIN: u8 = 0_u8;
    pub const C_MTSSW_MAX: u8 = 3_u8;
    pub const C_VOL_DN_SW_MIN: u8 = 0_u8;
    pub const C_VOL_DN_SW_MAX: u8 = 3_u8;
    pub const C_VOL_UP_SW_MIN: u8 = 0_u8;
    pub const C_VOL_UP_SW_MAX: u8 = 3_u8;
    
    /// Construct new GW_SWRC_PE from values
    pub fn new(c_mode_sw: u8, c_mute_sw: u8, c_seek_dn_sw: u8, c_seek_up_sw: u8, c_bt_phone_call_sw: u8, c_bt_phone_hang_up_sw: u8, c_disc_down_sw: u8, c_disc_up_sw: u8, c_sds_sw: u8, c_mtssw: u8, c_vol_dn_sw: u8, c_vol_up_sw: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_c_mode_sw(c_mode_sw)?;
        res.set_c_mute_sw(c_mute_sw)?;
        res.set_c_seek_dn_sw(c_seek_dn_sw)?;
        res.set_c_seek_up_sw(c_seek_up_sw)?;
        res.set_c_bt_phone_call_sw(c_bt_phone_call_sw)?;
        res.set_c_bt_phone_hang_up_sw(c_bt_phone_hang_up_sw)?;
        res.set_c_disc_down_sw(c_disc_down_sw)?;
        res.set_c_disc_up_sw(c_disc_up_sw)?;
        res.set_c_sds_sw(c_sds_sw)?;
        res.set_c_mtssw(c_mtssw)?;
        res.set_c_vol_dn_sw(c_vol_dn_sw)?;
        res.set_c_vol_up_sw(c_vol_up_sw)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// C_ModeSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_mode_sw(&self) -> u8 {
        self.c_mode_sw_raw()
    }
    
    /// Get raw value of C_ModeSW
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_mode_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_ModeSW
    #[inline(always)]
    pub fn set_c_mode_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1315 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// C_MuteSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_mute_sw(&self) -> u8 {
        self.c_mute_sw_raw()
    }
    
    /// Get raw value of C_MuteSW
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_mute_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_MuteSW
    #[inline(always)]
    pub fn set_c_mute_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1315 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
    /// C_SeekDnSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_seek_dn_sw(&self) -> u8 {
        self.c_seek_dn_sw_raw()
    }
    
    /// Get raw value of C_SeekDnSW
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_seek_dn_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_SeekDnSW
    #[inline(always)]
    pub fn set_c_seek_dn_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1315 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// C_SeekUpSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_seek_up_sw(&self) -> u8 {
        self.c_seek_up_sw_raw()
    }
    
    /// Get raw value of C_SeekUpSW
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_seek_up_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_SeekUpSW
    #[inline(always)]
    pub fn set_c_seek_up_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1315 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// C_BTPhoneCallSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_bt_phone_call_sw(&self) -> u8 {
        self.c_bt_phone_call_sw_raw()
    }
    
    /// Get raw value of C_BTPhoneCallSW
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_bt_phone_call_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_BTPhoneCallSW
    #[inline(always)]
    pub fn set_c_bt_phone_call_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1315 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..12].store_le(value);
        Ok(())
    }
    
    /// C_BTPhoneHangUpSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_bt_phone_hang_up_sw(&self) -> u8 {
        self.c_bt_phone_hang_up_sw_raw()
    }
    
    /// Get raw value of C_BTPhoneHangUpSW
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_bt_phone_hang_up_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_BTPhoneHangUpSW
    #[inline(always)]
    pub fn set_c_bt_phone_hang_up_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1315 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..14].store_le(value);
        Ok(())
    }
    
    /// C_DISCDownSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_disc_down_sw(&self) -> u8 {
        self.c_disc_down_sw_raw()
    }
    
    /// Get raw value of C_DISCDownSW
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_disc_down_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_DISCDownSW
    #[inline(always)]
    pub fn set_c_disc_down_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1315 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
    /// C_DISCUpSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_disc_up_sw(&self) -> u8 {
        self.c_disc_up_sw_raw()
    }
    
    /// Get raw value of C_DISCUpSW
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_disc_up_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_DISCUpSW
    #[inline(always)]
    pub fn set_c_disc_up_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1315 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..18].store_le(value);
        Ok(())
    }
    
    /// C_SdsSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_sds_sw(&self) -> u8 {
        self.c_sds_sw_raw()
    }
    
    /// Get raw value of C_SdsSW
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_sds_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_SdsSW
    #[inline(always)]
    pub fn set_c_sds_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1315 });
        }
        self.raw.view_bits_mut::<Lsb0>()[18..20].store_le(value);
        Ok(())
    }
    
    /// C_MTSSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_mtssw(&self) -> u8 {
        self.c_mtssw_raw()
    }
    
    /// Get raw value of C_MTSSW
    ///
    /// - Start bit: 20
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_mtssw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_MTSSW
    #[inline(always)]
    pub fn set_c_mtssw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1315 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..22].store_le(value);
        Ok(())
    }
    
    /// C_VolDnSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_vol_dn_sw(&self) -> u8 {
        self.c_vol_dn_sw_raw()
    }
    
    /// Get raw value of C_VolDnSW
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_vol_dn_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_VolDnSW
    #[inline(always)]
    pub fn set_c_vol_dn_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1315 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
    /// C_VolUpSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_vol_up_sw(&self) -> u8 {
        self.c_vol_up_sw_raw()
    }
    
    /// Get raw value of C_VolUpSW
    ///
    /// - Start bit: 24
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_vol_up_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..26].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_VolUpSW
    #[inline(always)]
    pub fn set_c_vol_up_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1315 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..26].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for GwSwrcPe {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for GwSwrcPe {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("GwSwrcPe")
                .field("c_mode_sw", &self.c_mode_sw())
                .field("c_mute_sw", &self.c_mute_sw())
                .field("c_seek_dn_sw", &self.c_seek_dn_sw())
                .field("c_seek_up_sw", &self.c_seek_up_sw())
                .field("c_bt_phone_call_sw", &self.c_bt_phone_call_sw())
                .field("c_bt_phone_hang_up_sw", &self.c_bt_phone_hang_up_sw())
                .field("c_disc_down_sw", &self.c_disc_down_sw())
                .field("c_disc_up_sw", &self.c_disc_up_sw())
                .field("c_sds_sw", &self.c_sds_sw())
                .field("c_mtssw", &self.c_mtssw())
                .field("c_vol_dn_sw", &self.c_vol_dn_sw())
                .field("c_vol_up_sw", &self.c_vol_up_sw())
            .finish()
        } else {
            f.debug_tuple("GwSwrcPe").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for GwSwrcPe {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let c_mode_sw = u.int_in_range(0..=3)?;
        let c_mute_sw = u.int_in_range(0..=3)?;
        let c_seek_dn_sw = u.int_in_range(0..=3)?;
        let c_seek_up_sw = u.int_in_range(0..=3)?;
        let c_bt_phone_call_sw = u.int_in_range(0..=3)?;
        let c_bt_phone_hang_up_sw = u.int_in_range(0..=3)?;
        let c_disc_down_sw = u.int_in_range(0..=3)?;
        let c_disc_up_sw = u.int_in_range(0..=3)?;
        let c_sds_sw = u.int_in_range(0..=3)?;
        let c_mtssw = u.int_in_range(0..=3)?;
        let c_vol_dn_sw = u.int_in_range(0..=3)?;
        let c_vol_up_sw = u.int_in_range(0..=3)?;
        GwSwrcPe::new(c_mode_sw,c_mute_sw,c_seek_dn_sw,c_seek_up_sw,c_bt_phone_call_sw,c_bt_phone_hang_up_sw,c_disc_down_sw,c_disc_up_sw,c_sds_sw,c_mtssw,c_vol_dn_sw,c_vol_up_sw).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// GW_IPM_PE_1
///
/// - ID: 1314 (0x522)
/// - Size: 8 bytes
/// - Transmitter: BCM
#[derive(Clone, Copy)]
pub struct GwIpmPe1 {
    raw: [u8; 8],
}

impl GwIpmPe1 {
    pub const MESSAGE_ID: u32 = 1314;
    
    pub const C_AV_TAIL_MIN: u8 = 0_u8;
    pub const C_AV_TAIL_MAX: u8 = 3_u8;
    pub const C_PARKING_BRAKE_SW_MIN: u8 = 0_u8;
    pub const C_PARKING_BRAKE_SW_MAX: u8 = 3_u8;
    pub const C_RKECMD_MIN: u8 = 0_u8;
    pub const C_RKECMD_MAX: u8 = 15_u8;
    pub const C_BA_STATE_MIN: u8 = 0_u8;
    pub const C_BA_STATE_MAX: u8 = 3_u8;
    pub const C_IGNSW_MIN: u8 = 0_u8;
    pub const C_IGNSW_MAX: u8 = 7_u8;
    pub const C_COUNTRY_CFG_MIN: u8 = 0_u8;
    pub const C_COUNTRY_CFG_MAX: u8 = 7_u8;
    pub const C_TAIL_LAMP_ACTIVITY_MIN: u8 = 0_u8;
    pub const C_TAIL_LAMP_ACTIVITY_MAX: u8 = 3_u8;
    pub const REAR_SW_RSE_LOCK_ON_OFF_MIN: u8 = 0_u8;
    pub const REAR_SW_RSE_LOCK_ON_OFF_MAX: u8 = 3_u8;
    pub const C_SMK_TELE_CRANKING_STATE_MIN: u8 = 0_u8;
    pub const C_SMK_TELE_CRANKING_STATE_MAX: u8 = 3_u8;
    pub const C_SMK_TELE_CRANKING_FAIL_RES_MIN: u8 = 0_u8;
    pub const C_SMK_TELE_CRANKING_FAIL_RES_MAX: u8 = 3_u8;
    
    /// Construct new GW_IPM_PE_1 from values
    pub fn new(c_av_tail: u8, c_parking_brake_sw: u8, c_rkecmd: u8, c_ba_state: u8, c_ignsw: u8, c_country_cfg: u8, c_tail_lamp_activity: u8, rear_sw_rse_lock_on_off: u8, c_smk_tele_cranking_state: u8, c_smk_tele_cranking_fail_res: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_c_av_tail(c_av_tail)?;
        res.set_c_parking_brake_sw(c_parking_brake_sw)?;
        res.set_c_rkecmd(c_rkecmd)?;
        res.set_c_ba_state(c_ba_state)?;
        res.set_c_ignsw(c_ignsw)?;
        res.set_c_country_cfg(c_country_cfg)?;
        res.set_c_tail_lamp_activity(c_tail_lamp_activity)?;
        res.set_rear_sw_rse_lock_on_off(rear_sw_rse_lock_on_off)?;
        res.set_c_smk_tele_cranking_state(c_smk_tele_cranking_state)?;
        res.set_c_smk_tele_cranking_fail_res(c_smk_tele_cranking_fail_res)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// C_AV_Tail
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_av_tail(&self) -> u8 {
        self.c_av_tail_raw()
    }
    
    /// Get raw value of C_AV_Tail
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_av_tail_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_AV_Tail
    #[inline(always)]
    pub fn set_c_av_tail(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1314 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// C_ParkingBrakeSW
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_parking_brake_sw(&self) -> u8 {
        self.c_parking_brake_sw_raw()
    }
    
    /// Get raw value of C_ParkingBrakeSW
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_parking_brake_sw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_ParkingBrakeSW
    #[inline(always)]
    pub fn set_c_parking_brake_sw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1314 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// C_RKECMD
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_rkecmd(&self) -> u8 {
        self.c_rkecmd_raw()
    }
    
    /// Get raw value of C_RKECMD
    ///
    /// - Start bit: 4
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_rkecmd_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_RKECMD
    #[inline(always)]
    pub fn set_c_rkecmd(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1314 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..8].store_le(value);
        Ok(())
    }
    
    /// C_BAState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_ba_state(&self) -> u8 {
        self.c_ba_state_raw()
    }
    
    /// Get raw value of C_BAState
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_ba_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_BAState
    #[inline(always)]
    pub fn set_c_ba_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1314 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// C_IGNSW
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_ignsw(&self) -> u8 {
        self.c_ignsw_raw()
    }
    
    /// Get raw value of C_IGNSW
    ///
    /// - Start bit: 12
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_ignsw_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_IGNSW
    #[inline(always)]
    pub fn set_c_ignsw(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1314 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..15].store_le(value);
        Ok(())
    }
    
    /// C_CountryCfg
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_country_cfg(&self) -> u8 {
        self.c_country_cfg_raw()
    }
    
    /// Get raw value of C_CountryCfg
    ///
    /// - Start bit: 16
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_country_cfg_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..19].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_CountryCfg
    #[inline(always)]
    pub fn set_c_country_cfg(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1314 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..19].store_le(value);
        Ok(())
    }
    
    /// C_TailLampActivity
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_tail_lamp_activity(&self) -> u8 {
        self.c_tail_lamp_activity_raw()
    }
    
    /// Get raw value of C_TailLampActivity
    ///
    /// - Start bit: 26
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_tail_lamp_activity_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[26..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_TailLampActivity
    #[inline(always)]
    pub fn set_c_tail_lamp_activity(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1314 });
        }
        self.raw.view_bits_mut::<Lsb0>()[26..28].store_le(value);
        Ok(())
    }
    
    /// RearSW_RSELockOnOff
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn rear_sw_rse_lock_on_off(&self) -> u8 {
        self.rear_sw_rse_lock_on_off_raw()
    }
    
    /// Get raw value of RearSW_RSELockOnOff
    ///
    /// - Start bit: 28
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rear_sw_rse_lock_on_off_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[28..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of RearSW_RSELockOnOff
    #[inline(always)]
    pub fn set_rear_sw_rse_lock_on_off(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1314 });
        }
        self.raw.view_bits_mut::<Lsb0>()[28..30].store_le(value);
        Ok(())
    }
    
    /// C_SMKTeleCrankingState
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_smk_tele_cranking_state(&self) -> u8 {
        self.c_smk_tele_cranking_state_raw()
    }
    
    /// Get raw value of C_SMKTeleCrankingState
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_smk_tele_cranking_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_SMKTeleCrankingState
    #[inline(always)]
    pub fn set_c_smk_tele_cranking_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1314 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..34].store_le(value);
        Ok(())
    }
    
    /// C_SMKTeleCrankingFailRes
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_smk_tele_cranking_fail_res(&self) -> u8 {
        self.c_smk_tele_cranking_fail_res_raw()
    }
    
    /// Get raw value of C_SMKTeleCrankingFailRes
    ///
    /// - Start bit: 34
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_smk_tele_cranking_fail_res_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[34..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_SMKTeleCrankingFailRes
    #[inline(always)]
    pub fn set_c_smk_tele_cranking_fail_res(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1314 });
        }
        self.raw.view_bits_mut::<Lsb0>()[34..36].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for GwIpmPe1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for GwIpmPe1 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("GwIpmPe1")
                .field("c_av_tail", &self.c_av_tail())
                .field("c_parking_brake_sw", &self.c_parking_brake_sw())
                .field("c_rkecmd", &self.c_rkecmd())
                .field("c_ba_state", &self.c_ba_state())
                .field("c_ignsw", &self.c_ignsw())
                .field("c_country_cfg", &self.c_country_cfg())
                .field("c_tail_lamp_activity", &self.c_tail_lamp_activity())
                .field("rear_sw_rse_lock_on_off", &self.rear_sw_rse_lock_on_off())
                .field("c_smk_tele_cranking_state", &self.c_smk_tele_cranking_state())
                .field("c_smk_tele_cranking_fail_res", &self.c_smk_tele_cranking_fail_res())
            .finish()
        } else {
            f.debug_tuple("GwIpmPe1").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for GwIpmPe1 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let c_av_tail = u.int_in_range(0..=3)?;
        let c_parking_brake_sw = u.int_in_range(0..=3)?;
        let c_rkecmd = u.int_in_range(0..=15)?;
        let c_ba_state = u.int_in_range(0..=3)?;
        let c_ignsw = u.int_in_range(0..=7)?;
        let c_country_cfg = u.int_in_range(0..=7)?;
        let c_tail_lamp_activity = u.int_in_range(0..=3)?;
        let rear_sw_rse_lock_on_off = u.int_in_range(0..=3)?;
        let c_smk_tele_cranking_state = u.int_in_range(0..=3)?;
        let c_smk_tele_cranking_fail_res = u.int_in_range(0..=3)?;
        GwIpmPe1::new(c_av_tail,c_parking_brake_sw,c_rkecmd,c_ba_state,c_ignsw,c_country_cfg,c_tail_lamp_activity,rear_sw_rse_lock_on_off,c_smk_tele_cranking_state,c_smk_tele_cranking_fail_res).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// SCC12
///
/// - ID: 1057 (0x421)
/// - Size: 8 bytes
/// - Transmitter: SCC
#[derive(Clone, Copy)]
pub struct Scc12 {
    raw: [u8; 8],
}

impl Scc12 {
    pub const MESSAGE_ID: u32 = 1057;
    
    pub const CF_VSM_HBA_CMD_MIN: u8 = 0_u8;
    pub const CF_VSM_HBA_CMD_MAX: u8 = 3_u8;
    pub const CF_VSM_WARN_MIN: u8 = 0_u8;
    pub const CF_VSM_WARN_MAX: u8 = 3_u8;
    pub const CF_VSM_STAT_MIN: u8 = 0_u8;
    pub const CF_VSM_STAT_MAX: u8 = 3_u8;
    pub const CF_VSM_BELT_CMD_MIN: u8 = 0_u8;
    pub const CF_VSM_BELT_CMD_MAX: u8 = 7_u8;
    pub const ACC_FAIL_INFO_MIN: u8 = 0_u8;
    pub const ACC_FAIL_INFO_MAX: u8 = 3_u8;
    pub const ACC_MODE_MIN: u8 = 0_u8;
    pub const ACC_MODE_MAX: u8 = 3_u8;
    pub const CR_VSM_DEC_CMD_MIN: f32 = 0_f32;
    pub const CR_VSM_DEC_CMD_MAX: f32 = 2.55_f32;
    pub const CF_VSM_CONF_MODE_MIN: u8 = 0_u8;
    pub const CF_VSM_CONF_MODE_MAX: u8 = 3_u8;
    pub const AEB_FAILINFO_MIN: u8 = 0_u8;
    pub const AEB_FAILINFO_MAX: u8 = 3_u8;
    pub const AEB_STATUS_MIN: u8 = 0_u8;
    pub const AEB_STATUS_MAX: u8 = 3_u8;
    pub const CR_VSM_ALIVE_MIN: u8 = 0_u8;
    pub const CR_VSM_ALIVE_MAX: u8 = 15_u8;
    pub const CR_VSM_CHK_SUM_MIN: u8 = 0_u8;
    pub const CR_VSM_CHK_SUM_MAX: u8 = 15_u8;
    pub const A_REQ_VALUE_MIN: f32 = -10.23_f32;
    pub const A_REQ_VALUE_MAX: f32 = 10.24_f32;
    pub const A_REQ_RAW_MIN: f32 = -10.23_f32;
    pub const A_REQ_RAW_MAX: f32 = 10.24_f32;
    
    /// Construct new SCC12 from values
    pub fn new(cf_vsm_prefill: bool, cf_vsm_dec_cmd_act: bool, cf_vsm_hba_cmd: u8, cf_vsm_warn: u8, cf_vsm_stat: u8, cf_vsm_belt_cmd: u8, acc_fail_info: u8, acc_mode: u8, stop_req: bool, cr_vsm_dec_cmd: f32, take_over_req: bool, pre_fill: bool, cf_vsm_conf_mode: u8, aeb_failinfo: u8, aeb_status: u8, aeb_cmd_act: bool, aeb_stop_req: bool, cr_vsm_alive: u8, cr_vsm_chk_sum: u8, a_req_value: f32, a_req_raw: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_vsm_prefill(cf_vsm_prefill)?;
        res.set_cf_vsm_dec_cmd_act(cf_vsm_dec_cmd_act)?;
        res.set_cf_vsm_hba_cmd(cf_vsm_hba_cmd)?;
        res.set_cf_vsm_warn(cf_vsm_warn)?;
        res.set_cf_vsm_stat(cf_vsm_stat)?;
        res.set_cf_vsm_belt_cmd(cf_vsm_belt_cmd)?;
        res.set_acc_fail_info(acc_fail_info)?;
        res.set_acc_mode(acc_mode)?;
        res.set_stop_req(stop_req)?;
        res.set_cr_vsm_dec_cmd(cr_vsm_dec_cmd)?;
        res.set_take_over_req(take_over_req)?;
        res.set_pre_fill(pre_fill)?;
        res.set_cf_vsm_conf_mode(cf_vsm_conf_mode)?;
        res.set_aeb_failinfo(aeb_failinfo)?;
        res.set_aeb_status(aeb_status)?;
        res.set_aeb_cmd_act(aeb_cmd_act)?;
        res.set_aeb_stop_req(aeb_stop_req)?;
        res.set_cr_vsm_alive(cr_vsm_alive)?;
        res.set_cr_vsm_chk_sum(cr_vsm_chk_sum)?;
        res.set_a_req_value(a_req_value)?;
        res.set_a_req_raw(a_req_raw)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_VSM_Prefill
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cf_vsm_prefill(&self) -> bool {
        self.cf_vsm_prefill_raw()
    }
    
    /// Get raw value of CF_VSM_Prefill
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_prefill_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_VSM_Prefill
    #[inline(always)]
    pub fn set_cf_vsm_prefill(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// CF_VSM_DecCmdAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cf_vsm_dec_cmd_act(&self) -> bool {
        self.cf_vsm_dec_cmd_act_raw()
    }
    
    /// Get raw value of CF_VSM_DecCmdAct
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_dec_cmd_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_VSM_DecCmdAct
    #[inline(always)]
    pub fn set_cf_vsm_dec_cmd_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// CF_VSM_HBACmd
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cf_vsm_hba_cmd(&self) -> u8 {
        self.cf_vsm_hba_cmd_raw()
    }
    
    /// Get raw value of CF_VSM_HBACmd
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_hba_cmd_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_VSM_HBACmd
    #[inline(always)]
    pub fn set_cf_vsm_hba_cmd(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1057 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// CF_VSM_Warn
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, ESC, IAP
    #[inline(always)]
    pub fn cf_vsm_warn(&self) -> u8 {
        self.cf_vsm_warn_raw()
    }
    
    /// Get raw value of CF_VSM_Warn
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_warn_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_VSM_Warn
    #[inline(always)]
    pub fn set_cf_vsm_warn(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1057 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
    /// CF_VSM_Stat
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, ESC, PSB
    #[inline(always)]
    pub fn cf_vsm_stat(&self) -> u8 {
        self.cf_vsm_stat_raw()
    }
    
    /// Get raw value of CF_VSM_Stat
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_VSM_Stat
    #[inline(always)]
    pub fn set_cf_vsm_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1057 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// CF_VSM_BeltCmd
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: ESC, PSB
    #[inline(always)]
    pub fn cf_vsm_belt_cmd(&self) -> u8 {
        self.cf_vsm_belt_cmd_raw()
    }
    
    /// Get raw value of CF_VSM_BeltCmd
    ///
    /// - Start bit: 8
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_belt_cmd_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_VSM_BeltCmd
    #[inline(always)]
    pub fn set_cf_vsm_belt_cmd(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1057 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..11].store_le(value);
        Ok(())
    }
    
    /// ACCFailInfo
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, CUBIS, ESC, IBOX
    #[inline(always)]
    pub fn acc_fail_info(&self) -> u8 {
        self.acc_fail_info_raw()
    }
    
    /// Get raw value of ACCFailInfo
    ///
    /// - Start bit: 11
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn acc_fail_info_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[11..13].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ACCFailInfo
    #[inline(always)]
    pub fn set_acc_fail_info(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1057 });
        }
        self.raw.view_bits_mut::<Lsb0>()[11..13].store_le(value);
        Ok(())
    }
    
    /// ACCMode
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, ESC, IBOX, TCU
    #[inline(always)]
    pub fn acc_mode(&self) -> Scc12AccMode {
        let signal = self.raw.view_bits::<Lsb0>()[13..15].load_le::<u8>();
        
        match signal {
            0 => Scc12AccMode::Off,
            1 => Scc12AccMode::Enabled,
            2 => Scc12AccMode::DriverOverride,
            3 => Scc12AccMode::OffMaybeFault,
            _ => Scc12AccMode::_Other(self.acc_mode_raw()),
        }
    }
    
    /// Get raw value of ACCMode
    ///
    /// - Start bit: 13
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn acc_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[13..15].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ACCMode
    #[inline(always)]
    pub fn set_acc_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1057 });
        }
        self.raw.view_bits_mut::<Lsb0>()[13..15].store_le(value);
        Ok(())
    }
    
    /// StopReq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EPB, ESC
    #[inline(always)]
    pub fn stop_req(&self) -> bool {
        self.stop_req_raw()
    }
    
    /// Get raw value of StopReq
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn stop_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of StopReq
    #[inline(always)]
    pub fn set_stop_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[15..16].store_le(value);
        Ok(())
    }
    
    /// CR_VSM_DecCmd
    ///
    /// - Min: 0
    /// - Max: 2.55
    /// - Unit: "g"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cr_vsm_dec_cmd(&self) -> f32 {
        self.cr_vsm_dec_cmd_raw()
    }
    
    /// Get raw value of CR_VSM_DecCmd
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_vsm_dec_cmd_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_VSM_DecCmd
    #[inline(always)]
    pub fn set_cr_vsm_dec_cmd(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2.55_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1057 });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// TakeOverReq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, ESC, TCU
    #[inline(always)]
    pub fn take_over_req(&self) -> bool {
        self.take_over_req_raw()
    }
    
    /// Get raw value of TakeOverReq
    ///
    /// - Start bit: 35
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn take_over_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[35..36].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of TakeOverReq
    #[inline(always)]
    pub fn set_take_over_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[35..36].store_le(value);
        Ok(())
    }
    
    /// PreFill
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC, TCU
    #[inline(always)]
    pub fn pre_fill(&self) -> bool {
        self.pre_fill_raw()
    }
    
    /// Get raw value of PreFill
    ///
    /// - Start bit: 36
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pre_fill_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[36..37].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of PreFill
    #[inline(always)]
    pub fn set_pre_fill(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[36..37].store_le(value);
        Ok(())
    }
    
    /// CF_VSM_ConfMode
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, ESC
    #[inline(always)]
    pub fn cf_vsm_conf_mode(&self) -> u8 {
        self.cf_vsm_conf_mode_raw()
    }
    
    /// Get raw value of CF_VSM_ConfMode
    ///
    /// - Start bit: 48
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_conf_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..50].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_VSM_ConfMode
    #[inline(always)]
    pub fn set_cf_vsm_conf_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1057 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..50].store_le(value);
        Ok(())
    }
    
    /// AEB_Failinfo
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, ESC
    #[inline(always)]
    pub fn aeb_failinfo(&self) -> u8 {
        self.aeb_failinfo_raw()
    }
    
    /// Get raw value of AEB_Failinfo
    ///
    /// - Start bit: 50
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aeb_failinfo_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[50..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AEB_Failinfo
    #[inline(always)]
    pub fn set_aeb_failinfo(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1057 });
        }
        self.raw.view_bits_mut::<Lsb0>()[50..52].store_le(value);
        Ok(())
    }
    
    /// AEB_Status
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, ESC
    #[inline(always)]
    pub fn aeb_status(&self) -> u8 {
        self.aeb_status_raw()
    }
    
    /// Get raw value of AEB_Status
    ///
    /// - Start bit: 52
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aeb_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[52..54].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AEB_Status
    #[inline(always)]
    pub fn set_aeb_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1057 });
        }
        self.raw.view_bits_mut::<Lsb0>()[52..54].store_le(value);
        Ok(())
    }
    
    /// AEB_CmdAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn aeb_cmd_act(&self) -> bool {
        self.aeb_cmd_act_raw()
    }
    
    /// Get raw value of AEB_CmdAct
    ///
    /// - Start bit: 54
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aeb_cmd_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[54..55].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of AEB_CmdAct
    #[inline(always)]
    pub fn set_aeb_cmd_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[54..55].store_le(value);
        Ok(())
    }
    
    /// AEB_StopReq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, ESC
    #[inline(always)]
    pub fn aeb_stop_req(&self) -> bool {
        self.aeb_stop_req_raw()
    }
    
    /// Get raw value of AEB_StopReq
    ///
    /// - Start bit: 55
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aeb_stop_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[55..56].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of AEB_StopReq
    #[inline(always)]
    pub fn set_aeb_stop_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[55..56].store_le(value);
        Ok(())
    }
    
    /// CR_VSM_Alive
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: ESC, PSB
    #[inline(always)]
    pub fn cr_vsm_alive(&self) -> u8 {
        self.cr_vsm_alive_raw()
    }
    
    /// Get raw value of CR_VSM_Alive
    ///
    /// - Start bit: 56
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_vsm_alive_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_VSM_Alive
    #[inline(always)]
    pub fn set_cr_vsm_alive(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1057 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..60].store_le(value);
        Ok(())
    }
    
    /// CR_VSM_ChkSum
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: ESC, PSB
    #[inline(always)]
    pub fn cr_vsm_chk_sum(&self) -> u8 {
        self.cr_vsm_chk_sum_raw()
    }
    
    /// Get raw value of CR_VSM_ChkSum
    ///
    /// - Start bit: 60
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_vsm_chk_sum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_VSM_ChkSum
    #[inline(always)]
    pub fn set_cr_vsm_chk_sum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1057 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..64].store_le(value);
        Ok(())
    }
    
    /// aReqValue
    ///
    /// - Min: -10.23
    /// - Max: 10.24
    /// - Unit: "m/s^2"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn a_req_value(&self) -> f32 {
        self.a_req_value_raw()
    }
    
    /// Get raw value of aReqValue
    ///
    /// - Start bit: 37
    /// - Signal size: 11 bits
    /// - Factor: 0.01
    /// - Offset: -10.23
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn a_req_value_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[37..48].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = -10.23_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of aReqValue
    #[inline(always)]
    pub fn set_a_req_value(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -10.23_f32 || 10.24_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1057 });
        }
        let factor = 0.01_f32;
        let offset = -10.23_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[37..48].store_le(value);
        Ok(())
    }
    
    /// aReqRaw
    ///
    /// - Min: -10.23
    /// - Max: 10.24
    /// - Unit: "m/s^2"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn a_req_raw(&self) -> f32 {
        self.a_req_raw_raw()
    }
    
    /// Get raw value of aReqRaw
    ///
    /// - Start bit: 24
    /// - Signal size: 11 bits
    /// - Factor: 0.01
    /// - Offset: -10.23
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn a_req_raw_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..35].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = -10.23_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of aReqRaw
    #[inline(always)]
    pub fn set_a_req_raw(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -10.23_f32 || 10.24_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1057 });
        }
        let factor = 0.01_f32;
        let offset = -10.23_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[24..35].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Scc12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Scc12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Scc12")
                .field("cf_vsm_prefill", &self.cf_vsm_prefill())
                .field("cf_vsm_dec_cmd_act", &self.cf_vsm_dec_cmd_act())
                .field("cf_vsm_hba_cmd", &self.cf_vsm_hba_cmd())
                .field("cf_vsm_warn", &self.cf_vsm_warn())
                .field("cf_vsm_stat", &self.cf_vsm_stat())
                .field("cf_vsm_belt_cmd", &self.cf_vsm_belt_cmd())
                .field("acc_fail_info", &self.acc_fail_info())
                .field("acc_mode", &self.acc_mode())
                .field("stop_req", &self.stop_req())
                .field("cr_vsm_dec_cmd", &self.cr_vsm_dec_cmd())
                .field("take_over_req", &self.take_over_req())
                .field("pre_fill", &self.pre_fill())
                .field("cf_vsm_conf_mode", &self.cf_vsm_conf_mode())
                .field("aeb_failinfo", &self.aeb_failinfo())
                .field("aeb_status", &self.aeb_status())
                .field("aeb_cmd_act", &self.aeb_cmd_act())
                .field("aeb_stop_req", &self.aeb_stop_req())
                .field("cr_vsm_alive", &self.cr_vsm_alive())
                .field("cr_vsm_chk_sum", &self.cr_vsm_chk_sum())
                .field("a_req_value", &self.a_req_value())
                .field("a_req_raw", &self.a_req_raw())
            .finish()
        } else {
            f.debug_tuple("Scc12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Scc12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_vsm_prefill = u.int_in_range(0..=1)? == 1;
        let cf_vsm_dec_cmd_act = u.int_in_range(0..=1)? == 1;
        let cf_vsm_hba_cmd = u.int_in_range(0..=3)?;
        let cf_vsm_warn = u.int_in_range(0..=3)?;
        let cf_vsm_stat = u.int_in_range(0..=3)?;
        let cf_vsm_belt_cmd = u.int_in_range(0..=7)?;
        let acc_fail_info = u.int_in_range(0..=3)?;
        let acc_mode = u.int_in_range(0..=3)?;
        let stop_req = u.int_in_range(0..=1)? == 1;
        let cr_vsm_dec_cmd = u.float_in_range(0_f32..=2.55_f32)?;
        let take_over_req = u.int_in_range(0..=1)? == 1;
        let pre_fill = u.int_in_range(0..=1)? == 1;
        let cf_vsm_conf_mode = u.int_in_range(0..=3)?;
        let aeb_failinfo = u.int_in_range(0..=3)?;
        let aeb_status = u.int_in_range(0..=3)?;
        let aeb_cmd_act = u.int_in_range(0..=1)? == 1;
        let aeb_stop_req = u.int_in_range(0..=1)? == 1;
        let cr_vsm_alive = u.int_in_range(0..=15)?;
        let cr_vsm_chk_sum = u.int_in_range(0..=15)?;
        let a_req_value = u.float_in_range(-10.23_f32..=10.24_f32)?;
        let a_req_raw = u.float_in_range(-10.23_f32..=10.24_f32)?;
        Scc12::new(cf_vsm_prefill,cf_vsm_dec_cmd_act,cf_vsm_hba_cmd,cf_vsm_warn,cf_vsm_stat,cf_vsm_belt_cmd,acc_fail_info,acc_mode,stop_req,cr_vsm_dec_cmd,take_over_req,pre_fill,cf_vsm_conf_mode,aeb_failinfo,aeb_status,aeb_cmd_act,aeb_stop_req,cr_vsm_alive,cr_vsm_chk_sum,a_req_value,a_req_raw).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for ACCMode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Scc12AccMode {
    Off,
    Enabled,
    DriverOverride,
    OffMaybeFault,
    _Other(u8),
}

impl From<Scc12AccMode> for u8 {
    fn from(val: Scc12AccMode) -> u8 {
        match val {
            Scc12AccMode::Off => 0,
            Scc12AccMode::Enabled => 1,
            Scc12AccMode::DriverOverride => 2,
            Scc12AccMode::OffMaybeFault => 3,
            Scc12AccMode::_Other(x) => x,
        }
    }
}


/// GW_DDM_PE
///
/// - ID: 1313 (0x521)
/// - Size: 8 bytes
/// - Transmitter: BCM
#[derive(Clone, Copy)]
pub struct GwDdmPe {
    raw: [u8; 8],
}

impl GwDdmPe {
    pub const MESSAGE_ID: u32 = 1313;
    
    pub const C_DRV_DOOR_STATUS_MIN: u8 = 0_u8;
    pub const C_DRV_DOOR_STATUS_MAX: u8 = 3_u8;
    pub const C_AST_DOOR_STATUS_MIN: u8 = 0_u8;
    pub const C_AST_DOOR_STATUS_MAX: u8 = 3_u8;
    pub const C_RL_DOOR_STATUS_MIN: u8 = 0_u8;
    pub const C_RL_DOOR_STATUS_MAX: u8 = 3_u8;
    pub const C_RR_DOOR_STATUS_MIN: u8 = 0_u8;
    pub const C_RR_DOOR_STATUS_MAX: u8 = 3_u8;
    pub const C_TRUNK_STATUS_MIN: u8 = 0_u8;
    pub const C_TRUNK_STATUS_MAX: u8 = 3_u8;
    pub const C_OS_MIRROR_STATUS_MIN: u8 = 0_u8;
    pub const C_OS_MIRROR_STATUS_MAX: u8 = 3_u8;
    
    /// Construct new GW_DDM_PE from values
    pub fn new(c_drv_door_status: u8, c_ast_door_status: u8, c_rl_door_status: u8, c_rr_door_status: u8, c_trunk_status: u8, c_os_mirror_status: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_c_drv_door_status(c_drv_door_status)?;
        res.set_c_ast_door_status(c_ast_door_status)?;
        res.set_c_rl_door_status(c_rl_door_status)?;
        res.set_c_rr_door_status(c_rr_door_status)?;
        res.set_c_trunk_status(c_trunk_status)?;
        res.set_c_os_mirror_status(c_os_mirror_status)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// C_DRVDoorStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_drv_door_status(&self) -> u8 {
        self.c_drv_door_status_raw()
    }
    
    /// Get raw value of C_DRVDoorStatus
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_drv_door_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_DRVDoorStatus
    #[inline(always)]
    pub fn set_c_drv_door_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1313 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// C_ASTDoorStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_ast_door_status(&self) -> u8 {
        self.c_ast_door_status_raw()
    }
    
    /// Get raw value of C_ASTDoorStatus
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_ast_door_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_ASTDoorStatus
    #[inline(always)]
    pub fn set_c_ast_door_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1313 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// C_RLDoorStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_rl_door_status(&self) -> u8 {
        self.c_rl_door_status_raw()
    }
    
    /// Get raw value of C_RLDoorStatus
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_rl_door_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_RLDoorStatus
    #[inline(always)]
    pub fn set_c_rl_door_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1313 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
    /// C_RRDoorStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_rr_door_status(&self) -> u8 {
        self.c_rr_door_status_raw()
    }
    
    /// Get raw value of C_RRDoorStatus
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_rr_door_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_RRDoorStatus
    #[inline(always)]
    pub fn set_c_rr_door_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1313 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// C_TrunkStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_trunk_status(&self) -> u8 {
        self.c_trunk_status_raw()
    }
    
    /// Get raw value of C_TrunkStatus
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_trunk_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_TrunkStatus
    #[inline(always)]
    pub fn set_c_trunk_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1313 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// C_OSMirrorStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn c_os_mirror_status(&self) -> u8 {
        self.c_os_mirror_status_raw()
    }
    
    /// Get raw value of C_OSMirrorStatus
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_os_mirror_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of C_OSMirrorStatus
    #[inline(always)]
    pub fn set_c_os_mirror_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1313 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..12].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for GwDdmPe {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for GwDdmPe {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("GwDdmPe")
                .field("c_drv_door_status", &self.c_drv_door_status())
                .field("c_ast_door_status", &self.c_ast_door_status())
                .field("c_rl_door_status", &self.c_rl_door_status())
                .field("c_rr_door_status", &self.c_rr_door_status())
                .field("c_trunk_status", &self.c_trunk_status())
                .field("c_os_mirror_status", &self.c_os_mirror_status())
            .finish()
        } else {
            f.debug_tuple("GwDdmPe").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for GwDdmPe {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let c_drv_door_status = u.int_in_range(0..=3)?;
        let c_ast_door_status = u.int_in_range(0..=3)?;
        let c_rl_door_status = u.int_in_range(0..=3)?;
        let c_rr_door_status = u.int_in_range(0..=3)?;
        let c_trunk_status = u.int_in_range(0..=3)?;
        let c_os_mirror_status = u.int_in_range(0..=3)?;
        GwDdmPe::new(c_drv_door_status,c_ast_door_status,c_rl_door_status,c_rr_door_status,c_trunk_status,c_os_mirror_status).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// SCC11
///
/// - ID: 1056 (0x420)
/// - Size: 8 bytes
/// - Transmitter: SCC
#[derive(Clone, Copy)]
pub struct Scc11 {
    raw: [u8; 8],
}

impl Scc11 {
    pub const MESSAGE_ID: u32 = 1056;
    
    pub const SCC_INFO_DISPLAY_MIN: u8 = 0_u8;
    pub const SCC_INFO_DISPLAY_MAX: u8 = 7_u8;
    pub const ALIVE_COUNTER_ACC_MIN: u8 = 0_u8;
    pub const ALIVE_COUNTER_ACC_MAX: u8 = 15_u8;
    pub const V_SET_DIS_MIN: u8 = 0_u8;
    pub const V_SET_DIS_MAX: u8 = 255_u8;
    pub const DRIVER_ALERT_DISPLAY_MIN: u8 = 0_u8;
    pub const DRIVER_ALERT_DISPLAY_MAX: u8 = 3_u8;
    pub const TAU_GAP_SET_MIN: u8 = 0_u8;
    pub const TAU_GAP_SET_MAX: u8 = 7_u8;
    pub const NAVI_SCC_CURVE_STATUS_MIN: u8 = 0_u8;
    pub const NAVI_SCC_CURVE_STATUS_MAX: u8 = 3_u8;
    pub const NAVI_SCC_CURVE_ACT_MIN: u8 = 0_u8;
    pub const NAVI_SCC_CURVE_ACT_MAX: u8 = 3_u8;
    pub const NAVI_SCC_CAMERA_ACT_MIN: u8 = 0_u8;
    pub const NAVI_SCC_CAMERA_ACT_MAX: u8 = 3_u8;
    pub const NAVI_SCC_CAMERA_STATUS_MIN: u8 = 0_u8;
    pub const NAVI_SCC_CAMERA_STATUS_MAX: u8 = 3_u8;
    pub const ACC_OBJ_STATUS_MIN: u8 = 0_u8;
    pub const ACC_OBJ_STATUS_MAX: u8 = 3_u8;
    pub const ACC_OBJ_LAT_POS_MIN: f32 = -20_f32;
    pub const ACC_OBJ_LAT_POS_MAX: f32 = 31.1_f32;
    pub const ACC_OBJ_REL_SPD_MIN: f32 = -170_f32;
    pub const ACC_OBJ_REL_SPD_MAX: f32 = 239.5_f32;
    pub const ACC_OBJ_DIST_MIN: f32 = 0_f32;
    pub const ACC_OBJ_DIST_MAX: f32 = 204.7_f32;
    
    /// Construct new SCC11 from values
    pub fn new(main_mode_acc: bool, scc_info_display: u8, alive_counter_acc: u8, v_set_dis: u8, obj_valid: bool, driver_alert_display: u8, tau_gap_set: u8, navi_scc_curve_status: u8, navi_scc_curve_act: u8, navi_scc_camera_act: u8, navi_scc_camera_status: u8, acc_obj_status: u8, acc_obj_lat_pos: f32, acc_obj_rel_spd: f32, acc_obj_dist: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_main_mode_acc(main_mode_acc)?;
        res.set_scc_info_display(scc_info_display)?;
        res.set_alive_counter_acc(alive_counter_acc)?;
        res.set_v_set_dis(v_set_dis)?;
        res.set_obj_valid(obj_valid)?;
        res.set_driver_alert_display(driver_alert_display)?;
        res.set_tau_gap_set(tau_gap_set)?;
        res.set_navi_scc_curve_status(navi_scc_curve_status)?;
        res.set_navi_scc_curve_act(navi_scc_curve_act)?;
        res.set_navi_scc_camera_act(navi_scc_camera_act)?;
        res.set_navi_scc_camera_status(navi_scc_camera_status)?;
        res.set_acc_obj_status(acc_obj_status)?;
        res.set_acc_obj_lat_pos(acc_obj_lat_pos)?;
        res.set_acc_obj_rel_spd(acc_obj_rel_spd)?;
        res.set_acc_obj_dist(acc_obj_dist)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// MainMode_ACC
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, EMS, ESC
    #[inline(always)]
    pub fn main_mode_acc(&self) -> bool {
        self.main_mode_acc_raw()
    }
    
    /// Get raw value of MainMode_ACC
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn main_mode_acc_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of MainMode_ACC
    #[inline(always)]
    pub fn set_main_mode_acc(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// SCCInfoDisplay
    ///
    /// Goes to 1 for a second while transitioning from Cruise Control to No Message
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, ESC
    #[inline(always)]
    pub fn scc_info_display(&self) -> Scc11SccInfoDisplay {
        let signal = self.raw.view_bits::<Lsb0>()[1..4].load_le::<u8>();
        
        match signal {
            0 => Scc11SccInfoDisplay::NoMessage,
            2 => Scc11SccInfoDisplay::CruiseControl,
            3 => Scc11SccInfoDisplay::LostLead,
            4 => Scc11SccInfoDisplay::Standstill,
            _ => Scc11SccInfoDisplay::_Other(self.scc_info_display_raw()),
        }
    }
    
    /// Get raw value of SCCInfoDisplay
    ///
    /// - Start bit: 1
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn scc_info_display_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[1..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of SCCInfoDisplay
    #[inline(always)]
    pub fn set_scc_info_display(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1056 });
        }
        self.raw.view_bits_mut::<Lsb0>()[1..4].store_le(value);
        Ok(())
    }
    
    /// AliveCounterACC
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU, EMS, ESC, TCU
    #[inline(always)]
    pub fn alive_counter_acc(&self) -> u8 {
        self.alive_counter_acc_raw()
    }
    
    /// Get raw value of AliveCounterACC
    ///
    /// - Start bit: 4
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn alive_counter_acc_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AliveCounterACC
    #[inline(always)]
    pub fn set_alive_counter_acc(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1056 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..8].store_le(value);
        Ok(())
    }
    
    /// VSetDis
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: "km/h or MPH"
    /// - Receivers: CLU, ESC, TCU
    #[inline(always)]
    pub fn v_set_dis(&self) -> u8 {
        self.v_set_dis_raw()
    }
    
    /// Get raw value of VSetDis
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn v_set_dis_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VSetDis
    #[inline(always)]
    pub fn set_v_set_dis(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1056 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// ObjValid
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, ESC, TCU
    #[inline(always)]
    pub fn obj_valid(&self) -> bool {
        self.obj_valid_raw()
    }
    
    /// Get raw value of ObjValid
    ///
    /// - Start bit: 16
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn obj_valid_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[16..17].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ObjValid
    #[inline(always)]
    pub fn set_obj_valid(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[16..17].store_le(value);
        Ok(())
    }
    
    /// DriverAlertDisplay
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, ESC
    #[inline(always)]
    pub fn driver_alert_display(&self) -> u8 {
        self.driver_alert_display_raw()
    }
    
    /// Get raw value of DriverAlertDisplay
    ///
    /// - Start bit: 17
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn driver_alert_display_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[17..19].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DriverAlertDisplay
    #[inline(always)]
    pub fn set_driver_alert_display(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1056 });
        }
        self.raw.view_bits_mut::<Lsb0>()[17..19].store_le(value);
        Ok(())
    }
    
    /// TauGapSet
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, ESC, TCU
    #[inline(always)]
    pub fn tau_gap_set(&self) -> u8 {
        self.tau_gap_set_raw()
    }
    
    /// Get raw value of TauGapSet
    ///
    /// - Start bit: 19
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tau_gap_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[19..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of TauGapSet
    #[inline(always)]
    pub fn set_tau_gap_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1056 });
        }
        self.raw.view_bits_mut::<Lsb0>()[19..22].store_le(value);
        Ok(())
    }
    
    /// Navi_SCC_Curve_Status
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn navi_scc_curve_status(&self) -> u8 {
        self.navi_scc_curve_status_raw()
    }
    
    /// Get raw value of Navi_SCC_Curve_Status
    ///
    /// - Start bit: 56
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn navi_scc_curve_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..58].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Navi_SCC_Curve_Status
    #[inline(always)]
    pub fn set_navi_scc_curve_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1056 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..58].store_le(value);
        Ok(())
    }
    
    /// Navi_SCC_Curve_Act
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn navi_scc_curve_act(&self) -> u8 {
        self.navi_scc_curve_act_raw()
    }
    
    /// Get raw value of Navi_SCC_Curve_Act
    ///
    /// - Start bit: 58
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn navi_scc_curve_act_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[58..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Navi_SCC_Curve_Act
    #[inline(always)]
    pub fn set_navi_scc_curve_act(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1056 });
        }
        self.raw.view_bits_mut::<Lsb0>()[58..60].store_le(value);
        Ok(())
    }
    
    /// Navi_SCC_Camera_Act
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn navi_scc_camera_act(&self) -> u8 {
        self.navi_scc_camera_act_raw()
    }
    
    /// Get raw value of Navi_SCC_Camera_Act
    ///
    /// - Start bit: 60
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn navi_scc_camera_act_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..62].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Navi_SCC_Camera_Act
    #[inline(always)]
    pub fn set_navi_scc_camera_act(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1056 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..62].store_le(value);
        Ok(())
    }
    
    /// Navi_SCC_Camera_Status
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn navi_scc_camera_status(&self) -> u8 {
        self.navi_scc_camera_status_raw()
    }
    
    /// Get raw value of Navi_SCC_Camera_Status
    ///
    /// - Start bit: 62
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn navi_scc_camera_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[62..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Navi_SCC_Camera_Status
    #[inline(always)]
    pub fn set_navi_scc_camera_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1056 });
        }
        self.raw.view_bits_mut::<Lsb0>()[62..64].store_le(value);
        Ok(())
    }
    
    /// ACC_ObjStatus
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: ABS, ESC
    #[inline(always)]
    pub fn acc_obj_status(&self) -> u8 {
        self.acc_obj_status_raw()
    }
    
    /// Get raw value of ACC_ObjStatus
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn acc_obj_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ACC_ObjStatus
    #[inline(always)]
    pub fn set_acc_obj_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1056 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
    /// ACC_ObjLatPos
    ///
    /// - Min: -20
    /// - Max: 31.1
    /// - Unit: "m"
    /// - Receivers: ABS, ESC
    #[inline(always)]
    pub fn acc_obj_lat_pos(&self) -> f32 {
        self.acc_obj_lat_pos_raw()
    }
    
    /// Get raw value of ACC_ObjLatPos
    ///
    /// - Start bit: 24
    /// - Signal size: 9 bits
    /// - Factor: 0.1
    /// - Offset: -20
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn acc_obj_lat_pos_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..33].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = -20_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of ACC_ObjLatPos
    #[inline(always)]
    pub fn set_acc_obj_lat_pos(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -20_f32 || 31.1_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1056 });
        }
        let factor = 0.1_f32;
        let offset = -20_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[24..33].store_le(value);
        Ok(())
    }
    
    /// ACC_ObjRelSpd
    ///
    /// - Min: -170
    /// - Max: 239.5
    /// - Unit: "m/s"
    /// - Receivers: ABS, ESC
    #[inline(always)]
    pub fn acc_obj_rel_spd(&self) -> f32 {
        self.acc_obj_rel_spd_raw()
    }
    
    /// Get raw value of ACC_ObjRelSpd
    ///
    /// - Start bit: 44
    /// - Signal size: 12 bits
    /// - Factor: 0.1
    /// - Offset: -170
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn acc_obj_rel_spd_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[44..56].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = -170_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of ACC_ObjRelSpd
    #[inline(always)]
    pub fn set_acc_obj_rel_spd(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -170_f32 || 239.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1056 });
        }
        let factor = 0.1_f32;
        let offset = -170_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[44..56].store_le(value);
        Ok(())
    }
    
    /// ACC_ObjDist
    ///
    /// - Min: 0
    /// - Max: 204.7
    /// - Unit: "m"
    /// - Receivers: ABS, ESC
    #[inline(always)]
    pub fn acc_obj_dist(&self) -> f32 {
        self.acc_obj_dist_raw()
    }
    
    /// Get raw value of ACC_ObjDist
    ///
    /// - Start bit: 33
    /// - Signal size: 11 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn acc_obj_dist_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[33..44].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of ACC_ObjDist
    #[inline(always)]
    pub fn set_acc_obj_dist(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 204.7_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1056 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[33..44].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Scc11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Scc11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Scc11")
                .field("main_mode_acc", &self.main_mode_acc())
                .field("scc_info_display", &self.scc_info_display())
                .field("alive_counter_acc", &self.alive_counter_acc())
                .field("v_set_dis", &self.v_set_dis())
                .field("obj_valid", &self.obj_valid())
                .field("driver_alert_display", &self.driver_alert_display())
                .field("tau_gap_set", &self.tau_gap_set())
                .field("navi_scc_curve_status", &self.navi_scc_curve_status())
                .field("navi_scc_curve_act", &self.navi_scc_curve_act())
                .field("navi_scc_camera_act", &self.navi_scc_camera_act())
                .field("navi_scc_camera_status", &self.navi_scc_camera_status())
                .field("acc_obj_status", &self.acc_obj_status())
                .field("acc_obj_lat_pos", &self.acc_obj_lat_pos())
                .field("acc_obj_rel_spd", &self.acc_obj_rel_spd())
                .field("acc_obj_dist", &self.acc_obj_dist())
            .finish()
        } else {
            f.debug_tuple("Scc11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Scc11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let main_mode_acc = u.int_in_range(0..=1)? == 1;
        let scc_info_display = u.int_in_range(0..=7)?;
        let alive_counter_acc = u.int_in_range(0..=15)?;
        let v_set_dis = u.int_in_range(0..=255)?;
        let obj_valid = u.int_in_range(0..=1)? == 1;
        let driver_alert_display = u.int_in_range(0..=3)?;
        let tau_gap_set = u.int_in_range(0..=7)?;
        let navi_scc_curve_status = u.int_in_range(0..=3)?;
        let navi_scc_curve_act = u.int_in_range(0..=3)?;
        let navi_scc_camera_act = u.int_in_range(0..=3)?;
        let navi_scc_camera_status = u.int_in_range(0..=3)?;
        let acc_obj_status = u.int_in_range(0..=3)?;
        let acc_obj_lat_pos = u.float_in_range(-20_f32..=31.1_f32)?;
        let acc_obj_rel_spd = u.float_in_range(-170_f32..=239.5_f32)?;
        let acc_obj_dist = u.float_in_range(0_f32..=204.7_f32)?;
        Scc11::new(main_mode_acc,scc_info_display,alive_counter_acc,v_set_dis,obj_valid,driver_alert_display,tau_gap_set,navi_scc_curve_status,navi_scc_curve_act,navi_scc_camera_act,navi_scc_camera_status,acc_obj_status,acc_obj_lat_pos,acc_obj_rel_spd,acc_obj_dist).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for SCCInfoDisplay
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Scc11SccInfoDisplay {
    NoMessage,
    CruiseControl,
    LostLead,
    Standstill,
    _Other(u8),
}

impl From<Scc11SccInfoDisplay> for u8 {
    fn from(val: Scc11SccInfoDisplay) -> u8 {
        match val {
            Scc11SccInfoDisplay::NoMessage => 0,
            Scc11SccInfoDisplay::CruiseControl => 2,
            Scc11SccInfoDisplay::LostLead => 3,
            Scc11SccInfoDisplay::Standstill => 4,
            Scc11SccInfoDisplay::_Other(x) => x,
        }
    }
}


/// CGW3
///
/// - ID: 1312 (0x520)
/// - Size: 8 bytes
/// - Transmitter: BCM
#[derive(Clone, Copy)]
pub struct Cgw3 {
    raw: [u8; 8],
}

impl Cgw3 {
    pub const MESSAGE_ID: u32 = 1312;
    
    pub const CR_PHOTOSENSOR_LH_MIN: f32 = 0_f32;
    pub const CR_PHOTOSENSOR_LH_MAX: f32 = 20000_f32;
    pub const CR_PHOTOSENSOR_RH_MIN: f32 = 0_f32;
    pub const CR_PHOTOSENSOR_RH_MAX: f32 = 20000_f32;
    pub const CF_HOODSW_MEMORY_MIN: u8 = 0_u8;
    pub const CF_HOODSW_MEMORY_MAX: u8 = 3_u8;
    pub const C_MIR_OUT_TEMP_SNS_MIN: f32 = -40_f32;
    pub const C_MIR_OUT_TEMP_SNS_MAX: f32 = 60_f32;
    
    /// Construct new CGW3 from values
    pub fn new(cr_photosensor_lh: f32, cr_photosensor_rh: f32, cf_hoodsw_memory: u8, c_mir_out_temp_sns: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cr_photosensor_lh(cr_photosensor_lh)?;
        res.set_cr_photosensor_rh(cr_photosensor_rh)?;
        res.set_cf_hoodsw_memory(cf_hoodsw_memory)?;
        res.set_c_mir_out_temp_sns(c_mir_out_temp_sns)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CR_Photosensor_LH
    ///
    /// - Min: 0
    /// - Max: 20000
    /// - Unit: ""
    /// - Receivers: DATC, DATC
    #[inline(always)]
    pub fn cr_photosensor_lh(&self) -> f32 {
        self.cr_photosensor_lh_raw()
    }
    
    /// Get raw value of CR_Photosensor_LH
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 78.125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_photosensor_lh_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 78.125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Photosensor_LH
    #[inline(always)]
    pub fn set_cr_photosensor_lh(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 20000_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1312 });
        }
        let factor = 78.125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CR_Photosensor_RH
    ///
    /// - Min: 0
    /// - Max: 20000
    /// - Unit: ""
    /// - Receivers: DATC, DATC
    #[inline(always)]
    pub fn cr_photosensor_rh(&self) -> f32 {
        self.cr_photosensor_rh_raw()
    }
    
    /// Get raw value of CR_Photosensor_RH
    ///
    /// - Start bit: 10
    /// - Signal size: 8 bits
    /// - Factor: 78.125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_photosensor_rh_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[10..18].load_le::<u8>();
        
        let factor = 78.125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Photosensor_RH
    #[inline(always)]
    pub fn set_cr_photosensor_rh(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 20000_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1312 });
        }
        let factor = 78.125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[10..18].store_le(value);
        Ok(())
    }
    
    /// CF_Hoodsw_memory
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, EMS
    #[inline(always)]
    pub fn cf_hoodsw_memory(&self) -> u8 {
        self.cf_hoodsw_memory_raw()
    }
    
    /// Get raw value of CF_Hoodsw_memory
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_hoodsw_memory_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Hoodsw_memory
    #[inline(always)]
    pub fn set_cf_hoodsw_memory(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1312 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
    /// C_MirOutTempSns
    ///
    /// - Min: -40
    /// - Max: 60
    /// - Unit: "deg"
    /// - Receivers: AAF, CLU, DATC, EMS, SPAS, AAF, DATC, EMS, SPAS
    #[inline(always)]
    pub fn c_mir_out_temp_sns(&self) -> f32 {
        self.c_mir_out_temp_sns_raw()
    }
    
    /// Get raw value of C_MirOutTempSns
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.5
    /// - Offset: -40.5
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn c_mir_out_temp_sns_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -40.5_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of C_MirOutTempSns
    #[inline(always)]
    pub fn set_c_mir_out_temp_sns(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 60_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1312 });
        }
        let factor = 0.5_f32;
        let offset = -40.5_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Cgw3 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Cgw3 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Cgw3")
                .field("cr_photosensor_lh", &self.cr_photosensor_lh())
                .field("cr_photosensor_rh", &self.cr_photosensor_rh())
                .field("cf_hoodsw_memory", &self.cf_hoodsw_memory())
                .field("c_mir_out_temp_sns", &self.c_mir_out_temp_sns())
            .finish()
        } else {
            f.debug_tuple("Cgw3").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Cgw3 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cr_photosensor_lh = u.float_in_range(0_f32..=20000_f32)?;
        let cr_photosensor_rh = u.float_in_range(0_f32..=20000_f32)?;
        let cf_hoodsw_memory = u.int_in_range(0..=3)?;
        let c_mir_out_temp_sns = u.float_in_range(-40_f32..=60_f32)?;
        Cgw3::new(cr_photosensor_lh,cr_photosensor_rh,cf_hoodsw_memory,c_mir_out_temp_sns).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ESP12
///
/// - ID: 544 (0x220)
/// - Size: 8 bytes
/// - Transmitter: ESC
#[derive(Clone, Copy)]
pub struct Esp12 {
    raw: [u8; 8],
}

impl Esp12 {
    pub const MESSAGE_ID: u32 = 544;
    
    pub const LAT_ACCEL_MIN: f32 = -10.23_f32;
    pub const LAT_ACCEL_MAX: f32 = 10.24_f32;
    pub const LONG_ACCEL_MIN: f32 = -10.23_f32;
    pub const LONG_ACCEL_MAX: f32 = 10.24_f32;
    pub const CYL_PRES_MIN: f32 = 0_f32;
    pub const CYL_PRES_MAX: f32 = 409.5_f32;
    pub const YAW_RATE_MIN: f32 = -40.95_f32;
    pub const YAW_RATE_MAX: f32 = 40.96_f32;
    pub const ESP12_CHECKSUM_MIN: u8 = 0_u8;
    pub const ESP12_CHECKSUM_MAX: u8 = 15_u8;
    pub const ESP12_ALIVE_COUNTER_MIN: u8 = 0_u8;
    pub const ESP12_ALIVE_COUNTER_MAX: u8 = 15_u8;
    
    /// Construct new ESP12 from values
    pub fn new(lat_accel: f32, lat_accel_stat: bool, lat_accel_diag: bool, long_accel: f32, long_accel_stat: bool, long_accel_diag: bool, cyl_pres: f32, cyl_pres_stat: bool, cyl_press_diag: bool, yaw_rate: f32, yaw_rate_stat: bool, yaw_rate_diag: bool, esp12_checksum: u8, esp12_alive_counter: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_lat_accel(lat_accel)?;
        res.set_lat_accel_stat(lat_accel_stat)?;
        res.set_lat_accel_diag(lat_accel_diag)?;
        res.set_long_accel(long_accel)?;
        res.set_long_accel_stat(long_accel_stat)?;
        res.set_long_accel_diag(long_accel_diag)?;
        res.set_cyl_pres(cyl_pres)?;
        res.set_cyl_pres_stat(cyl_pres_stat)?;
        res.set_cyl_press_diag(cyl_press_diag)?;
        res.set_yaw_rate(yaw_rate)?;
        res.set_yaw_rate_stat(yaw_rate_stat)?;
        res.set_yaw_rate_diag(yaw_rate_diag)?;
        res.set_esp12_checksum(esp12_checksum)?;
        res.set_esp12_alive_counter(esp12_alive_counter)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// LAT_ACCEL
    ///
    /// - Min: -10.23
    /// - Max: 10.24
    /// - Unit: "m/s^2"
    /// - Receivers: _4WD, ECS, IBOX, LCA, LDWS_LKAS, MDPS, PSB, SCC, TCU
    #[inline(always)]
    pub fn lat_accel(&self) -> f32 {
        self.lat_accel_raw()
    }
    
    /// Get raw value of LAT_ACCEL
    ///
    /// - Start bit: 0
    /// - Signal size: 11 bits
    /// - Factor: 0.01
    /// - Offset: -10.23
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lat_accel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..11].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = -10.23_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of LAT_ACCEL
    #[inline(always)]
    pub fn set_lat_accel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -10.23_f32 || 10.24_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 544 });
        }
        let factor = 0.01_f32;
        let offset = -10.23_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..11].store_le(value);
        Ok(())
    }
    
    /// LAT_ACCEL_STAT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, IBOX, LDWS_LKAS, MDPS, PSB, SCC, TCU
    #[inline(always)]
    pub fn lat_accel_stat(&self) -> bool {
        self.lat_accel_stat_raw()
    }
    
    /// Get raw value of LAT_ACCEL_STAT
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lat_accel_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LAT_ACCEL_STAT
    #[inline(always)]
    pub fn set_lat_accel_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[11..12].store_le(value);
        Ok(())
    }
    
    /// LAT_ACCEL_DIAG
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, IBOX, LDWS_LKAS, MDPS, PSB, SCC, TCU
    #[inline(always)]
    pub fn lat_accel_diag(&self) -> bool {
        self.lat_accel_diag_raw()
    }
    
    /// Get raw value of LAT_ACCEL_DIAG
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lat_accel_diag_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LAT_ACCEL_DIAG
    #[inline(always)]
    pub fn set_lat_accel_diag(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[12..13].store_le(value);
        Ok(())
    }
    
    /// LONG_ACCEL
    ///
    /// - Min: -10.23
    /// - Max: 10.24
    /// - Unit: "m/s^2"
    /// - Receivers: _4WD, ECS, EMS, EPB, IBOX, LCA, LDWS_LKAS, PSB, SCC, SPAS, TCU
    #[inline(always)]
    pub fn long_accel(&self) -> f32 {
        self.long_accel_raw()
    }
    
    /// Get raw value of LONG_ACCEL
    ///
    /// - Start bit: 13
    /// - Signal size: 11 bits
    /// - Factor: 0.01
    /// - Offset: -10.23
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn long_accel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[13..24].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = -10.23_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of LONG_ACCEL
    #[inline(always)]
    pub fn set_long_accel(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -10.23_f32 || 10.24_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 544 });
        }
        let factor = 0.01_f32;
        let offset = -10.23_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[13..24].store_le(value);
        Ok(())
    }
    
    /// LONG_ACCEL_STAT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, EPB, IBOX, LDWS_LKAS, PSB, SCC, SPAS, TCU
    #[inline(always)]
    pub fn long_accel_stat(&self) -> bool {
        self.long_accel_stat_raw()
    }
    
    /// Get raw value of LONG_ACCEL_STAT
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn long_accel_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LONG_ACCEL_STAT
    #[inline(always)]
    pub fn set_long_accel_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[24..25].store_le(value);
        Ok(())
    }
    
    /// LONG_ACCEL_DIAG
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, EPB, IBOX, LDWS_LKAS, PSB, SCC, SPAS, TCU
    #[inline(always)]
    pub fn long_accel_diag(&self) -> bool {
        self.long_accel_diag_raw()
    }
    
    /// Get raw value of LONG_ACCEL_DIAG
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn long_accel_diag_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LONG_ACCEL_DIAG
    #[inline(always)]
    pub fn set_long_accel_diag(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[25..26].store_le(value);
        Ok(())
    }
    
    /// CYL_PRES
    ///
    /// - Min: 0
    /// - Max: 409.5
    /// - Unit: "Bar"
    /// - Receivers: _4WD, ECS, EMS, EPB, IBOX, LDWS_LKAS, PSB, SCC, TCU
    #[inline(always)]
    pub fn cyl_pres(&self) -> f32 {
        self.cyl_pres_raw()
    }
    
    /// Get raw value of CYL_PRES
    ///
    /// - Start bit: 26
    /// - Signal size: 12 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cyl_pres_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[26..38].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CYL_PRES
    #[inline(always)]
    pub fn set_cyl_pres(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 409.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 544 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[26..38].store_le(value);
        Ok(())
    }
    
    /// CYL_PRES_STAT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ECS, EMS, EPB, IBOX, LDWS_LKAS, PSB, SCC, TCU
    #[inline(always)]
    pub fn cyl_pres_stat(&self) -> bool {
        self.cyl_pres_stat_raw()
    }
    
    /// Get raw value of CYL_PRES_STAT
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cyl_pres_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[38..39].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CYL_PRES_STAT
    #[inline(always)]
    pub fn set_cyl_pres_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[38..39].store_le(value);
        Ok(())
    }
    
    /// CYL_PRESS_DIAG
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ECS, EMS, EPB, IBOX, PSB, SCC, TCU
    #[inline(always)]
    pub fn cyl_press_diag(&self) -> bool {
        self.cyl_press_diag_raw()
    }
    
    /// Get raw value of CYL_PRESS_DIAG
    ///
    /// - Start bit: 39
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cyl_press_diag_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[39..40].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CYL_PRESS_DIAG
    #[inline(always)]
    pub fn set_cyl_press_diag(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[39..40].store_le(value);
        Ok(())
    }
    
    /// YAW_RATE
    ///
    /// - Min: -40.95
    /// - Max: 40.96
    /// - Unit: ""
    /// - Receivers: _4WD, AFLS, IBOX, LCA, LDWS_LKAS, MDPS, PSB, SCC, SPAS, TCU
    #[inline(always)]
    pub fn yaw_rate(&self) -> f32 {
        self.yaw_rate_raw()
    }
    
    /// Get raw value of YAW_RATE
    ///
    /// - Start bit: 40
    /// - Signal size: 13 bits
    /// - Factor: 0.01
    /// - Offset: -40.95
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn yaw_rate_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..53].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = -40.95_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of YAW_RATE
    #[inline(always)]
    pub fn set_yaw_rate(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40.95_f32 || 40.96_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 544 });
        }
        let factor = 0.01_f32;
        let offset = -40.95_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[40..53].store_le(value);
        Ok(())
    }
    
    /// YAW_RATE_STAT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, AFLS, IBOX, LCA, LDWS_LKAS, MDPS, PSB, SCC, SPAS, TCU
    #[inline(always)]
    pub fn yaw_rate_stat(&self) -> bool {
        self.yaw_rate_stat_raw()
    }
    
    /// Get raw value of YAW_RATE_STAT
    ///
    /// - Start bit: 53
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn yaw_rate_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[53..54].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of YAW_RATE_STAT
    #[inline(always)]
    pub fn set_yaw_rate_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[53..54].store_le(value);
        Ok(())
    }
    
    /// YAW_RATE_DIAG
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, AFLS, IBOX, LCA, LDWS_LKAS, MDPS, PSB, SCC, SPAS, TCU
    #[inline(always)]
    pub fn yaw_rate_diag(&self) -> bool {
        self.yaw_rate_diag_raw()
    }
    
    /// Get raw value of YAW_RATE_DIAG
    ///
    /// - Start bit: 54
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn yaw_rate_diag_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[54..55].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of YAW_RATE_DIAG
    #[inline(always)]
    pub fn set_yaw_rate_diag(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[54..55].store_le(value);
        Ok(())
    }
    
    /// ESP12_Checksum
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, LPI, TCU, TMU
    #[inline(always)]
    pub fn esp12_checksum(&self) -> u8 {
        self.esp12_checksum_raw()
    }
    
    /// Get raw value of ESP12_Checksum
    ///
    /// - Start bit: 56
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp12_checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESP12_Checksum
    #[inline(always)]
    pub fn set_esp12_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 544 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..60].store_le(value);
        Ok(())
    }
    
    /// ESP12_AliveCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, LPI, TCU, TMU
    #[inline(always)]
    pub fn esp12_alive_counter(&self) -> u8 {
        self.esp12_alive_counter_raw()
    }
    
    /// Get raw value of ESP12_AliveCounter
    ///
    /// - Start bit: 60
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esp12_alive_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESP12_AliveCounter
    #[inline(always)]
    pub fn set_esp12_alive_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 544 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Esp12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Esp12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Esp12")
                .field("lat_accel", &self.lat_accel())
                .field("lat_accel_stat", &self.lat_accel_stat())
                .field("lat_accel_diag", &self.lat_accel_diag())
                .field("long_accel", &self.long_accel())
                .field("long_accel_stat", &self.long_accel_stat())
                .field("long_accel_diag", &self.long_accel_diag())
                .field("cyl_pres", &self.cyl_pres())
                .field("cyl_pres_stat", &self.cyl_pres_stat())
                .field("cyl_press_diag", &self.cyl_press_diag())
                .field("yaw_rate", &self.yaw_rate())
                .field("yaw_rate_stat", &self.yaw_rate_stat())
                .field("yaw_rate_diag", &self.yaw_rate_diag())
                .field("esp12_checksum", &self.esp12_checksum())
                .field("esp12_alive_counter", &self.esp12_alive_counter())
            .finish()
        } else {
            f.debug_tuple("Esp12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Esp12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let lat_accel = u.float_in_range(-10.23_f32..=10.24_f32)?;
        let lat_accel_stat = u.int_in_range(0..=1)? == 1;
        let lat_accel_diag = u.int_in_range(0..=1)? == 1;
        let long_accel = u.float_in_range(-10.23_f32..=10.24_f32)?;
        let long_accel_stat = u.int_in_range(0..=1)? == 1;
        let long_accel_diag = u.int_in_range(0..=1)? == 1;
        let cyl_pres = u.float_in_range(0_f32..=409.5_f32)?;
        let cyl_pres_stat = u.int_in_range(0..=1)? == 1;
        let cyl_press_diag = u.int_in_range(0..=1)? == 1;
        let yaw_rate = u.float_in_range(-40.95_f32..=40.96_f32)?;
        let yaw_rate_stat = u.int_in_range(0..=1)? == 1;
        let yaw_rate_diag = u.int_in_range(0..=1)? == 1;
        let esp12_checksum = u.int_in_range(0..=15)?;
        let esp12_alive_counter = u.int_in_range(0..=15)?;
        Esp12::new(lat_accel,lat_accel_stat,lat_accel_diag,long_accel,long_accel_stat,long_accel_diag,cyl_pres,cyl_pres_stat,cyl_press_diag,yaw_rate,yaw_rate_stat,yaw_rate_diag,esp12_checksum,esp12_alive_counter).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// CLU16
///
/// - ID: 1307 (0x51b)
/// - Size: 8 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct Clu16 {
    raw: [u8; 8],
}

impl Clu16 {
    pub const MESSAGE_ID: u32 = 1307;
    
    pub const CF_CLU_TIRE_PRESS_UNIT_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_TIRE_PRESS_UNIT_N_VALUE_SET_MAX: u8 = 7_u8;
    pub const CF_CLU_SLIF_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_SLIF_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_REAR_WIPER_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_REAR_WIPER_N_VALUE_SET_MAX: u8 = 3_u8;
    
    /// Construct new CLU16 from values
    pub fn new(cf_clu_tire_press_unit_n_value_set: u8, cf_clu_slif_n_value_set: u8, cf_clu_rear_wiper_n_value_set: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_clu_tire_press_unit_n_value_set(cf_clu_tire_press_unit_n_value_set)?;
        res.set_cf_clu_slif_n_value_set(cf_clu_slif_n_value_set)?;
        res.set_cf_clu_rear_wiper_n_value_set(cf_clu_rear_wiper_n_value_set)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Clu_TirePressUnitNValueSet
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: TPMS
    #[inline(always)]
    pub fn cf_clu_tire_press_unit_n_value_set(&self) -> u8 {
        self.cf_clu_tire_press_unit_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_TirePressUnitNValueSet
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_tire_press_unit_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_TirePressUnitNValueSet
    #[inline(always)]
    pub fn set_cf_clu_tire_press_unit_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1307 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..3].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_SlifNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS
    #[inline(always)]
    pub fn cf_clu_slif_n_value_set(&self) -> u8 {
        self.cf_clu_slif_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_SlifNValueSet
    ///
    /// - Start bit: 3
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_slif_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[3..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_SlifNValueSet
    #[inline(always)]
    pub fn set_cf_clu_slif_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1307 });
        }
        self.raw.view_bits_mut::<Lsb0>()[3..5].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_RearWiperNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_rear_wiper_n_value_set(&self) -> u8 {
        self.cf_clu_rear_wiper_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_RearWiperNValueSet
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_rear_wiper_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_RearWiperNValueSet
    #[inline(always)]
    pub fn set_cf_clu_rear_wiper_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1307 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..14].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Clu16 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Clu16 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Clu16")
                .field("cf_clu_tire_press_unit_n_value_set", &self.cf_clu_tire_press_unit_n_value_set())
                .field("cf_clu_slif_n_value_set", &self.cf_clu_slif_n_value_set())
                .field("cf_clu_rear_wiper_n_value_set", &self.cf_clu_rear_wiper_n_value_set())
            .finish()
        } else {
            f.debug_tuple("Clu16").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Clu16 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_clu_tire_press_unit_n_value_set = u.int_in_range(0..=7)?;
        let cf_clu_slif_n_value_set = u.int_in_range(0..=3)?;
        let cf_clu_rear_wiper_n_value_set = u.int_in_range(0..=3)?;
        Clu16::new(cf_clu_tire_press_unit_n_value_set,cf_clu_slif_n_value_set,cf_clu_rear_wiper_n_value_set).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EMS11
///
/// - ID: 790 (0x316)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct Ems11 {
    raw: [u8; 8],
}

impl Ems11 {
    pub const MESSAGE_ID: u32 = 790;
    
    pub const TQ_COR_STAT_MIN: u8 = 0_u8;
    pub const TQ_COR_STAT_MAX: u8 = 3_u8;
    pub const TQI_ACOR_MIN: f32 = 0_f32;
    pub const TQI_ACOR_MAX: f32 = 99.6094_f32;
    pub const N_MIN: f32 = 0_f32;
    pub const N_MAX: f32 = 16383.75_f32;
    pub const TQI_MIN: f32 = 0_f32;
    pub const TQI_MAX: f32 = 99.6094_f32;
    pub const TQFR_MIN: f32 = 0_f32;
    pub const TQFR_MAX: f32 = 99.6094_f32;
    pub const VS_MIN: u8 = 0_u8;
    pub const VS_MAX: u8 = 254_u8;
    pub const RATIO_TQI_BAS_MAX_STND_MIN: f32 = 0_f32;
    pub const RATIO_TQI_BAS_MAX_STND_MAX: f32 = 2_f32;
    
    /// Construct new EMS11 from values
    pub fn new(swi_igk: bool, f_n_eng: bool, ack_tcs: bool, puc_stat: bool, tq_cor_stat: u8, rly_ac: bool, f_sub_tqi: bool, tqi_acor: f32, n: f32, tqi: f32, tqfr: f32, vs: u8, ratio_tqi_bas_max_stnd: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_swi_igk(swi_igk)?;
        res.set_f_n_eng(f_n_eng)?;
        res.set_ack_tcs(ack_tcs)?;
        res.set_puc_stat(puc_stat)?;
        res.set_tq_cor_stat(tq_cor_stat)?;
        res.set_rly_ac(rly_ac)?;
        res.set_f_sub_tqi(f_sub_tqi)?;
        res.set_tqi_acor(tqi_acor)?;
        res.set_n(n)?;
        res.set_tqi(tqi)?;
        res.set_tqfr(tqfr)?;
        res.set_vs(vs)?;
        res.set_ratio_tqi_bas_max_stnd(ratio_tqi_bas_max_stnd)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// SWI_IGK
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ABS, ACU, AHLS, CUBIS, DI_BOX, ECS, EPB, ESC, IBOX, LDWS_LKAS, MDPS, REA, SAS, SCC, TCU
    #[inline(always)]
    pub fn swi_igk(&self) -> bool {
        self.swi_igk_raw()
    }
    
    /// Get raw value of SWI_IGK
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn swi_igk_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of SWI_IGK
    #[inline(always)]
    pub fn set_swi_igk(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// F_N_ENG
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ACU, AFLS, CLU, CUBIS, DATC, ECS, EPB, ESC, IBOX, MDPS, SCC, TCU
    #[inline(always)]
    pub fn f_n_eng(&self) -> bool {
        self.f_n_eng_raw()
    }
    
    /// Get raw value of F_N_ENG
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn f_n_eng_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of F_N_ENG
    #[inline(always)]
    pub fn set_f_n_eng(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// ACK_TCS
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC, IBOX
    #[inline(always)]
    pub fn ack_tcs(&self) -> bool {
        self.ack_tcs_raw()
    }
    
    /// Get raw value of ACK_TCS
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ack_tcs_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ACK_TCS
    #[inline(always)]
    pub fn set_ack_tcs(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// PUC_STAT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, CLU, DATC, IBOX, TCU
    #[inline(always)]
    pub fn puc_stat(&self) -> bool {
        self.puc_stat_raw()
    }
    
    /// Get raw value of PUC_STAT
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn puc_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of PUC_STAT
    #[inline(always)]
    pub fn set_puc_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// TQ_COR_STAT
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: _4WD, ESC, IBOX, TCU
    #[inline(always)]
    pub fn tq_cor_stat(&self) -> u8 {
        self.tq_cor_stat_raw()
    }
    
    /// Get raw value of TQ_COR_STAT
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tq_cor_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of TQ_COR_STAT
    #[inline(always)]
    pub fn set_tq_cor_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 790 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
    /// RLY_AC
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: DATC, IBOX, TCU
    #[inline(always)]
    pub fn rly_ac(&self) -> bool {
        self.rly_ac_raw()
    }
    
    /// Get raw value of RLY_AC
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rly_ac_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of RLY_AC
    #[inline(always)]
    pub fn set_rly_ac(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[6..7].store_le(value);
        Ok(())
    }
    
    /// F_SUB_TQI
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ECS, EPB, ESC, IBOX, TCU
    #[inline(always)]
    pub fn f_sub_tqi(&self) -> bool {
        self.f_sub_tqi_raw()
    }
    
    /// Get raw value of F_SUB_TQI
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn f_sub_tqi_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of F_SUB_TQI
    #[inline(always)]
    pub fn set_f_sub_tqi(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// TQI_ACOR
    ///
    /// - Min: 0
    /// - Max: 99.6094
    /// - Unit: "%"
    /// - Receivers: _4WD, EPB, ESC, IBOX, TCU
    #[inline(always)]
    pub fn tqi_acor(&self) -> f32 {
        self.tqi_acor_raw()
    }
    
    /// Get raw value of TQI_ACOR
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_acor_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI_ACOR
    #[inline(always)]
    pub fn set_tqi_acor(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.6094_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 790 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// N
    ///
    /// - Min: 0
    /// - Max: 16383.75
    /// - Unit: "rpm"
    /// - Receivers: _4WD, ACU, AFLS, CLU, CUBIS, DATC, ECS, EPB, ESC, FPCM, IBOX, MDPS, SCC, TCU
    #[inline(always)]
    pub fn n(&self) -> f32 {
        self.n_raw()
    }
    
    /// Get raw value of N
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.25
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn n_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<u16>();
        
        let factor = 0.25_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of N
    #[inline(always)]
    pub fn set_n(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 16383.75_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 790 });
        }
        let factor = 0.25_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// TQI
    ///
    /// - Min: 0
    /// - Max: 99.6094
    /// - Unit: "%"
    /// - Receivers: _4WD, ECS, EPB, ESC, IBOX, TCU
    #[inline(always)]
    pub fn tqi(&self) -> f32 {
        self.tqi_raw()
    }
    
    /// Get raw value of TQI
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI
    #[inline(always)]
    pub fn set_tqi(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.6094_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 790 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// TQFR
    ///
    /// - Min: 0
    /// - Max: 99.6094
    /// - Unit: "%"
    /// - Receivers: _4WD, EPB, ESC, IBOX, TCU
    #[inline(always)]
    pub fn tqfr(&self) -> f32 {
        self.tqfr_raw()
    }
    
    /// Get raw value of TQFR
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqfr_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQFR
    #[inline(always)]
    pub fn set_tqfr(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.6094_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 790 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// VS
    ///
    /// - Min: 0
    /// - Max: 254
    /// - Unit: "km/h"
    /// - Receivers: _4WD, AAF, ACU, AHLS, BCM, CLU, DATC, ECS, EPB, IBOX, LCA, LDWS_LKAS, LVR, MDPS, ODS, SCC, SMK, SPAS, TCU, TPMS
    #[inline(always)]
    pub fn vs(&self) -> u8 {
        self.vs_raw()
    }
    
    /// Get raw value of VS
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vs_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VS
    #[inline(always)]
    pub fn set_vs(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 254_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 790 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// RATIO_TQI_BAS_MAX_STND
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: _4WD, IBOX, TCU
    #[inline(always)]
    pub fn ratio_tqi_bas_max_stnd(&self) -> f32 {
        self.ratio_tqi_bas_max_stnd_raw()
    }
    
    /// Get raw value of RATIO_TQI_BAS_MAX_STND
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 0.0078
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ratio_tqi_bas_max_stnd_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        let factor = 0.0078_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RATIO_TQI_BAS_MAX_STND
    #[inline(always)]
    pub fn set_ratio_tqi_bas_max_stnd(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 790 });
        }
        let factor = 0.0078_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ems11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ems11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ems11")
                .field("swi_igk", &self.swi_igk())
                .field("f_n_eng", &self.f_n_eng())
                .field("ack_tcs", &self.ack_tcs())
                .field("puc_stat", &self.puc_stat())
                .field("tq_cor_stat", &self.tq_cor_stat())
                .field("rly_ac", &self.rly_ac())
                .field("f_sub_tqi", &self.f_sub_tqi())
                .field("tqi_acor", &self.tqi_acor())
                .field("n", &self.n())
                .field("tqi", &self.tqi())
                .field("tqfr", &self.tqfr())
                .field("vs", &self.vs())
                .field("ratio_tqi_bas_max_stnd", &self.ratio_tqi_bas_max_stnd())
            .finish()
        } else {
            f.debug_tuple("Ems11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ems11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let swi_igk = u.int_in_range(0..=1)? == 1;
        let f_n_eng = u.int_in_range(0..=1)? == 1;
        let ack_tcs = u.int_in_range(0..=1)? == 1;
        let puc_stat = u.int_in_range(0..=1)? == 1;
        let tq_cor_stat = u.int_in_range(0..=3)?;
        let rly_ac = u.int_in_range(0..=1)? == 1;
        let f_sub_tqi = u.int_in_range(0..=1)? == 1;
        let tqi_acor = u.float_in_range(0_f32..=99.6094_f32)?;
        let n = u.float_in_range(0_f32..=16383.75_f32)?;
        let tqi = u.float_in_range(0_f32..=99.6094_f32)?;
        let tqfr = u.float_in_range(0_f32..=99.6094_f32)?;
        let vs = u.int_in_range(0..=254)?;
        let ratio_tqi_bas_max_stnd = u.float_in_range(0_f32..=2_f32)?;
        Ems11::new(swi_igk,f_n_eng,ack_tcs,puc_stat,tq_cor_stat,rly_ac,f_sub_tqi,tqi_acor,n,tqi,tqfr,vs,ratio_tqi_bas_max_stnd).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// CLU14
///
/// - ID: 1301 (0x515)
/// - Size: 8 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct Clu14 {
    raw: [u8; 8],
}

impl Clu14 {
    pub const MESSAGE_ID: u32 = 1301;
    
    pub const CF_CLU_A_DR_UN_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_A_DR_UN_VALUE_SET_MAX: u8 = 7_u8;
    pub const CF_CLU_A_DR_LN_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_A_DR_LN_VALUE_SET_MAX: u8 = 7_u8;
    pub const CF_CLU_ESCORT_HLN_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_ESCORT_HLN_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_DOOR_LSN_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_DOOR_LSN_VALUE_SET_MAX: u8 = 7_u8;
    pub const CF_CLU_PSMN_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_PSMN_VALUE_SET_MAX: u8 = 7_u8;
    pub const CF_CLU_TT_UNLOCK_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_TT_UNLOCK_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_PTGMN_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_PTGMN_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_SCMN_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_SCMN_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_WLIGHT_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_WLIGHT_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_TEMP_UNIT_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_TEMP_UNIT_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_MOOD_LP_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_MOOD_LP_N_VALUE_SET_MAX: u8 = 7_u8;
    pub const CF_CLU_TRF_CHG_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_TRF_CHG_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_OT_TURN_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_OT_TURN_N_VALUE_SET_MAX: u8 = 7_u8;
    pub const CF_CLU_LCA_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_LCA_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_RCTA_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_RCTA_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_RCW_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_RCW_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_ESC_OFF_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_ESC_OFF_N_VALUE_SET_MAX: u8 = 7_u8;
    pub const CF_CLU_SCC_NAVI_CRV_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_SCC_NAVI_CRV_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_SCC_NAVI_CAM_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_SCC_NAVI_CAM_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_SCC_AEB_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_SCC_AEB_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_LKAS_MODE_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_LKAS_MODE_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_FCW_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_FCW_N_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_PAS_SPKR_LV_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_PAS_SPKR_LV_N_VALUE_SET_MAX: u8 = 7_u8;
    pub const CF_CLU_SCC_DRV_MODE_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_SCC_DRV_MODE_N_VALUE_SET_MAX: u8 = 7_u8;
    pub const CF_CLU_H_AN_BN_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_H_AN_BN_VALUE_SET_MAX: u8 = 3_u8;
    pub const CF_CLU_HFREE_TRUNK_TG_N_VALUE_SET_MIN: u8 = 0_u8;
    pub const CF_CLU_HFREE_TRUNK_TG_N_VALUE_SET_MAX: u8 = 7_u8;
    
    /// Construct new CLU14 from values
    pub fn new(cf_clu_a_dr_un_value_set: u8, cf_clu_a_dr_ln_value_set: u8, cf_clu_escort_hln_value_set: u8, cf_clu_door_lsn_value_set: u8, cf_clu_psmn_value_set: u8, cf_clu_tt_unlock_n_value_set: u8, cf_clu_ptgmn_value_set: u8, cf_clu_scmn_value_set: u8, cf_clu_wlight_n_value_set: u8, cf_clu_temp_unit_n_value_set: u8, cf_clu_mood_lp_n_value_set: u8, cf_clu_trf_chg_set: u8, cf_clu_ot_turn_n_value_set: u8, cf_clu_lca_n_value_set: u8, cf_clu_rcta_n_value_set: u8, cf_clu_rcw_n_value_set: u8, cf_clu_esc_off_n_value_set: u8, cf_clu_scc_navi_crv_n_value_set: u8, cf_clu_scc_navi_cam_n_value_set: u8, cf_clu_scc_aeb_n_value_set: u8, cf_clu_lkas_mode_n_value_set: u8, cf_clu_fcw_n_value_set: u8, cf_clu_pas_spkr_lv_n_value_set: u8, cf_clu_scc_drv_mode_n_value_set: u8, cf_clu_h_an_bn_value_set: u8, cf_clu_hfree_trunk_tg_n_value_set: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_clu_a_dr_un_value_set(cf_clu_a_dr_un_value_set)?;
        res.set_cf_clu_a_dr_ln_value_set(cf_clu_a_dr_ln_value_set)?;
        res.set_cf_clu_escort_hln_value_set(cf_clu_escort_hln_value_set)?;
        res.set_cf_clu_door_lsn_value_set(cf_clu_door_lsn_value_set)?;
        res.set_cf_clu_psmn_value_set(cf_clu_psmn_value_set)?;
        res.set_cf_clu_tt_unlock_n_value_set(cf_clu_tt_unlock_n_value_set)?;
        res.set_cf_clu_ptgmn_value_set(cf_clu_ptgmn_value_set)?;
        res.set_cf_clu_scmn_value_set(cf_clu_scmn_value_set)?;
        res.set_cf_clu_wlight_n_value_set(cf_clu_wlight_n_value_set)?;
        res.set_cf_clu_temp_unit_n_value_set(cf_clu_temp_unit_n_value_set)?;
        res.set_cf_clu_mood_lp_n_value_set(cf_clu_mood_lp_n_value_set)?;
        res.set_cf_clu_trf_chg_set(cf_clu_trf_chg_set)?;
        res.set_cf_clu_ot_turn_n_value_set(cf_clu_ot_turn_n_value_set)?;
        res.set_cf_clu_lca_n_value_set(cf_clu_lca_n_value_set)?;
        res.set_cf_clu_rcta_n_value_set(cf_clu_rcta_n_value_set)?;
        res.set_cf_clu_rcw_n_value_set(cf_clu_rcw_n_value_set)?;
        res.set_cf_clu_esc_off_n_value_set(cf_clu_esc_off_n_value_set)?;
        res.set_cf_clu_scc_navi_crv_n_value_set(cf_clu_scc_navi_crv_n_value_set)?;
        res.set_cf_clu_scc_navi_cam_n_value_set(cf_clu_scc_navi_cam_n_value_set)?;
        res.set_cf_clu_scc_aeb_n_value_set(cf_clu_scc_aeb_n_value_set)?;
        res.set_cf_clu_lkas_mode_n_value_set(cf_clu_lkas_mode_n_value_set)?;
        res.set_cf_clu_fcw_n_value_set(cf_clu_fcw_n_value_set)?;
        res.set_cf_clu_pas_spkr_lv_n_value_set(cf_clu_pas_spkr_lv_n_value_set)?;
        res.set_cf_clu_scc_drv_mode_n_value_set(cf_clu_scc_drv_mode_n_value_set)?;
        res.set_cf_clu_h_an_bn_value_set(cf_clu_h_an_bn_value_set)?;
        res.set_cf_clu_hfree_trunk_tg_n_value_set(cf_clu_hfree_trunk_tg_n_value_set)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Clu_ADrUNValueSet
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_a_dr_un_value_set(&self) -> u8 {
        self.cf_clu_a_dr_un_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_ADrUNValueSet
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_a_dr_un_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_ADrUNValueSet
    #[inline(always)]
    pub fn set_cf_clu_a_dr_un_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..3].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_ADrLNValueSet
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_a_dr_ln_value_set(&self) -> u8 {
        self.cf_clu_a_dr_ln_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_ADrLNValueSet
    ///
    /// - Start bit: 3
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_a_dr_ln_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[3..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_ADrLNValueSet
    #[inline(always)]
    pub fn set_cf_clu_a_dr_ln_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[3..6].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_EscortHLNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_escort_hln_value_set(&self) -> u8 {
        self.cf_clu_escort_hln_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_EscortHLNValueSet
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_escort_hln_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_EscortHLNValueSet
    #[inline(always)]
    pub fn set_cf_clu_escort_hln_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_DoorLSNValueSet
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_door_lsn_value_set(&self) -> u8 {
        self.cf_clu_door_lsn_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_DoorLSNValueSet
    ///
    /// - Start bit: 8
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_door_lsn_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_DoorLSNValueSet
    #[inline(always)]
    pub fn set_cf_clu_door_lsn_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..11].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_PSMNValueSet
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_psmn_value_set(&self) -> u8 {
        self.cf_clu_psmn_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_PSMNValueSet
    ///
    /// - Start bit: 11
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_psmn_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[11..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_PSMNValueSet
    #[inline(always)]
    pub fn set_cf_clu_psmn_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[11..14].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_TTUnlockNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_tt_unlock_n_value_set(&self) -> u8 {
        self.cf_clu_tt_unlock_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_TTUnlockNValueSet
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_tt_unlock_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_TTUnlockNValueSet
    #[inline(always)]
    pub fn set_cf_clu_tt_unlock_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_PTGMNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_ptgmn_value_set(&self) -> u8 {
        self.cf_clu_ptgmn_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_PTGMNValueSet
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_ptgmn_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_PTGMNValueSet
    #[inline(always)]
    pub fn set_cf_clu_ptgmn_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..18].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_SCMNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_scmn_value_set(&self) -> u8 {
        self.cf_clu_scmn_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_SCMNValueSet
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_scmn_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_SCMNValueSet
    #[inline(always)]
    pub fn set_cf_clu_scmn_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[18..20].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_WlightNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_wlight_n_value_set(&self) -> u8 {
        self.cf_clu_wlight_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_WlightNValueSet
    ///
    /// - Start bit: 20
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_wlight_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..22].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_WlightNValueSet
    #[inline(always)]
    pub fn set_cf_clu_wlight_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..22].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_TempUnitNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, DATC
    #[inline(always)]
    pub fn cf_clu_temp_unit_n_value_set(&self) -> u8 {
        self.cf_clu_temp_unit_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_TempUnitNValueSet
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_temp_unit_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_TempUnitNValueSet
    #[inline(always)]
    pub fn set_cf_clu_temp_unit_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_MoodLpNValueSet
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_mood_lp_n_value_set(&self) -> u8 {
        self.cf_clu_mood_lp_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_MoodLpNValueSet
    ///
    /// - Start bit: 24
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_mood_lp_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..27].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_MoodLpNValueSet
    #[inline(always)]
    pub fn set_cf_clu_mood_lp_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..27].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_TrfChgSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: AFLS
    #[inline(always)]
    pub fn cf_clu_trf_chg_set(&self) -> u8 {
        self.cf_clu_trf_chg_set_raw()
    }
    
    /// Get raw value of CF_Clu_TrfChgSet
    ///
    /// - Start bit: 27
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_trf_chg_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[27..29].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_TrfChgSet
    #[inline(always)]
    pub fn set_cf_clu_trf_chg_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[27..29].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_OTTurnNValueSet
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_ot_turn_n_value_set(&self) -> u8 {
        self.cf_clu_ot_turn_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_OTTurnNValueSet
    ///
    /// - Start bit: 29
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_ot_turn_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[29..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_OTTurnNValueSet
    #[inline(always)]
    pub fn set_cf_clu_ot_turn_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[29..32].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_LcaNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: LCA
    #[inline(always)]
    pub fn cf_clu_lca_n_value_set(&self) -> u8 {
        self.cf_clu_lca_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_LcaNValueSet
    ///
    /// - Start bit: 32
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_lca_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..34].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_LcaNValueSet
    #[inline(always)]
    pub fn set_cf_clu_lca_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..34].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_RctaNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: LCA
    #[inline(always)]
    pub fn cf_clu_rcta_n_value_set(&self) -> u8 {
        self.cf_clu_rcta_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_RctaNValueSet
    ///
    /// - Start bit: 34
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_rcta_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[34..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_RctaNValueSet
    #[inline(always)]
    pub fn set_cf_clu_rcta_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[34..36].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_RcwNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: LCA
    #[inline(always)]
    pub fn cf_clu_rcw_n_value_set(&self) -> u8 {
        self.cf_clu_rcw_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_RcwNValueSet
    ///
    /// - Start bit: 36
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_rcw_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[36..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_RcwNValueSet
    #[inline(always)]
    pub fn set_cf_clu_rcw_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[36..38].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_EscOffNValueSet
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cf_clu_esc_off_n_value_set(&self) -> u8 {
        self.cf_clu_esc_off_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_EscOffNValueSet
    ///
    /// - Start bit: 38
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_esc_off_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[38..41].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_EscOffNValueSet
    #[inline(always)]
    pub fn set_cf_clu_esc_off_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[38..41].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_SccNaviCrvNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: SCC
    #[inline(always)]
    pub fn cf_clu_scc_navi_crv_n_value_set(&self) -> u8 {
        self.cf_clu_scc_navi_crv_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_SccNaviCrvNValueSet
    ///
    /// - Start bit: 41
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_scc_navi_crv_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[41..43].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_SccNaviCrvNValueSet
    #[inline(always)]
    pub fn set_cf_clu_scc_navi_crv_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[41..43].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_SccNaviCamNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: SCC
    #[inline(always)]
    pub fn cf_clu_scc_navi_cam_n_value_set(&self) -> u8 {
        self.cf_clu_scc_navi_cam_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_SccNaviCamNValueSet
    ///
    /// - Start bit: 43
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_scc_navi_cam_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[43..45].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_SccNaviCamNValueSet
    #[inline(always)]
    pub fn set_cf_clu_scc_navi_cam_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[43..45].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_SccAebNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: SCC
    #[inline(always)]
    pub fn cf_clu_scc_aeb_n_value_set(&self) -> u8 {
        self.cf_clu_scc_aeb_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_SccAebNValueSet
    ///
    /// - Start bit: 45
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_scc_aeb_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[45..47].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_SccAebNValueSet
    #[inline(always)]
    pub fn set_cf_clu_scc_aeb_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[45..47].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_LkasModeNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS
    #[inline(always)]
    pub fn cf_clu_lkas_mode_n_value_set(&self) -> u8 {
        self.cf_clu_lkas_mode_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_LkasModeNValueSet
    ///
    /// - Start bit: 47
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_lkas_mode_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[47..49].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_LkasModeNValueSet
    #[inline(always)]
    pub fn set_cf_clu_lkas_mode_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[47..49].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_FcwNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS
    #[inline(always)]
    pub fn cf_clu_fcw_n_value_set(&self) -> u8 {
        self.cf_clu_fcw_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_FcwNValueSet
    ///
    /// - Start bit: 51
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_fcw_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[51..53].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_FcwNValueSet
    #[inline(always)]
    pub fn set_cf_clu_fcw_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[51..53].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_PasSpkrLvNValueSet
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_pas_spkr_lv_n_value_set(&self) -> u8 {
        self.cf_clu_pas_spkr_lv_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_PasSpkrLvNValueSet
    ///
    /// - Start bit: 53
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_pas_spkr_lv_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[53..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_PasSpkrLvNValueSet
    #[inline(always)]
    pub fn set_cf_clu_pas_spkr_lv_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[53..56].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_SccDrvModeNValueSet
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: SCC
    #[inline(always)]
    pub fn cf_clu_scc_drv_mode_n_value_set(&self) -> u8 {
        self.cf_clu_scc_drv_mode_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_SccDrvModeNValueSet
    ///
    /// - Start bit: 56
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_scc_drv_mode_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..59].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_SccDrvModeNValueSet
    #[inline(always)]
    pub fn set_cf_clu_scc_drv_mode_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..59].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_HAnBNValueSet
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_h_an_bn_value_set(&self) -> u8 {
        self.cf_clu_h_an_bn_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_HAnBNValueSet
    ///
    /// - Start bit: 59
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_h_an_bn_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[59..61].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_HAnBNValueSet
    #[inline(always)]
    pub fn set_cf_clu_h_an_bn_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[59..61].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_HfreeTrunkTgNValueSet
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: BCM
    #[inline(always)]
    pub fn cf_clu_hfree_trunk_tg_n_value_set(&self) -> u8 {
        self.cf_clu_hfree_trunk_tg_n_value_set_raw()
    }
    
    /// Get raw value of CF_Clu_HfreeTrunkTgNValueSet
    ///
    /// - Start bit: 61
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_hfree_trunk_tg_n_value_set_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[61..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_HfreeTrunkTgNValueSet
    #[inline(always)]
    pub fn set_cf_clu_hfree_trunk_tg_n_value_set(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1301 });
        }
        self.raw.view_bits_mut::<Lsb0>()[61..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Clu14 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Clu14 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Clu14")
                .field("cf_clu_a_dr_un_value_set", &self.cf_clu_a_dr_un_value_set())
                .field("cf_clu_a_dr_ln_value_set", &self.cf_clu_a_dr_ln_value_set())
                .field("cf_clu_escort_hln_value_set", &self.cf_clu_escort_hln_value_set())
                .field("cf_clu_door_lsn_value_set", &self.cf_clu_door_lsn_value_set())
                .field("cf_clu_psmn_value_set", &self.cf_clu_psmn_value_set())
                .field("cf_clu_tt_unlock_n_value_set", &self.cf_clu_tt_unlock_n_value_set())
                .field("cf_clu_ptgmn_value_set", &self.cf_clu_ptgmn_value_set())
                .field("cf_clu_scmn_value_set", &self.cf_clu_scmn_value_set())
                .field("cf_clu_wlight_n_value_set", &self.cf_clu_wlight_n_value_set())
                .field("cf_clu_temp_unit_n_value_set", &self.cf_clu_temp_unit_n_value_set())
                .field("cf_clu_mood_lp_n_value_set", &self.cf_clu_mood_lp_n_value_set())
                .field("cf_clu_trf_chg_set", &self.cf_clu_trf_chg_set())
                .field("cf_clu_ot_turn_n_value_set", &self.cf_clu_ot_turn_n_value_set())
                .field("cf_clu_lca_n_value_set", &self.cf_clu_lca_n_value_set())
                .field("cf_clu_rcta_n_value_set", &self.cf_clu_rcta_n_value_set())
                .field("cf_clu_rcw_n_value_set", &self.cf_clu_rcw_n_value_set())
                .field("cf_clu_esc_off_n_value_set", &self.cf_clu_esc_off_n_value_set())
                .field("cf_clu_scc_navi_crv_n_value_set", &self.cf_clu_scc_navi_crv_n_value_set())
                .field("cf_clu_scc_navi_cam_n_value_set", &self.cf_clu_scc_navi_cam_n_value_set())
                .field("cf_clu_scc_aeb_n_value_set", &self.cf_clu_scc_aeb_n_value_set())
                .field("cf_clu_lkas_mode_n_value_set", &self.cf_clu_lkas_mode_n_value_set())
                .field("cf_clu_fcw_n_value_set", &self.cf_clu_fcw_n_value_set())
                .field("cf_clu_pas_spkr_lv_n_value_set", &self.cf_clu_pas_spkr_lv_n_value_set())
                .field("cf_clu_scc_drv_mode_n_value_set", &self.cf_clu_scc_drv_mode_n_value_set())
                .field("cf_clu_h_an_bn_value_set", &self.cf_clu_h_an_bn_value_set())
                .field("cf_clu_hfree_trunk_tg_n_value_set", &self.cf_clu_hfree_trunk_tg_n_value_set())
            .finish()
        } else {
            f.debug_tuple("Clu14").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Clu14 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_clu_a_dr_un_value_set = u.int_in_range(0..=7)?;
        let cf_clu_a_dr_ln_value_set = u.int_in_range(0..=7)?;
        let cf_clu_escort_hln_value_set = u.int_in_range(0..=3)?;
        let cf_clu_door_lsn_value_set = u.int_in_range(0..=7)?;
        let cf_clu_psmn_value_set = u.int_in_range(0..=7)?;
        let cf_clu_tt_unlock_n_value_set = u.int_in_range(0..=3)?;
        let cf_clu_ptgmn_value_set = u.int_in_range(0..=3)?;
        let cf_clu_scmn_value_set = u.int_in_range(0..=3)?;
        let cf_clu_wlight_n_value_set = u.int_in_range(0..=3)?;
        let cf_clu_temp_unit_n_value_set = u.int_in_range(0..=3)?;
        let cf_clu_mood_lp_n_value_set = u.int_in_range(0..=7)?;
        let cf_clu_trf_chg_set = u.int_in_range(0..=3)?;
        let cf_clu_ot_turn_n_value_set = u.int_in_range(0..=7)?;
        let cf_clu_lca_n_value_set = u.int_in_range(0..=3)?;
        let cf_clu_rcta_n_value_set = u.int_in_range(0..=3)?;
        let cf_clu_rcw_n_value_set = u.int_in_range(0..=3)?;
        let cf_clu_esc_off_n_value_set = u.int_in_range(0..=7)?;
        let cf_clu_scc_navi_crv_n_value_set = u.int_in_range(0..=3)?;
        let cf_clu_scc_navi_cam_n_value_set = u.int_in_range(0..=3)?;
        let cf_clu_scc_aeb_n_value_set = u.int_in_range(0..=3)?;
        let cf_clu_lkas_mode_n_value_set = u.int_in_range(0..=3)?;
        let cf_clu_fcw_n_value_set = u.int_in_range(0..=3)?;
        let cf_clu_pas_spkr_lv_n_value_set = u.int_in_range(0..=7)?;
        let cf_clu_scc_drv_mode_n_value_set = u.int_in_range(0..=7)?;
        let cf_clu_h_an_bn_value_set = u.int_in_range(0..=3)?;
        let cf_clu_hfree_trunk_tg_n_value_set = u.int_in_range(0..=7)?;
        Clu14::new(cf_clu_a_dr_un_value_set,cf_clu_a_dr_ln_value_set,cf_clu_escort_hln_value_set,cf_clu_door_lsn_value_set,cf_clu_psmn_value_set,cf_clu_tt_unlock_n_value_set,cf_clu_ptgmn_value_set,cf_clu_scmn_value_set,cf_clu_wlight_n_value_set,cf_clu_temp_unit_n_value_set,cf_clu_mood_lp_n_value_set,cf_clu_trf_chg_set,cf_clu_ot_turn_n_value_set,cf_clu_lca_n_value_set,cf_clu_rcta_n_value_set,cf_clu_rcw_n_value_set,cf_clu_esc_off_n_value_set,cf_clu_scc_navi_crv_n_value_set,cf_clu_scc_navi_cam_n_value_set,cf_clu_scc_aeb_n_value_set,cf_clu_lkas_mode_n_value_set,cf_clu_fcw_n_value_set,cf_clu_pas_spkr_lv_n_value_set,cf_clu_scc_drv_mode_n_value_set,cf_clu_h_an_bn_value_set,cf_clu_hfree_trunk_tg_n_value_set).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// TCU13
///
/// - ID: 275 (0x113)
/// - Size: 8 bytes
/// - Transmitter: TCU
#[derive(Clone, Copy)]
pub struct Tcu13 {
    raw: [u8; 8],
}

impl Tcu13 {
    pub const MESSAGE_ID: u32 = 275;
    
    pub const N_TGT_LUP_MIN: f32 = 500_f32;
    pub const N_TGT_LUP_MAX: f32 = 3040_f32;
    pub const SLOPE_TCU_MIN: f32 = -16_f32;
    pub const SLOPE_TCU_MAX: f32 = 15.5_f32;
    pub const CF_TCU_BKE_ON_REQ_MIN: u8 = 0_u8;
    pub const CF_TCU_BKE_ON_REQ_MAX: u8 = 3_u8;
    pub const CF_TCU_NC_STAT_MIN: u8 = 0_u8;
    pub const CF_TCU_NC_STAT_MAX: u8 = 3_u8;
    pub const CF_TCU_TAR_GR_MIN: u8 = 0_u8;
    pub const CF_TCU_TAR_GR_MAX: u8 = 15_u8;
    pub const CF_TCU_SHF_PATT_MIN: u8 = 0_u8;
    pub const CF_TCU_SHF_PATT_MAX: u8 = 15_u8;
    pub const CF_TCU_TQ_GRD_LIM_MIN: f32 = 0_f32;
    pub const CF_TCU_TQ_GRD_LIM_MAX: f32 = 2540_f32;
    pub const CR_TCU_ISG_TGT_RPM_MIN: f32 = 0_f32;
    pub const CR_TCU_ISG_TGT_RPM_MAX: f32 = 3500_f32;
    pub const CF_TCU_ALIVE3_MIN: u8 = 0_u8;
    pub const CF_TCU_ALIVE3_MAX: u8 = 3_u8;
    pub const CF_TCU_CHK_SUM3_MIN: u8 = 0_u8;
    pub const CF_TCU_CHK_SUM3_MAX: u8 = 15_u8;
    
    /// Construct new TCU13 from values
    pub fn new(n_tgt_lup: f32, slope_tcu: f32, cf_tcu_inh_cda: bool, cf_tcu_isg_inhib: bool, cf_tcu_bke_on_req: u8, cf_tcu_nc_stat: u8, cf_tcu_tar_gr: u8, cf_tcu_shf_patt: u8, cf_tcu_inh_vis: bool, cf_tcu_p_rel_req: bool, cf_tcu_it_phase: bool, cf_tcu_act_eco_rdy: bool, cf_tcu_tq_grd_lim: f32, cr_tcu_isg_tgt_rpm: f32, cf_tcu_spt_rdy: bool, cf_tcu_sbw_p_info: bool, cf_tcu_alive3: u8, cf_tcu_chk_sum3: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_n_tgt_lup(n_tgt_lup)?;
        res.set_slope_tcu(slope_tcu)?;
        res.set_cf_tcu_inh_cda(cf_tcu_inh_cda)?;
        res.set_cf_tcu_isg_inhib(cf_tcu_isg_inhib)?;
        res.set_cf_tcu_bke_on_req(cf_tcu_bke_on_req)?;
        res.set_cf_tcu_nc_stat(cf_tcu_nc_stat)?;
        res.set_cf_tcu_tar_gr(cf_tcu_tar_gr)?;
        res.set_cf_tcu_shf_patt(cf_tcu_shf_patt)?;
        res.set_cf_tcu_inh_vis(cf_tcu_inh_vis)?;
        res.set_cf_tcu_p_rel_req(cf_tcu_p_rel_req)?;
        res.set_cf_tcu_it_phase(cf_tcu_it_phase)?;
        res.set_cf_tcu_act_eco_rdy(cf_tcu_act_eco_rdy)?;
        res.set_cf_tcu_tq_grd_lim(cf_tcu_tq_grd_lim)?;
        res.set_cr_tcu_isg_tgt_rpm(cr_tcu_isg_tgt_rpm)?;
        res.set_cf_tcu_spt_rdy(cf_tcu_spt_rdy)?;
        res.set_cf_tcu_sbw_p_info(cf_tcu_sbw_p_info)?;
        res.set_cf_tcu_alive3(cf_tcu_alive3)?;
        res.set_cf_tcu_chk_sum3(cf_tcu_chk_sum3)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// N_TGT_LUP
    ///
    /// - Min: 500
    /// - Max: 3040
    /// - Unit: "rpm"
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn n_tgt_lup(&self) -> f32 {
        self.n_tgt_lup_raw()
    }
    
    /// Get raw value of N_TGT_LUP
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 10
    /// - Offset: 500
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn n_tgt_lup_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 10_f32;
        let offset = 500_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of N_TGT_LUP
    #[inline(always)]
    pub fn set_n_tgt_lup(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 500_f32 || 3040_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 275 });
        }
        let factor = 10_f32;
        let offset = 500_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// SLOPE_TCU
    ///
    /// - Min: -16
    /// - Max: 15.5
    /// - Unit: "%"
    /// - Receivers: CLU, CUBIS, EMS, IBOX
    #[inline(always)]
    pub fn slope_tcu(&self) -> f32 {
        self.slope_tcu_raw()
    }
    
    /// Get raw value of SLOPE_TCU
    ///
    /// - Start bit: 8
    /// - Signal size: 6 bits
    /// - Factor: 0.5
    /// - Offset: -16
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn slope_tcu_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..14].load_le::<u8>();
        
        let factor = 0.5_f32;
        let offset = -16_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of SLOPE_TCU
    #[inline(always)]
    pub fn set_slope_tcu(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -16_f32 || 15.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 275 });
        }
        let factor = 0.5_f32;
        let offset = -16_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..14].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_InhCda
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_tcu_inh_cda(&self) -> bool {
        self.cf_tcu_inh_cda_raw()
    }
    
    /// Get raw value of CF_Tcu_InhCda
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_inh_cda_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tcu_InhCda
    #[inline(always)]
    pub fn set_cf_tcu_inh_cda(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[14..15].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_IsgInhib
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_tcu_isg_inhib(&self) -> bool {
        self.cf_tcu_isg_inhib_raw()
    }
    
    /// Get raw value of CF_Tcu_IsgInhib
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_isg_inhib_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tcu_IsgInhib
    #[inline(always)]
    pub fn set_cf_tcu_isg_inhib(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[15..16].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_BkeOnReq
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_tcu_bke_on_req(&self) -> u8 {
        self.cf_tcu_bke_on_req_raw()
    }
    
    /// Get raw value of CF_Tcu_BkeOnReq
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_bke_on_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Tcu_BkeOnReq
    #[inline(always)]
    pub fn set_cf_tcu_bke_on_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 275 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..18].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_NCStat
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_tcu_nc_stat(&self) -> u8 {
        self.cf_tcu_nc_stat_raw()
    }
    
    /// Get raw value of CF_Tcu_NCStat
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_nc_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Tcu_NCStat
    #[inline(always)]
    pub fn set_cf_tcu_nc_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 275 });
        }
        self.raw.view_bits_mut::<Lsb0>()[18..20].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_TarGr
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: _4WD, CLU, DATC, EMS, EPB, ESC, IBOX, SCC
    #[inline(always)]
    pub fn cf_tcu_tar_gr(&self) -> u8 {
        self.cf_tcu_tar_gr_raw()
    }
    
    /// Get raw value of CF_Tcu_TarGr
    ///
    /// - Start bit: 20
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_tar_gr_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Tcu_TarGr
    #[inline(always)]
    pub fn set_cf_tcu_tar_gr(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 275 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..24].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_ShfPatt
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU, CUBIS, EMS, IBOX
    #[inline(always)]
    pub fn cf_tcu_shf_patt(&self) -> u8 {
        self.cf_tcu_shf_patt_raw()
    }
    
    /// Get raw value of CF_Tcu_ShfPatt
    ///
    /// - Start bit: 24
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_shf_patt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..28].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Tcu_ShfPatt
    #[inline(always)]
    pub fn set_cf_tcu_shf_patt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 275 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..28].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_InhVis
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_tcu_inh_vis(&self) -> bool {
        self.cf_tcu_inh_vis_raw()
    }
    
    /// Get raw value of CF_Tcu_InhVis
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_inh_vis_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tcu_InhVis
    #[inline(always)]
    pub fn set_cf_tcu_inh_vis(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[28..29].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_PRelReq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: IBOX, LVR
    #[inline(always)]
    pub fn cf_tcu_p_rel_req(&self) -> bool {
        self.cf_tcu_p_rel_req_raw()
    }
    
    /// Get raw value of CF_Tcu_PRelReq
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_p_rel_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tcu_PRelReq
    #[inline(always)]
    pub fn set_cf_tcu_p_rel_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[29..30].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_ITPhase
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_tcu_it_phase(&self) -> bool {
        self.cf_tcu_it_phase_raw()
    }
    
    /// Get raw value of CF_Tcu_ITPhase
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_it_phase_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tcu_ITPhase
    #[inline(always)]
    pub fn set_cf_tcu_it_phase(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[30..31].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_ActEcoRdy
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_tcu_act_eco_rdy(&self) -> bool {
        self.cf_tcu_act_eco_rdy_raw()
    }
    
    /// Get raw value of CF_Tcu_ActEcoRdy
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_act_eco_rdy_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tcu_ActEcoRdy
    #[inline(always)]
    pub fn set_cf_tcu_act_eco_rdy(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[31..32].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_TqGrdLim
    ///
    /// - Min: 0
    /// - Max: 2540
    /// - Unit: "Nm/s"
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_tcu_tq_grd_lim(&self) -> f32 {
        self.cf_tcu_tq_grd_lim_raw()
    }
    
    /// Get raw value of CF_Tcu_TqGrdLim
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_tq_grd_lim_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 10_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CF_Tcu_TqGrdLim
    #[inline(always)]
    pub fn set_cf_tcu_tq_grd_lim(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2540_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 275 });
        }
        let factor = 10_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// CR_Tcu_IsgTgtRPM
    ///
    /// - Min: 0
    /// - Max: 3500
    /// - Unit: "rpm"
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cr_tcu_isg_tgt_rpm(&self) -> f32 {
        self.cr_tcu_isg_tgt_rpm_raw()
    }
    
    /// Get raw value of CR_Tcu_IsgTgtRPM
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 20
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_tcu_isg_tgt_rpm_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 20_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Tcu_IsgTgtRPM
    #[inline(always)]
    pub fn set_cr_tcu_isg_tgt_rpm(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 3500_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 275 });
        }
        let factor = 20_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_SptRdy
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, IBOX
    #[inline(always)]
    pub fn cf_tcu_spt_rdy(&self) -> bool {
        self.cf_tcu_spt_rdy_raw()
    }
    
    /// Get raw value of CF_Tcu_SptRdy
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_spt_rdy_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[48..49].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tcu_SptRdy
    #[inline(always)]
    pub fn set_cf_tcu_spt_rdy(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[48..49].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_SbwPInfo
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_tcu_sbw_p_info(&self) -> bool {
        self.cf_tcu_sbw_p_info_raw()
    }
    
    /// Get raw value of CF_Tcu_SbwPInfo
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_sbw_p_info_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tcu_SbwPInfo
    #[inline(always)]
    pub fn set_cf_tcu_sbw_p_info(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[56..57].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_Alive3
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_tcu_alive3(&self) -> u8 {
        self.cf_tcu_alive3_raw()
    }
    
    /// Get raw value of CF_Tcu_Alive3
    ///
    /// - Start bit: 58
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_alive3_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[58..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Tcu_Alive3
    #[inline(always)]
    pub fn set_cf_tcu_alive3(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 275 });
        }
        self.raw.view_bits_mut::<Lsb0>()[58..60].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_ChkSum3
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_tcu_chk_sum3(&self) -> u8 {
        self.cf_tcu_chk_sum3_raw()
    }
    
    /// Get raw value of CF_Tcu_ChkSum3
    ///
    /// - Start bit: 60
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_chk_sum3_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Tcu_ChkSum3
    #[inline(always)]
    pub fn set_cf_tcu_chk_sum3(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 275 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Tcu13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Tcu13 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Tcu13")
                .field("n_tgt_lup", &self.n_tgt_lup())
                .field("slope_tcu", &self.slope_tcu())
                .field("cf_tcu_inh_cda", &self.cf_tcu_inh_cda())
                .field("cf_tcu_isg_inhib", &self.cf_tcu_isg_inhib())
                .field("cf_tcu_bke_on_req", &self.cf_tcu_bke_on_req())
                .field("cf_tcu_nc_stat", &self.cf_tcu_nc_stat())
                .field("cf_tcu_tar_gr", &self.cf_tcu_tar_gr())
                .field("cf_tcu_shf_patt", &self.cf_tcu_shf_patt())
                .field("cf_tcu_inh_vis", &self.cf_tcu_inh_vis())
                .field("cf_tcu_p_rel_req", &self.cf_tcu_p_rel_req())
                .field("cf_tcu_it_phase", &self.cf_tcu_it_phase())
                .field("cf_tcu_act_eco_rdy", &self.cf_tcu_act_eco_rdy())
                .field("cf_tcu_tq_grd_lim", &self.cf_tcu_tq_grd_lim())
                .field("cr_tcu_isg_tgt_rpm", &self.cr_tcu_isg_tgt_rpm())
                .field("cf_tcu_spt_rdy", &self.cf_tcu_spt_rdy())
                .field("cf_tcu_sbw_p_info", &self.cf_tcu_sbw_p_info())
                .field("cf_tcu_alive3", &self.cf_tcu_alive3())
                .field("cf_tcu_chk_sum3", &self.cf_tcu_chk_sum3())
            .finish()
        } else {
            f.debug_tuple("Tcu13").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Tcu13 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let n_tgt_lup = u.float_in_range(500_f32..=3040_f32)?;
        let slope_tcu = u.float_in_range(-16_f32..=15.5_f32)?;
        let cf_tcu_inh_cda = u.int_in_range(0..=1)? == 1;
        let cf_tcu_isg_inhib = u.int_in_range(0..=1)? == 1;
        let cf_tcu_bke_on_req = u.int_in_range(0..=3)?;
        let cf_tcu_nc_stat = u.int_in_range(0..=3)?;
        let cf_tcu_tar_gr = u.int_in_range(0..=15)?;
        let cf_tcu_shf_patt = u.int_in_range(0..=15)?;
        let cf_tcu_inh_vis = u.int_in_range(0..=1)? == 1;
        let cf_tcu_p_rel_req = u.int_in_range(0..=1)? == 1;
        let cf_tcu_it_phase = u.int_in_range(0..=1)? == 1;
        let cf_tcu_act_eco_rdy = u.int_in_range(0..=1)? == 1;
        let cf_tcu_tq_grd_lim = u.float_in_range(0_f32..=2540_f32)?;
        let cr_tcu_isg_tgt_rpm = u.float_in_range(0_f32..=3500_f32)?;
        let cf_tcu_spt_rdy = u.int_in_range(0..=1)? == 1;
        let cf_tcu_sbw_p_info = u.int_in_range(0..=1)? == 1;
        let cf_tcu_alive3 = u.int_in_range(0..=3)?;
        let cf_tcu_chk_sum3 = u.int_in_range(0..=15)?;
        Tcu13::new(n_tgt_lup,slope_tcu,cf_tcu_inh_cda,cf_tcu_isg_inhib,cf_tcu_bke_on_req,cf_tcu_nc_stat,cf_tcu_tar_gr,cf_tcu_shf_patt,cf_tcu_inh_vis,cf_tcu_p_rel_req,cf_tcu_it_phase,cf_tcu_act_eco_rdy,cf_tcu_tq_grd_lim,cr_tcu_isg_tgt_rpm,cf_tcu_spt_rdy,cf_tcu_sbw_p_info,cf_tcu_alive3,cf_tcu_chk_sum3).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// TCU12
///
/// - ID: 274 (0x112)
/// - Size: 8 bytes
/// - Transmitter: TCU
#[derive(Clone, Copy)]
pub struct Tcu12 {
    raw: [u8; 8],
}

impl Tcu12 {
    pub const MESSAGE_ID: u32 = 274;
    
    pub const ETL_TCU_MIN: f32 = 0_f32;
    pub const ETL_TCU_MAX: f32 = 508_f32;
    pub const CUR_GR_MIN: u8 = 0_u8;
    pub const CUR_GR_MAX: u8 = 15_u8;
    pub const CF_TCU_ALIVE_MIN: u8 = 0_u8;
    pub const CF_TCU_ALIVE_MAX: u8 = 3_u8;
    pub const CF_TCU_CHK_SUM_MIN: u8 = 0_u8;
    pub const CF_TCU_CHK_SUM_MAX: u8 = 3_u8;
    pub const VS_TCU_MIN: u8 = 0_u8;
    pub const VS_TCU_MAX: u8 = 254_u8;
    pub const SPK_RTD_TCU_MIN: f32 = -15_f32;
    pub const SPK_RTD_TCU_MAX: f32 = 15_f32;
    pub const N_TC_RAW_MIN: f32 = 0_f32;
    pub const N_TC_RAW_MAX: f32 = 16383.5_f32;
    pub const VS_TCU_DECIMAL_MIN: f32 = 0_f32;
    pub const VS_TCU_DECIMAL_MAX: f32 = 0.9921875_f32;
    
    /// Construct new TCU12 from values
    pub fn new(etl_tcu: f32, cur_gr: u8, cf_tcu_alive: u8, cf_tcu_chk_sum: u8, vs_tcu: u8, fuel_cut_tcu: bool, inh_fuel_cut: bool, idle_up_tcu: bool, n_inc_tcu: bool, spk_rtd_tcu: f32, n_tc_raw: f32, vs_tcu_decimal: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_etl_tcu(etl_tcu)?;
        res.set_cur_gr(cur_gr)?;
        res.set_cf_tcu_alive(cf_tcu_alive)?;
        res.set_cf_tcu_chk_sum(cf_tcu_chk_sum)?;
        res.set_vs_tcu(vs_tcu)?;
        res.set_fuel_cut_tcu(fuel_cut_tcu)?;
        res.set_inh_fuel_cut(inh_fuel_cut)?;
        res.set_idle_up_tcu(idle_up_tcu)?;
        res.set_n_inc_tcu(n_inc_tcu)?;
        res.set_spk_rtd_tcu(spk_rtd_tcu)?;
        res.set_n_tc_raw(n_tc_raw)?;
        res.set_vs_tcu_decimal(vs_tcu_decimal)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// ETL_TCU
    ///
    /// - Min: 0
    /// - Max: 508
    /// - Unit: "Nm"
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn etl_tcu(&self) -> f32 {
        self.etl_tcu_raw()
    }
    
    /// Get raw value of ETL_TCU
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 2
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn etl_tcu_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 2_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of ETL_TCU
    #[inline(always)]
    pub fn set_etl_tcu(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 508_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 274 });
        }
        let factor = 2_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// CUR_GR
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, ESC, IBOX, SCC, TPMS
    #[inline(always)]
    pub fn cur_gr(&self) -> Tcu12CurGr {
        let signal = self.raw.view_bits::<Lsb0>()[8..12].load_le::<u8>();
        
        match signal {
            1 => Tcu12CurGr::X1,
            2 => Tcu12CurGr::X2,
            3 => Tcu12CurGr::X3,
            4 => Tcu12CurGr::X4,
            5 => Tcu12CurGr::X5,
            6 => Tcu12CurGr::X6,
            7 => Tcu12CurGr::X7,
            8 => Tcu12CurGr::X8,
            14 => Tcu12CurGr::R,
            0 => Tcu12CurGr::P,
            _ => Tcu12CurGr::_Other(self.cur_gr_raw()),
        }
    }
    
    /// Get raw value of CUR_GR
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cur_gr_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CUR_GR
    #[inline(always)]
    pub fn set_cur_gr(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 274 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..12].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_Alive
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, ESC, IBOX, SCC
    #[inline(always)]
    pub fn cf_tcu_alive(&self) -> u8 {
        self.cf_tcu_alive_raw()
    }
    
    /// Get raw value of CF_Tcu_Alive
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_alive_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Tcu_Alive
    #[inline(always)]
    pub fn set_cf_tcu_alive(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 274 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..14].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_ChkSum
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, ESC, IBOX, SCC
    #[inline(always)]
    pub fn cf_tcu_chk_sum(&self) -> u8 {
        self.cf_tcu_chk_sum_raw()
    }
    
    /// Get raw value of CF_Tcu_ChkSum
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_chk_sum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Tcu_ChkSum
    #[inline(always)]
    pub fn set_cf_tcu_chk_sum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 274 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
    /// VS_TCU
    ///
    /// - Min: 0
    /// - Max: 254
    /// - Unit: "km/h"
    /// - Receivers: BCM, CLU, DATC, EMS, IBOX, LCA, LVR, PGS, SMK, SNV
    #[inline(always)]
    pub fn vs_tcu(&self) -> u8 {
        self.vs_tcu_raw()
    }
    
    /// Get raw value of VS_TCU
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vs_tcu_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VS_TCU
    #[inline(always)]
    pub fn set_vs_tcu(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 254_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 274 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// FUEL_CUT_TCU
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn fuel_cut_tcu(&self) -> bool {
        self.fuel_cut_tcu_raw()
    }
    
    /// Get raw value of FUEL_CUT_TCU
    ///
    /// - Start bit: 28
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fuel_cut_tcu_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[28..29].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of FUEL_CUT_TCU
    #[inline(always)]
    pub fn set_fuel_cut_tcu(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[28..29].store_le(value);
        Ok(())
    }
    
    /// INH_FUEL_CUT
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn inh_fuel_cut(&self) -> bool {
        self.inh_fuel_cut_raw()
    }
    
    /// Get raw value of INH_FUEL_CUT
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn inh_fuel_cut_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of INH_FUEL_CUT
    #[inline(always)]
    pub fn set_inh_fuel_cut(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[29..30].store_le(value);
        Ok(())
    }
    
    /// IDLE_UP_TCU
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn idle_up_tcu(&self) -> bool {
        self.idle_up_tcu_raw()
    }
    
    /// Get raw value of IDLE_UP_TCU
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn idle_up_tcu_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[30..31].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of IDLE_UP_TCU
    #[inline(always)]
    pub fn set_idle_up_tcu(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[30..31].store_le(value);
        Ok(())
    }
    
    /// N_INC_TCU
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn n_inc_tcu(&self) -> bool {
        self.n_inc_tcu_raw()
    }
    
    /// Get raw value of N_INC_TCU
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn n_inc_tcu_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of N_INC_TCU
    #[inline(always)]
    pub fn set_n_inc_tcu(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[31..32].store_le(value);
        Ok(())
    }
    
    /// SPK_RTD_TCU
    ///
    /// - Min: -15
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn spk_rtd_tcu(&self) -> f32 {
        self.spk_rtd_tcu_raw()
    }
    
    /// Get raw value of SPK_RTD_TCU
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.375
    /// - Offset: -23.625
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn spk_rtd_tcu_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 0.375_f32;
        let offset = -23.625_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of SPK_RTD_TCU
    #[inline(always)]
    pub fn set_spk_rtd_tcu(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -15_f32 || 15_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 274 });
        }
        let factor = 0.375_f32;
        let offset = -23.625_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// N_TC_RAW
    ///
    /// - Min: 0
    /// - Max: 16383.5
    /// - Unit: "rpm"
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn n_tc_raw(&self) -> f32 {
        self.n_tc_raw_raw()
    }
    
    /// Get raw value of N_TC_RAW
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 0.25
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn n_tc_raw_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..56].load_le::<u16>();
        
        let factor = 0.25_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of N_TC_RAW
    #[inline(always)]
    pub fn set_n_tc_raw(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 16383.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 274 });
        }
        let factor = 0.25_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[40..56].store_le(value);
        Ok(())
    }
    
    /// VS_TCU_DECIMAL
    ///
    /// - Min: 0
    /// - Max: 0.9921875
    /// - Unit: "km/h"
    /// - Receivers: CLU, EMS, IBOX, LCA
    #[inline(always)]
    pub fn vs_tcu_decimal(&self) -> f32 {
        self.vs_tcu_decimal_raw()
    }
    
    /// Get raw value of VS_TCU_DECIMAL
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 0.0078125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vs_tcu_decimal_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        let factor = 0.0078125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of VS_TCU_DECIMAL
    #[inline(always)]
    pub fn set_vs_tcu_decimal(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 0.9921875_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 274 });
        }
        let factor = 0.0078125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Tcu12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Tcu12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Tcu12")
                .field("etl_tcu", &self.etl_tcu())
                .field("cur_gr", &self.cur_gr())
                .field("cf_tcu_alive", &self.cf_tcu_alive())
                .field("cf_tcu_chk_sum", &self.cf_tcu_chk_sum())
                .field("vs_tcu", &self.vs_tcu())
                .field("fuel_cut_tcu", &self.fuel_cut_tcu())
                .field("inh_fuel_cut", &self.inh_fuel_cut())
                .field("idle_up_tcu", &self.idle_up_tcu())
                .field("n_inc_tcu", &self.n_inc_tcu())
                .field("spk_rtd_tcu", &self.spk_rtd_tcu())
                .field("n_tc_raw", &self.n_tc_raw())
                .field("vs_tcu_decimal", &self.vs_tcu_decimal())
            .finish()
        } else {
            f.debug_tuple("Tcu12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Tcu12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let etl_tcu = u.float_in_range(0_f32..=508_f32)?;
        let cur_gr = u.int_in_range(0..=15)?;
        let cf_tcu_alive = u.int_in_range(0..=3)?;
        let cf_tcu_chk_sum = u.int_in_range(0..=3)?;
        let vs_tcu = u.int_in_range(0..=254)?;
        let fuel_cut_tcu = u.int_in_range(0..=1)? == 1;
        let inh_fuel_cut = u.int_in_range(0..=1)? == 1;
        let idle_up_tcu = u.int_in_range(0..=1)? == 1;
        let n_inc_tcu = u.int_in_range(0..=1)? == 1;
        let spk_rtd_tcu = u.float_in_range(-15_f32..=15_f32)?;
        let n_tc_raw = u.float_in_range(0_f32..=16383.5_f32)?;
        let vs_tcu_decimal = u.float_in_range(0_f32..=0.9921875_f32)?;
        Tcu12::new(etl_tcu,cur_gr,cf_tcu_alive,cf_tcu_chk_sum,vs_tcu,fuel_cut_tcu,inh_fuel_cut,idle_up_tcu,n_inc_tcu,spk_rtd_tcu,n_tc_raw,vs_tcu_decimal).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for CUR_GR
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Tcu12CurGr {
    X1,
    X2,
    X3,
    X4,
    X5,
    X6,
    X7,
    X8,
    R,
    P,
    _Other(u8),
}

impl From<Tcu12CurGr> for u8 {
    fn from(val: Tcu12CurGr) -> u8 {
        match val {
            Tcu12CurGr::X1 => 1,
            Tcu12CurGr::X2 => 2,
            Tcu12CurGr::X3 => 3,
            Tcu12CurGr::X4 => 4,
            Tcu12CurGr::X5 => 5,
            Tcu12CurGr::X6 => 6,
            Tcu12CurGr::X7 => 7,
            Tcu12CurGr::X8 => 8,
            Tcu12CurGr::R => 14,
            Tcu12CurGr::P => 0,
            Tcu12CurGr::_Other(x) => x,
        }
    }
}


/// TCU11
///
/// - ID: 273 (0x111)
/// - Size: 8 bytes
/// - Transmitter: TCU
#[derive(Clone, Copy)]
pub struct Tcu11 {
    raw: [u8; 8],
}

impl Tcu11 {
    pub const MESSAGE_ID: u32 = 273;
    
    pub const TQI_TCU_INC_MIN: f32 = 0_f32;
    pub const TQI_TCU_INC_MAX: f32 = 99.609375_f32;
    pub const G_SEL_DISP_MIN: u8 = 0_u8;
    pub const G_SEL_DISP_MAX: u8 = 15_u8;
    pub const F_TCU_MIN: u8 = 0_u8;
    pub const F_TCU_MAX: u8 = 3_u8;
    pub const TCU_TYPE_MIN: u8 = 0_u8;
    pub const TCU_TYPE_MAX: u8 = 3_u8;
    pub const TCU_OBD_MIN: u8 = 0_u8;
    pub const TCU_OBD_MAX: u8 = 7_u8;
    pub const GEAR_TYPE_MIN: u8 = 0_u8;
    pub const GEAR_TYPE_MAX: u8 = 15_u8;
    pub const TQI_TCU_MIN: f32 = 0_f32;
    pub const TQI_TCU_MAX: f32 = 99.609375_f32;
    pub const TEMP_AT_MIN: f32 = -40_f32;
    pub const TEMP_AT_MAX: f32 = 214_f32;
    pub const N_TC_MIN: f32 = 0_f32;
    pub const N_TC_MAX: f32 = 16383.5_f32;
    pub const SWI_CC_MIN: u8 = 0_u8;
    pub const SWI_CC_MAX: u8 = 3_u8;
    pub const CF_TCU_ALIVE1_MIN: u8 = 0_u8;
    pub const CF_TCU_ALIVE1_MAX: u8 = 3_u8;
    pub const CF_TCU_CHK_SUM1_MIN: u8 = 0_u8;
    pub const CF_TCU_CHK_SUM1_MAX: u8 = 15_u8;
    
    /// Construct new TCU11 from values
    pub fn new(tqi_tcu_inc: f32, g_sel_disp: u8, f_tcu: u8, tcu_type: u8, tcu_obd: u8, swi_gs: bool, gear_type: u8, tqi_tcu: f32, temp_at: f32, n_tc: f32, swi_cc: u8, cf_tcu_alive1: u8, cf_tcu_chk_sum1: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_tqi_tcu_inc(tqi_tcu_inc)?;
        res.set_g_sel_disp(g_sel_disp)?;
        res.set_f_tcu(f_tcu)?;
        res.set_tcu_type(tcu_type)?;
        res.set_tcu_obd(tcu_obd)?;
        res.set_swi_gs(swi_gs)?;
        res.set_gear_type(gear_type)?;
        res.set_tqi_tcu(tqi_tcu)?;
        res.set_temp_at(temp_at)?;
        res.set_n_tc(n_tc)?;
        res.set_swi_cc(swi_cc)?;
        res.set_cf_tcu_alive1(cf_tcu_alive1)?;
        res.set_cf_tcu_chk_sum1(cf_tcu_chk_sum1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// TQI_TCU_INC
    ///
    /// - Min: 0
    /// - Max: 99.609375
    /// - Unit: "%"
    /// - Receivers: EMS, ESC, IBOX
    #[inline(always)]
    pub fn tqi_tcu_inc(&self) -> f32 {
        self.tqi_tcu_inc_raw()
    }
    
    /// Get raw value of TQI_TCU_INC
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_tcu_inc_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI_TCU_INC
    #[inline(always)]
    pub fn set_tqi_tcu_inc(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.609375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 273 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// G_SEL_DISP
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: _4WD, AFLS, AVM, BCM, CGW, CLU, CUBIS, ECS, EMS, EPB, ESC, IAP, IBOX, LCA, LDWS_LKAS, LVR, MDPS, PGS, SCC, SMK, SNV, SPAS, TPMS
    #[inline(always)]
    pub fn g_sel_disp(&self) -> u8 {
        self.g_sel_disp_raw()
    }
    
    /// Get raw value of G_SEL_DISP
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn g_sel_disp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of G_SEL_DISP
    #[inline(always)]
    pub fn set_g_sel_disp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 273 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..12].store_le(value);
        Ok(())
    }
    
    /// F_TCU
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, ESC, IBOX
    #[inline(always)]
    pub fn f_tcu(&self) -> u8 {
        self.f_tcu_raw()
    }
    
    /// Get raw value of F_TCU
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn f_tcu_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of F_TCU
    #[inline(always)]
    pub fn set_f_tcu(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 273 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..14].store_le(value);
        Ok(())
    }
    
    /// TCU_TYPE
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, ESC, IBOX
    #[inline(always)]
    pub fn tcu_type(&self) -> u8 {
        self.tcu_type_raw()
    }
    
    /// Get raw value of TCU_TYPE
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tcu_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of TCU_TYPE
    #[inline(always)]
    pub fn set_tcu_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 273 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
    /// TCU_OBD
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: EMS, ESC, IBOX
    #[inline(always)]
    pub fn tcu_obd(&self) -> u8 {
        self.tcu_obd_raw()
    }
    
    /// Get raw value of TCU_OBD
    ///
    /// - Start bit: 16
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tcu_obd_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..19].load_le::<u8>();
        
        signal
    }
    
    /// Set value of TCU_OBD
    #[inline(always)]
    pub fn set_tcu_obd(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 273 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..19].store_le(value);
        Ok(())
    }
    
    /// SWI_GS
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, EMS, EPB, ESC, IBOX, SCC
    #[inline(always)]
    pub fn swi_gs(&self) -> bool {
        self.swi_gs_raw()
    }
    
    /// Get raw value of SWI_GS
    ///
    /// - Start bit: 19
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn swi_gs_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[19..20].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of SWI_GS
    #[inline(always)]
    pub fn set_swi_gs(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[19..20].store_le(value);
        Ok(())
    }
    
    /// GEAR_TYPE
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: _4WD, CLU, EMS, ESC, IBOX, SCC
    #[inline(always)]
    pub fn gear_type(&self) -> u8 {
        self.gear_type_raw()
    }
    
    /// Get raw value of GEAR_TYPE
    ///
    /// - Start bit: 20
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gear_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of GEAR_TYPE
    #[inline(always)]
    pub fn set_gear_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 273 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..24].store_le(value);
        Ok(())
    }
    
    /// TQI_TCU
    ///
    /// - Min: 0
    /// - Max: 99.609375
    /// - Unit: "%"
    /// - Receivers: EMS, ESC, IBOX
    #[inline(always)]
    pub fn tqi_tcu(&self) -> f32 {
        self.tqi_tcu_raw()
    }
    
    /// Get raw value of TQI_TCU
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_tcu_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI_TCU
    #[inline(always)]
    pub fn set_tqi_tcu(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.609375_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 273 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// TEMP_AT
    ///
    /// - Min: -40
    /// - Max: 214
    /// - Unit: "deg"
    /// - Receivers: AAF, CLU, CUBIS, EMS, ESC, IBOX
    #[inline(always)]
    pub fn temp_at(&self) -> f32 {
        self.temp_at_raw()
    }
    
    /// Get raw value of TEMP_AT
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -40
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn temp_at_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -40_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TEMP_AT
    #[inline(always)]
    pub fn set_temp_at(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -40_f32 || 214_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 273 });
        }
        let factor = 1_f32;
        let offset = -40_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// N_TC
    ///
    /// - Min: 0
    /// - Max: 16383.5
    /// - Unit: "rpm"
    /// - Receivers: _4WD, EMS, EPB, ESC, IBOX
    #[inline(always)]
    pub fn n_tc(&self) -> f32 {
        self.n_tc_raw()
    }
    
    /// Get raw value of N_TC
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 0.25
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn n_tc_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..56].load_le::<u16>();
        
        let factor = 0.25_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of N_TC
    #[inline(always)]
    pub fn set_n_tc(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 16383.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 273 });
        }
        let factor = 0.25_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[40..56].store_le(value);
        Ok(())
    }
    
    /// SWI_CC
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: _4WD, CLU, EMS, ESC, IBOX
    #[inline(always)]
    pub fn swi_cc(&self) -> u8 {
        self.swi_cc_raw()
    }
    
    /// Get raw value of SWI_CC
    ///
    /// - Start bit: 56
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn swi_cc_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..58].load_le::<u8>();
        
        signal
    }
    
    /// Set value of SWI_CC
    #[inline(always)]
    pub fn set_swi_cc(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 273 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..58].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_Alive1
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_tcu_alive1(&self) -> u8 {
        self.cf_tcu_alive1_raw()
    }
    
    /// Get raw value of CF_Tcu_Alive1
    ///
    /// - Start bit: 58
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_alive1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[58..60].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Tcu_Alive1
    #[inline(always)]
    pub fn set_cf_tcu_alive1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 273 });
        }
        self.raw.view_bits_mut::<Lsb0>()[58..60].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_ChkSum1
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: EMS, IBOX
    #[inline(always)]
    pub fn cf_tcu_chk_sum1(&self) -> u8 {
        self.cf_tcu_chk_sum1_raw()
    }
    
    /// Get raw value of CF_Tcu_ChkSum1
    ///
    /// - Start bit: 60
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_chk_sum1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Tcu_ChkSum1
    #[inline(always)]
    pub fn set_cf_tcu_chk_sum1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 273 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Tcu11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Tcu11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Tcu11")
                .field("tqi_tcu_inc", &self.tqi_tcu_inc())
                .field("g_sel_disp", &self.g_sel_disp())
                .field("f_tcu", &self.f_tcu())
                .field("tcu_type", &self.tcu_type())
                .field("tcu_obd", &self.tcu_obd())
                .field("swi_gs", &self.swi_gs())
                .field("gear_type", &self.gear_type())
                .field("tqi_tcu", &self.tqi_tcu())
                .field("temp_at", &self.temp_at())
                .field("n_tc", &self.n_tc())
                .field("swi_cc", &self.swi_cc())
                .field("cf_tcu_alive1", &self.cf_tcu_alive1())
                .field("cf_tcu_chk_sum1", &self.cf_tcu_chk_sum1())
            .finish()
        } else {
            f.debug_tuple("Tcu11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Tcu11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let tqi_tcu_inc = u.float_in_range(0_f32..=99.609375_f32)?;
        let g_sel_disp = u.int_in_range(0..=15)?;
        let f_tcu = u.int_in_range(0..=3)?;
        let tcu_type = u.int_in_range(0..=3)?;
        let tcu_obd = u.int_in_range(0..=7)?;
        let swi_gs = u.int_in_range(0..=1)? == 1;
        let gear_type = u.int_in_range(0..=15)?;
        let tqi_tcu = u.float_in_range(0_f32..=99.609375_f32)?;
        let temp_at = u.float_in_range(-40_f32..=214_f32)?;
        let n_tc = u.float_in_range(0_f32..=16383.5_f32)?;
        let swi_cc = u.int_in_range(0..=3)?;
        let cf_tcu_alive1 = u.int_in_range(0..=3)?;
        let cf_tcu_chk_sum1 = u.int_in_range(0..=15)?;
        Tcu11::new(tqi_tcu_inc,g_sel_disp,f_tcu,tcu_type,tcu_obd,swi_gs,gear_type,tqi_tcu,temp_at,n_tc,swi_cc,cf_tcu_alive1,cf_tcu_chk_sum1).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ACU13
///
/// - ID: 16 (0x10)
/// - Size: 8 bytes
/// - Transmitter: ACU
#[derive(Clone, Copy)]
pub struct Acu13 {
    raw: [u8; 8],
}

impl Acu13 {
    pub const MESSAGE_ID: u32 = 16;
    
    
    /// Construct new ACU13 from values
    pub fn new(cf_acu_csh_act: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_acu_csh_act(cf_acu_csh_act)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Acu_CshAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CUBIS, IBOX, ODS
    #[inline(always)]
    pub fn cf_acu_csh_act(&self) -> bool {
        self.cf_acu_csh_act_raw()
    }
    
    /// Get raw value of CF_Acu_CshAct
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_acu_csh_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Acu_CshAct
    #[inline(always)]
    pub fn set_cf_acu_csh_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Acu13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Acu13 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Acu13")
                .field("cf_acu_csh_act", &self.cf_acu_csh_act())
            .finish()
        } else {
            f.debug_tuple("Acu13").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Acu13 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_acu_csh_act = u.int_in_range(0..=1)? == 1;
        Acu13::new(cf_acu_csh_act).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// CGW_USM1
///
/// - ID: 1040 (0x410)
/// - Size: 8 bytes
/// - Transmitter: BCM
#[derive(Clone, Copy)]
pub struct CgwUsm1 {
    raw: [u8; 8],
}

impl CgwUsm1 {
    pub const MESSAGE_ID: u32 = 1040;
    
    pub const CF_GWAY_AT_TURN_R_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_AT_TURN_R_VALUE_MAX: u8 = 3_u8;
    pub const CF_GWAY_PTGMR_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_PTGMR_VALUE_MAX: u8 = 3_u8;
    pub const CF_GWAY_ESCORT_HLR_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_ESCORT_HLR_VALUE_MAX: u8 = 3_u8;
    pub const CF_GWAY_TT_UNLOCK_R_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_TT_UNLOCK_R_VALUE_MAX: u8 = 3_u8;
    pub const CF_GWAY_A_DR_LR_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_A_DR_LR_VALUE_MAX: u8 = 7_u8;
    pub const CF_GWAY_A_DR_UR_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_A_DR_UR_VALUE_MAX: u8 = 7_u8;
    pub const CF_GWAY_SCMR_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_SCMR_VALUE_MAX: u8 = 3_u8;
    pub const CF_GWAY_WLIGHT_R_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_WLIGHT_R_VALUE_MAX: u8 = 3_u8;
    pub const CF_GWAY_PSMR_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_PSMR_VALUE_MAX: u8 = 7_u8;
    pub const CF_GWAY_OT_TURN_R_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_OT_TURN_R_VALUE_MAX: u8 = 7_u8;
    pub const CF_GWAY_DR_LOCK_SOUND_R_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_DR_LOCK_SOUND_R_VALUE_MAX: u8 = 7_u8;
    pub const CF_GWAY_H_AN_BR_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_H_AN_BR_VALUE_MAX: u8 = 7_u8;
    pub const CF_GWAY_MOOD_LP_R_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_MOOD_LP_R_VALUE_MAX: u8 = 3_u8;
    pub const CF_GWAY_HFREE_TRUNK_R_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_HFREE_TRUNK_R_VALUE_MAX: u8 = 7_u8;
    pub const CF_GWAY_AUTO_LIGHT_R_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_AUTO_LIGHT_R_VALUE_MAX: u8 = 7_u8;
    pub const CF_GWAY_REAR_WIPER_R_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_REAR_WIPER_R_VALUE_MAX: u8 = 3_u8;
    pub const CF_GWAY_PAS_SPKR_LV_R_VALUE_MIN: u8 = 0_u8;
    pub const CF_GWAY_PAS_SPKR_LV_R_VALUE_MAX: u8 = 7_u8;
    
    /// Construct new CGW_USM1 from values
    pub fn new(cf_gway_at_turn_r_value: u8, cf_gway_ptgmr_value: u8, cf_gway_escort_hlr_value: u8, cf_gway_tt_unlock_r_value: u8, cf_gway_a_dr_lr_value: u8, cf_gway_a_dr_ur_value: u8, cf_gway_scmr_value: u8, cf_gway_wlight_r_value: u8, cf_gway_psmr_value: u8, cf_gway_ot_turn_r_value: u8, cf_gway_dr_lock_sound_r_value: u8, cf_gway_h_an_br_value: u8, cf_gway_mood_lp_r_value: u8, cf_gway_hfree_trunk_r_value: u8, cf_gway_auto_light_r_value: u8, cf_gway_rear_wiper_r_value: u8, cf_gway_pas_spkr_lv_r_value: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_gway_at_turn_r_value(cf_gway_at_turn_r_value)?;
        res.set_cf_gway_ptgmr_value(cf_gway_ptgmr_value)?;
        res.set_cf_gway_escort_hlr_value(cf_gway_escort_hlr_value)?;
        res.set_cf_gway_tt_unlock_r_value(cf_gway_tt_unlock_r_value)?;
        res.set_cf_gway_a_dr_lr_value(cf_gway_a_dr_lr_value)?;
        res.set_cf_gway_a_dr_ur_value(cf_gway_a_dr_ur_value)?;
        res.set_cf_gway_scmr_value(cf_gway_scmr_value)?;
        res.set_cf_gway_wlight_r_value(cf_gway_wlight_r_value)?;
        res.set_cf_gway_psmr_value(cf_gway_psmr_value)?;
        res.set_cf_gway_ot_turn_r_value(cf_gway_ot_turn_r_value)?;
        res.set_cf_gway_dr_lock_sound_r_value(cf_gway_dr_lock_sound_r_value)?;
        res.set_cf_gway_h_an_br_value(cf_gway_h_an_br_value)?;
        res.set_cf_gway_mood_lp_r_value(cf_gway_mood_lp_r_value)?;
        res.set_cf_gway_hfree_trunk_r_value(cf_gway_hfree_trunk_r_value)?;
        res.set_cf_gway_auto_light_r_value(cf_gway_auto_light_r_value)?;
        res.set_cf_gway_rear_wiper_r_value(cf_gway_rear_wiper_r_value)?;
        res.set_cf_gway_pas_spkr_lv_r_value(cf_gway_pas_spkr_lv_r_value)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Gway_ATTurnRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_at_turn_r_value(&self) -> u8 {
        self.cf_gway_at_turn_r_value_raw()
    }
    
    /// Get raw value of CF_Gway_ATTurnRValue
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_at_turn_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_ATTurnRValue
    #[inline(always)]
    pub fn set_cf_gway_at_turn_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PTGMRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_ptgmr_value(&self) -> u8 {
        self.cf_gway_ptgmr_value_raw()
    }
    
    /// Get raw value of CF_Gway_PTGMRValue
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ptgmr_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PTGMRValue
    #[inline(always)]
    pub fn set_cf_gway_ptgmr_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_EscortHLRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_escort_hlr_value(&self) -> u8 {
        self.cf_gway_escort_hlr_value_raw()
    }
    
    /// Get raw value of CF_Gway_EscortHLRValue
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_escort_hlr_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_EscortHLRValue
    #[inline(always)]
    pub fn set_cf_gway_escort_hlr_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_TTUnlockRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_tt_unlock_r_value(&self) -> u8 {
        self.cf_gway_tt_unlock_r_value_raw()
    }
    
    /// Get raw value of CF_Gway_TTUnlockRValue
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_tt_unlock_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_TTUnlockRValue
    #[inline(always)]
    pub fn set_cf_gway_tt_unlock_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_ADrLRValue
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_a_dr_lr_value(&self) -> u8 {
        self.cf_gway_a_dr_lr_value_raw()
    }
    
    /// Get raw value of CF_Gway_ADrLRValue
    ///
    /// - Start bit: 8
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_a_dr_lr_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_ADrLRValue
    #[inline(always)]
    pub fn set_cf_gway_a_dr_lr_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..11].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_ADrURValue
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_a_dr_ur_value(&self) -> u8 {
        self.cf_gway_a_dr_ur_value_raw()
    }
    
    /// Get raw value of CF_Gway_ADrURValue
    ///
    /// - Start bit: 11
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_a_dr_ur_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[11..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_ADrURValue
    #[inline(always)]
    pub fn set_cf_gway_a_dr_ur_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[11..14].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_SCMRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_scmr_value(&self) -> u8 {
        self.cf_gway_scmr_value_raw()
    }
    
    /// Get raw value of CF_Gway_SCMRValue
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_scmr_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_SCMRValue
    #[inline(always)]
    pub fn set_cf_gway_scmr_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_WlightRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_wlight_r_value(&self) -> u8 {
        self.cf_gway_wlight_r_value_raw()
    }
    
    /// Get raw value of CF_Gway_WlightRValue
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_wlight_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_WlightRValue
    #[inline(always)]
    pub fn set_cf_gway_wlight_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..18].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PSMRValue
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_psmr_value(&self) -> u8 {
        self.cf_gway_psmr_value_raw()
    }
    
    /// Get raw value of CF_Gway_PSMRValue
    ///
    /// - Start bit: 18
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_psmr_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[18..21].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PSMRValue
    #[inline(always)]
    pub fn set_cf_gway_psmr_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[18..21].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_OTTurnRValue
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_ot_turn_r_value(&self) -> u8 {
        self.cf_gway_ot_turn_r_value_raw()
    }
    
    /// Get raw value of CF_Gway_OTTurnRValue
    ///
    /// - Start bit: 21
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_ot_turn_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[21..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_OTTurnRValue
    #[inline(always)]
    pub fn set_cf_gway_ot_turn_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[21..24].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_DrLockSoundRValue
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_dr_lock_sound_r_value(&self) -> u8 {
        self.cf_gway_dr_lock_sound_r_value_raw()
    }
    
    /// Get raw value of CF_Gway_DrLockSoundRValue
    ///
    /// - Start bit: 24
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_dr_lock_sound_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..27].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_DrLockSoundRValue
    #[inline(always)]
    pub fn set_cf_gway_dr_lock_sound_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..27].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_HAnBRValue
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_h_an_br_value(&self) -> u8 {
        self.cf_gway_h_an_br_value_raw()
    }
    
    /// Get raw value of CF_Gway_HAnBRValue
    ///
    /// - Start bit: 27
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_h_an_br_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[27..30].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_HAnBRValue
    #[inline(always)]
    pub fn set_cf_gway_h_an_br_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[27..30].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_MoodLpRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_mood_lp_r_value(&self) -> u8 {
        self.cf_gway_mood_lp_r_value_raw()
    }
    
    /// Get raw value of CF_Gway_MoodLpRValue
    ///
    /// - Start bit: 30
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_mood_lp_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[30..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_MoodLpRValue
    #[inline(always)]
    pub fn set_cf_gway_mood_lp_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[30..32].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_HfreeTrunkRValue
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_hfree_trunk_r_value(&self) -> u8 {
        self.cf_gway_hfree_trunk_r_value_raw()
    }
    
    /// Get raw value of CF_Gway_HfreeTrunkRValue
    ///
    /// - Start bit: 32
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_hfree_trunk_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..35].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_HfreeTrunkRValue
    #[inline(always)]
    pub fn set_cf_gway_hfree_trunk_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..35].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_AutoLightRValue
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_auto_light_r_value(&self) -> u8 {
        self.cf_gway_auto_light_r_value_raw()
    }
    
    /// Get raw value of CF_Gway_AutoLightRValue
    ///
    /// - Start bit: 35
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_auto_light_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[35..38].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_AutoLightRValue
    #[inline(always)]
    pub fn set_cf_gway_auto_light_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[35..38].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_RearWiperRValue
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_rear_wiper_r_value(&self) -> u8 {
        self.cf_gway_rear_wiper_r_value_raw()
    }
    
    /// Get raw value of CF_Gway_RearWiperRValue
    ///
    /// - Start bit: 38
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_rear_wiper_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[38..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_RearWiperRValue
    #[inline(always)]
    pub fn set_cf_gway_rear_wiper_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[38..40].store_le(value);
        Ok(())
    }
    
    /// CF_Gway_PasSpkrLvRValue
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_gway_pas_spkr_lv_r_value(&self) -> u8 {
        self.cf_gway_pas_spkr_lv_r_value_raw()
    }
    
    /// Get raw value of CF_Gway_PasSpkrLvRValue
    ///
    /// - Start bit: 40
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_gway_pas_spkr_lv_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..43].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Gway_PasSpkrLvRValue
    #[inline(always)]
    pub fn set_cf_gway_pas_spkr_lv_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1040 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..43].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for CgwUsm1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for CgwUsm1 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("CgwUsm1")
                .field("cf_gway_at_turn_r_value", &self.cf_gway_at_turn_r_value())
                .field("cf_gway_ptgmr_value", &self.cf_gway_ptgmr_value())
                .field("cf_gway_escort_hlr_value", &self.cf_gway_escort_hlr_value())
                .field("cf_gway_tt_unlock_r_value", &self.cf_gway_tt_unlock_r_value())
                .field("cf_gway_a_dr_lr_value", &self.cf_gway_a_dr_lr_value())
                .field("cf_gway_a_dr_ur_value", &self.cf_gway_a_dr_ur_value())
                .field("cf_gway_scmr_value", &self.cf_gway_scmr_value())
                .field("cf_gway_wlight_r_value", &self.cf_gway_wlight_r_value())
                .field("cf_gway_psmr_value", &self.cf_gway_psmr_value())
                .field("cf_gway_ot_turn_r_value", &self.cf_gway_ot_turn_r_value())
                .field("cf_gway_dr_lock_sound_r_value", &self.cf_gway_dr_lock_sound_r_value())
                .field("cf_gway_h_an_br_value", &self.cf_gway_h_an_br_value())
                .field("cf_gway_mood_lp_r_value", &self.cf_gway_mood_lp_r_value())
                .field("cf_gway_hfree_trunk_r_value", &self.cf_gway_hfree_trunk_r_value())
                .field("cf_gway_auto_light_r_value", &self.cf_gway_auto_light_r_value())
                .field("cf_gway_rear_wiper_r_value", &self.cf_gway_rear_wiper_r_value())
                .field("cf_gway_pas_spkr_lv_r_value", &self.cf_gway_pas_spkr_lv_r_value())
            .finish()
        } else {
            f.debug_tuple("CgwUsm1").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for CgwUsm1 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_gway_at_turn_r_value = u.int_in_range(0..=3)?;
        let cf_gway_ptgmr_value = u.int_in_range(0..=3)?;
        let cf_gway_escort_hlr_value = u.int_in_range(0..=3)?;
        let cf_gway_tt_unlock_r_value = u.int_in_range(0..=3)?;
        let cf_gway_a_dr_lr_value = u.int_in_range(0..=7)?;
        let cf_gway_a_dr_ur_value = u.int_in_range(0..=7)?;
        let cf_gway_scmr_value = u.int_in_range(0..=3)?;
        let cf_gway_wlight_r_value = u.int_in_range(0..=3)?;
        let cf_gway_psmr_value = u.int_in_range(0..=7)?;
        let cf_gway_ot_turn_r_value = u.int_in_range(0..=7)?;
        let cf_gway_dr_lock_sound_r_value = u.int_in_range(0..=7)?;
        let cf_gway_h_an_br_value = u.int_in_range(0..=7)?;
        let cf_gway_mood_lp_r_value = u.int_in_range(0..=3)?;
        let cf_gway_hfree_trunk_r_value = u.int_in_range(0..=7)?;
        let cf_gway_auto_light_r_value = u.int_in_range(0..=7)?;
        let cf_gway_rear_wiper_r_value = u.int_in_range(0..=3)?;
        let cf_gway_pas_spkr_lv_r_value = u.int_in_range(0..=7)?;
        CgwUsm1::new(cf_gway_at_turn_r_value,cf_gway_ptgmr_value,cf_gway_escort_hlr_value,cf_gway_tt_unlock_r_value,cf_gway_a_dr_lr_value,cf_gway_a_dr_ur_value,cf_gway_scmr_value,cf_gway_wlight_r_value,cf_gway_psmr_value,cf_gway_ot_turn_r_value,cf_gway_dr_lock_sound_r_value,cf_gway_h_an_br_value,cf_gway_mood_lp_r_value,cf_gway_hfree_trunk_r_value,cf_gway_auto_light_r_value,cf_gway_rear_wiper_r_value,cf_gway_pas_spkr_lv_r_value).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// CLU13
///
/// - ID: 1292 (0x50c)
/// - Size: 8 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct Clu13 {
    raw: [u8; 8],
}

impl Clu13 {
    pub const MESSAGE_ID: u32 = 1292;
    
    pub const CF_CLU_LOWFUEL_WARN_MIN: u8 = 0_u8;
    pub const CF_CLU_LOWFUEL_WARN_MAX: u8 = 3_u8;
    pub const CF_CLU_AVG_FCU_MIN: u8 = 0_u8;
    pub const CF_CLU_AVG_FCU_MAX: u8 = 3_u8;
    pub const CF_CLU_AVG_FCI_MIN: f32 = 0_f32;
    pub const CF_CLU_AVG_FCI_MAX: f32 = 102.2_f32;
    pub const CF_CLU_DRIVING_MODE_SWI_MIN: u8 = 0_u8;
    pub const CF_CLU_DRIVING_MODE_SWI_MAX: u8 = 3_u8;
    pub const CF_CLU_FUEL_DISP_LVL_MIN: u8 = 0_u8;
    pub const CF_CLU_FUEL_DISP_LVL_MAX: u8 = 31_u8;
    pub const CF_CLU_DTE_MIN: u16 = 0_u16;
    pub const CF_CLU_DTE_MAX: u16 = 1023_u16;
    pub const CF_CLU_TRIP_UNIT_MIN: u8 = 0_u8;
    pub const CF_CLU_TRIP_UNIT_MAX: u8 = 3_u8;
    pub const CF_CLU_SWL_STAT_MIN: u8 = 0_u8;
    pub const CF_CLU_SWL_STAT_MAX: u8 = 7_u8;
    pub const CF_CLU_ECO_DRIVE_INF_MIN: u8 = 0_u8;
    pub const CF_CLU_ECO_DRIVE_INF_MAX: u8 = 7_u8;
    pub const CF_CLU_ALIVE_CNT2_MIN: u8 = 0_u8;
    pub const CF_CLU_ALIVE_CNT2_MAX: u8 = 15_u8;
    
    /// Construct new CLU13 from values
    pub fn new(cf_clu_lowfuel_warn: u8, cf_clu_ref_det_mod: bool, cf_clu_avg_fcu: u8, cf_clu_avsm_cur: bool, cf_clu_avg_fci: f32, cf_clu_driving_mode_swi: u8, cf_clu_fuel_disp_lvl: u8, cf_clu_flex_steer_sw: bool, cf_clu_dte: u16, cf_clu_trip_unit: u8, cf_clu_swl_stat: u8, cf_clu_active_eco_sw: bool, cf_clu_eco_drive_inf: u8, cf_clu_isa_main_sw: bool, cf_clu_ldws_lkas_sw: bool, cf_clu_alt_l_status: bool, cf_clu_alive_cnt2: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_clu_lowfuel_warn(cf_clu_lowfuel_warn)?;
        res.set_cf_clu_ref_det_mod(cf_clu_ref_det_mod)?;
        res.set_cf_clu_avg_fcu(cf_clu_avg_fcu)?;
        res.set_cf_clu_avsm_cur(cf_clu_avsm_cur)?;
        res.set_cf_clu_avg_fci(cf_clu_avg_fci)?;
        res.set_cf_clu_driving_mode_swi(cf_clu_driving_mode_swi)?;
        res.set_cf_clu_fuel_disp_lvl(cf_clu_fuel_disp_lvl)?;
        res.set_cf_clu_flex_steer_sw(cf_clu_flex_steer_sw)?;
        res.set_cf_clu_dte(cf_clu_dte)?;
        res.set_cf_clu_trip_unit(cf_clu_trip_unit)?;
        res.set_cf_clu_swl_stat(cf_clu_swl_stat)?;
        res.set_cf_clu_active_eco_sw(cf_clu_active_eco_sw)?;
        res.set_cf_clu_eco_drive_inf(cf_clu_eco_drive_inf)?;
        res.set_cf_clu_isa_main_sw(cf_clu_isa_main_sw)?;
        res.set_cf_clu_ldws_lkas_sw(cf_clu_ldws_lkas_sw)?;
        res.set_cf_clu_alt_l_status(cf_clu_alt_l_status)?;
        res.set_cf_clu_alive_cnt2(cf_clu_alive_cnt2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Clu_LowfuelWarn
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, FPCM, IBOX
    #[inline(always)]
    pub fn cf_clu_lowfuel_warn(&self) -> u8 {
        self.cf_clu_lowfuel_warn_raw()
    }
    
    /// Get raw value of CF_Clu_LowfuelWarn
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_lowfuel_warn_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_LowfuelWarn
    #[inline(always)]
    pub fn set_cf_clu_lowfuel_warn(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1292 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_RefDetMod
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: IBOX
    #[inline(always)]
    pub fn cf_clu_ref_det_mod(&self) -> bool {
        self.cf_clu_ref_det_mod_raw()
    }
    
    /// Get raw value of CF_Clu_RefDetMod
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_ref_det_mod_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_RefDetMod
    #[inline(always)]
    pub fn set_cf_clu_ref_det_mod(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_AvgFCU
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: IBOX
    #[inline(always)]
    pub fn cf_clu_avg_fcu(&self) -> u8 {
        self.cf_clu_avg_fcu_raw()
    }
    
    /// Get raw value of CF_Clu_AvgFCU
    ///
    /// - Start bit: 3
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_avg_fcu_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[3..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_AvgFCU
    #[inline(always)]
    pub fn set_cf_clu_avg_fcu(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1292 });
        }
        self.raw.view_bits_mut::<Lsb0>()[3..5].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_AvsmCur
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC, SCC
    #[inline(always)]
    pub fn cf_clu_avsm_cur(&self) -> bool {
        self.cf_clu_avsm_cur_raw()
    }
    
    /// Get raw value of CF_Clu_AvsmCur
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_avsm_cur_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_AvsmCur
    #[inline(always)]
    pub fn set_cf_clu_avsm_cur(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_AvgFCI
    ///
    /// - Min: 0
    /// - Max: 102.2
    /// - Unit: ""
    /// - Receivers: IBOX
    #[inline(always)]
    pub fn cf_clu_avg_fci(&self) -> f32 {
        self.cf_clu_avg_fci_raw()
    }
    
    /// Get raw value of CF_Clu_AvgFCI
    ///
    /// - Start bit: 6
    /// - Signal size: 10 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_avg_fci_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[6..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CF_Clu_AvgFCI
    #[inline(always)]
    pub fn set_cf_clu_avg_fci(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 102.2_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1292 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[6..16].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_DrivingModeSwi
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: DATC, ECS, EMS, ESC, IAP, MDPS, TCU
    #[inline(always)]
    pub fn cf_clu_driving_mode_swi(&self) -> u8 {
        self.cf_clu_driving_mode_swi_raw()
    }
    
    /// Get raw value of CF_Clu_DrivingModeSwi
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_driving_mode_swi_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_DrivingModeSwi
    #[inline(always)]
    pub fn set_cf_clu_driving_mode_swi(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1292 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..18].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_FuelDispLvl
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: ""
    /// - Receivers: CGW, IBOX
    #[inline(always)]
    pub fn cf_clu_fuel_disp_lvl(&self) -> u8 {
        self.cf_clu_fuel_disp_lvl_raw()
    }
    
    /// Get raw value of CF_Clu_FuelDispLvl
    ///
    /// - Start bit: 18
    /// - Signal size: 5 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_fuel_disp_lvl_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[18..23].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_FuelDispLvl
    #[inline(always)]
    pub fn set_cf_clu_fuel_disp_lvl(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 31_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1292 });
        }
        self.raw.view_bits_mut::<Lsb0>()[18..23].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_FlexSteerSW
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn cf_clu_flex_steer_sw(&self) -> bool {
        self.cf_clu_flex_steer_sw_raw()
    }
    
    /// Get raw value of CF_Clu_FlexSteerSW
    ///
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_flex_steer_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[23..24].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_FlexSteerSW
    #[inline(always)]
    pub fn set_cf_clu_flex_steer_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[23..24].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_DTE
    ///
    /// - Min: 0
    /// - Max: 1023
    /// - Unit: ""
    /// - Receivers: DATC
    #[inline(always)]
    pub fn cf_clu_dte(&self) -> u16 {
        self.cf_clu_dte_raw()
    }
    
    /// Get raw value of CF_Clu_DTE
    ///
    /// - Start bit: 24
    /// - Signal size: 10 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_dte_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[24..34].load_le::<u16>();
        
        signal
    }
    
    /// Set value of CF_Clu_DTE
    #[inline(always)]
    pub fn set_cf_clu_dte(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 1023_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1292 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..34].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_TripUnit
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: DATC
    #[inline(always)]
    pub fn cf_clu_trip_unit(&self) -> u8 {
        self.cf_clu_trip_unit_raw()
    }
    
    /// Get raw value of CF_Clu_TripUnit
    ///
    /// - Start bit: 34
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_trip_unit_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[34..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_TripUnit
    #[inline(always)]
    pub fn set_cf_clu_trip_unit(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1292 });
        }
        self.raw.view_bits_mut::<Lsb0>()[34..36].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_SWL_Stat
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: ACU, EMS
    #[inline(always)]
    pub fn cf_clu_swl_stat(&self) -> u8 {
        self.cf_clu_swl_stat_raw()
    }
    
    /// Get raw value of CF_Clu_SWL_Stat
    ///
    /// - Start bit: 36
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_swl_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[36..39].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_SWL_Stat
    #[inline(always)]
    pub fn set_cf_clu_swl_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1292 });
        }
        self.raw.view_bits_mut::<Lsb0>()[36..39].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_ActiveEcoSW
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: DATC, EMS, TCU
    #[inline(always)]
    pub fn cf_clu_active_eco_sw(&self) -> bool {
        self.cf_clu_active_eco_sw_raw()
    }
    
    /// Get raw value of CF_Clu_ActiveEcoSW
    ///
    /// - Start bit: 39
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_active_eco_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[39..40].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_ActiveEcoSW
    #[inline(always)]
    pub fn set_cf_clu_active_eco_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[39..40].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_EcoDriveInf
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CUBIS, EMS, IAP, IBOX
    #[inline(always)]
    pub fn cf_clu_eco_drive_inf(&self) -> u8 {
        self.cf_clu_eco_drive_inf_raw()
    }
    
    /// Get raw value of CF_Clu_EcoDriveInf
    ///
    /// - Start bit: 40
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_eco_drive_inf_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..43].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_EcoDriveInf
    #[inline(always)]
    pub fn set_cf_clu_eco_drive_inf(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1292 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..43].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_IsaMainSW
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: EMS
    #[inline(always)]
    pub fn cf_clu_isa_main_sw(&self) -> bool {
        self.cf_clu_isa_main_sw_raw()
    }
    
    /// Get raw value of CF_Clu_IsaMainSW
    ///
    /// - Start bit: 43
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_isa_main_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[43..44].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_IsaMainSW
    #[inline(always)]
    pub fn set_cf_clu_isa_main_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[43..44].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_LdwsLkasSW
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS
    #[inline(always)]
    pub fn cf_clu_ldws_lkas_sw(&self) -> bool {
        self.cf_clu_ldws_lkas_sw_raw()
    }
    
    /// Get raw value of CF_Clu_LdwsLkasSW
    ///
    /// - Start bit: 56
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_ldws_lkas_sw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[56..57].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_LdwsLkasSW
    #[inline(always)]
    pub fn set_cf_clu_ldws_lkas_sw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[56..57].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_AltLStatus
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: BCM, DATC, EMS
    #[inline(always)]
    pub fn cf_clu_alt_l_status(&self) -> bool {
        self.cf_clu_alt_l_status_raw()
    }
    
    /// Get raw value of CF_Clu_AltLStatus
    ///
    /// - Start bit: 59
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_alt_l_status_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[59..60].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Clu_AltLStatus
    #[inline(always)]
    pub fn set_cf_clu_alt_l_status(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[59..60].store_le(value);
        Ok(())
    }
    
    /// CF_Clu_AliveCnt2
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: EMS, LDWS_LKAS
    #[inline(always)]
    pub fn cf_clu_alive_cnt2(&self) -> u8 {
        self.cf_clu_alive_cnt2_raw()
    }
    
    /// Get raw value of CF_Clu_AliveCnt2
    ///
    /// - Start bit: 60
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_clu_alive_cnt2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[60..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Clu_AliveCnt2
    #[inline(always)]
    pub fn set_cf_clu_alive_cnt2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1292 });
        }
        self.raw.view_bits_mut::<Lsb0>()[60..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Clu13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Clu13 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Clu13")
                .field("cf_clu_lowfuel_warn", &self.cf_clu_lowfuel_warn())
                .field("cf_clu_ref_det_mod", &self.cf_clu_ref_det_mod())
                .field("cf_clu_avg_fcu", &self.cf_clu_avg_fcu())
                .field("cf_clu_avsm_cur", &self.cf_clu_avsm_cur())
                .field("cf_clu_avg_fci", &self.cf_clu_avg_fci())
                .field("cf_clu_driving_mode_swi", &self.cf_clu_driving_mode_swi())
                .field("cf_clu_fuel_disp_lvl", &self.cf_clu_fuel_disp_lvl())
                .field("cf_clu_flex_steer_sw", &self.cf_clu_flex_steer_sw())
                .field("cf_clu_dte", &self.cf_clu_dte())
                .field("cf_clu_trip_unit", &self.cf_clu_trip_unit())
                .field("cf_clu_swl_stat", &self.cf_clu_swl_stat())
                .field("cf_clu_active_eco_sw", &self.cf_clu_active_eco_sw())
                .field("cf_clu_eco_drive_inf", &self.cf_clu_eco_drive_inf())
                .field("cf_clu_isa_main_sw", &self.cf_clu_isa_main_sw())
                .field("cf_clu_ldws_lkas_sw", &self.cf_clu_ldws_lkas_sw())
                .field("cf_clu_alt_l_status", &self.cf_clu_alt_l_status())
                .field("cf_clu_alive_cnt2", &self.cf_clu_alive_cnt2())
            .finish()
        } else {
            f.debug_tuple("Clu13").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Clu13 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_clu_lowfuel_warn = u.int_in_range(0..=3)?;
        let cf_clu_ref_det_mod = u.int_in_range(0..=1)? == 1;
        let cf_clu_avg_fcu = u.int_in_range(0..=3)?;
        let cf_clu_avsm_cur = u.int_in_range(0..=1)? == 1;
        let cf_clu_avg_fci = u.float_in_range(0_f32..=102.2_f32)?;
        let cf_clu_driving_mode_swi = u.int_in_range(0..=3)?;
        let cf_clu_fuel_disp_lvl = u.int_in_range(0..=31)?;
        let cf_clu_flex_steer_sw = u.int_in_range(0..=1)? == 1;
        let cf_clu_dte = u.int_in_range(0..=1023)?;
        let cf_clu_trip_unit = u.int_in_range(0..=3)?;
        let cf_clu_swl_stat = u.int_in_range(0..=7)?;
        let cf_clu_active_eco_sw = u.int_in_range(0..=1)? == 1;
        let cf_clu_eco_drive_inf = u.int_in_range(0..=7)?;
        let cf_clu_isa_main_sw = u.int_in_range(0..=1)? == 1;
        let cf_clu_ldws_lkas_sw = u.int_in_range(0..=1)? == 1;
        let cf_clu_alt_l_status = u.int_in_range(0..=1)? == 1;
        let cf_clu_alive_cnt2 = u.int_in_range(0..=15)?;
        Clu13::new(cf_clu_lowfuel_warn,cf_clu_ref_det_mod,cf_clu_avg_fcu,cf_clu_avsm_cur,cf_clu_avg_fci,cf_clu_driving_mode_swi,cf_clu_fuel_disp_lvl,cf_clu_flex_steer_sw,cf_clu_dte,cf_clu_trip_unit,cf_clu_swl_stat,cf_clu_active_eco_sw,cf_clu_eco_drive_inf,cf_clu_isa_main_sw,cf_clu_ldws_lkas_sw,cf_clu_alt_l_status,cf_clu_alive_cnt2).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// SCC13
///
/// - ID: 1290 (0x50a)
/// - Size: 8 bytes
/// - Transmitter: SCC
#[derive(Clone, Copy)]
pub struct Scc13 {
    raw: [u8; 8],
}

impl Scc13 {
    pub const MESSAGE_ID: u32 = 1290;
    
    pub const SCC_DRV_MODE_R_VALUE_MIN: u8 = 0_u8;
    pub const SCC_DRV_MODE_R_VALUE_MAX: u8 = 7_u8;
    pub const AEB_DRV_SET_STATUS_MIN: u8 = 0_u8;
    pub const AEB_DRV_SET_STATUS_MAX: u8 = 7_u8;
    pub const LEAD_VEH_DEP_ALERT_USM_MIN: u8 = 0_u8;
    pub const LEAD_VEH_DEP_ALERT_USM_MAX: u8 = 3_u8;
    
    /// Construct new SCC13 from values
    pub fn new(scc_drv_mode_r_value: u8, scc_equip: bool, aeb_drv_set_status: u8, lead_veh_dep_alert_usm: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_scc_drv_mode_r_value(scc_drv_mode_r_value)?;
        res.set_scc_equip(scc_equip)?;
        res.set_aeb_drv_set_status(aeb_drv_set_status)?;
        res.set_lead_veh_dep_alert_usm(lead_veh_dep_alert_usm)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// SCCDrvModeRValue
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn scc_drv_mode_r_value(&self) -> u8 {
        self.scc_drv_mode_r_value_raw()
    }
    
    /// Get raw value of SCCDrvModeRValue
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn scc_drv_mode_r_value_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of SCCDrvModeRValue
    #[inline(always)]
    pub fn set_scc_drv_mode_r_value(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1290 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..3].store_le(value);
        Ok(())
    }
    
    /// SCC_Equip
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn scc_equip(&self) -> bool {
        self.scc_equip_raw()
    }
    
    /// Get raw value of SCC_Equip
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn scc_equip_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of SCC_Equip
    #[inline(always)]
    pub fn set_scc_equip(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// AebDrvSetStatus
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, ESC
    #[inline(always)]
    pub fn aeb_drv_set_status(&self) -> u8 {
        self.aeb_drv_set_status_raw()
    }
    
    /// Get raw value of AebDrvSetStatus
    ///
    /// - Start bit: 4
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aeb_drv_set_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..7].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AebDrvSetStatus
    #[inline(always)]
    pub fn set_aeb_drv_set_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1290 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..7].store_le(value);
        Ok(())
    }
    
    /// Lead_Veh_Dep_Alert_USM
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn lead_veh_dep_alert_usm(&self) -> u8 {
        self.lead_veh_dep_alert_usm_raw()
    }
    
    /// Get raw value of Lead_Veh_Dep_Alert_USM
    ///
    /// - Start bit: 13
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lead_veh_dep_alert_usm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[10..12].load_be::<u8>();
        
        signal
    }
    
    /// Set value of Lead_Veh_Dep_Alert_USM
    #[inline(always)]
    pub fn set_lead_veh_dep_alert_usm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1290 });
        }
        self.raw.view_bits_mut::<Msb0>()[10..12].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Scc13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Scc13 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Scc13")
                .field("scc_drv_mode_r_value", &self.scc_drv_mode_r_value())
                .field("scc_equip", &self.scc_equip())
                .field("aeb_drv_set_status", &self.aeb_drv_set_status())
                .field("lead_veh_dep_alert_usm", &self.lead_veh_dep_alert_usm())
            .finish()
        } else {
            f.debug_tuple("Scc13").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Scc13 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let scc_drv_mode_r_value = u.int_in_range(0..=7)?;
        let scc_equip = u.int_in_range(0..=1)? == 1;
        let aeb_drv_set_status = u.int_in_range(0..=7)?;
        let lead_veh_dep_alert_usm = u.int_in_range(0..=3)?;
        Scc13::new(scc_drv_mode_r_value,scc_equip,aeb_drv_set_status,lead_veh_dep_alert_usm).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// TCS15
///
/// - ID: 1287 (0x507)
/// - Size: 4 bytes
/// - Transmitter: ESC
#[derive(Clone, Copy)]
pub struct Tcs15 {
    raw: [u8; 4],
}

impl Tcs15 {
    pub const MESSAGE_ID: u32 = 1287;
    
    pub const TCS_OFF_LAMP_MIN: u8 = 0_u8;
    pub const TCS_OFF_LAMP_MAX: u8 = 1_u8;
    pub const TCS_LAMP_MIN: u8 = 0_u8;
    pub const TCS_LAMP_MAX: u8 = 3_u8;
    pub const DBC_F_LAMP_MIN: u8 = 0_u8;
    pub const DBC_F_LAMP_MAX: u8 = 3_u8;
    pub const ESC_OFF_STEP_MIN: u8 = 0_u8;
    pub const ESC_OFF_STEP_MAX: u8 = 3_u8;
    pub const AVH_CLU_MIN: u8 = 0_u8;
    pub const AVH_CLU_MAX: u8 = 255_u8;
    pub const AVH_I_LAMP_MIN: u8 = 0_u8;
    pub const AVH_I_LAMP_MAX: u8 = 3_u8;
    pub const AVH_ALARM_MIN: u8 = 0_u8;
    pub const AVH_ALARM_MAX: u8 = 3_u8;
    pub const AVH_LAMP_MIN: u8 = 0_u8;
    pub const AVH_LAMP_MAX: u8 = 7_u8;
    
    /// Construct new TCS15 from values
    pub fn new(abs_w_lamp: bool, tcs_off_lamp: u8, tcs_lamp: u8, dbc_w_lamp: bool, dbc_f_lamp: u8, esc_off_step: u8, avh_clu: u8, avh_i_lamp: u8, ebd_w_lamp: bool, avh_alarm: u8, avh_lamp: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_abs_w_lamp(abs_w_lamp)?;
        res.set_tcs_off_lamp(tcs_off_lamp)?;
        res.set_tcs_lamp(tcs_lamp)?;
        res.set_dbc_w_lamp(dbc_w_lamp)?;
        res.set_dbc_f_lamp(dbc_f_lamp)?;
        res.set_esc_off_step(esc_off_step)?;
        res.set_avh_clu(avh_clu)?;
        res.set_avh_i_lamp(avh_i_lamp)?;
        res.set_ebd_w_lamp(ebd_w_lamp)?;
        res.set_avh_alarm(avh_alarm)?;
        res.set_avh_lamp(avh_lamp)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 4] {
        &self.raw
    }
    
    /// ABS_W_LAMP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, CLU, CUBIS, IBOX
    #[inline(always)]
    pub fn abs_w_lamp(&self) -> bool {
        self.abs_w_lamp_raw()
    }
    
    /// Get raw value of ABS_W_LAMP
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn abs_w_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ABS_W_LAMP
    #[inline(always)]
    pub fn set_abs_w_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// TCS_OFF_LAMP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, ACU, CLU
    #[inline(always)]
    pub fn tcs_off_lamp(&self) -> u8 {
        self.tcs_off_lamp_raw()
    }
    
    /// Get raw value of TCS_OFF_LAMP
    ///
    /// - Start bit: 1
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tcs_off_lamp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[1..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of TCS_OFF_LAMP
    #[inline(always)]
    pub fn set_tcs_off_lamp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 1_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1287 });
        }
        self.raw.view_bits_mut::<Lsb0>()[1..3].store_le(value);
        Ok(())
    }
    
    /// TCS_LAMP
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: _4WD, ACU, CLU, CUBIS, IBOX, SCC
    #[inline(always)]
    pub fn tcs_lamp(&self) -> u8 {
        self.tcs_lamp_raw()
    }
    
    /// Get raw value of TCS_LAMP
    ///
    /// - Start bit: 3
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tcs_lamp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[3..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of TCS_LAMP
    #[inline(always)]
    pub fn set_tcs_lamp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1287 });
        }
        self.raw.view_bits_mut::<Lsb0>()[3..5].store_le(value);
        Ok(())
    }
    
    /// DBC_W_LAMP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, CLU
    #[inline(always)]
    pub fn dbc_w_lamp(&self) -> bool {
        self.dbc_w_lamp_raw()
    }
    
    /// Get raw value of DBC_W_LAMP
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dbc_w_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of DBC_W_LAMP
    #[inline(always)]
    pub fn set_dbc_w_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// DBC_F_LAMP
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: _4WD, CLU
    #[inline(always)]
    pub fn dbc_f_lamp(&self) -> u8 {
        self.dbc_f_lamp_raw()
    }
    
    /// Get raw value of DBC_F_LAMP
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn dbc_f_lamp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of DBC_F_LAMP
    #[inline(always)]
    pub fn set_dbc_f_lamp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1287 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// ESC_Off_Step
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn esc_off_step(&self) -> u8 {
        self.esc_off_step_raw()
    }
    
    /// Get raw value of ESC_Off_Step
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn esc_off_step_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ESC_Off_Step
    #[inline(always)]
    pub fn set_esc_off_step(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1287 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// AVH_CLU
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU, EPB
    #[inline(always)]
    pub fn avh_clu(&self) -> u8 {
        self.avh_clu_raw()
    }
    
    /// Get raw value of AVH_CLU
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avh_clu_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVH_CLU
    #[inline(always)]
    pub fn set_avh_clu(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1287 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// AVH_I_LAMP
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EPB
    #[inline(always)]
    pub fn avh_i_lamp(&self) -> u8 {
        self.avh_i_lamp_raw()
    }
    
    /// Get raw value of AVH_I_LAMP
    ///
    /// - Start bit: 24
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avh_i_lamp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..26].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVH_I_LAMP
    #[inline(always)]
    pub fn set_avh_i_lamp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1287 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..26].store_le(value);
        Ok(())
    }
    
    /// EBD_W_LAMP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: _4WD, CLU
    #[inline(always)]
    pub fn ebd_w_lamp(&self) -> bool {
        self.ebd_w_lamp_raw()
    }
    
    /// Get raw value of EBD_W_LAMP
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ebd_w_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of EBD_W_LAMP
    #[inline(always)]
    pub fn set_ebd_w_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[26..27].store_le(value);
        Ok(())
    }
    
    /// AVH_ALARM
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn avh_alarm(&self) -> u8 {
        self.avh_alarm_raw()
    }
    
    /// Get raw value of AVH_ALARM
    ///
    /// - Start bit: 27
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avh_alarm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[27..29].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVH_ALARM
    #[inline(always)]
    pub fn set_avh_alarm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1287 });
        }
        self.raw.view_bits_mut::<Lsb0>()[27..29].store_le(value);
        Ok(())
    }
    
    /// AVH_LAMP
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, EPB, SPAS
    #[inline(always)]
    pub fn avh_lamp(&self) -> u8 {
        self.avh_lamp_raw()
    }
    
    /// Get raw value of AVH_LAMP
    ///
    /// - Start bit: 29
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn avh_lamp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[29..32].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AVH_LAMP
    #[inline(always)]
    pub fn set_avh_lamp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1287 });
        }
        self.raw.view_bits_mut::<Lsb0>()[29..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Tcs15 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Tcs15 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Tcs15")
                .field("abs_w_lamp", &self.abs_w_lamp())
                .field("tcs_off_lamp", &self.tcs_off_lamp())
                .field("tcs_lamp", &self.tcs_lamp())
                .field("dbc_w_lamp", &self.dbc_w_lamp())
                .field("dbc_f_lamp", &self.dbc_f_lamp())
                .field("esc_off_step", &self.esc_off_step())
                .field("avh_clu", &self.avh_clu())
                .field("avh_i_lamp", &self.avh_i_lamp())
                .field("ebd_w_lamp", &self.ebd_w_lamp())
                .field("avh_alarm", &self.avh_alarm())
                .field("avh_lamp", &self.avh_lamp())
            .finish()
        } else {
            f.debug_tuple("Tcs15").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Tcs15 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let abs_w_lamp = u.int_in_range(0..=1)? == 1;
        let tcs_off_lamp = u.int_in_range(0..=1)?;
        let tcs_lamp = u.int_in_range(0..=3)?;
        let dbc_w_lamp = u.int_in_range(0..=1)? == 1;
        let dbc_f_lamp = u.int_in_range(0..=3)?;
        let esc_off_step = u.int_in_range(0..=3)?;
        let avh_clu = u.int_in_range(0..=255)?;
        let avh_i_lamp = u.int_in_range(0..=3)?;
        let ebd_w_lamp = u.int_in_range(0..=1)? == 1;
        let avh_alarm = u.int_in_range(0..=3)?;
        let avh_lamp = u.int_in_range(0..=7)?;
        Tcs15::new(abs_w_lamp,tcs_off_lamp,tcs_lamp,dbc_w_lamp,dbc_f_lamp,esc_off_step,avh_clu,avh_i_lamp,ebd_w_lamp,avh_alarm,avh_lamp).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// TCU14
///
/// - ID: 1282 (0x502)
/// - Size: 4 bytes
/// - Transmitter: TCU
#[derive(Clone, Copy)]
pub struct Tcu14 {
    raw: [u8; 4],
}

impl Tcu14 {
    pub const MESSAGE_ID: u32 = 1282;
    
    pub const CF_TCU_WARN_MSG_MIN: u8 = 0_u8;
    pub const CF_TCU_WARN_MSG_MAX: u8 = 7_u8;
    pub const CF_TCU_DRI_WARN1_MIN: u8 = 0_u8;
    pub const CF_TCU_DRI_WARN1_MAX: u8 = 7_u8;
    pub const CF_TCU_DRI_WARN2_MIN: u8 = 0_u8;
    pub const CF_TCU_DRI_WARN2_MAX: u8 = 3_u8;
    
    /// Construct new TCU14 from values
    pub fn new(cf_tcu_warn_msg: u8, cf_tcu_warn_img: bool, cf_tcu_warn_snd: bool, cf_tcu_g_sel_blink_req: bool, cf_tcu_st_rel_stat: bool, cf_tcu_dri_warn1: u8, cf_tcu_dri_warn2: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_cf_tcu_warn_msg(cf_tcu_warn_msg)?;
        res.set_cf_tcu_warn_img(cf_tcu_warn_img)?;
        res.set_cf_tcu_warn_snd(cf_tcu_warn_snd)?;
        res.set_cf_tcu_g_sel_blink_req(cf_tcu_g_sel_blink_req)?;
        res.set_cf_tcu_st_rel_stat(cf_tcu_st_rel_stat)?;
        res.set_cf_tcu_dri_warn1(cf_tcu_dri_warn1)?;
        res.set_cf_tcu_dri_warn2(cf_tcu_dri_warn2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 4] {
        &self.raw
    }
    
    /// CF_TCU_WarnMsg
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_tcu_warn_msg(&self) -> u8 {
        self.cf_tcu_warn_msg_raw()
    }
    
    /// Get raw value of CF_TCU_WarnMsg
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_warn_msg_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_TCU_WarnMsg
    #[inline(always)]
    pub fn set_cf_tcu_warn_msg(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1282 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..3].store_le(value);
        Ok(())
    }
    
    /// CF_TCU_WarnImg
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_tcu_warn_img(&self) -> bool {
        self.cf_tcu_warn_img_raw()
    }
    
    /// Get raw value of CF_TCU_WarnImg
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_warn_img_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_TCU_WarnImg
    #[inline(always)]
    pub fn set_cf_tcu_warn_img(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// CF_TCU_WarnSnd
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_tcu_warn_snd(&self) -> bool {
        self.cf_tcu_warn_snd_raw()
    }
    
    /// Get raw value of CF_TCU_WarnSnd
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_warn_snd_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_TCU_WarnSnd
    #[inline(always)]
    pub fn set_cf_tcu_warn_snd(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_GSel_BlinkReq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, LVR
    #[inline(always)]
    pub fn cf_tcu_g_sel_blink_req(&self) -> bool {
        self.cf_tcu_g_sel_blink_req_raw()
    }
    
    /// Get raw value of CF_Tcu_GSel_BlinkReq
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_g_sel_blink_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tcu_GSel_BlinkReq
    #[inline(always)]
    pub fn set_cf_tcu_g_sel_blink_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_StRelStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, EMS, ESC
    #[inline(always)]
    pub fn cf_tcu_st_rel_stat(&self) -> bool {
        self.cf_tcu_st_rel_stat_raw()
    }
    
    /// Get raw value of CF_Tcu_StRelStat
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_st_rel_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Tcu_StRelStat
    #[inline(always)]
    pub fn set_cf_tcu_st_rel_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[12..13].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_DriWarn1
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, EMS, ESC
    #[inline(always)]
    pub fn cf_tcu_dri_warn1(&self) -> u8 {
        self.cf_tcu_dri_warn1_raw()
    }
    
    /// Get raw value of CF_Tcu_DriWarn1
    ///
    /// - Start bit: 13
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_dri_warn1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[13..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Tcu_DriWarn1
    #[inline(always)]
    pub fn set_cf_tcu_dri_warn1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1282 });
        }
        self.raw.view_bits_mut::<Lsb0>()[13..16].store_le(value);
        Ok(())
    }
    
    /// CF_Tcu_DriWarn2
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, EMS, ESC
    #[inline(always)]
    pub fn cf_tcu_dri_warn2(&self) -> u8 {
        self.cf_tcu_dri_warn2_raw()
    }
    
    /// Get raw value of CF_Tcu_DriWarn2
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_tcu_dri_warn2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Tcu_DriWarn2
    #[inline(always)]
    pub fn set_cf_tcu_dri_warn2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1282 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..18].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Tcu14 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Tcu14 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Tcu14")
                .field("cf_tcu_warn_msg", &self.cf_tcu_warn_msg())
                .field("cf_tcu_warn_img", &self.cf_tcu_warn_img())
                .field("cf_tcu_warn_snd", &self.cf_tcu_warn_snd())
                .field("cf_tcu_g_sel_blink_req", &self.cf_tcu_g_sel_blink_req())
                .field("cf_tcu_st_rel_stat", &self.cf_tcu_st_rel_stat())
                .field("cf_tcu_dri_warn1", &self.cf_tcu_dri_warn1())
                .field("cf_tcu_dri_warn2", &self.cf_tcu_dri_warn2())
            .finish()
        } else {
            f.debug_tuple("Tcu14").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Tcu14 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_tcu_warn_msg = u.int_in_range(0..=7)?;
        let cf_tcu_warn_img = u.int_in_range(0..=1)? == 1;
        let cf_tcu_warn_snd = u.int_in_range(0..=1)? == 1;
        let cf_tcu_g_sel_blink_req = u.int_in_range(0..=1)? == 1;
        let cf_tcu_st_rel_stat = u.int_in_range(0..=1)? == 1;
        let cf_tcu_dri_warn1 = u.int_in_range(0..=7)?;
        let cf_tcu_dri_warn2 = u.int_in_range(0..=3)?;
        Tcu14::new(cf_tcu_warn_msg,cf_tcu_warn_img,cf_tcu_warn_snd,cf_tcu_g_sel_blink_req,cf_tcu_st_rel_stat,cf_tcu_dri_warn1,cf_tcu_dri_warn2).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ECS11
///
/// - ID: 1281 (0x501)
/// - Size: 3 bytes
/// - Transmitter: ECS
#[derive(Clone, Copy)]
pub struct Ecs11 {
    raw: [u8; 3],
}

impl Ecs11 {
    pub const MESSAGE_ID: u32 = 1281;
    
    pub const DAMPING_MODE_MIN: u8 = 0_u8;
    pub const DAMPING_MODE_MAX: u8 = 3_u8;
    pub const REQ_DAMPING_MIN: u8 = 0_u8;
    pub const REQ_DAMPING_MAX: u8 = 3_u8;
    pub const REQ_HEIGHT_MIN: u8 = 0_u8;
    pub const REQ_HEIGHT_MAX: u8 = 3_u8;
    pub const REQ_LEVEL_MIN: u8 = 0_u8;
    pub const REQ_LEVEL_MAX: u8 = 15_u8;
    pub const ACT_HEIGHT_MIN: u8 = 0_u8;
    pub const ACT_HEIGHT_MAX: u8 = 15_u8;
    
    /// Construct new ECS11 from values
    pub fn new(ecs_w_lamp: bool, sys_na: bool, ecs_def: bool, ecs_diag: bool, l_chg_na: bool, leveling_off: bool, lc_overheat: bool, lifting: bool, lowering: bool, damping_mode: u8, req_damping: u8, req_height: u8, req_level: u8, act_height: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_ecs_w_lamp(ecs_w_lamp)?;
        res.set_sys_na(sys_na)?;
        res.set_ecs_def(ecs_def)?;
        res.set_ecs_diag(ecs_diag)?;
        res.set_l_chg_na(l_chg_na)?;
        res.set_leveling_off(leveling_off)?;
        res.set_lc_overheat(lc_overheat)?;
        res.set_lifting(lifting)?;
        res.set_lowering(lowering)?;
        res.set_damping_mode(damping_mode)?;
        res.set_req_damping(req_damping)?;
        res.set_req_height(req_height)?;
        res.set_req_level(req_level)?;
        res.set_act_height(act_height)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// ECS_W_LAMP
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, CUBIS, IBOX
    #[inline(always)]
    pub fn ecs_w_lamp(&self) -> bool {
        self.ecs_w_lamp_raw()
    }
    
    /// Get raw value of ECS_W_LAMP
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ecs_w_lamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ECS_W_LAMP
    #[inline(always)]
    pub fn set_ecs_w_lamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// SYS_NA
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn sys_na(&self) -> bool {
        self.sys_na_raw()
    }
    
    /// Get raw value of SYS_NA
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn sys_na_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of SYS_NA
    #[inline(always)]
    pub fn set_sys_na(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// ECS_DEF
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn ecs_def(&self) -> bool {
        self.ecs_def_raw()
    }
    
    /// Get raw value of ECS_DEF
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ecs_def_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ECS_DEF
    #[inline(always)]
    pub fn set_ecs_def(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// ECS_DIAG
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn ecs_diag(&self) -> bool {
        self.ecs_diag_raw()
    }
    
    /// Get raw value of ECS_DIAG
    ///
    /// - Start bit: 3
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ecs_diag_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[3..4].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of ECS_DIAG
    #[inline(always)]
    pub fn set_ecs_diag(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[3..4].store_le(value);
        Ok(())
    }
    
    /// L_CHG_NA
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn l_chg_na(&self) -> bool {
        self.l_chg_na_raw()
    }
    
    /// Get raw value of L_CHG_NA
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn l_chg_na_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[4..5].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of L_CHG_NA
    #[inline(always)]
    pub fn set_l_chg_na(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[4..5].store_le(value);
        Ok(())
    }
    
    /// Leveling_Off
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn leveling_off(&self) -> bool {
        self.leveling_off_raw()
    }
    
    /// Get raw value of Leveling_Off
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn leveling_off_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[5..6].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Leveling_Off
    #[inline(always)]
    pub fn set_leveling_off(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[5..6].store_le(value);
        Ok(())
    }
    
    /// LC_overheat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn lc_overheat(&self) -> bool {
        self.lc_overheat_raw()
    }
    
    /// Get raw value of LC_overheat
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lc_overheat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of LC_overheat
    #[inline(always)]
    pub fn set_lc_overheat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[6..7].store_le(value);
        Ok(())
    }
    
    /// Lifting
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn lifting(&self) -> bool {
        self.lifting_raw()
    }
    
    /// Get raw value of Lifting
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lifting_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Lifting
    #[inline(always)]
    pub fn set_lifting(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[8..9].store_le(value);
        Ok(())
    }
    
    /// Lowering
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn lowering(&self) -> bool {
        self.lowering_raw()
    }
    
    /// Get raw value of Lowering
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lowering_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Lowering
    #[inline(always)]
    pub fn set_lowering(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[9..10].store_le(value);
        Ok(())
    }
    
    /// Damping_Mode
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn damping_mode(&self) -> u8 {
        self.damping_mode_raw()
    }
    
    /// Get raw value of Damping_Mode
    ///
    /// - Start bit: 10
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn damping_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[10..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Damping_Mode
    #[inline(always)]
    pub fn set_damping_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1281 });
        }
        self.raw.view_bits_mut::<Lsb0>()[10..12].store_le(value);
        Ok(())
    }
    
    /// REQ_Damping
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn req_damping(&self) -> u8 {
        self.req_damping_raw()
    }
    
    /// Get raw value of REQ_Damping
    ///
    /// - Start bit: 12
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn req_damping_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[12..14].load_le::<u8>();
        
        signal
    }
    
    /// Set value of REQ_Damping
    #[inline(always)]
    pub fn set_req_damping(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1281 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..14].store_le(value);
        Ok(())
    }
    
    /// REQ_Height
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn req_height(&self) -> u8 {
        self.req_height_raw()
    }
    
    /// Get raw value of REQ_Height
    ///
    /// - Start bit: 14
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn req_height_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[14..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of REQ_Height
    #[inline(always)]
    pub fn set_req_height(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1281 });
        }
        self.raw.view_bits_mut::<Lsb0>()[14..16].store_le(value);
        Ok(())
    }
    
    /// REQ_level
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn req_level(&self) -> u8 {
        self.req_level_raw()
    }
    
    /// Get raw value of REQ_level
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn req_level_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of REQ_level
    #[inline(always)]
    pub fn set_req_level(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1281 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..20].store_le(value);
        Ok(())
    }
    
    /// ACT_Height
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn act_height(&self) -> u8 {
        self.act_height_raw()
    }
    
    /// Get raw value of ACT_Height
    ///
    /// - Start bit: 20
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn act_height_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ACT_Height
    #[inline(always)]
    pub fn set_act_height(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1281 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ecs11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ecs11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ecs11")
                .field("ecs_w_lamp", &self.ecs_w_lamp())
                .field("sys_na", &self.sys_na())
                .field("ecs_def", &self.ecs_def())
                .field("ecs_diag", &self.ecs_diag())
                .field("l_chg_na", &self.l_chg_na())
                .field("leveling_off", &self.leveling_off())
                .field("lc_overheat", &self.lc_overheat())
                .field("lifting", &self.lifting())
                .field("lowering", &self.lowering())
                .field("damping_mode", &self.damping_mode())
                .field("req_damping", &self.req_damping())
                .field("req_height", &self.req_height())
                .field("req_level", &self.req_level())
                .field("act_height", &self.act_height())
            .finish()
        } else {
            f.debug_tuple("Ecs11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ecs11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let ecs_w_lamp = u.int_in_range(0..=1)? == 1;
        let sys_na = u.int_in_range(0..=1)? == 1;
        let ecs_def = u.int_in_range(0..=1)? == 1;
        let ecs_diag = u.int_in_range(0..=1)? == 1;
        let l_chg_na = u.int_in_range(0..=1)? == 1;
        let leveling_off = u.int_in_range(0..=1)? == 1;
        let lc_overheat = u.int_in_range(0..=1)? == 1;
        let lifting = u.int_in_range(0..=1)? == 1;
        let lowering = u.int_in_range(0..=1)? == 1;
        let damping_mode = u.int_in_range(0..=3)?;
        let req_damping = u.int_in_range(0..=3)?;
        let req_height = u.int_in_range(0..=3)?;
        let req_level = u.int_in_range(0..=15)?;
        let act_height = u.int_in_range(0..=15)?;
        Ecs11::new(ecs_w_lamp,sys_na,ecs_def,ecs_diag,l_chg_na,leveling_off,lc_overheat,lifting,lowering,damping_mode,req_damping,req_height,req_level,act_height).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// CLU_CFG11
///
/// - ID: 1024 (0x400)
/// - Size: 2 bytes
/// - Transmitter: CLU
#[derive(Clone, Copy)]
pub struct CluCfg11 {
    raw: [u8; 2],
}

impl CluCfg11 {
    pub const MESSAGE_ID: u32 = 1024;
    
    pub const VEHICLE_TYPE_MIN: u16 = 0_u16;
    pub const VEHICLE_TYPE_MAX: u16 = 32767_u16;
    
    /// Construct new CLU_CFG11 from values
    pub fn new(vehicle_type: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_vehicle_type(vehicle_type)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Vehicle_Type
    ///
    /// - Min: 0
    /// - Max: 65536
    /// - Unit: ""
    /// - Receivers: _4WD
    #[inline(always)]
    pub fn vehicle_type(&self) -> u16 {
        self.vehicle_type_raw()
    }
    
    /// Get raw value of Vehicle_Type
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vehicle_type_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        signal
    }
    
    /// Set value of Vehicle_Type
    #[inline(always)]
    pub fn set_vehicle_type(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 65536_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1024 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for CluCfg11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for CluCfg11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("CluCfg11")
                .field("vehicle_type", &self.vehicle_type())
            .finish()
        } else {
            f.debug_tuple("CluCfg11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for CluCfg11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let vehicle_type = u.int_in_range(0..=65536)?;
        CluCfg11::new(vehicle_type).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ACU14
///
/// - ID: 1280 (0x500)
/// - Size: 1 bytes
/// - Transmitter: ACU
#[derive(Clone, Copy)]
pub struct Acu14 {
    raw: [u8; 1],
}

impl Acu14 {
    pub const MESSAGE_ID: u32 = 1280;
    
    pub const CF_SWL_IND_MIN: u8 = 0_u8;
    pub const CF_SWL_IND_MAX: u8 = 3_u8;
    pub const CF_TTL_IND_MIN: u8 = 0_u8;
    pub const CF_TTL_IND_MAX: u8 = 3_u8;
    pub const CF_SBR_IND_MIN: u8 = 0_u8;
    pub const CF_SBR_IND_MAX: u8 = 3_u8;
    
    /// Construct new ACU14 from values
    pub fn new(cf_swl_ind: u8, cf_ttl_ind: u8, cf_sbr_ind: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 1] };
        res.set_cf_swl_ind(cf_swl_ind)?;
        res.set_cf_ttl_ind(cf_ttl_ind)?;
        res.set_cf_sbr_ind(cf_sbr_ind)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 1] {
        &self.raw
    }
    
    /// CF_SWL_Ind
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_swl_ind(&self) -> u8 {
        self.cf_swl_ind_raw()
    }
    
    /// Get raw value of CF_SWL_Ind
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_swl_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_SWL_Ind
    #[inline(always)]
    pub fn set_cf_swl_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1280 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// CF_TTL_Ind
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_ttl_ind(&self) -> u8 {
        self.cf_ttl_ind_raw()
    }
    
    /// Get raw value of CF_TTL_Ind
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ttl_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_TTL_Ind
    #[inline(always)]
    pub fn set_cf_ttl_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1280 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// CF_SBR_Ind
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCM, CLU
    #[inline(always)]
    pub fn cf_sbr_ind(&self) -> u8 {
        self.cf_sbr_ind_raw()
    }
    
    /// Get raw value of CF_SBR_Ind
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_sbr_ind_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_SBR_Ind
    #[inline(always)]
    pub fn set_cf_sbr_ind(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1280 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Acu14 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 1 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 1];
        raw.copy_from_slice(&payload[..1]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Acu14 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Acu14")
                .field("cf_swl_ind", &self.cf_swl_ind())
                .field("cf_ttl_ind", &self.cf_ttl_ind())
                .field("cf_sbr_ind", &self.cf_sbr_ind())
            .finish()
        } else {
            f.debug_tuple("Acu14").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Acu14 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_swl_ind = u.int_in_range(0..=3)?;
        let cf_ttl_ind = u.int_in_range(0..=3)?;
        let cf_sbr_ind = u.int_in_range(0..=3)?;
        Acu14::new(cf_swl_ind,cf_ttl_ind,cf_sbr_ind).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EMS20
///
/// - ID: 512 (0x200)
/// - Size: 6 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct Ems20 {
    raw: [u8; 6],
}

impl Ems20 {
    pub const MESSAGE_ID: u32 = 512;
    
    pub const FCO_MIN: f32 = 0_f32;
    pub const FCO_MAX: f32 = 8388.48_f32;
    pub const CF_EMS_PUMP_T_PRES_MIN: f32 = 0_f32;
    pub const CF_EMS_PUMP_T_PRES_MAX: f32 = 800_f32;
    
    /// Construct new EMS20 from values
    pub fn new(fco: f32, cf_ems_pump_t_pres: f32, split_stat: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 6] };
        res.set_fco(fco)?;
        res.set_cf_ems_pump_t_pres(cf_ems_pump_t_pres)?;
        res.set_split_stat(split_stat)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 6] {
        &self.raw
    }
    
    /// FCO
    ///
    /// - Min: 0
    /// - Max: 8388.48
    /// - Unit: "ul"
    /// - Receivers: CLU, CUBIS, FPCM, IBOX
    #[inline(always)]
    pub fn fco(&self) -> f32 {
        self.fco_raw()
    }
    
    /// Get raw value of FCO
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.128
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fco_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.128_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of FCO
    #[inline(always)]
    pub fn set_fco(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 8388.48_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 512 });
        }
        let factor = 0.128_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
    /// CF_Ems_PumpTPres
    ///
    /// - Min: 0
    /// - Max: 800
    /// - Unit: "kPa"
    /// - Receivers: FPCM, IBOX
    #[inline(always)]
    pub fn cf_ems_pump_t_pres(&self) -> f32 {
        self.cf_ems_pump_t_pres_raw()
    }
    
    /// Get raw value of CF_Ems_PumpTPres
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 3.137254902
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ems_pump_t_pres_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 3.137254902_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CF_Ems_PumpTPres
    #[inline(always)]
    pub fn set_cf_ems_pump_t_pres(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 800_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 512 });
        }
        let factor = 3.137254902_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// Split_Stat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: FPCM
    #[inline(always)]
    pub fn split_stat(&self) -> bool {
        self.split_stat_raw()
    }
    
    /// Get raw value of Split_Stat
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn split_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[32..33].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Split_Stat
    #[inline(always)]
    pub fn set_split_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[32..33].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ems20 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 6 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 6];
        raw.copy_from_slice(&payload[..6]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ems20 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ems20")
                .field("fco", &self.fco())
                .field("cf_ems_pump_t_pres", &self.cf_ems_pump_t_pres())
                .field("split_stat", &self.split_stat())
            .finish()
        } else {
            f.debug_tuple("Ems20").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ems20 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let fco = u.float_in_range(0_f32..=8388.48_f32)?;
        let cf_ems_pump_t_pres = u.float_in_range(0_f32..=800_f32)?;
        let split_stat = u.int_in_range(0..=1)? == 1;
        Ems20::new(fco,cf_ems_pump_t_pres,split_stat).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// FCA11
///
/// - ID: 909 (0x38d)
/// - Size: 8 bytes
/// - Transmitter: FCA
#[derive(Clone, Copy)]
pub struct Fca11 {
    raw: [u8; 8],
}

impl Fca11 {
    pub const MESSAGE_ID: u32 = 909;
    
    pub const CF_VSM_HBA_CMD_MIN: u8 = 0_u8;
    pub const CF_VSM_HBA_CMD_MAX: u8 = 3_u8;
    pub const CF_VSM_WARN_MIN: u8 = 0_u8;
    pub const CF_VSM_WARN_MAX: u8 = 3_u8;
    pub const CF_VSM_BELT_CMD_MIN: u8 = 0_u8;
    pub const CF_VSM_BELT_CMD_MAX: u8 = 7_u8;
    pub const CR_VSM_DEC_CMD_MIN: f32 = 0_f32;
    pub const CR_VSM_DEC_CMD_MAX: f32 = 2.55_f32;
    pub const FCA_STATUS_MIN: u8 = 0_u8;
    pub const FCA_STATUS_MAX: u8 = 3_u8;
    pub const FCA_DRV_SET_STATUS_MIN: u8 = 0_u8;
    pub const FCA_DRV_SET_STATUS_MAX: u8 = 7_u8;
    pub const FCA_FAILINFO_MIN: u8 = 0_u8;
    pub const FCA_FAILINFO_MAX: u8 = 7_u8;
    pub const CR_FCA_ALIVE_MIN: u8 = 0_u8;
    pub const CR_FCA_ALIVE_MAX: u8 = 15_u8;
    pub const FCA_RELATIVE_VELOCITY_MIN: f32 = -25.5_f32;
    pub const FCA_RELATIVE_VELOCITY_MAX: f32 = 25.5_f32;
    pub const FCA_TIMETO_COLLISION_MIN: f32 = 0_f32;
    pub const FCA_TIMETO_COLLISION_MAX: f32 = 2540_f32;
    pub const CR_FCA_CHK_SUM_MIN: u8 = 0_u8;
    pub const CR_FCA_CHK_SUM_MAX: u8 = 255_u8;
    pub const PAINT1_STATUS_MIN: u8 = 0_u8;
    pub const PAINT1_STATUS_MAX: u8 = 1_u8;
    
    /// Construct new FCA11 from values
    pub fn new(cf_vsm_prefill: bool, cf_vsm_hba_cmd: u8, cf_vsm_warn: u8, cf_vsm_belt_cmd: u8, cr_vsm_dec_cmd: f32, fca_status: u8, fca_cmd_act: bool, fca_stop_req: bool, fca_drv_set_status: u8, cf_vsm_dec_cmd_act: bool, fca_failinfo: u8, cr_fca_alive: u8, fca_relative_velocity: f32, fca_timeto_collision: f32, cr_fca_chk_sum: u8, paint1_status: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_vsm_prefill(cf_vsm_prefill)?;
        res.set_cf_vsm_hba_cmd(cf_vsm_hba_cmd)?;
        res.set_cf_vsm_warn(cf_vsm_warn)?;
        res.set_cf_vsm_belt_cmd(cf_vsm_belt_cmd)?;
        res.set_cr_vsm_dec_cmd(cr_vsm_dec_cmd)?;
        res.set_fca_status(fca_status)?;
        res.set_fca_cmd_act(fca_cmd_act)?;
        res.set_fca_stop_req(fca_stop_req)?;
        res.set_fca_drv_set_status(fca_drv_set_status)?;
        res.set_cf_vsm_dec_cmd_act(cf_vsm_dec_cmd_act)?;
        res.set_fca_failinfo(fca_failinfo)?;
        res.set_cr_fca_alive(cr_fca_alive)?;
        res.set_fca_relative_velocity(fca_relative_velocity)?;
        res.set_fca_timeto_collision(fca_timeto_collision)?;
        res.set_cr_fca_chk_sum(cr_fca_chk_sum)?;
        res.set_paint1_status(paint1_status)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_VSM_Prefill
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cf_vsm_prefill(&self) -> bool {
        self.cf_vsm_prefill_raw()
    }
    
    /// Get raw value of CF_VSM_Prefill
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_prefill_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_VSM_Prefill
    #[inline(always)]
    pub fn set_cf_vsm_prefill(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
    /// CF_VSM_HBACmd
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cf_vsm_hba_cmd(&self) -> u8 {
        self.cf_vsm_hba_cmd_raw()
    }
    
    /// Get raw value of CF_VSM_HBACmd
    ///
    /// - Start bit: 1
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_hba_cmd_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[1..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_VSM_HBACmd
    #[inline(always)]
    pub fn set_cf_vsm_hba_cmd(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 909 });
        }
        self.raw.view_bits_mut::<Lsb0>()[1..3].store_le(value);
        Ok(())
    }
    
    /// CF_VSM_Warn
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: ACU, CLU, ESC
    #[inline(always)]
    pub fn cf_vsm_warn(&self) -> Fca11CfVsmWarn {
        let signal = self.raw.view_bits::<Lsb0>()[3..5].load_le::<u8>();
        
        match signal {
            2 => Fca11CfVsmWarn::Fcw,
            3 => Fca11CfVsmWarn::Aeb,
            _ => Fca11CfVsmWarn::_Other(self.cf_vsm_warn_raw()),
        }
    }
    
    /// Get raw value of CF_VSM_Warn
    ///
    /// - Start bit: 3
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_warn_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[3..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_VSM_Warn
    #[inline(always)]
    pub fn set_cf_vsm_warn(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 909 });
        }
        self.raw.view_bits_mut::<Lsb0>()[3..5].store_le(value);
        Ok(())
    }
    
    /// CF_VSM_BeltCmd
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cf_vsm_belt_cmd(&self) -> u8 {
        self.cf_vsm_belt_cmd_raw()
    }
    
    /// Get raw value of CF_VSM_BeltCmd
    ///
    /// - Start bit: 5
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_belt_cmd_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[5..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_VSM_BeltCmd
    #[inline(always)]
    pub fn set_cf_vsm_belt_cmd(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 909 });
        }
        self.raw.view_bits_mut::<Lsb0>()[5..8].store_le(value);
        Ok(())
    }
    
    /// CR_VSM_DecCmd
    ///
    /// - Min: 0
    /// - Max: 2.55
    /// - Unit: "g"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cr_vsm_dec_cmd(&self) -> f32 {
        self.cr_vsm_dec_cmd_raw()
    }
    
    /// Get raw value of CR_VSM_DecCmd
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_vsm_dec_cmd_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_VSM_DecCmd
    #[inline(always)]
    pub fn set_cr_vsm_dec_cmd(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2.55_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 909 });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// FCA_Status
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: ACU, CLU, ESC
    #[inline(always)]
    pub fn fca_status(&self) -> u8 {
        self.fca_status_raw()
    }
    
    /// Get raw value of FCA_Status
    ///
    /// - Start bit: 18
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fca_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[18..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of FCA_Status
    #[inline(always)]
    pub fn set_fca_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 909 });
        }
        self.raw.view_bits_mut::<Lsb0>()[18..20].store_le(value);
        Ok(())
    }
    
    /// FCA_CmdAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn fca_cmd_act(&self) -> bool {
        self.fca_cmd_act_raw()
    }
    
    /// Get raw value of FCA_CmdAct
    ///
    /// - Start bit: 20
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fca_cmd_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[20..21].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of FCA_CmdAct
    #[inline(always)]
    pub fn set_fca_cmd_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[20..21].store_le(value);
        Ok(())
    }
    
    /// FCA_StopReq
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU, ESC
    #[inline(always)]
    pub fn fca_stop_req(&self) -> bool {
        self.fca_stop_req_raw()
    }
    
    /// Get raw value of FCA_StopReq
    ///
    /// - Start bit: 21
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fca_stop_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[21..22].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of FCA_StopReq
    #[inline(always)]
    pub fn set_fca_stop_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[21..22].store_le(value);
        Ok(())
    }
    
    /// FCA_DrvSetStatus
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, ESC
    #[inline(always)]
    pub fn fca_drv_set_status(&self) -> u8 {
        self.fca_drv_set_status_raw()
    }
    
    /// Get raw value of FCA_DrvSetStatus
    ///
    /// - Start bit: 22
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fca_drv_set_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..25].load_le::<u8>();
        
        signal
    }
    
    /// Set value of FCA_DrvSetStatus
    #[inline(always)]
    pub fn set_fca_drv_set_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 909 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..25].store_le(value);
        Ok(())
    }
    
    /// CF_VSM_DecCmdAct
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cf_vsm_dec_cmd_act(&self) -> bool {
        self.cf_vsm_dec_cmd_act_raw()
    }
    
    /// Get raw value of CF_VSM_DecCmdAct
    ///
    /// - Start bit: 31
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vsm_dec_cmd_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[31..32].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_VSM_DecCmdAct
    #[inline(always)]
    pub fn set_cf_vsm_dec_cmd_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[31..32].store_le(value);
        Ok(())
    }
    
    /// FCA_Failinfo
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: ACU, CLU, ESC
    #[inline(always)]
    pub fn fca_failinfo(&self) -> u8 {
        self.fca_failinfo_raw()
    }
    
    /// Get raw value of FCA_Failinfo
    ///
    /// - Start bit: 32
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fca_failinfo_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..35].load_le::<u8>();
        
        signal
    }
    
    /// Set value of FCA_Failinfo
    #[inline(always)]
    pub fn set_fca_failinfo(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 909 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..35].store_le(value);
        Ok(())
    }
    
    /// CR_FCA_Alive
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cr_fca_alive(&self) -> u8 {
        self.cr_fca_alive_raw()
    }
    
    /// Get raw value of CR_FCA_Alive
    ///
    /// - Start bit: 35
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_fca_alive_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[35..39].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_FCA_Alive
    #[inline(always)]
    pub fn set_cr_fca_alive(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 909 });
        }
        self.raw.view_bits_mut::<Lsb0>()[35..39].store_le(value);
        Ok(())
    }
    
    /// FCA_RelativeVelocity
    ///
    /// - Min: -25.5
    /// - Max: 25.5
    /// - Unit: "m/s"
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn fca_relative_velocity(&self) -> f32 {
        self.fca_relative_velocity_raw()
    }
    
    /// Get raw value of FCA_RelativeVelocity
    ///
    /// - Start bit: 39
    /// - Signal size: 9 bits
    /// - Factor: 0.1
    /// - Offset: -25.5
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fca_relative_velocity_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[39..48].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = -25.5_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of FCA_RelativeVelocity
    #[inline(always)]
    pub fn set_fca_relative_velocity(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -25.5_f32 || 25.5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 909 });
        }
        let factor = 0.1_f32;
        let offset = -25.5_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[39..48].store_le(value);
        Ok(())
    }
    
    /// FCA_TimetoCollision
    ///
    /// - Min: 0
    /// - Max: 2540
    /// - Unit: "ms"
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn fca_timeto_collision(&self) -> f32 {
        self.fca_timeto_collision_raw()
    }
    
    /// Get raw value of FCA_TimetoCollision
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fca_timeto_collision_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        let factor = 10_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of FCA_TimetoCollision
    #[inline(always)]
    pub fn set_fca_timeto_collision(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 2540_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 909 });
        }
        let factor = 10_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// CR_FCA_ChkSum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: ESC
    #[inline(always)]
    pub fn cr_fca_chk_sum(&self) -> u8 {
        self.cr_fca_chk_sum_raw()
    }
    
    /// Get raw value of CR_FCA_ChkSum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_fca_chk_sum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_FCA_ChkSum
    #[inline(always)]
    pub fn set_cr_fca_chk_sum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 909 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
    /// PAINT1_Status
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn paint1_status(&self) -> u8 {
        self.paint1_status_raw()
    }
    
    /// Get raw value of PAINT1_Status
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn paint1_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PAINT1_Status
    #[inline(always)]
    pub fn set_paint1_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 1_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 909 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..18].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Fca11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Fca11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Fca11")
                .field("cf_vsm_prefill", &self.cf_vsm_prefill())
                .field("cf_vsm_hba_cmd", &self.cf_vsm_hba_cmd())
                .field("cf_vsm_warn", &self.cf_vsm_warn())
                .field("cf_vsm_belt_cmd", &self.cf_vsm_belt_cmd())
                .field("cr_vsm_dec_cmd", &self.cr_vsm_dec_cmd())
                .field("fca_status", &self.fca_status())
                .field("fca_cmd_act", &self.fca_cmd_act())
                .field("fca_stop_req", &self.fca_stop_req())
                .field("fca_drv_set_status", &self.fca_drv_set_status())
                .field("cf_vsm_dec_cmd_act", &self.cf_vsm_dec_cmd_act())
                .field("fca_failinfo", &self.fca_failinfo())
                .field("cr_fca_alive", &self.cr_fca_alive())
                .field("fca_relative_velocity", &self.fca_relative_velocity())
                .field("fca_timeto_collision", &self.fca_timeto_collision())
                .field("cr_fca_chk_sum", &self.cr_fca_chk_sum())
                .field("paint1_status", &self.paint1_status())
            .finish()
        } else {
            f.debug_tuple("Fca11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Fca11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_vsm_prefill = u.int_in_range(0..=1)? == 1;
        let cf_vsm_hba_cmd = u.int_in_range(0..=3)?;
        let cf_vsm_warn = u.int_in_range(0..=3)?;
        let cf_vsm_belt_cmd = u.int_in_range(0..=7)?;
        let cr_vsm_dec_cmd = u.float_in_range(0_f32..=2.55_f32)?;
        let fca_status = u.int_in_range(0..=3)?;
        let fca_cmd_act = u.int_in_range(0..=1)? == 1;
        let fca_stop_req = u.int_in_range(0..=1)? == 1;
        let fca_drv_set_status = u.int_in_range(0..=7)?;
        let cf_vsm_dec_cmd_act = u.int_in_range(0..=1)? == 1;
        let fca_failinfo = u.int_in_range(0..=7)?;
        let cr_fca_alive = u.int_in_range(0..=15)?;
        let fca_relative_velocity = u.float_in_range(-25.5_f32..=25.5_f32)?;
        let fca_timeto_collision = u.float_in_range(0_f32..=2540_f32)?;
        let cr_fca_chk_sum = u.int_in_range(0..=255)?;
        let paint1_status = u.int_in_range(0..=1)?;
        Fca11::new(cf_vsm_prefill,cf_vsm_hba_cmd,cf_vsm_warn,cf_vsm_belt_cmd,cr_vsm_dec_cmd,fca_status,fca_cmd_act,fca_stop_req,fca_drv_set_status,cf_vsm_dec_cmd_act,fca_failinfo,cr_fca_alive,fca_relative_velocity,fca_timeto_collision,cr_fca_chk_sum,paint1_status).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for CF_VSM_Warn
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Fca11CfVsmWarn {
    Fcw,
    Aeb,
    _Other(u8),
}

impl From<Fca11CfVsmWarn> for u8 {
    fn from(val: Fca11CfVsmWarn) -> u8 {
        match val {
            Fca11CfVsmWarn::Fcw => 2,
            Fca11CfVsmWarn::Aeb => 3,
            Fca11CfVsmWarn::_Other(x) => x,
        }
    }
}


/// HDA11_MFC
///
/// - ID: 1156 (0x484)
/// - Size: 8 bytes
/// - Transmitter: XXX
#[derive(Clone, Copy)]
pub struct Hda11Mfc {
    raw: [u8; 8],
}

impl Hda11Mfc {
    pub const MESSAGE_ID: u32 = 1156;
    
    pub const COUNTER_MIN: u8 = 0_u8;
    pub const COUNTER_MAX: u8 = 15_u8;
    pub const NEW_SIGNAL_1_MIN: u8 = 0_u8;
    pub const NEW_SIGNAL_1_MAX: u8 = 255_u8;
    pub const NEW_SIGNAL_2_MIN: u8 = 0_u8;
    pub const NEW_SIGNAL_2_MAX: u8 = 3_u8;
    pub const NEW_SIGNAL_3_MIN: u8 = 0_u8;
    pub const NEW_SIGNAL_3_MAX: u8 = 255_u8;
    pub const NEW_SIGNAL_4_MIN: u8 = 0_u8;
    pub const NEW_SIGNAL_4_MAX: u8 = 3_u8;
    pub const NEW_SIGNAL_5_MIN: u16 = 0_u16;
    pub const NEW_SIGNAL_5_MAX: u16 = 63_u16;
    pub const NEW_SIGNAL_6_MIN: u8 = 0_u8;
    pub const NEW_SIGNAL_6_MAX: u8 = 1_u8;
    pub const NEW_SIGNAL_7_MIN: u16 = 0_u16;
    pub const NEW_SIGNAL_7_MAX: u16 = 16383_u16;
    pub const NEW_SIGNAL_8_MIN: u8 = 0_u8;
    pub const NEW_SIGNAL_8_MAX: u8 = 1_u8;
    pub const NEW_SIGNAL_9_MIN: f32 = 0_f32;
    pub const NEW_SIGNAL_9_MAX: f32 = 16383_f32;
    
    /// Construct new HDA11_MFC from values
    pub fn new(counter: u8, new_signal_1: u8, new_signal_2: u8, new_signal_3: u8, new_signal_4: u8, new_signal_5: u16, new_signal_6: u8, new_signal_7: u16, new_signal_8: u8, new_signal_9: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_counter(counter)?;
        res.set_new_signal_1(new_signal_1)?;
        res.set_new_signal_2(new_signal_2)?;
        res.set_new_signal_3(new_signal_3)?;
        res.set_new_signal_4(new_signal_4)?;
        res.set_new_signal_5(new_signal_5)?;
        res.set_new_signal_6(new_signal_6)?;
        res.set_new_signal_7(new_signal_7)?;
        res.set_new_signal_8(new_signal_8)?;
        res.set_new_signal_9(new_signal_9)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Counter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn counter(&self) -> u8 {
        self.counter_raw()
    }
    
    /// Get raw value of Counter
    ///
    /// - Start bit: 5
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[2..6].load_be::<u8>();
        
        signal
    }
    
    /// Set value of Counter
    #[inline(always)]
    pub fn set_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1156 });
        }
        self.raw.view_bits_mut::<Msb0>()[2..6].store_be(value);
        Ok(())
    }
    
    /// NEW_SIGNAL_1
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn new_signal_1(&self) -> u8 {
        self.new_signal_1_raw()
    }
    
    /// Get raw value of NEW_SIGNAL_1
    ///
    /// - Start bit: 1
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn new_signal_1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[6..8].load_be::<u8>();
        
        signal
    }
    
    /// Set value of NEW_SIGNAL_1
    #[inline(always)]
    pub fn set_new_signal_1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1156 });
        }
        self.raw.view_bits_mut::<Msb0>()[6..8].store_be(value);
        Ok(())
    }
    
    /// NEW_SIGNAL_2
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn new_signal_2(&self) -> u8 {
        self.new_signal_2_raw()
    }
    
    /// Get raw value of NEW_SIGNAL_2
    ///
    /// - Start bit: 7
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn new_signal_2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[0..2].load_be::<u8>();
        
        signal
    }
    
    /// Set value of NEW_SIGNAL_2
    #[inline(always)]
    pub fn set_new_signal_2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1156 });
        }
        self.raw.view_bits_mut::<Msb0>()[0..2].store_be(value);
        Ok(())
    }
    
    /// NEW_SIGNAL_3
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn new_signal_3(&self) -> u8 {
        self.new_signal_3_raw()
    }
    
    /// Get raw value of NEW_SIGNAL_3
    ///
    /// - Start bit: 15
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn new_signal_3_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[8..16].load_be::<u8>();
        
        signal
    }
    
    /// Set value of NEW_SIGNAL_3
    #[inline(always)]
    pub fn set_new_signal_3(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1156 });
        }
        self.raw.view_bits_mut::<Msb0>()[8..16].store_be(value);
        Ok(())
    }
    
    /// NEW_SIGNAL_4
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn new_signal_4(&self) -> u8 {
        self.new_signal_4_raw()
    }
    
    /// Get raw value of NEW_SIGNAL_4
    ///
    /// - Start bit: 16
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn new_signal_4_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..18].load_le::<u8>();
        
        signal
    }
    
    /// Set value of NEW_SIGNAL_4
    #[inline(always)]
    pub fn set_new_signal_4(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1156 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..18].store_le(value);
        Ok(())
    }
    
    /// NEW_SIGNAL_5
    ///
    /// - Min: 0
    /// - Max: 63
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn new_signal_5(&self) -> u16 {
        self.new_signal_5_raw()
    }
    
    /// Get raw value of NEW_SIGNAL_5
    ///
    /// - Start bit: 18
    /// - Signal size: 14 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn new_signal_5_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[18..32].load_le::<u16>();
        
        signal
    }
    
    /// Set value of NEW_SIGNAL_5
    #[inline(always)]
    pub fn set_new_signal_5(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 63_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1156 });
        }
        self.raw.view_bits_mut::<Lsb0>()[18..32].store_le(value);
        Ok(())
    }
    
    /// NEW_SIGNAL_6
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn new_signal_6(&self) -> u8 {
        self.new_signal_6_raw()
    }
    
    /// Get raw value of NEW_SIGNAL_6
    ///
    /// - Start bit: 33
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn new_signal_6_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[38..40].load_be::<u8>();
        
        signal
    }
    
    /// Set value of NEW_SIGNAL_6
    #[inline(always)]
    pub fn set_new_signal_6(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 1_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1156 });
        }
        self.raw.view_bits_mut::<Msb0>()[38..40].store_be(value);
        Ok(())
    }
    
    /// NEW_SIGNAL_7
    ///
    /// - Min: 0
    /// - Max: 16383
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn new_signal_7(&self) -> u16 {
        self.new_signal_7_raw()
    }
    
    /// Get raw value of NEW_SIGNAL_7
    ///
    /// - Start bit: 34
    /// - Signal size: 14 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn new_signal_7_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[34..48].load_le::<u16>();
        
        signal
    }
    
    /// Set value of NEW_SIGNAL_7
    #[inline(always)]
    pub fn set_new_signal_7(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 16383_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1156 });
        }
        self.raw.view_bits_mut::<Lsb0>()[34..48].store_le(value);
        Ok(())
    }
    
    /// NEW_SIGNAL_8
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn new_signal_8(&self) -> u8 {
        self.new_signal_8_raw()
    }
    
    /// Get raw value of NEW_SIGNAL_8
    ///
    /// - Start bit: 49
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn new_signal_8_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[54..56].load_be::<u8>();
        
        signal
    }
    
    /// Set value of NEW_SIGNAL_8
    #[inline(always)]
    pub fn set_new_signal_8(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 1_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1156 });
        }
        self.raw.view_bits_mut::<Msb0>()[54..56].store_be(value);
        Ok(())
    }
    
    /// NEW_SIGNAL_9
    ///
    /// - Min: 0
    /// - Max: 16383
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn new_signal_9(&self) -> f32 {
        self.new_signal_9_raw()
    }
    
    /// Get raw value of NEW_SIGNAL_9
    ///
    /// - Start bit: 50
    /// - Signal size: 14 bits
    /// - Factor: 1
    /// - Offset: -4095
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn new_signal_9_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[50..64].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 1_f32;
        let offset = -4095_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of NEW_SIGNAL_9
    #[inline(always)]
    pub fn set_new_signal_9(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 16383_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1156 });
        }
        let factor = 1_f32;
        let offset = -4095_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[50..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Hda11Mfc {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Hda11Mfc {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Hda11Mfc")
                .field("counter", &self.counter())
                .field("new_signal_1", &self.new_signal_1())
                .field("new_signal_2", &self.new_signal_2())
                .field("new_signal_3", &self.new_signal_3())
                .field("new_signal_4", &self.new_signal_4())
                .field("new_signal_5", &self.new_signal_5())
                .field("new_signal_6", &self.new_signal_6())
                .field("new_signal_7", &self.new_signal_7())
                .field("new_signal_8", &self.new_signal_8())
                .field("new_signal_9", &self.new_signal_9())
            .finish()
        } else {
            f.debug_tuple("Hda11Mfc").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Hda11Mfc {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let counter = u.int_in_range(0..=15)?;
        let new_signal_1 = u.int_in_range(0..=255)?;
        let new_signal_2 = u.int_in_range(0..=3)?;
        let new_signal_3 = u.int_in_range(0..=255)?;
        let new_signal_4 = u.int_in_range(0..=3)?;
        let new_signal_5 = u.int_in_range(0..=63)?;
        let new_signal_6 = u.int_in_range(0..=1)?;
        let new_signal_7 = u.int_in_range(0..=16383)?;
        let new_signal_8 = u.int_in_range(0..=1)?;
        let new_signal_9 = u.float_in_range(0_f32..=16383_f32)?;
        Hda11Mfc::new(counter,new_signal_1,new_signal_2,new_signal_3,new_signal_4,new_signal_5,new_signal_6,new_signal_7,new_signal_8,new_signal_9).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// FCA12
///
/// - ID: 1155 (0x483)
/// - Size: 8 bytes
/// - Transmitter: FCA
#[derive(Clone, Copy)]
pub struct Fca12 {
    raw: [u8; 8],
}

impl Fca12 {
    pub const MESSAGE_ID: u32 = 1155;
    
    pub const FCA_USM_MIN: u8 = 0_u8;
    pub const FCA_USM_MAX: u8 = 7_u8;
    pub const FCA_DRV_SET_STATE_MIN: u8 = 0_u8;
    pub const FCA_DRV_SET_STATE_MAX: u8 = 7_u8;
    
    /// Construct new FCA12 from values
    pub fn new(fca_usm: u8, fca_drv_set_state: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_fca_usm(fca_usm)?;
        res.set_fca_drv_set_state(fca_drv_set_state)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// FCA_USM
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CGW, CLU, ESC
    #[inline(always)]
    pub fn fca_usm(&self) -> u8 {
        self.fca_usm_raw()
    }
    
    /// Get raw value of FCA_USM
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fca_usm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of FCA_USM
    #[inline(always)]
    pub fn set_fca_usm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1155 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..3].store_le(value);
        Ok(())
    }
    
    /// FCA_DrvSetState
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CGW
    #[inline(always)]
    pub fn fca_drv_set_state(&self) -> u8 {
        self.fca_drv_set_state_raw()
    }
    
    /// Get raw value of FCA_DrvSetState
    ///
    /// - Start bit: 3
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn fca_drv_set_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[3..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of FCA_DrvSetState
    #[inline(always)]
    pub fn set_fca_drv_set_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1155 });
        }
        self.raw.view_bits_mut::<Lsb0>()[3..6].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Fca12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Fca12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Fca12")
                .field("fca_usm", &self.fca_usm())
                .field("fca_drv_set_state", &self.fca_drv_set_state())
            .finish()
        } else {
            f.debug_tuple("Fca12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Fca12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let fca_usm = u.int_in_range(0..=7)?;
        let fca_drv_set_state = u.int_in_range(0..=7)?;
        Fca12::new(fca_usm,fca_drv_set_state).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// FRT_RADAR11
///
/// - ID: 1186 (0x4a2)
/// - Size: 2 bytes
/// - Transmitter: FCA
#[derive(Clone, Copy)]
pub struct FrtRadar11 {
    raw: [u8; 2],
}

impl FrtRadar11 {
    pub const MESSAGE_ID: u32 = 1186;
    
    pub const CF_FCA_EQUIP_FRONT_RADAR_MIN: u8 = 0_u8;
    pub const CF_FCA_EQUIP_FRONT_RADAR_MAX: u8 = 7_u8;
    
    /// Construct new FRT_RADAR11 from values
    pub fn new(cf_fca_equip_front_radar: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_cf_fca_equip_front_radar(cf_fca_equip_front_radar)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// CF_FCA_Equip_Front_Radar
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: LDWS_LKAS, LDW_LKA, ESC
    #[inline(always)]
    pub fn cf_fca_equip_front_radar(&self) -> u8 {
        self.cf_fca_equip_front_radar_raw()
    }
    
    /// Get raw value of CF_FCA_Equip_Front_Radar
    ///
    /// - Start bit: 0
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_fca_equip_front_radar_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..3].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_FCA_Equip_Front_Radar
    #[inline(always)]
    pub fn set_cf_fca_equip_front_radar(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1186 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..3].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for FrtRadar11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for FrtRadar11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("FrtRadar11")
                .field("cf_fca_equip_front_radar", &self.cf_fca_equip_front_radar())
            .finish()
        } else {
            f.debug_tuple("FrtRadar11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for FrtRadar11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_fca_equip_front_radar = u.int_in_range(0..=7)?;
        FrtRadar11::new(cf_fca_equip_front_radar).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// SCC14
///
/// - ID: 905 (0x389)
/// - Size: 8 bytes
/// - Transmitter: SCC
#[derive(Clone, Copy)]
pub struct Scc14 {
    raw: [u8; 8],
}

impl Scc14 {
    pub const MESSAGE_ID: u32 = 905;
    
    pub const COMFORT_BAND_UPPER_MIN: f32 = 0_f32;
    pub const COMFORT_BAND_UPPER_MAX: f32 = 1.26_f32;
    pub const COMFORT_BAND_LOWER_MIN: f32 = 0_f32;
    pub const COMFORT_BAND_LOWER_MAX: f32 = 1.26_f32;
    pub const JERK_UPPER_LIMIT_MIN: f32 = 0_f32;
    pub const JERK_UPPER_LIMIT_MAX: f32 = 12.7_f32;
    pub const JERK_LOWER_LIMIT_MIN: f32 = 0_f32;
    pub const JERK_LOWER_LIMIT_MAX: f32 = 12.7_f32;
    pub const ACC_MODE_MIN: u8 = 0_u8;
    pub const ACC_MODE_MAX: u8 = 7_u8;
    pub const OBJ_GAP_MIN: u8 = 0_u8;
    pub const OBJ_GAP_MAX: u8 = 255_u8;
    
    /// Construct new SCC14 from values
    pub fn new(comfort_band_upper: f32, comfort_band_lower: f32, jerk_upper_limit: f32, jerk_lower_limit: f32, acc_mode: u8, obj_gap: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_comfort_band_upper(comfort_band_upper)?;
        res.set_comfort_band_lower(comfort_band_lower)?;
        res.set_jerk_upper_limit(jerk_upper_limit)?;
        res.set_jerk_lower_limit(jerk_lower_limit)?;
        res.set_acc_mode(acc_mode)?;
        res.set_obj_gap(obj_gap)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// ComfortBandUpper
    ///
    /// - Min: 0
    /// - Max: 1.26
    /// - Unit: "m/s^2"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn comfort_band_upper(&self) -> f32 {
        self.comfort_band_upper_raw()
    }
    
    /// Get raw value of ComfortBandUpper
    ///
    /// - Start bit: 0
    /// - Signal size: 6 bits
    /// - Factor: 0.02
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn comfort_band_upper_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..6].load_le::<u8>();
        
        let factor = 0.02_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of ComfortBandUpper
    #[inline(always)]
    pub fn set_comfort_band_upper(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1.26_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 905 });
        }
        let factor = 0.02_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..6].store_le(value);
        Ok(())
    }
    
    /// ComfortBandLower
    ///
    /// - Min: 0
    /// - Max: 1.26
    /// - Unit: "m/s^2"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn comfort_band_lower(&self) -> f32 {
        self.comfort_band_lower_raw()
    }
    
    /// Get raw value of ComfortBandLower
    ///
    /// - Start bit: 6
    /// - Signal size: 6 bits
    /// - Factor: 0.02
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn comfort_band_lower_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[6..12].load_le::<u8>();
        
        let factor = 0.02_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of ComfortBandLower
    #[inline(always)]
    pub fn set_comfort_band_lower(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 1.26_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 905 });
        }
        let factor = 0.02_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[6..12].store_le(value);
        Ok(())
    }
    
    /// JerkUpperLimit
    ///
    /// - Min: 0
    /// - Max: 12.7
    /// - Unit: "m/s^3"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn jerk_upper_limit(&self) -> f32 {
        self.jerk_upper_limit_raw()
    }
    
    /// Get raw value of JerkUpperLimit
    ///
    /// - Start bit: 12
    /// - Signal size: 7 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn jerk_upper_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[12..19].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of JerkUpperLimit
    #[inline(always)]
    pub fn set_jerk_upper_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 12.7_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 905 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[12..19].store_le(value);
        Ok(())
    }
    
    /// JerkLowerLimit
    ///
    /// - Min: 0
    /// - Max: 12.7
    /// - Unit: "m/s^3"
    /// - Receivers: ESC
    #[inline(always)]
    pub fn jerk_lower_limit(&self) -> f32 {
        self.jerk_lower_limit_raw()
    }
    
    /// Get raw value of JerkLowerLimit
    ///
    /// - Start bit: 19
    /// - Signal size: 7 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn jerk_lower_limit_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[19..26].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of JerkLowerLimit
    #[inline(always)]
    pub fn set_jerk_lower_limit(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 12.7_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 905 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[19..26].store_le(value);
        Ok(())
    }
    
    /// ACCMode
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, HUD, LDWS_LKAS, ESC
    #[inline(always)]
    pub fn acc_mode(&self) -> Scc14AccMode {
        let signal = self.raw.view_bits::<Lsb0>()[32..35].load_le::<u8>();
        
        match signal {
            0 => Scc14AccMode::Off,
            1 => Scc14AccMode::Enabled,
            2 => Scc14AccMode::DriverOverride,
            3 => Scc14AccMode::OffMaybeFault,
            4 => Scc14AccMode::Cancelled,
            _ => Scc14AccMode::_Other(self.acc_mode_raw()),
        }
    }
    
    /// Get raw value of ACCMode
    ///
    /// - Start bit: 32
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn acc_mode_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..35].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ACCMode
    #[inline(always)]
    pub fn set_acc_mode(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 905 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..35].store_le(value);
        Ok(())
    }
    
    /// ObjGap
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: CLU, HUD, ESC
    #[inline(always)]
    pub fn obj_gap(&self) -> u8 {
        self.obj_gap_raw()
    }
    
    /// Get raw value of ObjGap
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn obj_gap_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of ObjGap
    #[inline(always)]
    pub fn set_obj_gap(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 905 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Scc14 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Scc14 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Scc14")
                .field("comfort_band_upper", &self.comfort_band_upper())
                .field("comfort_band_lower", &self.comfort_band_lower())
                .field("jerk_upper_limit", &self.jerk_upper_limit())
                .field("jerk_lower_limit", &self.jerk_lower_limit())
                .field("acc_mode", &self.acc_mode())
                .field("obj_gap", &self.obj_gap())
            .finish()
        } else {
            f.debug_tuple("Scc14").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Scc14 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let comfort_band_upper = u.float_in_range(0_f32..=1.26_f32)?;
        let comfort_band_lower = u.float_in_range(0_f32..=1.26_f32)?;
        let jerk_upper_limit = u.float_in_range(0_f32..=12.7_f32)?;
        let jerk_lower_limit = u.float_in_range(0_f32..=12.7_f32)?;
        let acc_mode = u.int_in_range(0..=7)?;
        let obj_gap = u.int_in_range(0..=255)?;
        Scc14::new(comfort_band_upper,comfort_band_lower,jerk_upper_limit,jerk_lower_limit,acc_mode,obj_gap).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for ACCMode
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum Scc14AccMode {
    Off,
    Enabled,
    DriverOverride,
    OffMaybeFault,
    Cancelled,
    _Other(u8),
}

impl From<Scc14AccMode> for u8 {
    fn from(val: Scc14AccMode) -> u8 {
        match val {
            Scc14AccMode::Off => 0,
            Scc14AccMode::Enabled => 1,
            Scc14AccMode::DriverOverride => 2,
            Scc14AccMode::OffMaybeFault => 3,
            Scc14AccMode::Cancelled => 4,
            Scc14AccMode::_Other(x) => x,
        }
    }
}


/// LFAHDA_MFC
///
/// - ID: 1157 (0x485)
/// - Size: 4 bytes
/// - Transmitter: XXX
#[derive(Clone, Copy)]
pub struct LfahdaMfc {
    raw: [u8; 4],
}

impl LfahdaMfc {
    pub const MESSAGE_ID: u32 = 1157;
    
    pub const HDA_USM_MIN: u8 = 0_u8;
    pub const HDA_USM_MAX: u8 = 3_u8;
    pub const HDA_ICON_STATE_MIN: u8 = 0_u8;
    pub const HDA_ICON_STATE_MAX: u8 = 3_u8;
    pub const HDA_V_SET_REQ_MIN: u8 = 0_u8;
    pub const HDA_V_SET_REQ_MAX: u8 = 255_u8;
    pub const LFA_SYS_WARNING_MIN: u8 = 0_u8;
    pub const LFA_SYS_WARNING_MAX: u8 = 7_u8;
    pub const NEW_SIGNAL_1_MIN: u8 = 0_u8;
    pub const NEW_SIGNAL_1_MAX: u8 = 7_u8;
    pub const LFA_ICON_STATE_MIN: u8 = 0_u8;
    pub const LFA_ICON_STATE_MAX: u8 = 3_u8;
    pub const LFA_USM_MIN: u8 = 0_u8;
    pub const LFA_USM_MAX: u8 = 3_u8;
    pub const HDA_SYS_WARNING_MIN: u8 = 0_u8;
    pub const HDA_SYS_WARNING_MAX: u8 = 3_u8;
    
    /// Construct new LFAHDA_MFC from values
    pub fn new(hda_usm: u8, hda_active: bool, hda_icon_state: u8, hda_chime: bool, hda_v_set_req: u8, lfa_sys_warning: u8, new_signal_1: u8, lfa_icon_state: u8, lfa_usm: u8, hda_sys_warning: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 4] };
        res.set_hda_usm(hda_usm)?;
        res.set_hda_active(hda_active)?;
        res.set_hda_icon_state(hda_icon_state)?;
        res.set_hda_chime(hda_chime)?;
        res.set_hda_v_set_req(hda_v_set_req)?;
        res.set_lfa_sys_warning(lfa_sys_warning)?;
        res.set_new_signal_1(new_signal_1)?;
        res.set_lfa_icon_state(lfa_icon_state)?;
        res.set_lfa_usm(lfa_usm)?;
        res.set_hda_sys_warning(hda_sys_warning)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 4] {
        &self.raw
    }
    
    /// HDA_USM
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn hda_usm(&self) -> u8 {
        self.hda_usm_raw()
    }
    
    /// Get raw value of HDA_USM
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hda_usm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HDA_USM
    #[inline(always)]
    pub fn set_hda_usm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1157 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// HDA_Active
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn hda_active(&self) -> bool {
        self.hda_active_raw()
    }
    
    /// Get raw value of HDA_Active
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hda_active_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HDA_Active
    #[inline(always)]
    pub fn set_hda_active(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// HDA_Icon_State
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn hda_icon_state(&self) -> LfahdaMfcHdaIconState {
        let signal = self.raw.view_bits::<Lsb0>()[3..5].load_le::<u8>();
        
        match signal {
            0 => LfahdaMfcHdaIconState::NoHda,
            1 => LfahdaMfcHdaIconState::WhiteHda,
            2 => LfahdaMfcHdaIconState::GreenHda,
            _ => LfahdaMfcHdaIconState::_Other(self.hda_icon_state_raw()),
        }
    }
    
    /// Get raw value of HDA_Icon_State
    ///
    /// - Start bit: 3
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hda_icon_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[3..5].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HDA_Icon_State
    #[inline(always)]
    pub fn set_hda_icon_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1157 });
        }
        self.raw.view_bits_mut::<Lsb0>()[3..5].store_le(value);
        Ok(())
    }
    
    /// HDA_Chime
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn hda_chime(&self) -> bool {
        self.hda_chime_raw()
    }
    
    /// Get raw value of HDA_Chime
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hda_chime_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of HDA_Chime
    #[inline(always)]
    pub fn set_hda_chime(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// HDA_VSetReq
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: "km/h"
    /// - Receivers: XXX
    #[inline(always)]
    pub fn hda_v_set_req(&self) -> u8 {
        self.hda_v_set_req_raw()
    }
    
    /// Get raw value of HDA_VSetReq
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hda_v_set_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HDA_VSetReq
    #[inline(always)]
    pub fn set_hda_v_set_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1157 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// LFA_SysWarning
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn lfa_sys_warning(&self) -> LfahdaMfcLfaSysWarning {
        let signal = self.raw.view_bits::<Lsb0>()[16..19].load_le::<u8>();
        
        match signal {
            0 => LfahdaMfcLfaSysWarning::NoMessage,
            1 => LfahdaMfcLfaSysWarning::SwitchingToHda,
            2 => LfahdaMfcLfaSysWarning::SwitchingToScc,
            3 => LfahdaMfcLfaSysWarning::LfaError,
            4 => LfahdaMfcLfaSysWarning::CheckHda,
            5 => LfahdaMfcLfaSysWarning::KeepHandsOnWheelOrange,
            6 => LfahdaMfcLfaSysWarning::KeepHandsOnWheelRed,
            _ => LfahdaMfcLfaSysWarning::_Other(self.lfa_sys_warning_raw()),
        }
    }
    
    /// Get raw value of LFA_SysWarning
    ///
    /// - Start bit: 16
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lfa_sys_warning_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..19].load_le::<u8>();
        
        signal
    }
    
    /// Set value of LFA_SysWarning
    #[inline(always)]
    pub fn set_lfa_sys_warning(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1157 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..19].store_le(value);
        Ok(())
    }
    
    /// NEW_SIGNAL_1
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn new_signal_1(&self) -> u8 {
        self.new_signal_1_raw()
    }
    
    /// Get raw value of NEW_SIGNAL_1
    ///
    /// - Start bit: 20
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn new_signal_1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..23].load_le::<u8>();
        
        signal
    }
    
    /// Set value of NEW_SIGNAL_1
    #[inline(always)]
    pub fn set_new_signal_1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1157 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..23].store_le(value);
        Ok(())
    }
    
    /// LFA_Icon_State
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn lfa_icon_state(&self) -> LfahdaMfcLfaIconState {
        let signal = self.raw.view_bits::<Lsb0>()[24..26].load_le::<u8>();
        
        match signal {
            0 => LfahdaMfcLfaIconState::NoWheel,
            1 => LfahdaMfcLfaIconState::WhiteWheel,
            2 => LfahdaMfcLfaIconState::GreenWheel,
            3 => LfahdaMfcLfaIconState::GreenWheelBlink,
            _ => LfahdaMfcLfaIconState::_Other(self.lfa_icon_state_raw()),
        }
    }
    
    /// Get raw value of LFA_Icon_State
    ///
    /// - Start bit: 24
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lfa_icon_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..26].load_le::<u8>();
        
        signal
    }
    
    /// Set value of LFA_Icon_State
    #[inline(always)]
    pub fn set_lfa_icon_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1157 });
        }
        self.raw.view_bits_mut::<Lsb0>()[24..26].store_le(value);
        Ok(())
    }
    
    /// LFA_USM
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn lfa_usm(&self) -> u8 {
        self.lfa_usm_raw()
    }
    
    /// Get raw value of LFA_USM
    ///
    /// - Start bit: 27
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lfa_usm_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[27..29].load_le::<u8>();
        
        signal
    }
    
    /// Set value of LFA_USM
    #[inline(always)]
    pub fn set_lfa_usm(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1157 });
        }
        self.raw.view_bits_mut::<Lsb0>()[27..29].store_le(value);
        Ok(())
    }
    
    /// HDA_SysWarning
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn hda_sys_warning(&self) -> LfahdaMfcHdaSysWarning {
        let signal = self.raw.view_bits::<Lsb0>()[29..31].load_le::<u8>();
        
        match signal {
            0 => LfahdaMfcHdaSysWarning::NoMessage,
            1 => LfahdaMfcHdaSysWarning::DrivingConvenienceSystemsCancelled,
            2 => LfahdaMfcHdaSysWarning::HighwayDriveAssistSystemCancelled,
            _ => LfahdaMfcHdaSysWarning::_Other(self.hda_sys_warning_raw()),
        }
    }
    
    /// Get raw value of HDA_SysWarning
    ///
    /// - Start bit: 29
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hda_sys_warning_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[29..31].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HDA_SysWarning
    #[inline(always)]
    pub fn set_hda_sys_warning(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1157 });
        }
        self.raw.view_bits_mut::<Lsb0>()[29..31].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for LfahdaMfc {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 4 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 4];
        raw.copy_from_slice(&payload[..4]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for LfahdaMfc {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("LfahdaMfc")
                .field("hda_usm", &self.hda_usm())
                .field("hda_active", &self.hda_active())
                .field("hda_icon_state", &self.hda_icon_state())
                .field("hda_chime", &self.hda_chime())
                .field("hda_v_set_req", &self.hda_v_set_req())
                .field("lfa_sys_warning", &self.lfa_sys_warning())
                .field("new_signal_1", &self.new_signal_1())
                .field("lfa_icon_state", &self.lfa_icon_state())
                .field("lfa_usm", &self.lfa_usm())
                .field("hda_sys_warning", &self.hda_sys_warning())
            .finish()
        } else {
            f.debug_tuple("LfahdaMfc").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for LfahdaMfc {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let hda_usm = u.int_in_range(0..=3)?;
        let hda_active = u.int_in_range(0..=1)? == 1;
        let hda_icon_state = u.int_in_range(0..=3)?;
        let hda_chime = u.int_in_range(0..=1)? == 1;
        let hda_v_set_req = u.int_in_range(0..=255)?;
        let lfa_sys_warning = u.int_in_range(0..=7)?;
        let new_signal_1 = u.int_in_range(0..=7)?;
        let lfa_icon_state = u.int_in_range(0..=3)?;
        let lfa_usm = u.int_in_range(0..=3)?;
        let hda_sys_warning = u.int_in_range(0..=3)?;
        LfahdaMfc::new(hda_usm,hda_active,hda_icon_state,hda_chime,hda_v_set_req,lfa_sys_warning,new_signal_1,lfa_icon_state,lfa_usm,hda_sys_warning).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for HDA_Icon_State
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum LfahdaMfcHdaIconState {
    NoHda,
    WhiteHda,
    GreenHda,
    _Other(u8),
}

impl From<LfahdaMfcHdaIconState> for u8 {
    fn from(val: LfahdaMfcHdaIconState) -> u8 {
        match val {
            LfahdaMfcHdaIconState::NoHda => 0,
            LfahdaMfcHdaIconState::WhiteHda => 1,
            LfahdaMfcHdaIconState::GreenHda => 2,
            LfahdaMfcHdaIconState::_Other(x) => x,
        }
    }
}

/// Defined values for LFA_SysWarning
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum LfahdaMfcLfaSysWarning {
    NoMessage,
    SwitchingToHda,
    SwitchingToScc,
    LfaError,
    CheckHda,
    KeepHandsOnWheelOrange,
    KeepHandsOnWheelRed,
    _Other(u8),
}

impl From<LfahdaMfcLfaSysWarning> for u8 {
    fn from(val: LfahdaMfcLfaSysWarning) -> u8 {
        match val {
            LfahdaMfcLfaSysWarning::NoMessage => 0,
            LfahdaMfcLfaSysWarning::SwitchingToHda => 1,
            LfahdaMfcLfaSysWarning::SwitchingToScc => 2,
            LfahdaMfcLfaSysWarning::LfaError => 3,
            LfahdaMfcLfaSysWarning::CheckHda => 4,
            LfahdaMfcLfaSysWarning::KeepHandsOnWheelOrange => 5,
            LfahdaMfcLfaSysWarning::KeepHandsOnWheelRed => 6,
            LfahdaMfcLfaSysWarning::_Other(x) => x,
        }
    }
}

/// Defined values for LFA_Icon_State
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum LfahdaMfcLfaIconState {
    NoWheel,
    WhiteWheel,
    GreenWheel,
    GreenWheelBlink,
    _Other(u8),
}

impl From<LfahdaMfcLfaIconState> for u8 {
    fn from(val: LfahdaMfcLfaIconState) -> u8 {
        match val {
            LfahdaMfcLfaIconState::NoWheel => 0,
            LfahdaMfcLfaIconState::WhiteWheel => 1,
            LfahdaMfcLfaIconState::GreenWheel => 2,
            LfahdaMfcLfaIconState::GreenWheelBlink => 3,
            LfahdaMfcLfaIconState::_Other(x) => x,
        }
    }
}

/// Defined values for HDA_SysWarning
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum LfahdaMfcHdaSysWarning {
    NoMessage,
    DrivingConvenienceSystemsCancelled,
    HighwayDriveAssistSystemCancelled,
    _Other(u8),
}

impl From<LfahdaMfcHdaSysWarning> for u8 {
    fn from(val: LfahdaMfcHdaSysWarning) -> u8 {
        match val {
            LfahdaMfcHdaSysWarning::NoMessage => 0,
            LfahdaMfcHdaSysWarning::DrivingConvenienceSystemsCancelled => 1,
            LfahdaMfcHdaSysWarning::HighwayDriveAssistSystemCancelled => 2,
            LfahdaMfcHdaSysWarning::_Other(x) => x,
        }
    }
}


/// BCM_PO_11
///
/// - ID: 913 (0x391)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct BcmPo11 {
    raw: [u8; 8],
}

impl BcmPo11 {
    pub const MESSAGE_ID: u32 = 913;
    
    pub const BCM_SHIFT_R_MT_SW_STATUS_MIN: u8 = 0_u8;
    pub const BCM_SHIFT_R_MT_SW_STATUS_MAX: u8 = 3_u8;
    
    /// Construct new BCM_PO_11 from values
    pub fn new(bcm_door_dri_status: bool, bcm_shift_r_mt_sw_status: u8, lfa_pressed: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_bcm_door_dri_status(bcm_door_dri_status)?;
        res.set_bcm_shift_r_mt_sw_status(bcm_shift_r_mt_sw_status)?;
        res.set_lfa_pressed(lfa_pressed)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// BCM_Door_Dri_Status
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: PT_ESC_ABS
    #[inline(always)]
    pub fn bcm_door_dri_status(&self) -> bool {
        self.bcm_door_dri_status_raw()
    }
    
    /// Get raw value of BCM_Door_Dri_Status
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bcm_door_dri_status_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[2..3].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of BCM_Door_Dri_Status
    #[inline(always)]
    pub fn set_bcm_door_dri_status(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[2..3].store_be(value);
        Ok(())
    }
    
    /// BCM_Shift_R_MT_SW_Status
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: PT_ESC_ABS
    #[inline(always)]
    pub fn bcm_shift_r_mt_sw_status(&self) -> u8 {
        self.bcm_shift_r_mt_sw_status_raw()
    }
    
    /// Get raw value of BCM_Shift_R_MT_SW_Status
    ///
    /// - Start bit: 39
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn bcm_shift_r_mt_sw_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[32..34].load_be::<u8>();
        
        signal
    }
    
    /// Set value of BCM_Shift_R_MT_SW_Status
    #[inline(always)]
    pub fn set_bcm_shift_r_mt_sw_status(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 913 });
        }
        self.raw.view_bits_mut::<Msb0>()[32..34].store_be(value);
        Ok(())
    }
    
    /// LFA_Pressed
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn lfa_pressed(&self) -> bool {
        self.lfa_pressed_raw()
    }
    
    /// Get raw value of LFA_Pressed
    ///
    /// - Start bit: 4
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn lfa_pressed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[3..4].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of LFA_Pressed
    #[inline(always)]
    pub fn set_lfa_pressed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[3..4].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for BcmPo11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for BcmPo11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("BcmPo11")
                .field("bcm_door_dri_status", &self.bcm_door_dri_status())
                .field("bcm_shift_r_mt_sw_status", &self.bcm_shift_r_mt_sw_status())
                .field("lfa_pressed", &self.lfa_pressed())
            .finish()
        } else {
            f.debug_tuple("BcmPo11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for BcmPo11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let bcm_door_dri_status = u.int_in_range(0..=1)? == 1;
        let bcm_shift_r_mt_sw_status = u.int_in_range(0..=3)?;
        let lfa_pressed = u.int_in_range(0..=1)? == 1;
        BcmPo11::new(bcm_door_dri_status,bcm_shift_r_mt_sw_status,lfa_pressed).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// LABEL11
///
/// - ID: 1426 (0x592)
/// - Size: 8 bytes
/// - Transmitter: XXX
#[derive(Clone, Copy)]
pub struct Label11 {
    raw: [u8; 8],
}

impl Label11 {
    pub const MESSAGE_ID: u32 = 1426;
    
    
    /// Construct new LABEL11 from values
    pub fn new(cc_react: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cc_react(cc_react)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CC_React
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cc_react(&self) -> bool {
        self.cc_react_raw()
    }
    
    /// Get raw value of CC_React
    ///
    /// - Start bit: 34
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cc_react_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[34..35].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CC_React
    #[inline(always)]
    pub fn set_cc_react(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[34..35].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Label11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Label11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Label11")
                .field("cc_react", &self.cc_react())
            .finish()
        } else {
            f.debug_tuple("Label11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Label11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cc_react = u.int_in_range(0..=1)? == 1;
        Label11::new(cc_react).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// WHL_SPD12_FS
///
/// - ID: 910 (0x38e)
/// - Size: 5 bytes
/// - Transmitter: iBAU
#[derive(Clone, Copy)]
pub struct WhlSpd12Fs {
    raw: [u8; 5],
}

impl WhlSpd12Fs {
    pub const MESSAGE_ID: u32 = 910;
    
    pub const CRC_MIN: u8 = 0_u8;
    pub const CRC_MAX: u8 = 0_u8;
    pub const WHL_SPD12_ALIVE_COUNTER_MIN: u8 = 0_u8;
    pub const WHL_SPD12_ALIVE_COUNTER_MAX: u8 = 15_u8;
    pub const WHL_SPD_FL_MIN: f32 = 0_f32;
    pub const WHL_SPD_FL_MAX: f32 = 511.96875_f32;
    pub const WHL_SPD_FR_MIN: f32 = 0_f32;
    pub const WHL_SPD_FR_MAX: f32 = 511.96875_f32;
    
    /// Construct new WHL_SPD12_FS from values
    pub fn new(crc: u8, whl_spd12_alive_counter: u8, whl_spd_fl: f32, whl_spd_fr: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 5] };
        res.set_crc(crc)?;
        res.set_whl_spd12_alive_counter(whl_spd12_alive_counter)?;
        res.set_whl_spd_fl(whl_spd_fl)?;
        res.set_whl_spd_fr(whl_spd_fr)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 5] {
        &self.raw
    }
    
    /// CRC
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn crc(&self) -> u8 {
        self.crc_raw()
    }
    
    /// Get raw value of CRC
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn crc_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CRC
    #[inline(always)]
    pub fn set_crc(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 910 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// WHL_SPD12_AliveCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn whl_spd12_alive_counter(&self) -> u8 {
        self.whl_spd12_alive_counter_raw()
    }
    
    /// Get raw value of WHL_SPD12_AliveCounter
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_spd12_alive_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of WHL_SPD12_AliveCounter
    #[inline(always)]
    pub fn set_whl_spd12_alive_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 910 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..12].store_le(value);
        Ok(())
    }
    
    /// WHL_SPD_FL
    ///
    /// - Min: 0
    /// - Max: 511.96875
    /// - Unit: "km/h"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn whl_spd_fl(&self) -> f32 {
        self.whl_spd_fl_raw()
    }
    
    /// Get raw value of WHL_SPD_FL
    ///
    /// - Start bit: 12
    /// - Signal size: 14 bits
    /// - Factor: 0.03125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_spd_fl_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[12..26].load_le::<u16>();
        
        let factor = 0.03125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of WHL_SPD_FL
    #[inline(always)]
    pub fn set_whl_spd_fl(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 511.96875_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 910 });
        }
        let factor = 0.03125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[12..26].store_le(value);
        Ok(())
    }
    
    /// WHL_SPD_FR
    ///
    /// - Min: 0
    /// - Max: 511.96875
    /// - Unit: "km/h"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn whl_spd_fr(&self) -> f32 {
        self.whl_spd_fr_raw()
    }
    
    /// Get raw value of WHL_SPD_FR
    ///
    /// - Start bit: 26
    /// - Signal size: 14 bits
    /// - Factor: 0.03125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_spd_fr_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[26..40].load_le::<u16>();
        
        let factor = 0.03125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of WHL_SPD_FR
    #[inline(always)]
    pub fn set_whl_spd_fr(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 511.96875_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 910 });
        }
        let factor = 0.03125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[26..40].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for WhlSpd12Fs {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 5 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 5];
        raw.copy_from_slice(&payload[..5]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for WhlSpd12Fs {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("WhlSpd12Fs")
                .field("crc", &self.crc())
                .field("whl_spd12_alive_counter", &self.whl_spd12_alive_counter())
                .field("whl_spd_fl", &self.whl_spd_fl())
                .field("whl_spd_fr", &self.whl_spd_fr())
            .finish()
        } else {
            f.debug_tuple("WhlSpd12Fs").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for WhlSpd12Fs {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let crc = u.int_in_range(0..=0)?;
        let whl_spd12_alive_counter = u.int_in_range(0..=15)?;
        let whl_spd_fl = u.float_in_range(0_f32..=511.96875_f32)?;
        let whl_spd_fr = u.float_in_range(0_f32..=511.96875_f32)?;
        WhlSpd12Fs::new(crc,whl_spd12_alive_counter,whl_spd_fl,whl_spd_fr).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// WHL_SPD13_FS
///
/// - ID: 911 (0x38f)
/// - Size: 5 bytes
/// - Transmitter: iBAU
#[derive(Clone, Copy)]
pub struct WhlSpd13Fs {
    raw: [u8; 5],
}

impl WhlSpd13Fs {
    pub const MESSAGE_ID: u32 = 911;
    
    pub const CRC_MIN: u8 = 0_u8;
    pub const CRC_MAX: u8 = 0_u8;
    pub const WHL_SPD13_ALIVE_COUNTER_MIN: u8 = 0_u8;
    pub const WHL_SPD13_ALIVE_COUNTER_MAX: u8 = 15_u8;
    pub const WHL_SPD_RL_MIN: f32 = 0_f32;
    pub const WHL_SPD_RL_MAX: f32 = 511.96875_f32;
    pub const WHL_SPD_RR_MIN: f32 = 0_f32;
    pub const WHL_SPD_RR_MAX: f32 = 511.96875_f32;
    
    /// Construct new WHL_SPD13_FS from values
    pub fn new(crc: u8, whl_spd13_alive_counter: u8, whl_spd_rl: f32, whl_spd_rr: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 5] };
        res.set_crc(crc)?;
        res.set_whl_spd13_alive_counter(whl_spd13_alive_counter)?;
        res.set_whl_spd_rl(whl_spd_rl)?;
        res.set_whl_spd_rr(whl_spd_rr)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 5] {
        &self.raw
    }
    
    /// CRC
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn crc(&self) -> u8 {
        self.crc_raw()
    }
    
    /// Get raw value of CRC
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn crc_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CRC
    #[inline(always)]
    pub fn set_crc(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 911 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// WHL_SPD13_AliveCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn whl_spd13_alive_counter(&self) -> u8 {
        self.whl_spd13_alive_counter_raw()
    }
    
    /// Get raw value of WHL_SPD13_AliveCounter
    ///
    /// - Start bit: 8
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_spd13_alive_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..12].load_le::<u8>();
        
        signal
    }
    
    /// Set value of WHL_SPD13_AliveCounter
    #[inline(always)]
    pub fn set_whl_spd13_alive_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 911 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..12].store_le(value);
        Ok(())
    }
    
    /// WHL_SPD_RL
    ///
    /// - Min: 0
    /// - Max: 511.96875
    /// - Unit: "km/h"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn whl_spd_rl(&self) -> f32 {
        self.whl_spd_rl_raw()
    }
    
    /// Get raw value of WHL_SPD_RL
    ///
    /// - Start bit: 12
    /// - Signal size: 14 bits
    /// - Factor: 0.03125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_spd_rl_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[12..26].load_le::<u16>();
        
        let factor = 0.03125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of WHL_SPD_RL
    #[inline(always)]
    pub fn set_whl_spd_rl(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 511.96875_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 911 });
        }
        let factor = 0.03125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[12..26].store_le(value);
        Ok(())
    }
    
    /// WHL_SPD_RR
    ///
    /// - Min: 0
    /// - Max: 511.96875
    /// - Unit: "km/h"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn whl_spd_rr(&self) -> f32 {
        self.whl_spd_rr_raw()
    }
    
    /// Get raw value of WHL_SPD_RR
    ///
    /// - Start bit: 26
    /// - Signal size: 14 bits
    /// - Factor: 0.03125
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn whl_spd_rr_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[26..40].load_le::<u16>();
        
        let factor = 0.03125_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of WHL_SPD_RR
    #[inline(always)]
    pub fn set_whl_spd_rr(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 511.96875_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 911 });
        }
        let factor = 0.03125_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[26..40].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for WhlSpd13Fs {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 5 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 5];
        raw.copy_from_slice(&payload[..5]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for WhlSpd13Fs {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("WhlSpd13Fs")
                .field("crc", &self.crc())
                .field("whl_spd13_alive_counter", &self.whl_spd13_alive_counter())
                .field("whl_spd_rl", &self.whl_spd_rl())
                .field("whl_spd_rr", &self.whl_spd_rr())
            .finish()
        } else {
            f.debug_tuple("WhlSpd13Fs").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for WhlSpd13Fs {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let crc = u.int_in_range(0..=0)?;
        let whl_spd13_alive_counter = u.int_in_range(0..=15)?;
        let whl_spd_rl = u.float_in_range(0_f32..=511.96875_f32)?;
        let whl_spd_rr = u.float_in_range(0_f32..=511.96875_f32)?;
        WhlSpd13Fs::new(crc,whl_spd13_alive_counter,whl_spd_rl,whl_spd_rr).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ADAS_PRK_11
///
/// - ID: 865 (0x361)
/// - Size: 8 bytes
/// - Transmitter: ADAS_PRK
#[derive(Clone, Copy)]
pub struct AdasPrk11 {
    raw: [u8; 8],
}

impl AdasPrk11 {
    pub const MESSAGE_ID: u32 = 865;
    
    pub const CF_PCA_DCL_TRGT_VAL_MIN: f32 = 0_f32;
    pub const CF_PCA_DCL_TRGT_VAL_MAX: f32 = 0_f32;
    pub const PCA_ALIVE_CNT_MIN: u8 = 0_u8;
    pub const PCA_ALIVE_CNT_MAX: u8 = 0_u8;
    pub const PCA_CHECK_SUM_MIN: u8 = 0_u8;
    pub const PCA_CHECK_SUM_MAX: u8 = 0_u8;
    
    /// Construct new ADAS_PRK_11 from values
    pub fn new(cf_pca_brk_req: bool, cf_pca_dcl_trgt_val: f32, pca_alive_cnt: u8, pca_check_sum: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_pca_brk_req(cf_pca_brk_req)?;
        res.set_cf_pca_dcl_trgt_val(cf_pca_dcl_trgt_val)?;
        res.set_pca_alive_cnt(pca_alive_cnt)?;
        res.set_pca_check_sum(pca_check_sum)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_PCA_BrkReq
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cf_pca_brk_req(&self) -> bool {
        self.cf_pca_brk_req_raw()
    }
    
    /// Get raw value of CF_PCA_BrkReq
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_pca_brk_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_PCA_BrkReq
    #[inline(always)]
    pub fn set_cf_pca_brk_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[24..25].store_le(value);
        Ok(())
    }
    
    /// CF_PCA_DclTrgtVal
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: "g"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cf_pca_dcl_trgt_val(&self) -> f32 {
        self.cf_pca_dcl_trgt_val_raw()
    }
    
    /// Get raw value of CF_PCA_DclTrgtVal
    ///
    /// - Start bit: 28
    /// - Signal size: 4 bits
    /// - Factor: 0.04
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_pca_dcl_trgt_val_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[28..32].load_le::<u8>();
        
        let factor = 0.04_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CF_PCA_DclTrgtVal
    #[inline(always)]
    pub fn set_cf_pca_dcl_trgt_val(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 865 });
        }
        let factor = 0.04_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[28..32].store_le(value);
        Ok(())
    }
    
    /// PCA_ALIVE_CNT
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn pca_alive_cnt(&self) -> u8 {
        self.pca_alive_cnt_raw()
    }
    
    /// Get raw value of PCA_ALIVE_CNT
    ///
    /// - Start bit: 40
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pca_alive_cnt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..44].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PCA_ALIVE_CNT
    #[inline(always)]
    pub fn set_pca_alive_cnt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 865 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..44].store_le(value);
        Ok(())
    }
    
    /// PCA_CHECK_SUM
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn pca_check_sum(&self) -> u8 {
        self.pca_check_sum_raw()
    }
    
    /// Get raw value of PCA_CHECK_SUM
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pca_check_sum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of PCA_CHECK_SUM
    #[inline(always)]
    pub fn set_pca_check_sum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 0_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 865 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for AdasPrk11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for AdasPrk11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("AdasPrk11")
                .field("cf_pca_brk_req", &self.cf_pca_brk_req())
                .field("cf_pca_dcl_trgt_val", &self.cf_pca_dcl_trgt_val())
                .field("pca_alive_cnt", &self.pca_alive_cnt())
                .field("pca_check_sum", &self.pca_check_sum())
            .finish()
        } else {
            f.debug_tuple("AdasPrk11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for AdasPrk11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_pca_brk_req = u.int_in_range(0..=1)? == 1;
        let cf_pca_dcl_trgt_val = u.float_in_range(0_f32..=0_f32)?;
        let pca_alive_cnt = u.int_in_range(0..=0)?;
        let pca_check_sum = u.int_in_range(0..=0)?;
        AdasPrk11::new(cf_pca_brk_req,cf_pca_dcl_trgt_val,pca_alive_cnt,pca_check_sum).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ELECT_GEAR
///
/// - ID: 882 (0x372)
/// - Size: 8 bytes
/// - Transmitter: XXX
#[derive(Clone, Copy)]
pub struct ElectGear {
    raw: [u8; 8],
}

impl ElectGear {
    pub const MESSAGE_ID: u32 = 882;
    
    pub const ELECT_GEAR_SHIFTER_MIN: u8 = 0_u8;
    pub const ELECT_GEAR_SHIFTER_MAX: u8 = 7_u8;
    
    /// Construct new ELECT_GEAR from values
    pub fn new(elect_gear_shifter: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_elect_gear_shifter(elect_gear_shifter)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Elect_Gear_Shifter
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn elect_gear_shifter(&self) -> ElectGearElectGearShifter {
        let signal = self.raw.view_bits::<Lsb0>()[16..20].load_le::<u8>();
        
        match signal {
            5 => ElectGearElectGearShifter::D,
            8 => ElectGearElectGearShifter::S,
            6 => ElectGearElectGearShifter::N,
            7 => ElectGearElectGearShifter::R,
            0 => ElectGearElectGearShifter::P,
            _ => ElectGearElectGearShifter::_Other(self.elect_gear_shifter_raw()),
        }
    }
    
    /// Get raw value of Elect_Gear_Shifter
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn elect_gear_shifter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Elect_Gear_Shifter
    #[inline(always)]
    pub fn set_elect_gear_shifter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 882 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..20].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for ElectGear {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for ElectGear {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("ElectGear")
                .field("elect_gear_shifter", &self.elect_gear_shifter())
            .finish()
        } else {
            f.debug_tuple("ElectGear").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for ElectGear {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let elect_gear_shifter = u.int_in_range(0..=7)?;
        ElectGear::new(elect_gear_shifter).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}
/// Defined values for Elect_Gear_Shifter
#[derive(Clone, Copy, PartialEq)]
#[cfg_attr(feature = "debug", derive(Debug))]
pub enum ElectGearElectGearShifter {
    D,
    S,
    N,
    R,
    P,
    _Other(u8),
}

impl From<ElectGearElectGearShifter> for u8 {
    fn from(val: ElectGearElectGearShifter) -> u8 {
        match val {
            ElectGearElectGearShifter::D => 5,
            ElectGearElectGearShifter::S => 8,
            ElectGearElectGearShifter::N => 6,
            ElectGearElectGearShifter::R => 7,
            ElectGearElectGearShifter::P => 0,
            ElectGearElectGearShifter::_Other(x) => x,
        }
    }
}


/// E_EMS11
///
/// - ID: 881 (0x371)
/// - Size: 8 bytes
/// - Transmitter: XXX
#[derive(Clone, Copy)]
pub struct EEms11 {
    raw: [u8; 8],
}

impl EEms11 {
    pub const MESSAGE_ID: u32 = 881;
    
    pub const BRAKE_PEDAL_POS_MIN: u8 = 0_u8;
    pub const BRAKE_PEDAL_POS_MAX: u8 = 127_u8;
    pub const IG_REACTIVE_STAT_MIN: u8 = 0_u8;
    pub const IG_REACTIVE_STAT_MAX: u8 = 3_u8;
    pub const CRUISE_LIMIT_TARGET_MIN: u8 = 0_u8;
    pub const CRUISE_LIMIT_TARGET_MAX: u8 = 15_u8;
    pub const ACCEL_PEDAL_POS_MIN: u8 = 0_u8;
    pub const ACCEL_PEDAL_POS_MAX: u8 = 254_u8;
    pub const CR_VCU_ACC_PED_DEP_POS_MIN: u8 = 0_u8;
    pub const CR_VCU_ACC_PED_DEP_POS_MAX: u8 = 254_u8;
    
    /// Construct new E_EMS11 from values
    pub fn new(brake_pedal_pos: u8, ig_reactive_stat: u8, gear_change: bool, cruise_limit_status: bool, cruise_limit_target: u8, accel_pedal_pos: u8, cr_vcu_acc_ped_dep_pos: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_brake_pedal_pos(brake_pedal_pos)?;
        res.set_ig_reactive_stat(ig_reactive_stat)?;
        res.set_gear_change(gear_change)?;
        res.set_cruise_limit_status(cruise_limit_status)?;
        res.set_cruise_limit_target(cruise_limit_target)?;
        res.set_accel_pedal_pos(accel_pedal_pos)?;
        res.set_cr_vcu_acc_ped_dep_pos(cr_vcu_acc_ped_dep_pos)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Brake_Pedal_Pos
    ///
    /// - Min: 0
    /// - Max: 127
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn brake_pedal_pos(&self) -> u8 {
        self.brake_pedal_pos_raw()
    }
    
    /// Get raw value of Brake_Pedal_Pos
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn brake_pedal_pos_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Brake_Pedal_Pos
    #[inline(always)]
    pub fn set_brake_pedal_pos(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 127_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 881 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// IG_Reactive_Stat
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn ig_reactive_stat(&self) -> u8 {
        self.ig_reactive_stat_raw()
    }
    
    /// Get raw value of IG_Reactive_Stat
    ///
    /// - Start bit: 8
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ig_reactive_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..11].load_le::<u8>();
        
        signal
    }
    
    /// Set value of IG_Reactive_Stat
    #[inline(always)]
    pub fn set_ig_reactive_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 881 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..11].store_le(value);
        Ok(())
    }
    
    /// Gear_Change
    ///
    /// - Min: 0
    /// - Max: 31
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn gear_change(&self) -> bool {
        self.gear_change_raw()
    }
    
    /// Get raw value of Gear_Change
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gear_change_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[11..12].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of Gear_Change
    #[inline(always)]
    pub fn set_gear_change(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[11..12].store_be(value);
        Ok(())
    }
    
    /// Cruise_Limit_Status
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cruise_limit_status(&self) -> bool {
        self.cruise_limit_status_raw()
    }
    
    /// Get raw value of Cruise_Limit_Status
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cruise_limit_status_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Cruise_Limit_Status
    #[inline(always)]
    pub fn set_cruise_limit_status(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[13..14].store_le(value);
        Ok(())
    }
    
    /// Cruise_Limit_Target
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cruise_limit_target(&self) -> u8 {
        self.cruise_limit_target_raw()
    }
    
    /// Get raw value of Cruise_Limit_Target
    ///
    /// - Start bit: 23
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cruise_limit_target_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[23..31].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Cruise_Limit_Target
    #[inline(always)]
    pub fn set_cruise_limit_target(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 881 });
        }
        self.raw.view_bits_mut::<Lsb0>()[23..31].store_le(value);
        Ok(())
    }
    
    /// Accel_Pedal_Pos
    ///
    /// - Min: 0
    /// - Max: 254
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn accel_pedal_pos(&self) -> u8 {
        self.accel_pedal_pos_raw()
    }
    
    /// Get raw value of Accel_Pedal_Pos
    ///
    /// - Start bit: 31
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accel_pedal_pos_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[31..39].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Accel_Pedal_Pos
    #[inline(always)]
    pub fn set_accel_pedal_pos(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 254_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 881 });
        }
        self.raw.view_bits_mut::<Lsb0>()[31..39].store_le(value);
        Ok(())
    }
    
    /// CR_Vcu_AccPedDep_Pos
    ///
    /// - Min: 0
    /// - Max: 254
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cr_vcu_acc_ped_dep_pos(&self) -> u8 {
        self.cr_vcu_acc_ped_dep_pos_raw()
    }
    
    /// Get raw value of CR_Vcu_AccPedDep_Pos
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_vcu_acc_ped_dep_pos_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Vcu_AccPedDep_Pos
    #[inline(always)]
    pub fn set_cr_vcu_acc_ped_dep_pos(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 254_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 881 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for EEms11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for EEms11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("EEms11")
                .field("brake_pedal_pos", &self.brake_pedal_pos())
                .field("ig_reactive_stat", &self.ig_reactive_stat())
                .field("gear_change", &self.gear_change())
                .field("cruise_limit_status", &self.cruise_limit_status())
                .field("cruise_limit_target", &self.cruise_limit_target())
                .field("accel_pedal_pos", &self.accel_pedal_pos())
                .field("cr_vcu_acc_ped_dep_pos", &self.cr_vcu_acc_ped_dep_pos())
            .finish()
        } else {
            f.debug_tuple("EEms11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for EEms11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let brake_pedal_pos = u.int_in_range(0..=127)?;
        let ig_reactive_stat = u.int_in_range(0..=3)?;
        let gear_change = u.int_in_range(0..=1)? == 1;
        let cruise_limit_status = u.int_in_range(0..=1)? == 1;
        let cruise_limit_target = u.int_in_range(0..=15)?;
        let accel_pedal_pos = u.int_in_range(0..=254)?;
        let cr_vcu_acc_ped_dep_pos = u.int_in_range(0..=254)?;
        EEms11::new(brake_pedal_pos,ig_reactive_stat,gear_change,cruise_limit_status,cruise_limit_target,accel_pedal_pos,cr_vcu_acc_ped_dep_pos).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EV_PC6
///
/// - ID: 1355 (0x54b)
/// - Size: 8 bytes
/// - Transmitter: CGW
#[derive(Clone, Copy)]
pub struct EvPc6 {
    raw: [u8; 8],
}

impl EvPc6 {
    pub const MESSAGE_ID: u32 = 1355;
    
    pub const CF_VCU_SBW_WARN_MSG_MIN: u8 = 0_u8;
    pub const CF_VCU_SBW_WARN_MSG_MAX: u8 = 7_u8;
    
    /// Construct new EV_PC6 from values
    pub fn new(cf_vcu_sbw_warn_msg: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_vcu_sbw_warn_msg(cf_vcu_sbw_warn_msg)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Vcu_SbwWarnMsg
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cf_vcu_sbw_warn_msg(&self) -> u8 {
        self.cf_vcu_sbw_warn_msg_raw()
    }
    
    /// Get raw value of CF_Vcu_SbwWarnMsg
    ///
    /// - Start bit: 16
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vcu_sbw_warn_msg_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..19].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Vcu_SbwWarnMsg
    #[inline(always)]
    pub fn set_cf_vcu_sbw_warn_msg(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1355 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..19].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for EvPc6 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for EvPc6 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("EvPc6")
                .field("cf_vcu_sbw_warn_msg", &self.cf_vcu_sbw_warn_msg())
            .finish()
        } else {
            f.debug_tuple("EvPc6").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for EvPc6 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_vcu_sbw_warn_msg = u.int_in_range(0..=7)?;
        EvPc6::new(cf_vcu_sbw_warn_msg).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EV_PC2
///
/// - ID: 1430 (0x596)
/// - Size: 8 bytes
/// - Transmitter: CGW
#[derive(Clone, Copy)]
pub struct EvPc2 {
    raw: [u8; 8],
}

impl EvPc2 {
    pub const MESSAGE_ID: u32 = 1430;
    
    pub const CR_LDC_ACT_VOL_LS_V_MIN: f32 = 0_f32;
    pub const CR_LDC_ACT_VOL_LS_V_MAX: f32 = 0_f32;
    
    /// Construct new EV_PC2 from values
    pub fn new(cr_ldc_act_vol_ls_v: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cr_ldc_act_vol_ls_v(cr_ldc_act_vol_ls_v)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CR_Ldc_ActVol_LS_V
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: "V"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cr_ldc_act_vol_ls_v(&self) -> f32 {
        self.cr_ldc_act_vol_ls_v_raw()
    }
    
    /// Get raw value of CR_Ldc_ActVol_LS_V
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_ldc_act_vol_ls_v_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Ldc_ActVol_LS_V
    #[inline(always)]
    pub fn set_cr_ldc_act_vol_ls_v(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1430 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for EvPc2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for EvPc2 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("EvPc2")
                .field("cr_ldc_act_vol_ls_v", &self.cr_ldc_act_vol_ls_v())
            .finish()
        } else {
            f.debug_tuple("EvPc2").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for EvPc2 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cr_ldc_act_vol_ls_v = u.float_in_range(0_f32..=0_f32)?;
        EvPc2::new(cr_ldc_act_vol_ls_v).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EV_PC10
///
/// - ID: 1535 (0x5ff)
/// - Size: 8 bytes
/// - Transmitter: CGW
#[derive(Clone, Copy)]
pub struct EvPc10 {
    raw: [u8; 8],
}

impl EvPc10 {
    pub const MESSAGE_ID: u32 = 1535;
    
    
    /// Construct new EV_PC10 from values
    pub fn new(cf_vcu_epb_request: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_vcu_epb_request(cf_vcu_epb_request)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Vcu_EpbRequest
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cf_vcu_epb_request(&self) -> bool {
        self.cf_vcu_epb_request_raw()
    }
    
    /// Get raw value of CF_Vcu_EpbRequest
    ///
    /// - Start bit: 37
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_vcu_epb_request_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[37..38].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Vcu_EpbRequest
    #[inline(always)]
    pub fn set_cf_vcu_epb_request(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[37..38].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for EvPc10 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for EvPc10 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("EvPc10")
                .field("cf_vcu_epb_request", &self.cf_vcu_epb_request())
            .finish()
        } else {
            f.debug_tuple("EvPc10").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for EvPc10 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_vcu_epb_request = u.int_in_range(0..=1)? == 1;
        EvPc10::new(cf_vcu_epb_request).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// RSPA11
///
/// - ID: 908 (0x38c)
/// - Size: 8 bytes
/// - Transmitter: RSPA
#[derive(Clone, Copy)]
pub struct Rspa11 {
    raw: [u8; 8],
}

impl Rspa11 {
    pub const MESSAGE_ID: u32 = 908;
    
    pub const CF_RSPA_STATE_MIN: u8 = 0_u8;
    pub const CF_RSPA_STATE_MAX: u8 = 15_u8;
    pub const CF_RSPA_ACT_MIN: u8 = 0_u8;
    pub const CF_RSPA_ACT_MAX: u8 = 3_u8;
    pub const CF_RSPA_DEC_CMD_MIN: u8 = 0_u8;
    pub const CF_RSPA_DEC_CMD_MAX: u8 = 3_u8;
    pub const CF_RSPA_TRGT_SPD_MIN: f32 = 0_f32;
    pub const CF_RSPA_TRGT_SPD_MAX: f32 = 10.23_f32;
    pub const CR_RSPA_EPB_REQ_MIN: u8 = 0_u8;
    pub const CR_RSPA_EPB_REQ_MAX: u8 = 3_u8;
    pub const CF_RSPA_ALIVE_COUNTER_MIN: u8 = 0_u8;
    pub const CF_RSPA_ALIVE_COUNTER_MAX: u8 = 15_u8;
    pub const CF_RSPA_CRC_MIN: u8 = 0_u8;
    pub const CF_RSPA_CRC_MAX: u8 = 255_u8;
    
    /// Construct new RSPA11 from values
    pub fn new(cf_rspa_state: u8, cf_rspa_act: u8, cf_rspa_dec_cmd: u8, cf_rspa_trgt_spd: f32, cf_rspa_stop_req: bool, cr_rspa_epb_req: u8, cf_rspa_acc_act: bool, cf_rspa_alive_counter: u8, cf_rspa_crc: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_rspa_state(cf_rspa_state)?;
        res.set_cf_rspa_act(cf_rspa_act)?;
        res.set_cf_rspa_dec_cmd(cf_rspa_dec_cmd)?;
        res.set_cf_rspa_trgt_spd(cf_rspa_trgt_spd)?;
        res.set_cf_rspa_stop_req(cf_rspa_stop_req)?;
        res.set_cr_rspa_epb_req(cr_rspa_epb_req)?;
        res.set_cf_rspa_acc_act(cf_rspa_acc_act)?;
        res.set_cf_rspa_alive_counter(cf_rspa_alive_counter)?;
        res.set_cf_rspa_crc(cf_rspa_crc)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_RSPA_State
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_rspa_state(&self) -> u8 {
        self.cf_rspa_state_raw()
    }
    
    /// Get raw value of CF_RSPA_State
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rspa_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_RSPA_State
    #[inline(always)]
    pub fn set_cf_rspa_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 908 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..4].store_le(value);
        Ok(())
    }
    
    /// CF_RSPA_Act
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_rspa_act(&self) -> u8 {
        self.cf_rspa_act_raw()
    }
    
    /// Get raw value of CF_RSPA_Act
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rspa_act_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_RSPA_Act
    #[inline(always)]
    pub fn set_cf_rspa_act(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 908 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
    /// CF_RSPA_DecCmd
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_rspa_dec_cmd(&self) -> u8 {
        self.cf_rspa_dec_cmd_raw()
    }
    
    /// Get raw value of CF_RSPA_DecCmd
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rspa_dec_cmd_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_RSPA_DecCmd
    #[inline(always)]
    pub fn set_cf_rspa_dec_cmd(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 908 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// CF_RSPA_Trgt_Spd
    ///
    /// - Min: 0
    /// - Max: 10.23
    /// - Unit: "km/h"
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_rspa_trgt_spd(&self) -> f32 {
        self.cf_rspa_trgt_spd_raw()
    }
    
    /// Get raw value of CF_RSPA_Trgt_Spd
    ///
    /// - Start bit: 8
    /// - Signal size: 10 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rspa_trgt_spd_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..18].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CF_RSPA_Trgt_Spd
    #[inline(always)]
    pub fn set_cf_rspa_trgt_spd(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 10.23_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 908 });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[8..18].store_le(value);
        Ok(())
    }
    
    /// CF_RSPA_StopReq
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_rspa_stop_req(&self) -> bool {
        self.cf_rspa_stop_req_raw()
    }
    
    /// Get raw value of CF_RSPA_StopReq
    ///
    /// - Start bit: 18
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rspa_stop_req_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[18..19].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_RSPA_StopReq
    #[inline(always)]
    pub fn set_cf_rspa_stop_req(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[18..19].store_le(value);
        Ok(())
    }
    
    /// CR_RSPA_EPB_Req
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cr_rspa_epb_req(&self) -> u8 {
        self.cr_rspa_epb_req_raw()
    }
    
    /// Get raw value of CR_RSPA_EPB_Req
    ///
    /// - Start bit: 22
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_rspa_epb_req_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[22..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_RSPA_EPB_Req
    #[inline(always)]
    pub fn set_cr_rspa_epb_req(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 908 });
        }
        self.raw.view_bits_mut::<Lsb0>()[22..24].store_le(value);
        Ok(())
    }
    
    /// CF_RSPA_ACC_ACT
    ///
    /// - Min: 0
    /// - Max: 2
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_rspa_acc_act(&self) -> bool {
        self.cf_rspa_acc_act_raw()
    }
    
    /// Get raw value of CF_RSPA_ACC_ACT
    ///
    /// - Start bit: 50
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rspa_acc_act_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[50..51].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_RSPA_ACC_ACT
    #[inline(always)]
    pub fn set_cf_rspa_acc_act(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[50..51].store_le(value);
        Ok(())
    }
    
    /// CF_RSPA_AliveCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_rspa_alive_counter(&self) -> u8 {
        self.cf_rspa_alive_counter_raw()
    }
    
    /// Get raw value of CF_RSPA_AliveCounter
    ///
    /// - Start bit: 52
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rspa_alive_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[52..56].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_RSPA_AliveCounter
    #[inline(always)]
    pub fn set_cf_rspa_alive_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 908 });
        }
        self.raw.view_bits_mut::<Lsb0>()[52..56].store_le(value);
        Ok(())
    }
    
    /// CF_RSPA_CRC
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_rspa_crc(&self) -> u8 {
        self.cf_rspa_crc_raw()
    }
    
    /// Get raw value of CF_RSPA_CRC
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_rspa_crc_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_RSPA_CRC
    #[inline(always)]
    pub fn set_cf_rspa_crc(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 908 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Rspa11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Rspa11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Rspa11")
                .field("cf_rspa_state", &self.cf_rspa_state())
                .field("cf_rspa_act", &self.cf_rspa_act())
                .field("cf_rspa_dec_cmd", &self.cf_rspa_dec_cmd())
                .field("cf_rspa_trgt_spd", &self.cf_rspa_trgt_spd())
                .field("cf_rspa_stop_req", &self.cf_rspa_stop_req())
                .field("cr_rspa_epb_req", &self.cr_rspa_epb_req())
                .field("cf_rspa_acc_act", &self.cf_rspa_acc_act())
                .field("cf_rspa_alive_counter", &self.cf_rspa_alive_counter())
                .field("cf_rspa_crc", &self.cf_rspa_crc())
            .finish()
        } else {
            f.debug_tuple("Rspa11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Rspa11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_rspa_state = u.int_in_range(0..=15)?;
        let cf_rspa_act = u.int_in_range(0..=3)?;
        let cf_rspa_dec_cmd = u.int_in_range(0..=3)?;
        let cf_rspa_trgt_spd = u.float_in_range(0_f32..=10.23_f32)?;
        let cf_rspa_stop_req = u.int_in_range(0..=1)? == 1;
        let cr_rspa_epb_req = u.int_in_range(0..=3)?;
        let cf_rspa_acc_act = u.int_in_range(0..=1)? == 1;
        let cf_rspa_alive_counter = u.int_in_range(0..=15)?;
        let cf_rspa_crc = u.int_in_range(0..=255)?;
        Rspa11::new(cf_rspa_state,cf_rspa_act,cf_rspa_dec_cmd,cf_rspa_trgt_spd,cf_rspa_stop_req,cr_rspa_epb_req,cf_rspa_acc_act,cf_rspa_alive_counter,cf_rspa_crc).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// S_MDPS11
///
/// - ID: 914 (0x392)
/// - Size: 8 bytes
/// - Transmitter: XXX
#[derive(Clone, Copy)]
pub struct SMdps11 {
    raw: [u8; 8],
}

impl SMdps11 {
    pub const MESSAGE_ID: u32 = 914;
    
    pub const CF_MDPS_STAT_MIN: u8 = 0_u8;
    pub const CF_MDPS_STAT_MAX: u8 = 15_u8;
    pub const CR_MDPS_DRV_TQ_MIN: u16 = 0_u16;
    pub const CR_MDPS_DRV_TQ_MAX: u16 = 15_u16;
    pub const CR_MDPS_STR_ANG_MIN: i16 = 0_i16;
    pub const CR_MDPS_STR_ANG_MAX: i16 = 32767_i16;
    pub const CF_MDPS_ALIVE_CNT_MIN: u8 = 0_u8;
    pub const CF_MDPS_ALIVE_CNT_MAX: u8 = 255_u8;
    pub const CF_MDPS_CHKSUM_MIN: u8 = 0_u8;
    pub const CF_MDPS_CHKSUM_MAX: u8 = 255_u8;
    
    /// Construct new S_MDPS11 from values
    pub fn new(cf_mdps_stat: u8, cr_mdps_drv_tq: u16, cr_mdps_str_ang: i16, cf_mdps_alive_cnt: u8, cf_mdps_chksum: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_mdps_stat(cf_mdps_stat)?;
        res.set_cr_mdps_drv_tq(cr_mdps_drv_tq)?;
        res.set_cr_mdps_str_ang(cr_mdps_str_ang)?;
        res.set_cf_mdps_alive_cnt(cf_mdps_alive_cnt)?;
        res.set_cf_mdps_chksum(cf_mdps_chksum)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Mdps_Stat
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_mdps_stat(&self) -> u8 {
        self.cf_mdps_stat_raw()
    }
    
    /// Get raw value of CF_Mdps_Stat
    ///
    /// - Start bit: 0
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Mdps_Stat
    #[inline(always)]
    pub fn set_cf_mdps_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 914 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..4].store_le(value);
        Ok(())
    }
    
    /// CR_Mdps_DrvTq
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cr_mdps_drv_tq(&self) -> u16 {
        self.cr_mdps_drv_tq_raw()
    }
    
    /// Get raw value of CR_Mdps_DrvTq
    ///
    /// - Start bit: 8
    /// - Signal size: 12 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_mdps_drv_tq_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[8..20].load_le::<u16>();
        
        signal
    }
    
    /// Set value of CR_Mdps_DrvTq
    #[inline(always)]
    pub fn set_cr_mdps_drv_tq(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 15_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 914 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..20].store_le(value);
        Ok(())
    }
    
    /// CR_Mdps_StrAng
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cr_mdps_str_ang(&self) -> i16 {
        self.cr_mdps_str_ang_raw()
    }
    
    /// Get raw value of CR_Mdps_StrAng
    ///
    /// - Start bit: 24
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn cr_mdps_str_ang_raw(&self) -> i16 {
        let signal = self.raw.view_bits::<Lsb0>()[24..40].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        signal
    }
    
    /// Set value of CR_Mdps_StrAng
    #[inline(always)]
    pub fn set_cr_mdps_str_ang(&mut self, value: i16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_i16 || 65535_i16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 914 });
        }
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[24..40].store_le(value);
        Ok(())
    }
    
    /// CF_Mdps_AliveCnt
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_mdps_alive_cnt(&self) -> u8 {
        self.cf_mdps_alive_cnt_raw()
    }
    
    /// Get raw value of CF_Mdps_AliveCnt
    ///
    /// - Start bit: 47
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_alive_cnt_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[40..48].load_be::<u8>();
        
        signal
    }
    
    /// Set value of CF_Mdps_AliveCnt
    #[inline(always)]
    pub fn set_cf_mdps_alive_cnt(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 914 });
        }
        self.raw.view_bits_mut::<Msb0>()[40..48].store_be(value);
        Ok(())
    }
    
    /// CF_Mdps_Chksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn cf_mdps_chksum(&self) -> u8 {
        self.cf_mdps_chksum_raw()
    }
    
    /// Get raw value of CF_Mdps_Chksum
    ///
    /// - Start bit: 63
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_mdps_chksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[56..64].load_be::<u8>();
        
        signal
    }
    
    /// Set value of CF_Mdps_Chksum
    #[inline(always)]
    pub fn set_cf_mdps_chksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 914 });
        }
        self.raw.view_bits_mut::<Msb0>()[56..64].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for SMdps11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for SMdps11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("SMdps11")
                .field("cf_mdps_stat", &self.cf_mdps_stat())
                .field("cr_mdps_drv_tq", &self.cr_mdps_drv_tq())
                .field("cr_mdps_str_ang", &self.cr_mdps_str_ang())
                .field("cf_mdps_alive_cnt", &self.cf_mdps_alive_cnt())
                .field("cf_mdps_chksum", &self.cf_mdps_chksum())
            .finish()
        } else {
            f.debug_tuple("SMdps11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for SMdps11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_mdps_stat = u.int_in_range(0..=15)?;
        let cr_mdps_drv_tq = u.int_in_range(0..=15)?;
        let cr_mdps_str_ang = u.int_in_range(0..=65535)?;
        let cf_mdps_alive_cnt = u.int_in_range(0..=255)?;
        let cf_mdps_chksum = u.int_in_range(0..=255)?;
        SMdps11::new(cf_mdps_stat,cr_mdps_drv_tq,cr_mdps_str_ang,cf_mdps_alive_cnt,cf_mdps_chksum).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// S_MDPS12
///
/// - ID: 357 (0x165)
/// - Size: 8 bytes
/// - Transmitter: XXX
#[derive(Clone, Copy)]
pub struct SMdps12 {
    raw: [u8; 8],
}

impl SMdps12 {
    pub const MESSAGE_ID: u32 = 357;
    
    pub const NEW_SIGNAL_1_MIN: u16 = 0_u16;
    pub const NEW_SIGNAL_1_MAX: u16 = 4095_u16;
    pub const NEW_SIGNAL_2_MIN: u16 = 0_u16;
    pub const NEW_SIGNAL_2_MAX: u16 = 4095_u16;
    pub const COUNTER_MIN: u8 = 0_u8;
    pub const COUNTER_MAX: u8 = 15_u8;
    pub const CHECKSUM_MIN: u8 = 0_u8;
    pub const CHECKSUM_MAX: u8 = 255_u8;
    
    /// Construct new S_MDPS12 from values
    pub fn new(new_signal_1: u16, new_signal_2: u16, counter: u8, checksum: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_new_signal_1(new_signal_1)?;
        res.set_new_signal_2(new_signal_2)?;
        res.set_counter(counter)?;
        res.set_checksum(checksum)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// NEW_SIGNAL_1
    ///
    /// - Min: 0
    /// - Max: 4095
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn new_signal_1(&self) -> u16 {
        self.new_signal_1_raw()
    }
    
    /// Get raw value of NEW_SIGNAL_1
    ///
    /// - Start bit: 0
    /// - Signal size: 12 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn new_signal_1_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[0..12].load_le::<u16>();
        
        signal
    }
    
    /// Set value of NEW_SIGNAL_1
    #[inline(always)]
    pub fn set_new_signal_1(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 4095_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 357 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..12].store_le(value);
        Ok(())
    }
    
    /// NEW_SIGNAL_2
    ///
    /// - Min: 0
    /// - Max: 4095
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn new_signal_2(&self) -> u16 {
        self.new_signal_2_raw()
    }
    
    /// Get raw value of NEW_SIGNAL_2
    ///
    /// - Start bit: 12
    /// - Signal size: 12 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn new_signal_2_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[12..24].load_le::<u16>();
        
        signal
    }
    
    /// Set value of NEW_SIGNAL_2
    #[inline(always)]
    pub fn set_new_signal_2(&mut self, value: u16) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u16 || 4095_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 357 });
        }
        self.raw.view_bits_mut::<Lsb0>()[12..24].store_le(value);
        Ok(())
    }
    
    /// Counter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn counter(&self) -> u8 {
        self.counter_raw()
    }
    
    /// Get raw value of Counter
    ///
    /// - Start bit: 48
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Counter
    #[inline(always)]
    pub fn set_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 357 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..52].store_le(value);
        Ok(())
    }
    
    /// Checksum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn checksum(&self) -> u8 {
        self.checksum_raw()
    }
    
    /// Get raw value of Checksum
    ///
    /// - Start bit: 63
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[56..64].load_be::<u8>();
        
        signal
    }
    
    /// Set value of Checksum
    #[inline(always)]
    pub fn set_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 357 });
        }
        self.raw.view_bits_mut::<Msb0>()[56..64].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for SMdps12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for SMdps12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("SMdps12")
                .field("new_signal_1", &self.new_signal_1())
                .field("new_signal_2", &self.new_signal_2())
                .field("counter", &self.counter())
                .field("checksum", &self.checksum())
            .finish()
        } else {
            f.debug_tuple("SMdps12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for SMdps12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let new_signal_1 = u.int_in_range(0..=4095)?;
        let new_signal_2 = u.int_in_range(0..=4095)?;
        let counter = u.int_in_range(0..=15)?;
        let checksum = u.int_in_range(0..=255)?;
        SMdps12::new(new_signal_1,new_signal_2,counter,checksum).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// AHB1
///
/// - ID: 352 (0x160)
/// - Size: 8 bytes
/// - Transmitter: iBAU
#[derive(Clone, Copy)]
pub struct Ahb1 {
    raw: [u8; 8],
}

impl Ahb1 {
    pub const MESSAGE_ID: u32 = 352;
    
    pub const CF_AHB_S_LMP_MIN: u8 = 0_u8;
    pub const CF_AHB_S_LMP_MAX: u8 = 3_u8;
    pub const CF_AHB_DEF_MIN: u8 = 0_u8;
    pub const CF_AHB_DEF_MAX: u8 = 3_u8;
    pub const CF_AHB_ACT_MIN: u8 = 0_u8;
    pub const CF_AHB_ACT_MAX: u8 = 3_u8;
    pub const CR_AHB_ST_DEP_MM_MIN: f32 = -3276.8_f32;
    pub const CR_AHB_ST_DEP_MM_MAX: f32 = 3276.7_f32;
    pub const CF_AHB_CHK_SUM_MIN: u8 = 0_u8;
    pub const CF_AHB_CHK_SUM_MAX: u8 = 255_u8;
    
    /// Construct new AHB1 from values
    pub fn new(cf_ahb_s_lmp: u8, cf_ahb_def: u8, cf_ahb_act: u8, cf_ahb_diag: bool, cf_ahb_w_lmp: bool, cr_ahb_st_dep_mm: f32, cf_ahb_sns_fail: bool, cf_ahb_pedal_cal_stat: bool, cf_ahb_bzzr: bool, cf_ahb_chk_sum: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_ahb_s_lmp(cf_ahb_s_lmp)?;
        res.set_cf_ahb_def(cf_ahb_def)?;
        res.set_cf_ahb_act(cf_ahb_act)?;
        res.set_cf_ahb_diag(cf_ahb_diag)?;
        res.set_cf_ahb_w_lmp(cf_ahb_w_lmp)?;
        res.set_cr_ahb_st_dep_mm(cr_ahb_st_dep_mm)?;
        res.set_cf_ahb_sns_fail(cf_ahb_sns_fail)?;
        res.set_cf_ahb_pedal_cal_stat(cf_ahb_pedal_cal_stat)?;
        res.set_cf_ahb_bzzr(cf_ahb_bzzr)?;
        res.set_cf_ahb_chk_sum(cf_ahb_chk_sum)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Ahb_SLmp
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_ahb_s_lmp(&self) -> u8 {
        self.cf_ahb_s_lmp_raw()
    }
    
    /// Get raw value of CF_Ahb_SLmp
    ///
    /// - Start bit: 0
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ahb_s_lmp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..2].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ahb_SLmp
    #[inline(always)]
    pub fn set_cf_ahb_s_lmp(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 352 });
        }
        self.raw.view_bits_mut::<Lsb0>()[0..2].store_le(value);
        Ok(())
    }
    
    /// CF_Ahb_Def
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CGW
    #[inline(always)]
    pub fn cf_ahb_def(&self) -> u8 {
        self.cf_ahb_def_raw()
    }
    
    /// Get raw value of CF_Ahb_Def
    ///
    /// - Start bit: 2
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ahb_def_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[2..4].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ahb_Def
    #[inline(always)]
    pub fn set_cf_ahb_def(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 352 });
        }
        self.raw.view_bits_mut::<Lsb0>()[2..4].store_le(value);
        Ok(())
    }
    
    /// CF_Ahb_Act
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cf_ahb_act(&self) -> u8 {
        self.cf_ahb_act_raw()
    }
    
    /// Get raw value of CF_Ahb_Act
    ///
    /// - Start bit: 4
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ahb_act_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[4..6].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ahb_Act
    #[inline(always)]
    pub fn set_cf_ahb_act(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 352 });
        }
        self.raw.view_bits_mut::<Lsb0>()[4..6].store_le(value);
        Ok(())
    }
    
    /// CF_Ahb_Diag
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cf_ahb_diag(&self) -> bool {
        self.cf_ahb_diag_raw()
    }
    
    /// Get raw value of CF_Ahb_Diag
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ahb_diag_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[6..7].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ahb_Diag
    #[inline(always)]
    pub fn set_cf_ahb_diag(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[6..7].store_le(value);
        Ok(())
    }
    
    /// CF_Ahb_WLmp
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: CLU
    #[inline(always)]
    pub fn cf_ahb_w_lmp(&self) -> bool {
        self.cf_ahb_w_lmp_raw()
    }
    
    /// Get raw value of CF_Ahb_WLmp
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ahb_w_lmp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[7..8].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ahb_WLmp
    #[inline(always)]
    pub fn set_cf_ahb_w_lmp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[7..8].store_le(value);
        Ok(())
    }
    
    /// CR_Ahb_StDep_mm
    ///
    /// - Min: -3276.8
    /// - Max: 3276.7
    /// - Unit: "mm"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cr_ahb_st_dep_mm(&self) -> f32 {
        self.cr_ahb_st_dep_mm_raw()
    }
    
    /// Get raw value of CR_Ahb_StDep_mm
    ///
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn cr_ahb_st_dep_mm_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..24].load_le::<u16>();
        
        let signal  = i16::from_ne_bytes(signal.to_ne_bytes());
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Ahb_StDep_mm
    #[inline(always)]
    pub fn set_cr_ahb_st_dep_mm(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -3276.8_f32 || 3276.7_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 352 });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[8..24].store_le(value);
        Ok(())
    }
    
    /// CF_Ahb_SnsFail
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cf_ahb_sns_fail(&self) -> bool {
        self.cf_ahb_sns_fail_raw()
    }
    
    /// Get raw value of CF_Ahb_SnsFail
    ///
    /// - Start bit: 24
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ahb_sns_fail_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[24..25].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ahb_SnsFail
    #[inline(always)]
    pub fn set_cf_ahb_sns_fail(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[24..25].store_le(value);
        Ok(())
    }
    
    /// CF_Ahb_PedalCalStat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cf_ahb_pedal_cal_stat(&self) -> bool {
        self.cf_ahb_pedal_cal_stat_raw()
    }
    
    /// Get raw value of CF_Ahb_PedalCalStat
    ///
    /// - Start bit: 25
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ahb_pedal_cal_stat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[25..26].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ahb_PedalCalStat
    #[inline(always)]
    pub fn set_cf_ahb_pedal_cal_stat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[25..26].store_le(value);
        Ok(())
    }
    
    /// CF_Ahb_Bzzr
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cf_ahb_bzzr(&self) -> bool {
        self.cf_ahb_bzzr_raw()
    }
    
    /// Get raw value of CF_Ahb_Bzzr
    ///
    /// - Start bit: 26
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ahb_bzzr_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[26..27].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of CF_Ahb_Bzzr
    #[inline(always)]
    pub fn set_cf_ahb_bzzr(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[26..27].store_le(value);
        Ok(())
    }
    
    /// CF_Ahb_ChkSum
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cf_ahb_chk_sum(&self) -> u8 {
        self.cf_ahb_chk_sum_raw()
    }
    
    /// Get raw value of CF_Ahb_ChkSum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_ahb_chk_sum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Ahb_ChkSum
    #[inline(always)]
    pub fn set_cf_ahb_chk_sum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 352 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ahb1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ahb1 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ahb1")
                .field("cf_ahb_s_lmp", &self.cf_ahb_s_lmp())
                .field("cf_ahb_def", &self.cf_ahb_def())
                .field("cf_ahb_act", &self.cf_ahb_act())
                .field("cf_ahb_diag", &self.cf_ahb_diag())
                .field("cf_ahb_w_lmp", &self.cf_ahb_w_lmp())
                .field("cr_ahb_st_dep_mm", &self.cr_ahb_st_dep_mm())
                .field("cf_ahb_sns_fail", &self.cf_ahb_sns_fail())
                .field("cf_ahb_pedal_cal_stat", &self.cf_ahb_pedal_cal_stat())
                .field("cf_ahb_bzzr", &self.cf_ahb_bzzr())
                .field("cf_ahb_chk_sum", &self.cf_ahb_chk_sum())
            .finish()
        } else {
            f.debug_tuple("Ahb1").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ahb1 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_ahb_s_lmp = u.int_in_range(0..=3)?;
        let cf_ahb_def = u.int_in_range(0..=3)?;
        let cf_ahb_act = u.int_in_range(0..=3)?;
        let cf_ahb_diag = u.int_in_range(0..=1)? == 1;
        let cf_ahb_w_lmp = u.int_in_range(0..=1)? == 1;
        let cr_ahb_st_dep_mm = u.float_in_range(-3276.8_f32..=3276.7_f32)?;
        let cf_ahb_sns_fail = u.int_in_range(0..=1)? == 1;
        let cf_ahb_pedal_cal_stat = u.int_in_range(0..=1)? == 1;
        let cf_ahb_bzzr = u.int_in_range(0..=1)? == 1;
        let cf_ahb_chk_sum = u.int_in_range(0..=255)?;
        Ahb1::new(cf_ahb_s_lmp,cf_ahb_def,cf_ahb_act,cf_ahb_diag,cf_ahb_w_lmp,cr_ahb_st_dep_mm,cf_ahb_sns_fail,cf_ahb_pedal_cal_stat,cf_ahb_bzzr,cf_ahb_chk_sum).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// MFC_4a7
///
/// - ID: 1191 (0x4a7)
/// - Size: 8 bytes
/// - Transmitter: XXX
#[derive(Clone, Copy)]
pub struct Mfc4a7 {
    raw: [u8; 8],
}

impl Mfc4a7 {
    pub const MESSAGE_ID: u32 = 1191;
    
    
    /// Construct new MFC_4a7 from values
    pub fn new(paint1: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_paint1(paint1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// PAINT1
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn paint1(&self) -> bool {
        self.paint1_raw()
    }
    
    /// Get raw value of PAINT1
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn paint1_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[7..8].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of PAINT1
    #[inline(always)]
    pub fn set_paint1(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[7..8].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Mfc4a7 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Mfc4a7 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Mfc4a7")
                .field("paint1", &self.paint1())
            .finish()
        } else {
            f.debug_tuple("Mfc4a7").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Mfc4a7 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let paint1 = u.int_in_range(0..=1)? == 1;
        Mfc4a7::new(paint1).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// BCA11
///
/// - ID: 1162 (0x48a)
/// - Size: 8 bytes
/// - Transmitter: BCW
#[derive(Clone, Copy)]
pub struct Bca11 {
    raw: [u8; 8],
}

impl Bca11 {
    pub const MESSAGE_ID: u32 = 1162;
    
    pub const CF_BCA_STATE_MIN: u8 = 0_u8;
    pub const CF_BCA_STATE_MAX: u8 = 7_u8;
    pub const CF_BCA_WARNING_MIN: u8 = 0_u8;
    pub const CF_BCA_WARNING_MAX: u8 = 3_u8;
    pub const ALIVE_COUNTER_MIN: u8 = 0_u8;
    pub const ALIVE_COUNTER_MAX: u8 = 15_u8;
    pub const CHECK_SUM_MIN: u8 = 0_u8;
    pub const CHECK_SUM_MAX: u8 = 16_u8;
    
    /// Construct new BCA11 from values
    pub fn new(cf_bca_state: u8, cf_bca_warning: u8, alive_counter: u8, rcca_brake_command: bool, check_sum: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_bca_state(cf_bca_state)?;
        res.set_cf_bca_warning(cf_bca_warning)?;
        res.set_alive_counter(alive_counter)?;
        res.set_rcca_brake_command(rcca_brake_command)?;
        res.set_check_sum(check_sum)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_BCA_State
    ///
    /// - Min: 0
    /// - Max: 7
    /// - Unit: ""
    /// - Receivers: CLU, iBAU
    #[inline(always)]
    pub fn cf_bca_state(&self) -> u8 {
        self.cf_bca_state_raw()
    }
    
    /// Get raw value of CF_BCA_State
    ///
    /// - Start bit: 16
    /// - Signal size: 3 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_bca_state_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..19].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_BCA_State
    #[inline(always)]
    pub fn set_cf_bca_state(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 7_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1162 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..19].store_le(value);
        Ok(())
    }
    
    /// CF_BCA_Warning
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: CLU, iBAU
    #[inline(always)]
    pub fn cf_bca_warning(&self) -> u8 {
        self.cf_bca_warning_raw()
    }
    
    /// Get raw value of CF_BCA_Warning
    ///
    /// - Start bit: 19
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_bca_warning_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[19..21].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_BCA_Warning
    #[inline(always)]
    pub fn set_cf_bca_warning(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1162 });
        }
        self.raw.view_bits_mut::<Lsb0>()[19..21].store_le(value);
        Ok(())
    }
    
    /// AliveCounter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: CLU, iBAU
    #[inline(always)]
    pub fn alive_counter(&self) -> u8 {
        self.alive_counter_raw()
    }
    
    /// Get raw value of AliveCounter
    ///
    /// - Start bit: 21
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn alive_counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[21..25].load_le::<u8>();
        
        signal
    }
    
    /// Set value of AliveCounter
    #[inline(always)]
    pub fn set_alive_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1162 });
        }
        self.raw.view_bits_mut::<Lsb0>()[21..25].store_le(value);
        Ok(())
    }
    
    /// RCCA_Brake_Command
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn rcca_brake_command(&self) -> bool {
        self.rcca_brake_command_raw()
    }
    
    /// Get raw value of RCCA_Brake_Command
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rcca_brake_command_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[29..30].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of RCCA_Brake_Command
    #[inline(always)]
    pub fn set_rcca_brake_command(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[29..30].store_le(value);
        Ok(())
    }
    
    /// Check_Sum
    ///
    /// - Min: 0
    /// - Max: 16
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn check_sum(&self) -> u8 {
        self.check_sum_raw()
    }
    
    /// Get raw value of Check_Sum
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn check_sum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Check_Sum
    #[inline(always)]
    pub fn set_check_sum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 16_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1162 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Bca11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Bca11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Bca11")
                .field("cf_bca_state", &self.cf_bca_state())
                .field("cf_bca_warning", &self.cf_bca_warning())
                .field("alive_counter", &self.alive_counter())
                .field("rcca_brake_command", &self.rcca_brake_command())
                .field("check_sum", &self.check_sum())
            .finish()
        } else {
            f.debug_tuple("Bca11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Bca11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_bca_state = u.int_in_range(0..=7)?;
        let cf_bca_warning = u.int_in_range(0..=3)?;
        let alive_counter = u.int_in_range(0..=15)?;
        let rcca_brake_command = u.int_in_range(0..=1)? == 1;
        let check_sum = u.int_in_range(0..=16)?;
        Bca11::new(cf_bca_state,cf_bca_warning,alive_counter,rcca_brake_command,check_sum).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// P_STS
///
/// - ID: 1136 (0x470)
/// - Size: 8 bytes
/// - Transmitter: CGW
#[derive(Clone, Copy)]
pub struct PSts {
    raw: [u8; 8],
}

impl PSts {
    pub const MESSAGE_ID: u32 = 1136;
    
    pub const HCU1_STS_MIN: u8 = 0_u8;
    pub const HCU1_STS_MAX: u8 = 3_u8;
    pub const HCU5_STS_MIN: u8 = 0_u8;
    pub const HCU5_STS_MAX: u8 = 3_u8;
    pub const COUNTER_MIN: u8 = 0_u8;
    pub const COUNTER_MAX: u8 = 15_u8;
    pub const CHECKSUM_MIN: u8 = 0_u8;
    pub const CHECKSUM_MAX: u8 = 3_u8;
    
    /// Construct new P_STS from values
    pub fn new(hcu1_sts: u8, hcu5_sts: u8, counter: u8, checksum: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_hcu1_sts(hcu1_sts)?;
        res.set_hcu5_sts(hcu5_sts)?;
        res.set_counter(counter)?;
        res.set_checksum(checksum)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// HCU1_STS
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: BCW, EPB, FCA, MDPS, SCC, iBAU
    #[inline(always)]
    pub fn hcu1_sts(&self) -> u8 {
        self.hcu1_sts_raw()
    }
    
    /// Get raw value of HCU1_STS
    ///
    /// - Start bit: 6
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hcu1_sts_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[6..8].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HCU1_STS
    #[inline(always)]
    pub fn set_hcu1_sts(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1136 });
        }
        self.raw.view_bits_mut::<Lsb0>()[6..8].store_le(value);
        Ok(())
    }
    
    /// HCU5_STS
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: EPB, FCA, MDPS, iBAU
    #[inline(always)]
    pub fn hcu5_sts(&self) -> u8 {
        self.hcu5_sts_raw()
    }
    
    /// Get raw value of HCU5_STS
    ///
    /// - Start bit: 8
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn hcu5_sts_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..10].load_le::<u8>();
        
        signal
    }
    
    /// Set value of HCU5_STS
    #[inline(always)]
    pub fn set_hcu5_sts(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1136 });
        }
        self.raw.view_bits_mut::<Lsb0>()[8..10].store_le(value);
        Ok(())
    }
    
    /// Counter
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn counter(&self) -> u8 {
        self.counter_raw()
    }
    
    /// Get raw value of Counter
    ///
    /// - Start bit: 58
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn counter_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[58..62].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Counter
    #[inline(always)]
    pub fn set_counter(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1136 });
        }
        self.raw.view_bits_mut::<Lsb0>()[58..62].store_le(value);
        Ok(())
    }
    
    /// Checksum
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn checksum(&self) -> u8 {
        self.checksum_raw()
    }
    
    /// Get raw value of Checksum
    ///
    /// - Start bit: 62
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn checksum_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[62..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of Checksum
    #[inline(always)]
    pub fn set_checksum(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1136 });
        }
        self.raw.view_bits_mut::<Lsb0>()[62..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for PSts {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for PSts {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("PSts")
                .field("hcu1_sts", &self.hcu1_sts())
                .field("hcu5_sts", &self.hcu5_sts())
                .field("counter", &self.counter())
                .field("checksum", &self.checksum())
            .finish()
        } else {
            f.debug_tuple("PSts").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for PSts {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let hcu1_sts = u.int_in_range(0..=3)?;
        let hcu5_sts = u.int_in_range(0..=3)?;
        let counter = u.int_in_range(0..=15)?;
        let checksum = u.int_in_range(0..=3)?;
        PSts::new(hcu1_sts,hcu5_sts,counter,checksum).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// YRS11
///
/// - ID: 304 (0x130)
/// - Size: 8 bytes
/// - Transmitter: ACU
#[derive(Clone, Copy)]
pub struct Yrs11 {
    raw: [u8; 8],
}

impl Yrs11 {
    pub const MESSAGE_ID: u32 = 304;
    
    pub const CR_YRS_YR_MIN: f32 = -163.84_f32;
    pub const CR_YRS_YR_MAX: f32 = 163.83_f32;
    pub const CR_YRS_LAT_AC_MIN: f32 = -4.17677312_f32;
    pub const CR_YRS_LAT_AC_MAX: f32 = 4.17651819_f32;
    pub const CF_YRS_YR_STAT_MIN: u8 = 0_u8;
    pub const CF_YRS_YR_STAT_MAX: u8 = 15_u8;
    pub const CF_YRS_LAT_AC_STAT_MIN: u8 = 0_u8;
    pub const CF_YRS_LAT_AC_STAT_MAX: u8 = 15_u8;
    pub const CF_YRS_MCU_STAT_MIN: u8 = 0_u8;
    pub const CF_YRS_MCU_STAT_MAX: u8 = 15_u8;
    pub const CR_YRS_MSG_CNT1_MIN: u8 = 0_u8;
    pub const CR_YRS_MSG_CNT1_MAX: u8 = 15_u8;
    pub const CR_YRS_CRC1_MIN: u8 = 0_u8;
    pub const CR_YRS_CRC1_MAX: u8 = 255_u8;
    
    /// Construct new YRS11 from values
    pub fn new(cr_yrs_yr: f32, cr_yrs_lat_ac: f32, cf_yrs_yr_stat: u8, cf_yrs_lat_ac_stat: u8, cf_yrs_mcu_stat: u8, cr_yrs_msg_cnt1: u8, cr_yrs_crc1: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cr_yrs_yr(cr_yrs_yr)?;
        res.set_cr_yrs_lat_ac(cr_yrs_lat_ac)?;
        res.set_cf_yrs_yr_stat(cf_yrs_yr_stat)?;
        res.set_cf_yrs_lat_ac_stat(cf_yrs_lat_ac_stat)?;
        res.set_cf_yrs_mcu_stat(cf_yrs_mcu_stat)?;
        res.set_cr_yrs_msg_cnt1(cr_yrs_msg_cnt1)?;
        res.set_cr_yrs_crc1(cr_yrs_crc1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CR_Yrs_Yr
    ///
    /// - Min: -163.84
    /// - Max: 163.83
    /// - Unit: "deg/s"
    /// - Receivers: CGW, iBAU
    #[inline(always)]
    pub fn cr_yrs_yr(&self) -> f32 {
        self.cr_yrs_yr_raw()
    }
    
    /// Get raw value of CR_Yrs_Yr
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.005
    /// - Offset: -163.84
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_yrs_yr_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.005_f32;
        let offset = -163.84_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Yrs_Yr
    #[inline(always)]
    pub fn set_cr_yrs_yr(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -163.84_f32 || 163.83_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 304 });
        }
        let factor = 0.005_f32;
        let offset = -163.84_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
    /// CR_Yrs_LatAc
    ///
    /// - Min: -4.17677312
    /// - Max: 4.17651819
    /// - Unit: "g"
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn cr_yrs_lat_ac(&self) -> f32 {
        self.cr_yrs_lat_ac_raw()
    }
    
    /// Get raw value of CR_Yrs_LatAc
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.000127465
    /// - Offset: -4.17677312
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_yrs_lat_ac_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<u16>();
        
        let factor = 0.000127465_f32;
        let offset = -4.17677312_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Yrs_LatAc
    #[inline(always)]
    pub fn set_cr_yrs_lat_ac(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -4.17677312_f32 || 4.17651819_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 304 });
        }
        let factor = 0.000127465_f32;
        let offset = -4.17677312_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// CF_Yrs_YrStat
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn cf_yrs_yr_stat(&self) -> u8 {
        self.cf_yrs_yr_stat_raw()
    }
    
    /// Get raw value of CF_Yrs_YrStat
    ///
    /// - Start bit: 32
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_yrs_yr_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Yrs_YrStat
    #[inline(always)]
    pub fn set_cf_yrs_yr_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 304 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..36].store_le(value);
        Ok(())
    }
    
    /// CF_Yrs_LatAcStat
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn cf_yrs_lat_ac_stat(&self) -> u8 {
        self.cf_yrs_lat_ac_stat_raw()
    }
    
    /// Get raw value of CF_Yrs_LatAcStat
    ///
    /// - Start bit: 36
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_yrs_lat_ac_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[36..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Yrs_LatAcStat
    #[inline(always)]
    pub fn set_cf_yrs_lat_ac_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 304 });
        }
        self.raw.view_bits_mut::<Lsb0>()[36..40].store_le(value);
        Ok(())
    }
    
    /// CF_Yrs_MCUStat
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn cf_yrs_mcu_stat(&self) -> u8 {
        self.cf_yrs_mcu_stat_raw()
    }
    
    /// Get raw value of CF_Yrs_MCUStat
    ///
    /// - Start bit: 40
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_yrs_mcu_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..44].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Yrs_MCUStat
    #[inline(always)]
    pub fn set_cf_yrs_mcu_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 304 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..44].store_le(value);
        Ok(())
    }
    
    /// CR_Yrs_MsgCnt1
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn cr_yrs_msg_cnt1(&self) -> u8 {
        self.cr_yrs_msg_cnt1_raw()
    }
    
    /// Get raw value of CR_Yrs_MsgCnt1
    ///
    /// - Start bit: 48
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_yrs_msg_cnt1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Yrs_MsgCnt1
    #[inline(always)]
    pub fn set_cr_yrs_msg_cnt1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 304 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..52].store_le(value);
        Ok(())
    }
    
    /// CR_Yrs_Crc1
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn cr_yrs_crc1(&self) -> u8 {
        self.cr_yrs_crc1_raw()
    }
    
    /// Get raw value of CR_Yrs_Crc1
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_yrs_crc1_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Yrs_Crc1
    #[inline(always)]
    pub fn set_cr_yrs_crc1(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 304 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Yrs11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Yrs11 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Yrs11")
                .field("cr_yrs_yr", &self.cr_yrs_yr())
                .field("cr_yrs_lat_ac", &self.cr_yrs_lat_ac())
                .field("cf_yrs_yr_stat", &self.cf_yrs_yr_stat())
                .field("cf_yrs_lat_ac_stat", &self.cf_yrs_lat_ac_stat())
                .field("cf_yrs_mcu_stat", &self.cf_yrs_mcu_stat())
                .field("cr_yrs_msg_cnt1", &self.cr_yrs_msg_cnt1())
                .field("cr_yrs_crc1", &self.cr_yrs_crc1())
            .finish()
        } else {
            f.debug_tuple("Yrs11").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Yrs11 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cr_yrs_yr = u.float_in_range(-163.84_f32..=163.83_f32)?;
        let cr_yrs_lat_ac = u.float_in_range(-4.17677312_f32..=4.17651819_f32)?;
        let cf_yrs_yr_stat = u.int_in_range(0..=15)?;
        let cf_yrs_lat_ac_stat = u.int_in_range(0..=15)?;
        let cf_yrs_mcu_stat = u.int_in_range(0..=15)?;
        let cr_yrs_msg_cnt1 = u.int_in_range(0..=15)?;
        let cr_yrs_crc1 = u.int_in_range(0..=255)?;
        Yrs11::new(cr_yrs_yr,cr_yrs_lat_ac,cf_yrs_yr_stat,cf_yrs_lat_ac_stat,cf_yrs_mcu_stat,cr_yrs_msg_cnt1,cr_yrs_crc1).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// YRS12
///
/// - ID: 320 (0x140)
/// - Size: 8 bytes
/// - Transmitter: ACU
#[derive(Clone, Copy)]
pub struct Yrs12 {
    raw: [u8; 8],
}

impl Yrs12 {
    pub const MESSAGE_ID: u32 = 320;
    
    pub const CF_YRS_LONG_AC_STAT_MIN: u8 = 0_u8;
    pub const CF_YRS_LONG_AC_STAT_MAX: u8 = 15_u8;
    pub const CF_IMU_RESET_STAT_MIN: u8 = 0_u8;
    pub const CF_IMU_RESET_STAT_MAX: u8 = 15_u8;
    pub const YRS_TEMP_MIN: f32 = -68_f32;
    pub const YRS_TEMP_MAX: f32 = 187_f32;
    pub const YRS_TEMP_STAT_MIN: u8 = 0_u8;
    pub const YRS_TEMP_STAT_MAX: u8 = 15_u8;
    pub const CF_YRS_TYPE_MIN: u8 = 0_u8;
    pub const CF_YRS_TYPE_MAX: u8 = 15_u8;
    pub const CR_YRS_MSG_CNT2_MIN: u8 = 0_u8;
    pub const CR_YRS_MSG_CNT2_MAX: u8 = 15_u8;
    pub const CR_YRS_CRC2_MIN: u8 = 0_u8;
    pub const CR_YRS_CRC2_MAX: u8 = 255_u8;
    pub const CR_YRS_LONG_AC_MIN: f32 = -4.17677312_f32;
    pub const CR_YRS_LONG_AC_MAX: f32 = 4.17651819_f32;
    
    /// Construct new YRS12 from values
    pub fn new(cf_yrs_long_ac_stat: u8, cf_imu_reset_stat: u8, yrs_temp: f32, yrs_temp_stat: u8, cf_yrs_type: u8, cr_yrs_msg_cnt2: u8, cr_yrs_crc2: u8, cr_yrs_long_ac: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cf_yrs_long_ac_stat(cf_yrs_long_ac_stat)?;
        res.set_cf_imu_reset_stat(cf_imu_reset_stat)?;
        res.set_yrs_temp(yrs_temp)?;
        res.set_yrs_temp_stat(yrs_temp_stat)?;
        res.set_cf_yrs_type(cf_yrs_type)?;
        res.set_cr_yrs_msg_cnt2(cr_yrs_msg_cnt2)?;
        res.set_cr_yrs_crc2(cr_yrs_crc2)?;
        res.set_cr_yrs_long_ac(cr_yrs_long_ac)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// CF_Yrs_LongAcStat
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn cf_yrs_long_ac_stat(&self) -> u8 {
        self.cf_yrs_long_ac_stat_raw()
    }
    
    /// Get raw value of CF_Yrs_LongAcStat
    ///
    /// - Start bit: 16
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_yrs_long_ac_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..20].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Yrs_LongAcStat
    #[inline(always)]
    pub fn set_cf_yrs_long_ac_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 320 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..20].store_le(value);
        Ok(())
    }
    
    /// CF_IMU_ResetStat
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn cf_imu_reset_stat(&self) -> u8 {
        self.cf_imu_reset_stat_raw()
    }
    
    /// Get raw value of CF_IMU_ResetStat
    ///
    /// - Start bit: 20
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_imu_reset_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[20..24].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_IMU_ResetStat
    #[inline(always)]
    pub fn set_cf_imu_reset_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 320 });
        }
        self.raw.view_bits_mut::<Lsb0>()[20..24].store_le(value);
        Ok(())
    }
    
    /// YRS_Temp
    ///
    /// - Min: -68
    /// - Max: 187
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn yrs_temp(&self) -> f32 {
        self.yrs_temp_raw()
    }
    
    /// Get raw value of YRS_Temp
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: -68
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn yrs_temp_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 1_f32;
        let offset = -68_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of YRS_Temp
    #[inline(always)]
    pub fn set_yrs_temp(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -68_f32 || 187_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 320 });
        }
        let factor = 1_f32;
        let offset = -68_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// YRS_TempStat
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn yrs_temp_stat(&self) -> u8 {
        self.yrs_temp_stat_raw()
    }
    
    /// Get raw value of YRS_TempStat
    ///
    /// - Start bit: 32
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn yrs_temp_stat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..36].load_le::<u8>();
        
        signal
    }
    
    /// Set value of YRS_TempStat
    #[inline(always)]
    pub fn set_yrs_temp_stat(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 320 });
        }
        self.raw.view_bits_mut::<Lsb0>()[32..36].store_le(value);
        Ok(())
    }
    
    /// CF_Yrs_Type
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn cf_yrs_type(&self) -> u8 {
        self.cf_yrs_type_raw()
    }
    
    /// Get raw value of CF_Yrs_Type
    ///
    /// - Start bit: 36
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cf_yrs_type_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[36..40].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CF_Yrs_Type
    #[inline(always)]
    pub fn set_cf_yrs_type(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 320 });
        }
        self.raw.view_bits_mut::<Lsb0>()[36..40].store_le(value);
        Ok(())
    }
    
    /// CR_Yrs_MsgCnt2
    ///
    /// - Min: 0
    /// - Max: 15
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn cr_yrs_msg_cnt2(&self) -> u8 {
        self.cr_yrs_msg_cnt2_raw()
    }
    
    /// Get raw value of CR_Yrs_MsgCnt2
    ///
    /// - Start bit: 48
    /// - Signal size: 4 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_yrs_msg_cnt2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..52].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Yrs_MsgCnt2
    #[inline(always)]
    pub fn set_cr_yrs_msg_cnt2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 15_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 320 });
        }
        self.raw.view_bits_mut::<Lsb0>()[48..52].store_le(value);
        Ok(())
    }
    
    /// CR_Yrs_Crc2
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn cr_yrs_crc2(&self) -> u8 {
        self.cr_yrs_crc2_raw()
    }
    
    /// Get raw value of CR_Yrs_Crc2
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_yrs_crc2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        signal
    }
    
    /// Set value of CR_Yrs_Crc2
    #[inline(always)]
    pub fn set_cr_yrs_crc2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 320 });
        }
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
    /// CR_Yrs_LongAc
    ///
    /// - Min: -4.17677312
    /// - Max: 4.17651819
    /// - Unit: "g"
    /// - Receivers: CGW, iBAU
    #[inline(always)]
    pub fn cr_yrs_long_ac(&self) -> f32 {
        self.cr_yrs_long_ac_raw()
    }
    
    /// Get raw value of CR_Yrs_LongAc
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.000127465
    /// - Offset: -4.17677312
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cr_yrs_long_ac_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.000127465_f32;
        let offset = -4.17677312_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of CR_Yrs_LongAc
    #[inline(always)]
    pub fn set_cr_yrs_long_ac(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < -4.17677312_f32 || 4.17651819_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 320 });
        }
        let factor = 0.000127465_f32;
        let offset = -4.17677312_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Yrs12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Yrs12 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Yrs12")
                .field("cf_yrs_long_ac_stat", &self.cf_yrs_long_ac_stat())
                .field("cf_imu_reset_stat", &self.cf_imu_reset_stat())
                .field("yrs_temp", &self.yrs_temp())
                .field("yrs_temp_stat", &self.yrs_temp_stat())
                .field("cf_yrs_type", &self.cf_yrs_type())
                .field("cr_yrs_msg_cnt2", &self.cr_yrs_msg_cnt2())
                .field("cr_yrs_crc2", &self.cr_yrs_crc2())
                .field("cr_yrs_long_ac", &self.cr_yrs_long_ac())
            .finish()
        } else {
            f.debug_tuple("Yrs12").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Yrs12 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let cf_yrs_long_ac_stat = u.int_in_range(0..=15)?;
        let cf_imu_reset_stat = u.int_in_range(0..=15)?;
        let yrs_temp = u.float_in_range(-68_f32..=187_f32)?;
        let yrs_temp_stat = u.int_in_range(0..=15)?;
        let cf_yrs_type = u.int_in_range(0..=15)?;
        let cr_yrs_msg_cnt2 = u.int_in_range(0..=15)?;
        let cr_yrs_crc2 = u.int_in_range(0..=255)?;
        let cr_yrs_long_ac = u.float_in_range(-4.17677312_f32..=4.17651819_f32)?;
        Yrs12::new(cf_yrs_long_ac_stat,cf_imu_reset_stat,yrs_temp,yrs_temp_stat,cf_yrs_type,cr_yrs_msg_cnt2,cr_yrs_crc2,cr_yrs_long_ac).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// YRS13
///
/// - ID: 1173 (0x495)
/// - Size: 8 bytes
/// - Transmitter: ACU
#[derive(Clone, Copy)]
pub struct Yrs13 {
    raw: [u8; 8],
}

impl Yrs13 {
    pub const MESSAGE_ID: u32 = 1173;
    
    pub const YRS_SERAL_NO_MIN: u64 = 0_u64;
    pub const YRS_SERAL_NO_MAX: u64 = 281474976710655_u64;
    
    /// Construct new YRS13 from values
    pub fn new(yrs_seral_no: u64) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_yrs_seral_no(yrs_seral_no)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// YRS_SeralNo
    ///
    /// - Min: 0
    /// - Max: 281474976710655
    /// - Unit: ""
    /// - Receivers: iBAU
    #[inline(always)]
    pub fn yrs_seral_no(&self) -> u64 {
        self.yrs_seral_no_raw()
    }
    
    /// Get raw value of YRS_SeralNo
    ///
    /// - Start bit: 16
    /// - Signal size: 48 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn yrs_seral_no_raw(&self) -> u64 {
        let signal = self.raw.view_bits::<Lsb0>()[16..64].load_le::<u64>();
        
        signal
    }
    
    /// Set value of YRS_SeralNo
    #[inline(always)]
    pub fn set_yrs_seral_no(&mut self, value: u64) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u64 || 281474976710655_u64 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1173 });
        }
        self.raw.view_bits_mut::<Lsb0>()[16..64].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Yrs13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Yrs13 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Yrs13")
                .field("yrs_seral_no", &self.yrs_seral_no())
            .finish()
        } else {
            f.debug_tuple("Yrs13").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Yrs13 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let yrs_seral_no = u.int_in_range(0..=281474976710655)?;
        Yrs13::new(yrs_seral_no).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// EMS_366
///
/// - ID: 870 (0x366)
/// - Size: 8 bytes
/// - Transmitter: EMS
#[derive(Clone, Copy)]
pub struct Ems366 {
    raw: [u8; 8],
}

impl Ems366 {
    pub const MESSAGE_ID: u32 = 870;
    
    pub const TQI_1_MIN: f32 = 0_f32;
    pub const TQI_1_MAX: f32 = 99.6094_f32;
    pub const N_MIN: f32 = 0_f32;
    pub const N_MAX: f32 = 16383.75_f32;
    pub const TQI_2_MIN: f32 = 0_f32;
    pub const TQI_2_MAX: f32 = 99.6094_f32;
    pub const VS_MIN: u8 = 0_u8;
    pub const VS_MAX: u8 = 255_u8;
    
    /// Construct new EMS_366 from values
    pub fn new(tqi_1: f32, n: f32, tqi_2: f32, vs: u8, swi_igk: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_tqi_1(tqi_1)?;
        res.set_n(n)?;
        res.set_tqi_2(tqi_2)?;
        res.set_vs(vs)?;
        res.set_swi_igk(swi_igk)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// TQI_1
    ///
    /// - Min: 0
    /// - Max: 99.6094
    /// - Unit: "%"
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn tqi_1(&self) -> f32 {
        self.tqi_1_raw()
    }
    
    /// Get raw value of TQI_1
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI_1
    #[inline(always)]
    pub fn set_tqi_1(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.6094_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 870 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
    /// N
    ///
    /// - Min: 0
    /// - Max: 16383.75
    /// - Unit: "rpm"
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn n(&self) -> f32 {
        self.n_raw()
    }
    
    /// Get raw value of N
    ///
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 0.25
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn n_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..24].load_le::<u16>();
        
        let factor = 0.25_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of N
    #[inline(always)]
    pub fn set_n(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 16383.75_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 870 });
        }
        let factor = 0.25_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[8..24].store_le(value);
        Ok(())
    }
    
    /// TQI_2
    ///
    /// - Min: 0
    /// - Max: 99.6094
    /// - Unit: "%"
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn tqi_2(&self) -> f32 {
        self.tqi_2_raw()
    }
    
    /// Get raw value of TQI_2
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 0.390625
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn tqi_2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 0.390625_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of TQI_2
    #[inline(always)]
    pub fn set_tqi_2(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 99.6094_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 870 });
        }
        let factor = 0.390625_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// VS
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: "km/h"
    /// - Receivers: MDPS
    #[inline(always)]
    pub fn vs(&self) -> u8 {
        self.vs_raw()
    }
    
    /// Get raw value of VS
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn vs_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        signal
    }
    
    /// Set value of VS
    #[inline(always)]
    pub fn set_vs(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 870 });
        }
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// SWI_IGK
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn swi_igk(&self) -> bool {
        self.swi_igk_raw()
    }
    
    /// Get raw value of SWI_IGK
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn swi_igk_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[55..56].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of SWI_IGK
    #[inline(always)]
    pub fn set_swi_igk(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[55..56].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Ems366 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Ems366 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Ems366")
                .field("tqi_1", &self.tqi_1())
                .field("n", &self.n())
                .field("tqi_2", &self.tqi_2())
                .field("vs", &self.vs())
                .field("swi_igk", &self.swi_igk())
            .finish()
        } else {
            f.debug_tuple("Ems366").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Ems366 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let tqi_1 = u.float_in_range(0_f32..=99.6094_f32)?;
        let n = u.float_in_range(0_f32..=16383.75_f32)?;
        let tqi_2 = u.float_in_range(0_f32..=99.6094_f32)?;
        let vs = u.int_in_range(0..=255)?;
        let swi_igk = u.int_in_range(0..=1)? == 1;
        Ems366::new(tqi_1,n,tqi_2,vs,swi_igk).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// M_356
///
/// - ID: 854 (0x356)
/// - Size: 8 bytes
/// - Transmitter: XXX
#[derive(Clone, Copy)]
pub struct M356 {
    raw: [u8; 8],
}

impl M356 {
    pub const MESSAGE_ID: u32 = 854;
    
    pub const PAINT2_MIN: u8 = 0_u8;
    pub const PAINT2_MAX: u8 = 1_u8;
    pub const PAINT3_MIN: u8 = 0_u8;
    pub const PAINT3_MAX: u8 = 3_u8;
    
    /// Construct new M_356 from values
    pub fn new(paint1: bool, paint2: u8, paint3: u8, paint4: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_paint1(paint1)?;
        res.set_paint2(paint2)?;
        res.set_paint3(paint3)?;
        res.set_paint4(paint4)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// PAINT1
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn paint1(&self) -> bool {
        self.paint1_raw()
    }
    
    /// Get raw value of PAINT1
    ///
    /// - Start bit: 32
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn paint1_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[39..40].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of PAINT1
    #[inline(always)]
    pub fn set_paint1(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[39..40].store_be(value);
        Ok(())
    }
    
    /// PAINT2
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn paint2(&self) -> u8 {
        self.paint2_raw()
    }
    
    /// Get raw value of PAINT2
    ///
    /// - Start bit: 34
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn paint2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[37..39].load_be::<u8>();
        
        signal
    }
    
    /// Set value of PAINT2
    #[inline(always)]
    pub fn set_paint2(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 1_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 854 });
        }
        self.raw.view_bits_mut::<Msb0>()[37..39].store_be(value);
        Ok(())
    }
    
    /// PAINT3
    ///
    /// - Min: 0
    /// - Max: 3
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn paint3(&self) -> u8 {
        self.paint3_raw()
    }
    
    /// Get raw value of PAINT3
    ///
    /// - Start bit: 36
    /// - Signal size: 2 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn paint3_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[35..37].load_be::<u8>();
        
        signal
    }
    
    /// Set value of PAINT3
    #[inline(always)]
    pub fn set_paint3(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 3_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 854 });
        }
        self.raw.view_bits_mut::<Msb0>()[35..37].store_be(value);
        Ok(())
    }
    
    /// PAINT4
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn paint4(&self) -> bool {
        self.paint4_raw()
    }
    
    /// Get raw value of PAINT4
    ///
    /// - Start bit: 38
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn paint4_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[33..34].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of PAINT4
    #[inline(always)]
    pub fn set_paint4(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[33..34].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for M356 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for M356 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("M356")
                .field("paint1", &self.paint1())
                .field("paint2", &self.paint2())
                .field("paint3", &self.paint3())
                .field("paint4", &self.paint4())
            .finish()
        } else {
            f.debug_tuple("M356").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for M356 {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let paint1 = u.int_in_range(0..=1)? == 1;
        let paint2 = u.int_in_range(0..=1)?;
        let paint3 = u.int_in_range(0..=3)?;
        let paint4 = u.int_in_range(0..=1)? == 1;
        M356::new(paint1,paint2,paint3,paint4).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// ICM_412h
///
/// - ID: 1042 (0x412)
/// - Size: 8 bytes
/// - Transmitter: ICM
#[derive(Clone, Copy)]
pub struct Icm412h {
    raw: [u8; 8],
}

impl Icm412h {
    pub const MESSAGE_ID: u32 = 1042;
    
    pub const T_OUTSIDE_INPUT_MIN: f32 = 0_f32;
    pub const T_OUTSIDE_INPUT_MAX: f32 = 5_f32;
    pub const TRIP_A_DT_DISPLAY_CLOCK_MIN: u8 = 0_u8;
    pub const TRIP_A_DT_DISPLAY_CLOCK_MAX: u8 = 99_u8;
    pub const TRIP_A_DT_DISPLAY_MINUTE_MIN: u8 = 0_u8;
    pub const TRIP_A_DT_DISPLAY_MINUTE_MAX: u8 = 59_u8;
    pub const TRIP_B_DT_DISPLAY_CLOCK_MIN: u8 = 0_u8;
    pub const TRIP_B_DT_DISPLAY_CLOCK_MAX: u8 = 99_u8;
    pub const TRIP_B_DT_DISPLAY_MINUTE_MIN: u8 = 0_u8;
    pub const TRIP_B_DT_DISPLAY_MINUTE_MAX: u8 = 59_u8;
    
    /// Construct new ICM_412h from values
    pub fn new(t_outside_input: f32, warning_sound_output_1group: bool, warning_sound_output_2group: bool, warning_sound_output_3group: bool, trip_a_dt_display_clock: u8, trip_a_dt_display_minute: u8, trip_b_dt_display_clock: u8, trip_b_dt_display_minute: u8, popup_message_output_1level: bool, popup_message_output_2level: bool, popup_message_output_3level: bool, popup_message_output_4level: bool, popup_message_output_5level: bool, popup_message_output_6level: bool, popup_message_output_7level: bool, popup_message_output_8level: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_t_outside_input(t_outside_input)?;
        res.set_warning_sound_output_1group(warning_sound_output_1group)?;
        res.set_warning_sound_output_2group(warning_sound_output_2group)?;
        res.set_warning_sound_output_3group(warning_sound_output_3group)?;
        res.set_trip_a_dt_display_clock(trip_a_dt_display_clock)?;
        res.set_trip_a_dt_display_minute(trip_a_dt_display_minute)?;
        res.set_trip_b_dt_display_clock(trip_b_dt_display_clock)?;
        res.set_trip_b_dt_display_minute(trip_b_dt_display_minute)?;
        res.set_popup_message_output_1level(popup_message_output_1level)?;
        res.set_popup_message_output_2level(popup_message_output_2level)?;
        res.set_popup_message_output_3level(popup_message_output_3level)?;
        res.set_popup_message_output_4level(popup_message_output_4level)?;
        res.set_popup_message_output_5level(popup_message_output_5level)?;
        res.set_popup_message_output_6level(popup_message_output_6level)?;
        res.set_popup_message_output_7level(popup_message_output_7level)?;
        res.set_popup_message_output_8level(popup_message_output_8level)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// T_Outside_input
    ///
    /// - Min: 0
    /// - Max: 5
    /// - Unit: "V"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn t_outside_input(&self) -> f32 {
        self.t_outside_input_raw()
    }
    
    /// Get raw value of T_Outside_input
    ///
    /// - Start bit: 0
    /// - Signal size: 9 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn t_outside_input_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[7..16].load_be::<u16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of T_Outside_input
    #[inline(always)]
    pub fn set_t_outside_input(&mut self, value: f32) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_f32 || 5_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1042 });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[7..16].store_be(value);
        Ok(())
    }
    
    /// WarningSoundOutput_1Group
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn warning_sound_output_1group(&self) -> bool {
        self.warning_sound_output_1group_raw()
    }
    
    /// Get raw value of WarningSoundOutput_1Group
    ///
    /// - Start bit: 5
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn warning_sound_output_1group_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[2..3].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of WarningSoundOutput_1Group
    #[inline(always)]
    pub fn set_warning_sound_output_1group(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[2..3].store_be(value);
        Ok(())
    }
    
    /// WarningSoundOutput_2Group
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn warning_sound_output_2group(&self) -> bool {
        self.warning_sound_output_2group_raw()
    }
    
    /// Get raw value of WarningSoundOutput_2Group
    ///
    /// - Start bit: 6
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn warning_sound_output_2group_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[1..2].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of WarningSoundOutput_2Group
    #[inline(always)]
    pub fn set_warning_sound_output_2group(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[1..2].store_be(value);
        Ok(())
    }
    
    /// WarningSoundOutput_3Group
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn warning_sound_output_3group(&self) -> bool {
        self.warning_sound_output_3group_raw()
    }
    
    /// Get raw value of WarningSoundOutput_3Group
    ///
    /// - Start bit: 7
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn warning_sound_output_3group_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[0..1].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of WarningSoundOutput_3Group
    #[inline(always)]
    pub fn set_warning_sound_output_3group(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[0..1].store_be(value);
        Ok(())
    }
    
    /// TRIP_A_DT_Display_clock
    ///
    /// - Min: 0
    /// - Max: 99
    /// - Unit: "clock"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn trip_a_dt_display_clock(&self) -> u8 {
        self.trip_a_dt_display_clock_raw()
    }
    
    /// Get raw value of TRIP_A_DT_Display_clock
    ///
    /// - Start bit: 22
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn trip_a_dt_display_clock_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[17..24].load_be::<u8>();
        
        signal
    }
    
    /// Set value of TRIP_A_DT_Display_clock
    #[inline(always)]
    pub fn set_trip_a_dt_display_clock(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 99_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1042 });
        }
        self.raw.view_bits_mut::<Msb0>()[17..24].store_be(value);
        Ok(())
    }
    
    /// TRIP_A_DT_Display_minute
    ///
    /// - Min: 0
    /// - Max: 59
    /// - Unit: "minute"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn trip_a_dt_display_minute(&self) -> u8 {
        self.trip_a_dt_display_minute_raw()
    }
    
    /// Get raw value of TRIP_A_DT_Display_minute
    ///
    /// - Start bit: 29
    /// - Signal size: 6 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn trip_a_dt_display_minute_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[26..32].load_be::<u8>();
        
        signal
    }
    
    /// Set value of TRIP_A_DT_Display_minute
    #[inline(always)]
    pub fn set_trip_a_dt_display_minute(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 59_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1042 });
        }
        self.raw.view_bits_mut::<Msb0>()[26..32].store_be(value);
        Ok(())
    }
    
    /// TRIP_B_DT_Display_clock
    ///
    /// - Min: 0
    /// - Max: 99
    /// - Unit: "clock"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn trip_b_dt_display_clock(&self) -> u8 {
        self.trip_b_dt_display_clock_raw()
    }
    
    /// Get raw value of TRIP_B_DT_Display_clock
    ///
    /// - Start bit: 38
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn trip_b_dt_display_clock_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[33..40].load_be::<u8>();
        
        signal
    }
    
    /// Set value of TRIP_B_DT_Display_clock
    #[inline(always)]
    pub fn set_trip_b_dt_display_clock(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 99_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1042 });
        }
        self.raw.view_bits_mut::<Msb0>()[33..40].store_be(value);
        Ok(())
    }
    
    /// TRIP_B_DT_Display_minute
    ///
    /// - Min: 0
    /// - Max: 59
    /// - Unit: "minute"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn trip_b_dt_display_minute(&self) -> u8 {
        self.trip_b_dt_display_minute_raw()
    }
    
    /// Get raw value of TRIP_B_DT_Display_minute
    ///
    /// - Start bit: 45
    /// - Signal size: 6 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn trip_b_dt_display_minute_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[42..48].load_be::<u8>();
        
        signal
    }
    
    /// Set value of TRIP_B_DT_Display_minute
    #[inline(always)]
    pub fn set_trip_b_dt_display_minute(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 59_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1042 });
        }
        self.raw.view_bits_mut::<Msb0>()[42..48].store_be(value);
        Ok(())
    }
    
    /// PopupMessageOutput_1Level
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn popup_message_output_1level(&self) -> bool {
        self.popup_message_output_1level_raw()
    }
    
    /// Get raw value of PopupMessageOutput_1Level
    ///
    /// - Start bit: 48
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn popup_message_output_1level_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[55..56].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of PopupMessageOutput_1Level
    #[inline(always)]
    pub fn set_popup_message_output_1level(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[55..56].store_be(value);
        Ok(())
    }
    
    /// PopupMessageOutput_2Level
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn popup_message_output_2level(&self) -> bool {
        self.popup_message_output_2level_raw()
    }
    
    /// Get raw value of PopupMessageOutput_2Level
    ///
    /// - Start bit: 49
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn popup_message_output_2level_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[54..55].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of PopupMessageOutput_2Level
    #[inline(always)]
    pub fn set_popup_message_output_2level(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[54..55].store_be(value);
        Ok(())
    }
    
    /// PopupMessageOutput_3Level
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn popup_message_output_3level(&self) -> bool {
        self.popup_message_output_3level_raw()
    }
    
    /// Get raw value of PopupMessageOutput_3Level
    ///
    /// - Start bit: 50
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn popup_message_output_3level_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[53..54].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of PopupMessageOutput_3Level
    #[inline(always)]
    pub fn set_popup_message_output_3level(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[53..54].store_be(value);
        Ok(())
    }
    
    /// PopupMessageOutput_4Level
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn popup_message_output_4level(&self) -> bool {
        self.popup_message_output_4level_raw()
    }
    
    /// Get raw value of PopupMessageOutput_4Level
    ///
    /// - Start bit: 51
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn popup_message_output_4level_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[52..53].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of PopupMessageOutput_4Level
    #[inline(always)]
    pub fn set_popup_message_output_4level(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[52..53].store_be(value);
        Ok(())
    }
    
    /// PopupMessageOutput_5Level
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn popup_message_output_5level(&self) -> bool {
        self.popup_message_output_5level_raw()
    }
    
    /// Get raw value of PopupMessageOutput_5Level
    ///
    /// - Start bit: 52
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn popup_message_output_5level_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[51..52].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of PopupMessageOutput_5Level
    #[inline(always)]
    pub fn set_popup_message_output_5level(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[51..52].store_be(value);
        Ok(())
    }
    
    /// PopupMessageOutput_6Level
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn popup_message_output_6level(&self) -> bool {
        self.popup_message_output_6level_raw()
    }
    
    /// Get raw value of PopupMessageOutput_6Level
    ///
    /// - Start bit: 53
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn popup_message_output_6level_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[50..51].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of PopupMessageOutput_6Level
    #[inline(always)]
    pub fn set_popup_message_output_6level(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[50..51].store_be(value);
        Ok(())
    }
    
    /// PopupMessageOutput_7Level
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn popup_message_output_7level(&self) -> bool {
        self.popup_message_output_7level_raw()
    }
    
    /// Get raw value of PopupMessageOutput_7Level
    ///
    /// - Start bit: 54
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn popup_message_output_7level_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[49..50].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of PopupMessageOutput_7Level
    #[inline(always)]
    pub fn set_popup_message_output_7level(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[49..50].store_be(value);
        Ok(())
    }
    
    /// PopupMessageOutput_8Level
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn popup_message_output_8level(&self) -> bool {
        self.popup_message_output_8level_raw()
    }
    
    /// Get raw value of PopupMessageOutput_8Level
    ///
    /// - Start bit: 55
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn popup_message_output_8level_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[48..49].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of PopupMessageOutput_8Level
    #[inline(always)]
    pub fn set_popup_message_output_8level(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[48..49].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for Icm412h {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for Icm412h {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("Icm412h")
                .field("t_outside_input", &self.t_outside_input())
                .field("warning_sound_output_1group", &self.warning_sound_output_1group())
                .field("warning_sound_output_2group", &self.warning_sound_output_2group())
                .field("warning_sound_output_3group", &self.warning_sound_output_3group())
                .field("trip_a_dt_display_clock", &self.trip_a_dt_display_clock())
                .field("trip_a_dt_display_minute", &self.trip_a_dt_display_minute())
                .field("trip_b_dt_display_clock", &self.trip_b_dt_display_clock())
                .field("trip_b_dt_display_minute", &self.trip_b_dt_display_minute())
                .field("popup_message_output_1level", &self.popup_message_output_1level())
                .field("popup_message_output_2level", &self.popup_message_output_2level())
                .field("popup_message_output_3level", &self.popup_message_output_3level())
                .field("popup_message_output_4level", &self.popup_message_output_4level())
                .field("popup_message_output_5level", &self.popup_message_output_5level())
                .field("popup_message_output_6level", &self.popup_message_output_6level())
                .field("popup_message_output_7level", &self.popup_message_output_7level())
                .field("popup_message_output_8level", &self.popup_message_output_8level())
            .finish()
        } else {
            f.debug_tuple("Icm412h").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for Icm412h {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let t_outside_input = u.float_in_range(0_f32..=5_f32)?;
        let warning_sound_output_1group = u.int_in_range(0..=1)? == 1;
        let warning_sound_output_2group = u.int_in_range(0..=1)? == 1;
        let warning_sound_output_3group = u.int_in_range(0..=1)? == 1;
        let trip_a_dt_display_clock = u.int_in_range(0..=99)?;
        let trip_a_dt_display_minute = u.int_in_range(0..=59)?;
        let trip_b_dt_display_clock = u.int_in_range(0..=99)?;
        let trip_b_dt_display_minute = u.int_in_range(0..=59)?;
        let popup_message_output_1level = u.int_in_range(0..=1)? == 1;
        let popup_message_output_2level = u.int_in_range(0..=1)? == 1;
        let popup_message_output_3level = u.int_in_range(0..=1)? == 1;
        let popup_message_output_4level = u.int_in_range(0..=1)? == 1;
        let popup_message_output_5level = u.int_in_range(0..=1)? == 1;
        let popup_message_output_6level = u.int_in_range(0..=1)? == 1;
        let popup_message_output_7level = u.int_in_range(0..=1)? == 1;
        let popup_message_output_8level = u.int_in_range(0..=1)? == 1;
        Icm412h::new(t_outside_input,warning_sound_output_1group,warning_sound_output_2group,warning_sound_output_3group,trip_a_dt_display_clock,trip_a_dt_display_minute,trip_b_dt_display_clock,trip_b_dt_display_minute,popup_message_output_1level,popup_message_output_2level,popup_message_output_3level,popup_message_output_4level,popup_message_output_5level,popup_message_output_6level,popup_message_output_7level,popup_message_output_8level).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

/// Navi_HU
///
/// - ID: 1348 (0x544)
/// - Size: 8 bytes
/// - Transmitter: XXX
#[derive(Clone, Copy)]
pub struct NaviHu {
    raw: [u8; 8],
}

impl NaviHu {
    pub const MESSAGE_ID: u32 = 1348;
    
    pub const SPEED_LIM_NAV_CLU_MIN: u8 = 0_u8;
    pub const SPEED_LIM_NAV_CLU_MAX: u8 = 255_u8;
    
    /// Construct new Navi_HU from values
    pub fn new(speed_lim_nav_clu: u8, speed_lim_nav_general: bool, speed_lim_nav_cam: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_speed_lim_nav_clu(speed_lim_nav_clu)?;
        res.set_speed_lim_nav_general(speed_lim_nav_general)?;
        res.set_speed_lim_nav_cam(speed_lim_nav_cam)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// SpeedLim_Nav_Clu
    ///
    /// Speed limit displayed on Nav, Cluster and HUD
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn speed_lim_nav_clu(&self) -> u8 {
        self.speed_lim_nav_clu_raw()
    }
    
    /// Get raw value of SpeedLim_Nav_Clu
    ///
    /// - Start bit: 7
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn speed_lim_nav_clu_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Msb0>()[0..8].load_be::<u8>();
        
        signal
    }
    
    /// Set value of SpeedLim_Nav_Clu
    #[inline(always)]
    pub fn set_speed_lim_nav_clu(&mut self, value: u8) -> Result<(), CanError> {
        #[cfg(feature = "range_checked")]
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: 1348 });
        }
        self.raw.view_bits_mut::<Msb0>()[0..8].store_be(value);
        Ok(())
    }
    
    /// SpeedLim_Nav_General
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn speed_lim_nav_general(&self) -> bool {
        self.speed_lim_nav_general_raw()
    }
    
    /// Get raw value of SpeedLim_Nav_General
    ///
    /// - Start bit: 29
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn speed_lim_nav_general_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[26..27].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of SpeedLim_Nav_General
    #[inline(always)]
    pub fn set_speed_lim_nav_general(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[26..27].store_be(value);
        Ok(())
    }
    
    /// SpeedLim_Nav_Cam
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: XXX
    #[inline(always)]
    pub fn speed_lim_nav_cam(&self) -> bool {
        self.speed_lim_nav_cam_raw()
    }
    
    /// Get raw value of SpeedLim_Nav_Cam
    ///
    /// - Start bit: 30
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn speed_lim_nav_cam_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Msb0>()[25..26].load_be::<u8>();
        
        signal == 1
    }
    
    /// Set value of SpeedLim_Nav_Cam
    #[inline(always)]
    pub fn set_speed_lim_nav_cam(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Msb0>()[25..26].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for NaviHu {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

#[cfg(feature = "debug")]
impl core::fmt::Debug for NaviHu {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        if f.alternate() {
            f.debug_struct("NaviHu")
                .field("speed_lim_nav_clu", &self.speed_lim_nav_clu())
                .field("speed_lim_nav_general", &self.speed_lim_nav_general())
                .field("speed_lim_nav_cam", &self.speed_lim_nav_cam())
            .finish()
        } else {
            f.debug_tuple("NaviHu").field(&self.raw).finish()
        }
    }
}

#[cfg(feature = "arb")]
impl<'a> Arbitrary<'a> for NaviHu {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self, arbitrary::Error> {
        let speed_lim_nav_clu = u.int_in_range(0..=255)?;
        let speed_lim_nav_general = u.int_in_range(0..=1)? == 1;
        let speed_lim_nav_cam = u.int_in_range(0..=1)? == 1;
        NaviHu::new(speed_lim_nav_clu,speed_lim_nav_general,speed_lim_nav_cam).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}


/// This is just to make testing easier
#[allow(dead_code)]
fn main() {}

#[derive(Clone, Copy, PartialEq, Eq)]
#[cfg_attr(any(feature = "debug", feature = "std"), derive(Debug))]
pub enum CanError {
    UnknownMessageId(u32),
    /// Signal parameter is not within the range
    /// defined in the dbc
    ParameterOutOfRange {
        /// dbc message id
        message_id: u32,
    },
    InvalidPayloadSize,
    /// Multiplexor value not defined in the dbc
    InvalidMultiplexor {
        /// dbc message id
        message_id: u32,
        /// Multiplexor value not defined in the dbc
        multiplexor: u16,
    },
}

#[cfg(feature = "std")]
use std::error::Error;
#[cfg(feature = "std")]
use std::fmt;

#[cfg(feature = "std")]
impl fmt::Display for CanError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[cfg(feature = "std")]
impl Error for CanError {}
#[cfg(feature = "arb")]
trait UnstructuredFloatExt {
    fn float_in_range(&mut self, range: core::ops::RangeInclusive<f32>) -> arbitrary::Result<f32>;
}

#[cfg(feature = "arb")]
impl UnstructuredFloatExt for arbitrary::Unstructured<'_> {
    fn float_in_range(&mut self, range: core::ops::RangeInclusive<f32>) -> arbitrary::Result<f32> {
        let min = range.start();
        let max = range.end();
        let steps = u32::MAX;
        let factor = (max - min) / (steps as f32);
        let random_int: u32 = self.int_in_range(0..=steps)?;
        let random = min + factor * (random_int as f32);
        Ok(random)
    }
}

