#![feature(prelude_import)]
#![no_std]
#![no_main]
#![feature(type_alias_impl_trait)]
#![feature(let_chains)]
#![feature(impl_trait_in_assoc_type)]
#[prelude_import]
use core::prelude::rust_2021::*;
#[macro_use]
extern crate core;
extern crate compiler_builtins as _;

extern crate alloc;

use core::{mem::MaybeUninit, panic::PanicInfo};

use defmt::{error, expect, info, unwrap};
#[cfg(not(feature = "defmt-brtt"))]
use defmt_rtt as _;
use embassy_executor::Spawner;
use esp_hal_embassy::main;
use panic_persist::{self as _, get_panic_message_utf8};

mod cap1188 {
    //mod defmt_serial;

    use defmt::{error, info, Format};
    use embedded_hal_async::spi::{Operation, SpiDevice};
    use esp_hal::gpio::InputPin;
    use modular_bitfield::prelude::*;
    #[allow(clippy::identity_op)]
    pub struct Cap1188Inputs {
        bytes: [::core::primitive::u8; {
            ((({
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            } - 1)
                / 8)
                + 1)
                * 8
        } / 8usize],
    }
    #[automatically_derived]
    #[allow(clippy::identity_op)]
    impl ::core::marker::Copy for Cap1188Inputs {}
    #[automatically_derived]
    #[allow(clippy::identity_op)]
    impl ::core::clone::Clone for Cap1188Inputs {
        #[inline]
        fn clone(&self) -> Cap1188Inputs {
            let _: ::core::clone::AssertParamIsClone<
                [::core::primitive::u8; {
                    ((({
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            >;
            *self
        }
    }
    impl defmt::Format for Cap1188Inputs
    where
        [::core::primitive::u8; {
            ((({
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            } - 1)
                / 8)
                + 1)
                * 8
        } / 8usize]: defmt::Format,
    {
        fn format(&self, f: defmt::Formatter) {
            {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::cap1188".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"9573061730447088157\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"9573061730447088157\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                defmt::export::panic()
            }
        }
        fn _format_tag() -> defmt::Str {
            {
                defmt::export::make_istr({
                    #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"Cap1188Inputs {{ bytes: {=?:?} }}\",\"disambiguator\":\"9491893518805946197\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"Cap1188Inputs {{ bytes: {=?:?} }}\",\"disambiguator\":\"9491893518805946197\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                    static S: u8 = 0;
                    &S as *const u8 as u16
                })
            }
        }
        fn _format_data(&self) {
            match self {
                Self { bytes } => {
                    defmt::export::fmt(bytes);
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::identity_op)]
    impl ::core::default::Default for Cap1188Inputs {
        #[inline]
        fn default() -> Cap1188Inputs {
            Cap1188Inputs {
                bytes: ::core::default::Default::default(),
            }
        }
    }
    #[allow(clippy::identity_op)]
    const _: () = {
        impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for Cap1188Inputs {
            type Size = ::modular_bitfield::private::checks::TotalSize<
                [(); {
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } % 8usize],
            >;
        }
    };
    impl Cap1188Inputs {
        /// Returns an instance with zero initialized data.
        #[allow(clippy::identity_op)]
        pub const fn new() -> Self {
            Self {
                bytes: [0u8; {
                    ((({
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            }
        }
    }
    impl Cap1188Inputs {
        /// Returns the underlying bits.
        ///
        /// # Layout
        ///
        /// The returned byte array is layed out in the same way as described
        /// [here](https://docs.rs/modular-bitfield/#generated-structure).
        #[inline]
        #[allow(clippy::identity_op)]
        pub const fn into_bytes(
            self,
        ) -> [::core::primitive::u8; {
               ((({
                   0usize
                       + <bool as ::modular_bitfield::Specifier>::BITS
                       + <bool as ::modular_bitfield::Specifier>::BITS
                       + <bool as ::modular_bitfield::Specifier>::BITS
                       + <bool as ::modular_bitfield::Specifier>::BITS
                       + <bool as ::modular_bitfield::Specifier>::BITS
                       + <bool as ::modular_bitfield::Specifier>::BITS
                       + <bool as ::modular_bitfield::Specifier>::BITS
                       + <bool as ::modular_bitfield::Specifier>::BITS
               } - 1)
                   / 8)
                   + 1)
                   * 8
           } / 8usize] {
            self.bytes
        }
        /// Converts the given bytes directly into the bitfield struct.
        #[inline]
        #[allow(clippy::identity_op)]
        pub const fn from_bytes(
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        ) -> Self {
            Self { bytes }
        }
    }
    const _: () = {
        const _: () = {};
        const _: () = {};
        const _: () = {};
        const _: () = {};
        const _: () = {};
        const _: () = {};
        const _: () = {};
        const _: () = {};
    };
    impl Cap1188Inputs {
        ///Returns the value of b0.
        #[inline]
        pub fn b0(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.b0_or_err()
                .expect("value contains invalid bit pattern for field Cap1188Inputs.b0")
        }
        ///Returns the value of b0.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for b0.
        #[inline]
        #[allow(dead_code)]
        pub fn b0_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes =
                { ::modular_bitfield::private::read_specifier::<bool>(&self.bytes[..], 0usize) };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of b0 set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b0.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b0(mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) -> Self {
            self.set_b0(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of b0 set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b0.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b0_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_b0_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of b0 to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b0.
        #[inline]
        #[allow(dead_code)]
        pub fn set_b0(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
            self.set_b0_checked(new_val)
                .expect("value out of bounds for field Cap1188Inputs.b0")
        }
        ///Sets the value of b0 to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b0.
        #[inline]
        pub fn set_b0_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
        ///Returns the value of b1.
        #[inline]
        pub fn b1(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.b1_or_err()
                .expect("value contains invalid bit pattern for field Cap1188Inputs.b1")
        }
        ///Returns the value of b1.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for b1.
        #[inline]
        #[allow(dead_code)]
        pub fn b1_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                ::modular_bitfield::private::read_specifier::<bool>(
                    &self.bytes[..],
                    0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                )
            };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of b1 set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b1.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b1(mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) -> Self {
            self.set_b1(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of b1 set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b1.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b1_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_b1_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of b1 to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b1.
        #[inline]
        #[allow(dead_code)]
        pub fn set_b1(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
            self.set_b1_checked(new_val)
                .expect("value out of bounds for field Cap1188Inputs.b1")
        }
        ///Sets the value of b1 to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b1.
        #[inline]
        pub fn set_b1_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
        ///Returns the value of b2.
        #[inline]
        pub fn b2(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.b2_or_err()
                .expect("value contains invalid bit pattern for field Cap1188Inputs.b2")
        }
        ///Returns the value of b2.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for b2.
        #[inline]
        #[allow(dead_code)]
        pub fn b2_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                ::modular_bitfield::private::read_specifier::<bool>(
                    &self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                )
            };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of b2 set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b2.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b2(mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) -> Self {
            self.set_b2(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of b2 set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b2.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b2_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_b2_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of b2 to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b2.
        #[inline]
        #[allow(dead_code)]
        pub fn set_b2(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
            self.set_b2_checked(new_val)
                .expect("value out of bounds for field Cap1188Inputs.b2")
        }
        ///Sets the value of b2 to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b2.
        #[inline]
        pub fn set_b2_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
        ///Returns the value of b3.
        #[inline]
        pub fn b3(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.b3_or_err()
                .expect("value contains invalid bit pattern for field Cap1188Inputs.b3")
        }
        ///Returns the value of b3.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for b3.
        #[inline]
        #[allow(dead_code)]
        pub fn b3_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                ::modular_bitfield::private::read_specifier::<bool>(
                    &self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                )
            };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of b3 set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b3.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b3(mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) -> Self {
            self.set_b3(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of b3 set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b3.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b3_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_b3_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of b3 to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b3.
        #[inline]
        #[allow(dead_code)]
        pub fn set_b3(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
            self.set_b3_checked(new_val)
                .expect("value out of bounds for field Cap1188Inputs.b3")
        }
        ///Sets the value of b3 to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b3.
        #[inline]
        pub fn set_b3_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
        ///Returns the value of b4.
        #[inline]
        pub fn b4(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.b4_or_err()
                .expect("value contains invalid bit pattern for field Cap1188Inputs.b4")
        }
        ///Returns the value of b4.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for b4.
        #[inline]
        #[allow(dead_code)]
        pub fn b4_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                ::modular_bitfield::private::read_specifier::<bool>(
                    &self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                )
            };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of b4 set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b4.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b4(mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) -> Self {
            self.set_b4(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of b4 set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b4.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b4_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_b4_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of b4 to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b4.
        #[inline]
        #[allow(dead_code)]
        pub fn set_b4(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
            self.set_b4_checked(new_val)
                .expect("value out of bounds for field Cap1188Inputs.b4")
        }
        ///Sets the value of b4 to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b4.
        #[inline]
        pub fn set_b4_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
        ///Returns the value of b5.
        #[inline]
        pub fn b5(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.b5_or_err()
                .expect("value contains invalid bit pattern for field Cap1188Inputs.b5")
        }
        ///Returns the value of b5.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for b5.
        #[inline]
        #[allow(dead_code)]
        pub fn b5_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                ::modular_bitfield::private::read_specifier::<bool>(
                    &self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                )
            };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of b5 set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b5.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b5(mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) -> Self {
            self.set_b5(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of b5 set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b5.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b5_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_b5_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of b5 to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b5.
        #[inline]
        #[allow(dead_code)]
        pub fn set_b5(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
            self.set_b5_checked(new_val)
                .expect("value out of bounds for field Cap1188Inputs.b5")
        }
        ///Sets the value of b5 to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b5.
        #[inline]
        pub fn set_b5_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
        ///Returns the value of b6.
        #[inline]
        pub fn b6(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.b6_or_err()
                .expect("value contains invalid bit pattern for field Cap1188Inputs.b6")
        }
        ///Returns the value of b6.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for b6.
        #[inline]
        #[allow(dead_code)]
        pub fn b6_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                ::modular_bitfield::private::read_specifier::<bool>(
                    &self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                )
            };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of b6 set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b6.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b6(mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) -> Self {
            self.set_b6(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of b6 set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b6.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b6_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_b6_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of b6 to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b6.
        #[inline]
        #[allow(dead_code)]
        pub fn set_b6(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
            self.set_b6_checked(new_val)
                .expect("value out of bounds for field Cap1188Inputs.b6")
        }
        ///Sets the value of b6 to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b6.
        #[inline]
        pub fn set_b6_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
        ///Returns the value of b7.
        #[inline]
        pub fn b7(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.b7_or_err()
                .expect("value contains invalid bit pattern for field Cap1188Inputs.b7")
        }
        ///Returns the value of b7.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for b7.
        #[inline]
        #[allow(dead_code)]
        pub fn b7_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                ::modular_bitfield::private::read_specifier::<bool>(
                    &self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                )
            };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of b7 set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b7.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b7(mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) -> Self {
            self.set_b7(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of b7 set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b7.
        #[inline]
        #[allow(dead_code)]
        pub fn with_b7_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_b7_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of b7 to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b7.
        #[inline]
        #[allow(dead_code)]
        pub fn set_b7(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
            self.set_b7_checked(new_val)
                .expect("value out of bounds for field Cap1188Inputs.b7")
        }
        ///Sets the value of b7 to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b7.
        #[inline]
        pub fn set_b7_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
    }
    impl ::core::convert::From<::core::primitive::u8> for Cap1188Inputs
    where
        [(); {
            0usize
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
        }]: ::modular_bitfield::private::IsU8Compatible,
    {
        #[inline]
        fn from(__bf_prim: ::core::primitive::u8) -> Self {
            Self {
                bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
            }
        }
    }
    impl ::core::convert::From<Cap1188Inputs> for ::core::primitive::u8
    where
        [(); {
            0usize
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
        }]: ::modular_bitfield::private::IsU8Compatible,
    {
        #[inline]
        fn from(__bf_bitfield: Cap1188Inputs) -> Self {
            <Self>::from_le_bytes(__bf_bitfield.bytes)
        }
    }
    impl ::core::fmt::Debug for Cap1188Inputs {
        fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            __bf_f
                .debug_struct("Cap1188Inputs")
                .field(
                    "b0",
                    self.b0_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .field(
                    "b1",
                    self.b1_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .field(
                    "b2",
                    self.b2_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .field(
                    "b3",
                    self.b3_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .field(
                    "b4",
                    self.b4_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .field(
                    "b5",
                    self.b5_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .field(
                    "b6",
                    self.b6_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .field(
                    "b7",
                    self.b7_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .finish()
        }
    }
    #[allow(clippy::identity_op)]
    pub struct Cap1188Configuration1 {
        bytes: [::core::primitive::u8; {
            ((({
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            } - 1)
                / 8)
                + 1)
                * 8
        } / 8usize],
    }
    #[automatically_derived]
    #[allow(clippy::identity_op)]
    impl ::core::marker::Copy for Cap1188Configuration1 {}
    #[automatically_derived]
    #[allow(clippy::identity_op)]
    impl ::core::clone::Clone for Cap1188Configuration1 {
        #[inline]
        fn clone(&self) -> Cap1188Configuration1 {
            let _: ::core::clone::AssertParamIsClone<
                [::core::primitive::u8; {
                    ((({
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            >;
            *self
        }
    }
    impl defmt::Format for Cap1188Configuration1
    where
        [::core::primitive::u8; {
            ((({
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            } - 1)
                / 8)
                + 1)
                * 8
        } / 8usize]: defmt::Format,
    {
        fn format(&self, f: defmt::Formatter) {
            {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::cap1188".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"17738684919975116684\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"17738684919975116684\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                defmt::export::panic()
            }
        }
        fn _format_tag() -> defmt::Str {
            {
                defmt::export::make_istr({
                    #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"Cap1188Configuration1 {{ bytes: {=?:?} }}\",\"disambiguator\":\"18066602191804251074\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"Cap1188Configuration1 {{ bytes: {=?:?} }}\",\"disambiguator\":\"18066602191804251074\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                    static S: u8 = 0;
                    &S as *const u8 as u16
                })
            }
        }
        fn _format_data(&self) {
            match self {
                Self { bytes } => {
                    defmt::export::fmt(bytes);
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(clippy::identity_op)]
    impl ::core::default::Default for Cap1188Configuration1 {
        #[inline]
        fn default() -> Cap1188Configuration1 {
            Cap1188Configuration1 {
                bytes: ::core::default::Default::default(),
            }
        }
    }
    #[allow(clippy::identity_op)]
    const _: () = {
        impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for Cap1188Configuration1 {
            type Size = ::modular_bitfield::private::checks::TotalSize<
                [(); {
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } % 8usize],
            >;
        }
    };
    impl Cap1188Configuration1 {
        /// Returns an instance with zero initialized data.
        #[allow(clippy::identity_op)]
        pub const fn new() -> Self {
            Self {
                bytes: [0u8; {
                    ((({
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            }
        }
    }
    impl Cap1188Configuration1 {
        /// Returns the underlying bits.
        ///
        /// # Layout
        ///
        /// The returned byte array is layed out in the same way as described
        /// [here](https://docs.rs/modular-bitfield/#generated-structure).
        #[inline]
        #[allow(clippy::identity_op)]
        pub const fn into_bytes(
            self,
        ) -> [::core::primitive::u8; {
               ((({
                   0usize
                       + <bool as ::modular_bitfield::Specifier>::BITS
                       + <bool as ::modular_bitfield::Specifier>::BITS
                       + <bool as ::modular_bitfield::Specifier>::BITS
                       + <bool as ::modular_bitfield::Specifier>::BITS
                       + <bool as ::modular_bitfield::Specifier>::BITS
                       + <bool as ::modular_bitfield::Specifier>::BITS
                       + <bool as ::modular_bitfield::Specifier>::BITS
                       + <bool as ::modular_bitfield::Specifier>::BITS
               } - 1)
                   / 8)
                   + 1)
                   * 8
           } / 8usize] {
            self.bytes
        }
        /// Converts the given bytes directly into the bitfield struct.
        #[inline]
        #[allow(clippy::identity_op)]
        pub const fn from_bytes(
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        ) -> Self {
            Self { bytes }
        }
    }
    const _: () = {
        const _: () = {};
        const _: () = {};
        const _: () = {};
        const _: () = {};
        const _: () = {};
        const _: () = {};
        const _: () = {};
        const _: () = {};
    };
    impl Cap1188Configuration1 {
        ///Returns the value of b0.
        #[inline]
        fn b0(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.b0_or_err()
                .expect("value contains invalid bit pattern for field Cap1188Configuration1.b0")
        }
        ///Returns the value of b0.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for b0.
        #[inline]
        #[allow(dead_code)]
        fn b0_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes =
                { ::modular_bitfield::private::read_specifier::<bool>(&self.bytes[..], 0usize) };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of b0 set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b0.
        #[inline]
        #[allow(dead_code)]
        fn with_b0(mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) -> Self {
            self.set_b0(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of b0 set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b0.
        #[inline]
        #[allow(dead_code)]
        fn with_b0_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_b0_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of b0 to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b0.
        #[inline]
        #[allow(dead_code)]
        fn set_b0(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
            self.set_b0_checked(new_val)
                .expect("value out of bounds for field Cap1188Configuration1.b0")
        }
        ///Sets the value of b0 to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b0.
        #[inline]
        fn set_b0_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
        ///Returns the value of b1.
        #[inline]
        fn b1(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.b1_or_err()
                .expect("value contains invalid bit pattern for field Cap1188Configuration1.b1")
        }
        ///Returns the value of b1.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for b1.
        #[inline]
        #[allow(dead_code)]
        fn b1_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                ::modular_bitfield::private::read_specifier::<bool>(
                    &self.bytes[..],
                    0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                )
            };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of b1 set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b1.
        #[inline]
        #[allow(dead_code)]
        fn with_b1(mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) -> Self {
            self.set_b1(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of b1 set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b1.
        #[inline]
        #[allow(dead_code)]
        fn with_b1_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_b1_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of b1 to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b1.
        #[inline]
        #[allow(dead_code)]
        fn set_b1(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
            self.set_b1_checked(new_val)
                .expect("value out of bounds for field Cap1188Configuration1.b1")
        }
        ///Sets the value of b1 to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b1.
        #[inline]
        fn set_b1_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
        ///Returns the value of b2.
        #[inline]
        fn b2(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.b2_or_err()
                .expect("value contains invalid bit pattern for field Cap1188Configuration1.b2")
        }
        ///Returns the value of b2.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for b2.
        #[inline]
        #[allow(dead_code)]
        fn b2_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                ::modular_bitfield::private::read_specifier::<bool>(
                    &self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                )
            };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of b2 set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b2.
        #[inline]
        #[allow(dead_code)]
        fn with_b2(mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) -> Self {
            self.set_b2(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of b2 set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b2.
        #[inline]
        #[allow(dead_code)]
        fn with_b2_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_b2_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of b2 to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for b2.
        #[inline]
        #[allow(dead_code)]
        fn set_b2(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
            self.set_b2_checked(new_val)
                .expect("value out of bounds for field Cap1188Configuration1.b2")
        }
        ///Sets the value of b2 to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for b2.
        #[inline]
        fn set_b2_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
        ///Returns the value of max_dur_en.
        #[inline]
        pub fn max_dur_en(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.max_dur_en_or_err().expect(
                "value contains invalid bit pattern for field Cap1188Configuration1.max_dur_en",
            )
        }
        ///Returns the value of max_dur_en.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for max_dur_en.
        #[inline]
        #[allow(dead_code)]
        pub fn max_dur_en_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                ::modular_bitfield::private::read_specifier::<bool>(
                    &self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                )
            };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of max_dur_en set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for max_dur_en.
        #[inline]
        #[allow(dead_code)]
        pub fn with_max_dur_en(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> Self {
            self.set_max_dur_en(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of max_dur_en set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for max_dur_en.
        #[inline]
        #[allow(dead_code)]
        pub fn with_max_dur_en_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_max_dur_en_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of max_dur_en to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for max_dur_en.
        #[inline]
        #[allow(dead_code)]
        pub fn set_max_dur_en(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
            self.set_max_dur_en_checked(new_val)
                .expect("value out of bounds for field Cap1188Configuration1.max_dur_en")
        }
        ///Sets the value of max_dur_en to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for max_dur_en.
        #[inline]
        pub fn set_max_dur_en_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
        ///Returns the value of dis_ana_noise.
        #[inline]
        pub fn dis_ana_noise(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.dis_ana_noise_or_err().expect(
                "value contains invalid bit pattern for field Cap1188Configuration1.dis_ana_noise",
            )
        }
        ///Returns the value of dis_ana_noise.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for dis_ana_noise.
        #[inline]
        #[allow(dead_code)]
        pub fn dis_ana_noise_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                ::modular_bitfield::private::read_specifier::<bool>(
                    &self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                )
            };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of dis_ana_noise set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for dis_ana_noise.
        #[inline]
        #[allow(dead_code)]
        pub fn with_dis_ana_noise(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> Self {
            self.set_dis_ana_noise(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of dis_ana_noise set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for dis_ana_noise.
        #[inline]
        #[allow(dead_code)]
        pub fn with_dis_ana_noise_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_dis_ana_noise_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of dis_ana_noise to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for dis_ana_noise.
        #[inline]
        #[allow(dead_code)]
        pub fn set_dis_ana_noise(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) {
            self.set_dis_ana_noise_checked(new_val)
                .expect("value out of bounds for field Cap1188Configuration1.dis_ana_noise")
        }
        ///Sets the value of dis_ana_noise to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for dis_ana_noise.
        #[inline]
        pub fn set_dis_ana_noise_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
        ///Returns the value of dis_dig_noise.
        #[inline]
        pub fn dis_dig_noise(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.dis_dig_noise_or_err().expect(
                "value contains invalid bit pattern for field Cap1188Configuration1.dis_dig_noise",
            )
        }
        ///Returns the value of dis_dig_noise.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for dis_dig_noise.
        #[inline]
        #[allow(dead_code)]
        pub fn dis_dig_noise_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                ::modular_bitfield::private::read_specifier::<bool>(
                    &self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                )
            };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of dis_dig_noise set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for dis_dig_noise.
        #[inline]
        #[allow(dead_code)]
        pub fn with_dis_dig_noise(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> Self {
            self.set_dis_dig_noise(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of dis_dig_noise set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for dis_dig_noise.
        #[inline]
        #[allow(dead_code)]
        pub fn with_dis_dig_noise_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_dis_dig_noise_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of dis_dig_noise to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for dis_dig_noise.
        #[inline]
        #[allow(dead_code)]
        pub fn set_dis_dig_noise(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) {
            self.set_dis_dig_noise_checked(new_val)
                .expect("value out of bounds for field Cap1188Configuration1.dis_dig_noise")
        }
        ///Sets the value of dis_dig_noise to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for dis_dig_noise.
        #[inline]
        pub fn set_dis_dig_noise_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
        ///Returns the value of wake_cfg.
        #[inline]
        pub fn wake_cfg(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.wake_cfg_or_err().expect(
                "value contains invalid bit pattern for field Cap1188Configuration1.wake_cfg",
            )
        }
        ///Returns the value of wake_cfg.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for wake_cfg.
        #[inline]
        #[allow(dead_code)]
        pub fn wake_cfg_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                ::modular_bitfield::private::read_specifier::<bool>(
                    &self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                )
            };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of wake_cfg set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for wake_cfg.
        #[inline]
        #[allow(dead_code)]
        pub fn with_wake_cfg(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> Self {
            self.set_wake_cfg(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of wake_cfg set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for wake_cfg.
        #[inline]
        #[allow(dead_code)]
        pub fn with_wake_cfg_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_wake_cfg_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of wake_cfg to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for wake_cfg.
        #[inline]
        #[allow(dead_code)]
        pub fn set_wake_cfg(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
            self.set_wake_cfg_checked(new_val)
                .expect("value out of bounds for field Cap1188Configuration1.wake_cfg")
        }
        ///Sets the value of wake_cfg to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for wake_cfg.
        #[inline]
        pub fn set_wake_cfg_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
        ///Returns the value of smb_timeout.
        #[inline]
        pub fn smb_timeout(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
            self.smb_timeout_or_err().expect(
                "value contains invalid bit pattern for field Cap1188Configuration1.smb_timeout",
            )
        }
        ///Returns the value of smb_timeout.
        ///
        ///#Errors
        ///
        ///If the returned value contains an invalid bit pattern for smb_timeout.
        #[inline]
        #[allow(dead_code)]
        pub fn smb_timeout_or_err(
            &self,
        ) -> ::core::result::Result<
            <bool as ::modular_bitfield::Specifier>::InOut,
            ::modular_bitfield::error::InvalidBitPattern<
                <bool as ::modular_bitfield::Specifier>::Bytes,
            >,
        > {
            let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                ::modular_bitfield::private::read_specifier::<bool>(
                    &self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                )
            };
            <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
        }
        ///Returns a copy of the bitfield with the value of smb_timeout set to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for smb_timeout.
        #[inline]
        #[allow(dead_code)]
        pub fn with_smb_timeout(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> Self {
            self.set_smb_timeout(new_val);
            self
        }
        ///Returns a copy of the bitfield with the value of smb_timeout set to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for smb_timeout.
        #[inline]
        #[allow(dead_code)]
        pub fn with_smb_timeout_checked(
            mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
            self.set_smb_timeout_checked(new_val)?;
            ::core::result::Result::Ok(self)
        }
        ///Sets the value of smb_timeout to the given value.
        ///
        ///#Panics
        ///
        ///If the given value is out of bounds for smb_timeout.
        #[inline]
        #[allow(dead_code)]
        pub fn set_smb_timeout(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
            self.set_smb_timeout_checked(new_val)
                .expect("value out of bounds for field Cap1188Configuration1.smb_timeout")
        }
        ///Sets the value of smb_timeout to the given value.
        ///
        ///#Errors
        ///
        ///If the given value is out of bounds for smb_timeout.
        #[inline]
        pub fn set_smb_timeout_checked(
            &mut self,
            new_val: <bool as ::modular_bitfield::Specifier>::InOut,
        ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
            let __bf_base_bits: ::core::primitive::usize =
                8usize * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
            let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
            let __bf_spec_bits: ::core::primitive::usize =
                <bool as ::modular_bitfield::Specifier>::BITS;
            let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
            if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
            }
            ::modular_bitfield::private::write_specifier::<bool>(
                &mut self.bytes[..],
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS,
                __bf_raw_val,
            );
            ::core::result::Result::Ok(())
        }
    }
    impl ::core::convert::From<::core::primitive::u8> for Cap1188Configuration1
    where
        [(); {
            0usize
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
        }]: ::modular_bitfield::private::IsU8Compatible,
    {
        #[inline]
        fn from(__bf_prim: ::core::primitive::u8) -> Self {
            Self {
                bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
            }
        }
    }
    impl ::core::convert::From<Cap1188Configuration1> for ::core::primitive::u8
    where
        [(); {
            0usize
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
                + <bool as ::modular_bitfield::Specifier>::BITS
        }]: ::modular_bitfield::private::IsU8Compatible,
    {
        #[inline]
        fn from(__bf_bitfield: Cap1188Configuration1) -> Self {
            <Self>::from_le_bytes(__bf_bitfield.bytes)
        }
    }
    impl ::core::fmt::Debug for Cap1188Configuration1 {
        fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            __bf_f
                .debug_struct("Cap1188Configuration1")
                .field(
                    "b0",
                    self.b0_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .field(
                    "b1",
                    self.b1_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .field(
                    "b2",
                    self.b2_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .field(
                    "max_dur_en",
                    self.max_dur_en_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .field(
                    "dis_ana_noise",
                    self.dis_ana_noise_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .field(
                    "dis_dig_noise",
                    self.dis_dig_noise_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .field(
                    "wake_cfg",
                    self.wake_cfg_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .field(
                    "smb_timeout",
                    self.smb_timeout_or_err()
                        .as_ref()
                        .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                        .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                )
                .finish()
        }
    }
    pub struct Cap1188<SPI, INT> {
        spi: SPI,
        int: INT,
    }
    ///< The Sensor Input Status Register stores status bits that indicate a
    ///< touch has been detected. A value of ‘0’ in any bit indicates that no
    ///< touch has been detected. A value of ‘1’ in any bit indicates that a
    ///< touch has been detected.
    const CAP1188_SENINPUTSTATUS: u8 = 0x3;
    ///< multiple touch detection circuitry. These settings determine the
    ///< number of simultaneous buttons that may be pressed before additional
    ///< buttons are blocked and the MULT status bit is set. [0/1]
    const CAP1188_MTBLK: u8 = 0x2A;
    const CAP1188_LEDLINK: u8 = 0x72;
    const CAP1188_PRODID: u8 = 0xFD;
    const CAP1188_MANUID: u8 = 0xFE;
    const CAP1188_STANDBYCFG: u8 = 0x41;
    const CAP1188_REV: u8 = 0xFF;
    const CAP1188_MAIN: u8 = 0x00;
    const CAP1188_MAIN_INT: u8 = 0x01;
    const CAP1188_LEDPOL: u8 = 0x73;
    const CAP1188_CONFIGURATION_1: u8 = 0x20;
    const CAP1188_CALIBRATION_ACTIVE: u8 = 0x26;
    impl<SPI, INT> Cap1188<SPI, INT>
    where
        SPI: SpiDevice<u8>,
        INT: embedded_hal_async::digital::Wait,
    {
        pub fn new(spi: SPI, int: INT) -> Self {
            Self { spi, int }
        }
        pub async fn init(&mut self) -> Result<bool, SPI::Error> {
            let mut prod_id = [0; 3];
            self.read_register(CAP1188_PRODID, &mut prod_id).await?;
            if prod_id[0] != 0x50 {
                match (&(prod_id[0])) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::cap1188".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe {
                                defmt::export::acquire_and_header(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"cap1188.rs: Invalid Product ID {}\",\"disambiguator\":\"5623801629620658225\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"cap1188.rs: Invalid Product ID {}\",\"disambiguator\":\"5623801629620658225\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            };
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                return Ok(false);
            }
            if prod_id[1] != 0x5d {
                match (&(prod_id[1])) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::cap1188".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe {
                                defmt::export::acquire_and_header(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"cap1188.rs: Invalid Manufacturer {}\",\"disambiguator\":\"9245390072804166930\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"cap1188.rs: Invalid Manufacturer {}\",\"disambiguator\":\"9245390072804166930\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            };
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                return Ok(false);
            }
            if prod_id[2] != 0x83 {
                match (&(prod_id[2])) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::cap1188".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe {
                                defmt::export::acquire_and_header(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"cap1188.rs: Revision {}\",\"disambiguator\":\"2898513293402396027\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"cap1188.rs: Revision {}\",\"disambiguator\":\"2898513293402396027\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            };
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                return Ok(false);
            }
            self.write_register(CAP1188_MTBLK, &[0]).await?;
            self.write_register(CAP1188_LEDLINK, &[0xFF]).await?;
            self.write_register(CAP1188_STANDBYCFG, &[0x30]).await?;
            self.write_register(CAP1188_MAIN, &[0b1000_0000]).await?;
            self.write_register(
                CAP1188_CONFIGURATION_1,
                &Cap1188Configuration1::from_bytes([0x20])
                    .with_dis_ana_noise(true)
                    .into_bytes(),
            )
            .await?;
            Ok(true)
        }
        pub async fn touched(&mut self) -> Result<Cap1188Inputs, SPI::Error> {
            let mut touched = [0; 1];
            self.read_register(CAP1188_SENINPUTSTATUS, &mut touched)
                .await?;
            if touched[0] != 0 {
                let mut main = [0; 1];
                self.read_register(CAP1188_MAIN, &mut main).await?;
                self.write_register(CAP1188_MAIN, &[main[0] & !CAP1188_MAIN_INT])
                    .await?;
            }
            Ok(Cap1188Inputs::from_bytes(touched))
        }
        async fn read_register(&mut self, reg: u8, out_buf: &mut [u8]) -> Result<(), SPI::Error> {
            let init_buf = [0x7d, reg, 0x7f];
            out_buf.fill(0x7F);
            self.spi
                .transaction(&mut [
                    Operation::Write(&init_buf),
                    Operation::TransferInPlace(out_buf),
                ])
                .await
        }
        async fn write_register(&mut self, reg: u8, in_buf: &[u8]) -> Result<(), SPI::Error> {
            let init_buf = [0x7d, reg, 0x7E, in_buf[0]];
            self.spi
                .transaction(&mut [Operation::Write(&init_buf)])
                .await
        }
        pub async fn reset(&mut self) -> Result<(), SPI::Error> {
            let mut buffer = [0; 2];
            buffer[0] = 0x7a;
            buffer[1] = 0x7a;
            self.spi.transaction(&mut [Operation::Write(&buffer)]).await
        }
        pub async fn shutdown(&mut self) -> Result<(), SPI::Error> {
            self.write_register(CAP1188_MAIN, &[0b0011_0000]).await
        }
        pub async fn wait_for_touched(&mut self) {
            self.int.wait_for_low().await.ok();
        }
        pub async fn wait_for_released(&mut self) {
            self.int.wait_for_any_edge().await.ok();
        }
        pub async fn calibrate(&mut self) -> Result<(), SPI::Error> {
            self.write_register(CAP1188_CALIBRATION_ACTIVE, &[0xFF])
                .await?;
            loop {
                let mut out_buf = [0; 1];
                self.read_register(CAP1188_CALIBRATION_ACTIVE, &mut out_buf)
                    .await?;
                if out_buf[0] == 0 {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "kia_obd2_esp32c3_v2::cap1188".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"calibration done\",\"disambiguator\":\"12092243206662880581\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"calibration done\",\"disambiguator\":\"12092243206662880581\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    break;
                }
            }
            Ok(())
        }
    }
}
mod debug {
    use defmt::*;
    use embassy_sync::{
        blocking_mutex::raw::CriticalSectionRawMutex,
        channel::{Channel, TrySendError},
    };
    use heapless::String;
    pub const DEBUG_STRING_LEN: usize = 120;
    pub const DEBUG_CHANNEL_LEN: usize = 16;
    static DEBUG_CHANNEL: Channel<
        CriticalSectionRawMutex,
        String<DEBUG_STRING_LEN>,
        DEBUG_CHANNEL_LEN,
    > = Channel::new();
    pub fn debug(string: String<DEBUG_STRING_LEN>) {
        if let Err(TrySendError::Full(string)) = DEBUG_CHANNEL.try_send(string) {
            let _ = DEBUG_CHANNEL.try_receive();
            DEBUG_CHANNEL.try_send(string).ok();
        }
    }
    macro_rules! internal_debug {
        ($($arg:tt)*) =>
        {
            {
                use heapless::String as InternalDebugString; use
                core::fmt::Write as _; let mut string =
                InternalDebugString::new();
                core::write!(&mut string, "{:.1}: ",
                embassy_time::Instant::from_ticks(0).elapsed().as_millis() as
                f64 / 1000.0).ok(); core::write!(&mut string, $($arg)*).ok();
                crate::debug::debug(string);
            }
        }; () => {};
    }
    pub async fn receive() -> String<DEBUG_STRING_LEN> {
        DEBUG_CHANNEL.receive().await
    }
    pub(crate) use internal_debug;
}
mod display {
    use embedded_graphics::{prelude::*, primitives::Rectangle};
    pub mod widgets {
        mod arrow {
            use core::fmt::Write;
            use defmt::info;
            use display_interface::DisplayError;
            use embedded_graphics::{
                draw_target::Clipped,
                mono_font::{
                    ascii::{FONT_10X20, FONT_6X10, FONT_6X13_BOLD, FONT_9X15_BOLD},
                    MonoTextStyle,
                },
                pixelcolor::Gray4,
                prelude::*,
                primitives::*,
                text::{Alignment, LineHeight, Text, TextStyleBuilder},
            };
            use heapless::String;
            use num_traits::float::FloatCore;
            use profont::*;
            pub enum ArrowDirection {
                #[default]
                Forward,
                Reverse,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ArrowDirection {
                #[inline]
                fn clone(&self) -> ArrowDirection {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ArrowDirection {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ArrowDirection {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ArrowDirection {
                #[inline]
                fn eq(&self, other: &ArrowDirection) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for ArrowDirection {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::default::Default for ArrowDirection {
                #[inline]
                fn default() -> ArrowDirection {
                    Self::Forward
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ArrowDirection {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            ArrowDirection::Forward => "Forward",
                            ArrowDirection::Reverse => "Reverse",
                        },
                    )
                }
            }
            pub struct Arrow {
                size: Size,
                position: Point,
                arrow_width: u32,
                offset: f64,
                old_offest: i32,
                force_update: bool,
                color: u8,
                speed: f64,
                direction: ArrowDirection,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Arrow {
                #[inline]
                fn clone(&self) -> Arrow {
                    let _: ::core::clone::AssertParamIsClone<Size>;
                    let _: ::core::clone::AssertParamIsClone<Point>;
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    let _: ::core::clone::AssertParamIsClone<f64>;
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    let _: ::core::clone::AssertParamIsClone<bool>;
                    let _: ::core::clone::AssertParamIsClone<u8>;
                    let _: ::core::clone::AssertParamIsClone<ArrowDirection>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Arrow {}
            #[automatically_derived]
            impl ::core::fmt::Debug for Arrow {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "size",
                        "position",
                        "arrow_width",
                        "offset",
                        "old_offest",
                        "force_update",
                        "color",
                        "speed",
                        "direction",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.size,
                        &self.position,
                        &self.arrow_width,
                        &self.offset,
                        &self.old_offest,
                        &self.force_update,
                        &self.color,
                        &self.speed,
                        &&self.direction,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(f, "Arrow", names, values)
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for Arrow {
                #[inline]
                fn default() -> Arrow {
                    Arrow {
                        size: ::core::default::Default::default(),
                        position: ::core::default::Default::default(),
                        arrow_width: ::core::default::Default::default(),
                        offset: ::core::default::Default::default(),
                        old_offest: ::core::default::Default::default(),
                        force_update: ::core::default::Default::default(),
                        color: ::core::default::Default::default(),
                        speed: ::core::default::Default::default(),
                        direction: ::core::default::Default::default(),
                    }
                }
            }
            impl Arrow {
                pub fn new(
                    position: Point,
                    size: Size,
                    arrow_width: u32,
                    direction: ArrowDirection,
                ) -> Self {
                    Self {
                        position,
                        size,
                        arrow_width,
                        old_offest: i32::MAX,
                        force_update: true,
                        color: 0,
                        offset: 0.0,
                        speed: 0.0,
                        direction,
                    }
                }
                pub fn update_direction(&mut self, direction: ArrowDirection) {
                    if self.direction != direction {
                        self.direction = direction;
                        self.force_update = true;
                    }
                }
                pub fn update_speed(&mut self, speed: f64) {
                    let old_speed = self.speed;
                    if speed > 0.0 {
                        self.speed = speed / 100.0 * 3.5 + 1.0;
                    } else {
                        self.speed = 0.0;
                    }
                    self.color = (speed / 100.0 * 16.0).round() as u8;
                    if speed != 0.0 && self.color == 0 {
                        self.color = 1;
                    }
                    if speed != old_speed {
                        self.force_update = true;
                    }
                    if self.color > 15 {
                        self.color = 15;
                    }
                    if self.speed > 4.5 {
                        self.speed = 4.5;
                    }
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if self.offset >= self.arrow_width as f64 {
                        self.offset = self.speed;
                    }
                    let new_offest = self.offset.ceil() as i32;
                    if new_offest != self.old_offest || self.force_update {
                        let mut size = self.size;
                        size.height += 1;
                        let style_black = PrimitiveStyleBuilder::new()
                            .stroke_width(2)
                            .stroke_color(Gray4::BLACK)
                            .fill_color(Gray4::BLACK)
                            .build();
                        let area = Rectangle::new(self.position, size);
                        area.draw_styled(&style_black, target)?;
                        let mut area = target.clipped(&area);
                        let style = PrimitiveStyleBuilder::new()
                            .stroke_width(2)
                            .stroke_color(Gray4::new(self.color))
                            .fill_color(Gray4::new(self.color))
                            .build();
                        let triangle_offset = match self.direction {
                            ArrowDirection::Forward => -1,
                            ArrowDirection::Reverse => 1,
                        };
                        let triangle = Triangle::new(
                            Point::new(self.position.x, self.position.y),
                            Point::new(
                                self.position.x - (self.arrow_width as i32 - 6) * triangle_offset,
                                self.position.y + self.size.height as i32 / 2,
                            ),
                            Point::new(self.position.x, self.position.y + self.size.height as i32),
                        )
                        .translate(Point::new(-(triangle_offset * new_offest), 0));
                        if self.direction == ArrowDirection::Forward {
                            for a in (-1..(self.size.width / self.arrow_width) as i32 + 2).rev() {
                                self.draw_triangle(
                                    &mut area,
                                    &style,
                                    &style_black,
                                    triangle,
                                    triangle_offset,
                                    a,
                                )?;
                            }
                        } else {
                            for a in 0..(self.size.width / self.arrow_width) as i32 + 4 {
                                self.draw_triangle(
                                    &mut area,
                                    &style,
                                    &style_black,
                                    triangle,
                                    triangle_offset,
                                    a,
                                )?;
                            }
                        }
                        self.old_offest = new_offest;
                        self.force_update = false;
                    }
                    self.offset += self.speed;
                    Ok(())
                }
                fn draw_triangle<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    area: &mut Clipped<D>,
                    style: &PrimitiveStyle<Gray4>,
                    style_black: &PrimitiveStyle<Gray4>,
                    triangle: Triangle,
                    triangle_offset: i32,
                    a: i32,
                ) -> Result<(), D::Error> {
                    let triangle_a = triangle.translate(Point::new(
                        (self.arrow_width as f64 / 1.2).ceil() as i32 * a,
                        0,
                    ));
                    triangle_a.draw_styled(style, area)?;
                    triangle_a
                        .translate(Point::new(
                            triangle_offset * (self.arrow_width as i32 / 3),
                            0,
                        ))
                        .draw_styled(style_black, area)?;
                    Ok(())
                }
            }
        }
        mod battery {
            use core::fmt::Write;
            use display_interface::DisplayError;
            use embedded_graphics::{
                mono_font::{
                    ascii::{FONT_10X20, FONT_6X10, FONT_6X13_BOLD, FONT_9X15_BOLD},
                    MonoTextStyle,
                },
                pixelcolor::Gray4,
                prelude::*,
                primitives::*,
                text::{Alignment, LineHeight, Text, TextStyleBuilder},
            };
            use heapless::String;
            use num_traits::float::FloatCore;
            use profont::*;
            pub enum BatteryOrientation {
                #[default]
                VerticalTop,
                VerticalDown,
                HorizontalLeft,
                HorizontalRight,
            }
            #[automatically_derived]
            impl ::core::default::Default for BatteryOrientation {
                #[inline]
                fn default() -> BatteryOrientation {
                    Self::VerticalTop
                }
            }
            pub struct Battery {
                min_temp: f32,
                max_temp: f32,
                voltage: f32,
                cell_voltage_deviation: f32,
                cell_voltage: f32,
                percentage: f32,
                size: Size,
                position: Point,
                orientation: BatteryOrientation,
                cap: Option<Size>,
                bars: i32,
                inited: Option<(Point, Size)>,
                redraw: bool,
                text: bool,
            }
            #[automatically_derived]
            impl ::core::default::Default for Battery {
                #[inline]
                fn default() -> Battery {
                    Battery {
                        min_temp: ::core::default::Default::default(),
                        max_temp: ::core::default::Default::default(),
                        voltage: ::core::default::Default::default(),
                        cell_voltage_deviation: ::core::default::Default::default(),
                        cell_voltage: ::core::default::Default::default(),
                        percentage: ::core::default::Default::default(),
                        size: ::core::default::Default::default(),
                        position: ::core::default::Default::default(),
                        orientation: ::core::default::Default::default(),
                        cap: ::core::default::Default::default(),
                        bars: ::core::default::Default::default(),
                        inited: ::core::default::Default::default(),
                        redraw: ::core::default::Default::default(),
                        text: ::core::default::Default::default(),
                    }
                }
            }
            impl Battery {
                pub fn new(
                    position: Point,
                    size: Size,
                    orientation: BatteryOrientation,
                    cap: Option<Size>,
                    bars: i32,
                    text: bool,
                ) -> Self {
                    Self {
                        position,
                        size,
                        orientation,
                        percentage: 0.0,
                        min_temp: 0.0,
                        max_temp: 0.0,
                        voltage: 0.0,
                        cell_voltage_deviation: 0.0,
                        cell_voltage: 0.0,
                        cap,
                        bars,
                        inited: None,
                        text,
                        redraw: true,
                    }
                }
                fn cap_draw<D: DrawTarget<Color = Gray4>>(
                    &self,
                    target: &mut D,
                ) -> Result<(Point, Size), D::Error> {
                    use BatteryOrientation::*;
                    Ok(if let Some(cap) = self.cap {
                        let style = PrimitiveStyleBuilder::new()
                            .stroke_width(2)
                            .stroke_color(Gray4::WHITE)
                            .fill_color(Gray4::WHITE)
                            .build();
                        let mut size = self.size;
                        match self.orientation {
                            VerticalDown => {
                                size.height -= cap.height;
                                let mut position = self.position;
                                position.x += (self.size.width / 2) as i32 - (cap.width / 2) as i32;
                                position.y = self.size.height as i32 - cap.height as i32;
                                Rectangle::new(position, cap).draw_styled(&style, target)?;
                                (self.position, size)
                            }
                            VerticalTop => {
                                size.height -= cap.height + 2;
                                let mut position = self.position;
                                position.x += (self.size.width / 2) as i32 - (cap.width / 2) as i32;
                                let mut bar_position = self.position;
                                bar_position.y += cap.height as i32;
                                Rectangle::new(position, cap).draw_styled(&style, target)?;
                                (bar_position, size)
                            }
                            HorizontalRight => {
                                size.width -= cap.width;
                                let mut position = self.position;
                                position.x += self.size.width as i32 - cap.width as i32 - 6;
                                position.y +=
                                    (self.size.height / 2) as i32 - (cap.height / 2) as i32;
                                Rectangle::new(position, cap).draw_styled(&style, target)?;
                                let mut bar_position = self.position;
                                bar_position.x -= cap.width as i32;
                                (bar_position, size)
                            }
                            HorizontalLeft => {
                                size.width -= cap.width;
                                let mut position = self.position;
                                position.x = self.size.width as i32 - cap.width as i32;
                                position.y +=
                                    (self.size.height / 2) as i32 - (cap.height / 2) as i32;
                                Rectangle::new(position, cap).draw_styled(&style, target)?;
                                (self.position, size)
                            }
                        }
                    } else {
                        (self.position, self.size)
                    })
                }
                fn init_draw<D: DrawTarget<Color = Gray4>>(
                    &self,
                    target: &mut D,
                ) -> Result<(Point, Size), D::Error> {
                    let style = PrimitiveStyleBuilder::new()
                        .stroke_width(2)
                        .stroke_color(Gray4::WHITE)
                        .fill_color(Gray4::BLACK)
                        .build();
                    let (mut position, mut size) = self.cap_draw(target)?;
                    Rectangle::new(position, size).draw_styled(&style, target)?;
                    size.width -= 8;
                    size.height -= 8;
                    position.x += 4;
                    position.y += 4;
                    Ok((position, size))
                }
                pub fn update_percentage(&mut self, percentage: f32) {
                    if self.percentage != percentage {
                        self.percentage = percentage;
                        self.redraw = true;
                    }
                }
                pub fn update_voltage(&mut self, voltage: f32) {
                    if self.voltage != voltage {
                        self.voltage = voltage;
                        self.redraw = true;
                    }
                }
                pub fn update_cell_voltage_deviation(&mut self, cell_voltage_deviation: f32) {
                    if self.cell_voltage_deviation != cell_voltage_deviation {
                        self.cell_voltage_deviation = cell_voltage_deviation;
                        self.redraw = true;
                    }
                }
                pub fn update_cell_voltage(&mut self, cell_voltage: f32) {
                    if self.cell_voltage != cell_voltage {
                        self.cell_voltage = cell_voltage;
                        self.redraw = true;
                    }
                }
                pub fn update_min_temp(&mut self, min_temp: f32) {
                    if self.min_temp != min_temp {
                        self.min_temp = min_temp;
                        self.redraw = true;
                    }
                }
                pub fn update_max_temp(&mut self, max_temp: f32) {
                    if self.max_temp != max_temp {
                        self.max_temp = max_temp;
                        self.redraw = true;
                    }
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if self.inited.is_none() {
                        self.inited = Some(self.init_draw(target)?);
                    }
                    if let Some((mut position, mut size)) = self.inited
                        && self.redraw
                    {
                        use BatteryOrientation::*;
                        let style = PrimitiveStyleBuilder::new()
                            .stroke_width(2)
                            .stroke_color(Gray4::WHITE)
                            .fill_color(Gray4::WHITE)
                            .build();
                        let mut style_black = style;
                        style_black.fill_color = Some(Gray4::BLACK);
                        style_black.stroke_color = Some(Gray4::BLACK);
                        Rectangle::new(position, size).draw_styled(&style_black, target)?;
                        let org_size = size;
                        let org_position = position;
                        let mut bar_style = style;
                        bar_style.stroke_color = Some(Gray4::new(0x02));
                        bar_style.fill_color = Some(Gray4::new(0x02));
                        match self.orientation {
                            VerticalDown => {
                                size.height =
                                    ((size.height as f32 * self.percentage) / 100.0).round() as u32;
                                Rectangle::new(position, size).draw_styled(&bar_style, target)?;
                            }
                            VerticalTop => {
                                size.height =
                                    ((size.height as f32 * self.percentage) / 100.0).round() as u32;
                                position.y += org_size.height as i32 - size.height as i32;
                                Rectangle::new(position, size).draw_styled(&bar_style, target)?;
                            }
                            HorizontalRight => {
                                size.width =
                                    ((size.width as f32 * self.percentage) / 100.0).round() as u32;
                                Rectangle::new(position, size).draw_styled(&bar_style, target)?;
                            }
                            HorizontalLeft => {
                                size.width =
                                    ((size.width as f32 * self.percentage) / 100.0).round() as u32;
                                position.x += org_size.width as i32 - size.width as i32;
                                Rectangle::new(position, size).draw_styled(&bar_style, target)?;
                            }
                        }
                        if self.bars > 2 {
                            match self.orientation {
                                VerticalDown | VerticalTop => {
                                    let bar_size = org_size.height as i32 / self.bars;
                                    for bar in 0..self.bars {
                                        let mut bar_position = org_position;
                                        bar_position.y +=
                                            bar_size * (bar + 1) - (bar_size / 2 - 2) - (bar * 2);
                                        Rectangle::new(
                                            bar_position,
                                            Size {
                                                width: size.width,
                                                height: 1,
                                            },
                                        )
                                        .draw_styled(&style_black, target)?;
                                    }
                                }
                                HorizontalLeft | HorizontalRight => {
                                    let bar_size = ((org_size.width as i32 - self.bars * 2) as f32
                                        / (self.bars + 1) as f32)
                                        .floor()
                                        as i32
                                        + self.bars * 2;
                                    for bar in 0..(self.bars - 1) {
                                        let bar_translate = Point::new(
                                            (bar_size + 2) * bar - 2 + 1 + bar_size - 2,
                                            0,
                                        );
                                        Rectangle::new(
                                            org_position + bar_translate,
                                            Size {
                                                width: 1,
                                                height: size.height,
                                            },
                                        )
                                        .draw_styled(&style_black, target)?;
                                    }
                                }
                            }
                        }
                        if self.text {
                            let mut text: String<32> = String::new();
                            text.write_fmt(format_args!("{0:.1}%", self.percentage))
                                .ok();
                            let character_style =
                                MonoTextStyle::new(&PROFONT_14_POINT, Gray4::WHITE);
                            let mut text_style = TextStyleBuilder::new()
                                .alignment(Alignment::Center)
                                .line_height(LineHeight::Percent(100))
                                .build();
                            let mut text_position = org_position;
                            text_position.x +=
                                org_size.width as i32 / 2 / 2 + org_size.width as i32 / 2;
                            text_position.y += org_size.height as i32 / 2 + 5;
                            Text::with_text_style(
                                text.as_str(),
                                text_position,
                                character_style,
                                text_style,
                            )
                            .draw(target)?;
                            let character_style =
                                MonoTextStyle::new(&PROFONT_12_POINT, Gray4::WHITE);
                            text_style.alignment = Alignment::Left;
                            let mut text_position = org_position;
                            text_position.x += 2;
                            text_position.y +=
                                org_size.height as i32 / 2 / 2 + org_size.height as i32 / 2 + 6;
                            text.clear();
                            text.write_fmt(format_args!(
                                "{0:.1}V {1:.2}±{2:.0}",
                                self.voltage, self.cell_voltage, self.cell_voltage_deviation
                            ))
                            .ok();
                            Text::with_text_style(
                                text.as_str(),
                                text_position,
                                character_style,
                                text_style,
                            )
                            .draw(target)?;
                            let mut text_position = org_position;
                            text_position.x += 2;
                            text_position.y += org_size.height as i32 / 2 / 2 + 2;
                            text.clear();
                            text.write_fmt(format_args!(
                                "{0:.0}/{1:.0}°C",
                                self.min_temp, self.max_temp
                            ))
                            .ok();
                            Text::with_text_style(
                                text.as_str(),
                                text_position,
                                character_style,
                                text_style,
                            )
                            .draw(target)?;
                        }
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        mod battery_12v {
            use core::fmt::Write;
            use display_interface::DisplayError;
            use embedded_graphics::{
                mono_font::{
                    ascii::{FONT_10X20, FONT_6X10, FONT_6X13_BOLD, FONT_9X15_BOLD},
                    MonoTextStyle,
                },
                pixelcolor::Gray4,
                prelude::*,
                primitives::*,
                text::{Alignment, LineHeight, Text, TextStyleBuilder},
            };
            use heapless::String;
            use num_traits::float::FloatCore;
            use profont::*;
            pub struct Battery12V {
                voltage: f32,
                position: Point,
                redraw: bool,
                inited: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Battery12V {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Battery12V",
                        "voltage",
                        &self.voltage,
                        "position",
                        &self.position,
                        "redraw",
                        &self.redraw,
                        "inited",
                        &&self.inited,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Battery12V {
                #[inline]
                fn clone(&self) -> Battery12V {
                    let _: ::core::clone::AssertParamIsClone<f32>;
                    let _: ::core::clone::AssertParamIsClone<Point>;
                    let _: ::core::clone::AssertParamIsClone<bool>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Battery12V {}
            #[automatically_derived]
            impl ::core::default::Default for Battery12V {
                #[inline]
                fn default() -> Battery12V {
                    Battery12V {
                        voltage: ::core::default::Default::default(),
                        position: ::core::default::Default::default(),
                        redraw: ::core::default::Default::default(),
                        inited: ::core::default::Default::default(),
                    }
                }
            }
            impl Battery12V {
                pub fn new(position: Point) -> Self {
                    Self {
                        position,
                        voltage: 0.0,
                        redraw: true,
                        inited: false,
                    }
                }
                pub fn update_voltage(&mut self, voltage: f32) {
                    if self.voltage != voltage {
                        self.voltage = voltage;
                        self.redraw = true;
                    }
                }
                pub fn init<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    let cap_height = 7;
                    let cap_width = 10;
                    let main_width = 32;
                    let main_height = 32;
                    let mut style = PrimitiveStyleBuilder::new()
                        .stroke_width(2)
                        .stroke_color(Gray4::WHITE)
                        .fill_color(Gray4::BLACK)
                        .build();
                    let main_rectangle = Rectangle::new(
                        self.position + Point::new(0, cap_height),
                        Size::new(main_width, main_height - cap_height as u32),
                    );
                    main_rectangle.draw_styled(&style, target)?;
                    let cap1_rectangle = Rectangle::with_center(
                        self.position + Point::new(main_width as i32 / 2 / 2, cap_height / 2),
                        Size::new(cap_width, cap_height as u32),
                    );
                    style.stroke_color = None;
                    style.fill_color = Some(Gray4::WHITE);
                    cap1_rectangle.draw_styled(&style, target)?;
                    let cap2_rectangle = cap1_rectangle.translate(Point::new(
                        main_width as i32 / 2 / 2 + cap_width as i32 / 2 + 1,
                        0,
                    ));
                    cap2_rectangle.draw_styled(&style, target)?;
                    let minus_rectangle = Rectangle::with_center(
                        Point::new(
                            cap1_rectangle.center().x,
                            main_rectangle.top_left.y + main_width as i32 / 2 / 2 - 2,
                        ),
                        Size::new(cap_width - 2, 3),
                    );
                    minus_rectangle.draw_styled(&style, target)?;
                    let plus1_rectangle = Rectangle::with_center(
                        Point::new(
                            cap2_rectangle.center().x + 1,
                            main_rectangle.top_left.y + main_width as i32 / 2 / 2 - 2,
                        ),
                        Size::new(cap_width - 1, 3),
                    );
                    let plus2_rectangle = Rectangle::with_center(
                        Point::new(
                            cap2_rectangle.center().x + 1,
                            main_rectangle.top_left.y + main_width as i32 / 2 / 2 - 2,
                        ),
                        Size::new(3, cap_width - 1),
                    );
                    plus1_rectangle.draw_styled(&style, target)?;
                    plus2_rectangle.draw_styled(&style, target)?;
                    self.inited = true;
                    Ok(())
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if !self.inited {
                        self.init(target)?;
                    }
                    if self.redraw {
                        let style = PrimitiveStyleBuilder::new()
                            .fill_color(Gray4::BLACK)
                            .build();
                        let main_width = 32;
                        let main_height = 30;
                        let mut text: String<16> = String::new();
                        text.write_fmt(format_args!("{0:.1}V", self.voltage)).ok();
                        let character_style = MonoTextStyle::new(&PROFONT_7_POINT, Gray4::WHITE);
                        let text_style = TextStyleBuilder::new()
                            .alignment(Alignment::Center)
                            .line_height(LineHeight::Percent(100))
                            .build();
                        let text = Text::with_text_style(
                            text.as_str(),
                            self.position + Point::new(main_width / 2, main_height - 4),
                            character_style,
                            text_style,
                        );
                        let mut rectangle = text.bounding_box();
                        rectangle.top_left.x = self.position.x + 1;
                        rectangle.size.width = main_width as u32 - 2;
                        rectangle.draw_styled(&style, target)?;
                        text.draw(target)?;
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        mod connection {
            use core::fmt::Write;
            use display_interface::DisplayError;
            use embedded_graphics::{
                image::Image,
                pixelcolor::Gray4,
                prelude::*,
                primitives::{Rectangle, StyledDrawable as _},
            };
            use embedded_iconoir::prelude::IconoirNewIcon as _;
            pub struct Connection {
                position: Point,
                redraw: bool,
                last_send: bool,
                last_receive: bool,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Connection {
                #[inline]
                fn clone(&self) -> Connection {
                    Connection {
                        position: ::core::clone::Clone::clone(&self.position),
                        redraw: ::core::clone::Clone::clone(&self.redraw),
                        last_send: ::core::clone::Clone::clone(&self.last_send),
                        last_receive: ::core::clone::Clone::clone(&self.last_receive),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Connection {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Connection",
                        "position",
                        &self.position,
                        "redraw",
                        &self.redraw,
                        "last_send",
                        &self.last_send,
                        "last_receive",
                        &&self.last_receive,
                    )
                }
            }
            impl Default for Connection {
                fn default() -> Self {
                    Self {
                        position: Point::zero(),
                        redraw: true,
                        last_send: false,
                        last_receive: false,
                    }
                }
            }
            impl Connection {
                pub fn new(position: Point) -> Self {
                    Self {
                        position,
                        ..Default::default()
                    }
                }
                pub fn update_last_send(&mut self, last_send: bool) {
                    if self.last_send == last_send {
                        return;
                    }
                    self.last_send = last_send;
                    self.redraw = true;
                }
                pub fn update_last_receive(&mut self, last_receive: bool) {
                    if self.last_receive == last_receive {
                        return;
                    }
                    self.last_receive = last_receive;
                    self.redraw = true;
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if self.redraw {
                        let icon =
                            embedded_iconoir::icons::size18px::connectivity::DataTransferBoth::new(
                                GrayColor::WHITE,
                            );
                        let image = Image::new(&icon, self.position);
                        image.draw(target)?;
                        let style = embedded_graphics::primitives::PrimitiveStyleBuilder::new()
                            .stroke_width(0)
                            .stroke_color(Gray4::BLACK)
                            .fill_color(Gray4::BLACK)
                            .build();
                        if !self.last_receive {
                            let bounding_box = Rectangle::new(
                                self.position + Point::new(0, 0),
                                Size::new(18 / 2, 18),
                            );
                            bounding_box.draw_styled(&style, target)?;
                        }
                        if !self.last_send {
                            let bounding_box = Rectangle::new(
                                self.position + Point::new(18 / 2, 0),
                                Size::new(18 / 2, 18),
                            );
                            bounding_box.draw_styled(&style, target)?;
                        }
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        mod debug {
            use core::{fmt::Write, str::FromStr as _};
            use defmt::{info, unwrap};
            use display_interface::DisplayError;
            use embassy_time::Instant;
            use embedded_graphics::{
                mono_font::{
                    ascii::{FONT_10X20, FONT_6X10, FONT_6X13_BOLD, FONT_9X15_BOLD},
                    MonoTextStyle,
                },
                pixelcolor::Gray4,
                prelude::*,
                primitives::*,
                text::{Alignment, LineHeight, Text, TextStyleBuilder},
            };
            use heapless::String;
            use num_traits::float::FloatCore;
            use profont::*;
            use crate::debug::{DEBUG_CHANNEL_LEN, DEBUG_STRING_LEN};
            pub struct DebugScroll {
                text_buffer: [heapless::String<DEBUG_STRING_LEN>; DEBUG_CHANNEL_LEN],
                redraw: bool,
            }
            #[automatically_derived]
            impl ::core::default::Default for DebugScroll {
                #[inline]
                fn default() -> DebugScroll {
                    DebugScroll {
                        text_buffer: ::core::default::Default::default(),
                        redraw: ::core::default::Default::default(),
                    }
                }
            }
            impl DebugScroll {
                pub fn new() -> Self {
                    Self {
                        text_buffer: Default::default(),
                        redraw: false,
                    }
                }
                pub fn add_line(&mut self, line: &str) {
                    for i in 0..self.text_buffer.len() - 1 {
                        self.text_buffer[i] = self.text_buffer[i + 1].clone();
                    }
                    self.text_buffer[self.text_buffer.len() - 1] =
                        String::from_str(line).unwrap_or_default();
                    self.redraw = true;
                }
                pub fn draw<D: DrawTarget<Color = Gray4>, D2: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                    target2: &mut D2,
                ) -> Result<(), ()> {
                    if self.redraw {
                        target.clear(Gray4::BLACK).map_err(|_| ())?;
                        target2.clear(Gray4::BLACK).map_err(|_| ())?;
                        let character_style = MonoTextStyle::new(&PROFONT_7_POINT, Gray4::WHITE);
                        let text_style = TextStyleBuilder::new()
                            .alignment(Alignment::Left)
                            .line_height(LineHeight::Percent(100))
                            .build();
                        let mut position = Point::new(0, 6);
                        let mut text_buffer_chunks = self.text_buffer.chunks(DEBUG_CHANNEL_LEN / 2);
                        for text in match defmt::export::into_result(text_buffer_chunks.next()) {
                            ::core::result::Result::Ok(res) => res,
                            ::core::result::Result::Err(_unwrap_err) => {
                                match (&(_unwrap_err)) {
                                    (arg0) => {
                                        if {
                                            const CHECK: bool = {
                                                const fn check() -> bool {
                                                    let module_path =
                                                                            "kia_obd2_esp32c3_v2::display::widgets::debug".as_bytes();
                                                    if if 19usize > module_path.len() {
                                                        false
                                                    } else {
                                                        module_path[0usize] == 107u8
                                                            && module_path[1usize] == 105u8
                                                            && module_path[2usize] == 97u8
                                                            && module_path[3usize] == 95u8
                                                            && module_path[4usize] == 111u8
                                                            && module_path[5usize] == 98u8
                                                            && module_path[6usize] == 100u8
                                                            && module_path[7usize] == 50u8
                                                            && module_path[8usize] == 95u8
                                                            && module_path[9usize] == 101u8
                                                            && module_path[10usize] == 115u8
                                                            && module_path[11usize] == 112u8
                                                            && module_path[12usize] == 51u8
                                                            && module_path[13usize] == 50u8
                                                            && module_path[14usize] == 99u8
                                                            && module_path[15usize] == 51u8
                                                            && module_path[16usize] == 95u8
                                                            && module_path[17usize] == 118u8
                                                            && module_path[18usize] == 50u8
                                                            && if 19usize == module_path.len() {
                                                                true
                                                            } else {
                                                                module_path[19usize] == b':'
                                                            }
                                                    } {
                                                        return true;
                                                    }
                                                    false
                                                }
                                                check()
                                            };
                                            CHECK
                                        } {
                                            unsafe {
                                                defmt::export::acquire_and_header(&{
                                                    defmt::export::make_istr({
                                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: text_buffer_chunks.next()'\\nerror: `{:?}`\",\"disambiguator\":\"12631468911963139656\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: text_buffer_chunks.next()'\\nerror: `{:?}`\",\"disambiguator\":\"12631468911963139656\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                    })
                                                });
                                            };
                                            defmt::export::fmt(arg0);
                                            unsafe { defmt::export::release() }
                                        }
                                    }
                                };
                                defmt::export::panic()
                            }
                        } {
                            let text =
                                Text::with_text_style(text, position, character_style, text_style);
                            text.draw(target).map_err(|_| ())?;
                            position += Point::new(0, 8);
                        }
                        let mut position = Point::new(0, 6);
                        for text in match defmt::export::into_result(text_buffer_chunks.next()) {
                            ::core::result::Result::Ok(res) => res,
                            ::core::result::Result::Err(_unwrap_err) => {
                                match (&(_unwrap_err)) {
                                    (arg0) => {
                                        if {
                                            const CHECK: bool = {
                                                const fn check() -> bool {
                                                    let module_path =
                                                                            "kia_obd2_esp32c3_v2::display::widgets::debug".as_bytes();
                                                    if if 19usize > module_path.len() {
                                                        false
                                                    } else {
                                                        module_path[0usize] == 107u8
                                                            && module_path[1usize] == 105u8
                                                            && module_path[2usize] == 97u8
                                                            && module_path[3usize] == 95u8
                                                            && module_path[4usize] == 111u8
                                                            && module_path[5usize] == 98u8
                                                            && module_path[6usize] == 100u8
                                                            && module_path[7usize] == 50u8
                                                            && module_path[8usize] == 95u8
                                                            && module_path[9usize] == 101u8
                                                            && module_path[10usize] == 115u8
                                                            && module_path[11usize] == 112u8
                                                            && module_path[12usize] == 51u8
                                                            && module_path[13usize] == 50u8
                                                            && module_path[14usize] == 99u8
                                                            && module_path[15usize] == 51u8
                                                            && module_path[16usize] == 95u8
                                                            && module_path[17usize] == 118u8
                                                            && module_path[18usize] == 50u8
                                                            && if 19usize == module_path.len() {
                                                                true
                                                            } else {
                                                                module_path[19usize] == b':'
                                                            }
                                                    } {
                                                        return true;
                                                    }
                                                    false
                                                }
                                                check()
                                            };
                                            CHECK
                                        } {
                                            unsafe {
                                                defmt::export::acquire_and_header(&{
                                                    defmt::export::make_istr({
                                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: text_buffer_chunks.next()'\\nerror: `{:?}`\",\"disambiguator\":\"17610450684057967766\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: text_buffer_chunks.next()'\\nerror: `{:?}`\",\"disambiguator\":\"17610450684057967766\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                    })
                                                });
                                            };
                                            defmt::export::fmt(arg0);
                                            unsafe { defmt::export::release() }
                                        }
                                    }
                                };
                                defmt::export::panic()
                            }
                        } {
                            let text =
                                Text::with_text_style(text, position, character_style, text_style);
                            text.draw(target2).map_err(|_| ())?;
                            position += Point::new(0, 8);
                        }
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        mod fuel {
            use core::fmt::Write;
            use display_interface::DisplayError;
            use embedded_graphics::{
                mono_font::{
                    ascii::{FONT_10X20, FONT_6X10, FONT_6X13_BOLD, FONT_9X15_BOLD},
                    MonoTextStyle,
                },
                pixelcolor::Gray4,
                prelude::*,
                primitives::*,
                text::{Alignment, LineHeight, Text, TextStyleBuilder},
            };
            use heapless::String;
            use num_traits::float::FloatCore;
            use profont::*;
            use crate::display::RotatedDrawTarget;
            pub struct Fuel<D> {
                max_temp: f64,
                min_temp: f64,
                current_temp: f64,
                current_temp_percentage: f64,
                size: Size,
                position: Point,
                bars: i32,
                redraw: bool,
                _marker: core::marker::PhantomData<D>,
            }
            impl<D> Fuel<D>
            where
                D: DrawTarget<Color = Gray4>,
            {
                pub fn new(position: Point, size: Size, min: f64, max: f64, bars: i32) -> Self {
                    Self {
                        position,
                        size,
                        current_temp: 0.0,
                        current_temp_percentage: 0.0,
                        max_temp: max,
                        min_temp: min,
                        bars,
                        redraw: true,
                        _marker: core::marker::PhantomData::default(),
                    }
                }
                pub fn update_temp(&mut self, temp: f64) {
                    if self.current_temp != temp {
                        self.current_temp = temp;
                        self.current_temp_percentage =
                            (temp - self.min_temp) / (self.max_temp - self.min_temp);
                        if self.current_temp > self.max_temp {
                            self.current_temp_percentage = 1.0;
                        } else if self.current_temp < self.min_temp {
                            self.current_temp_percentage = 0.0;
                        }
                        self.redraw = true;
                    }
                }
                pub fn draw(&mut self, target: &mut D) -> Result<(), D::Error> {
                    if self.redraw {
                        let color = Gray4::new(4);
                        let mut style = PrimitiveStyleBuilder::new()
                            .stroke_width(2)
                            .stroke_color(Gray4::WHITE)
                            .fill_color(Gray4::BLACK)
                            .build();
                        let mut size = self.size;
                        size.width /= 2;
                        size.height -= self.size.width / 2;
                        let mut area = Rectangle::new(
                            self.position + Point::new(self.size.width as i32 / 2, 0),
                            size,
                        );
                        area.draw_styled(&style, target)?;
                        let mut circle_bottom = Circle::with_center(
                            self.position
                                + Point::new(
                                    self.size.width as i32 / 4,
                                    self.size.height as i32 - (self.size.width as i32 / 2),
                                )
                                + Point::new(size.width as i32 - 1, -2),
                            self.size.width,
                        );
                        circle_bottom.draw_styled(&style, target)?;
                        let circle = Circle::with_center(
                            self.position + Point::new(self.size.width as i32 / 2 + 3, 4),
                            self.size.width / 2,
                        );
                        style.fill_color = Some(Gray4::BLACK);
                        let mut circle_box = circle.bounding_box();
                        circle_box.size.width += 2;
                        circle_box.size.height -= 1;
                        circle_box.top_left.x -= 1;
                        circle_box.top_left.y -= 1;
                        target.fill_solid(&circle_box, Gray4::BLACK)?;
                        circle.draw_styled(&style, target)?;
                        style.stroke_color = Some(color);
                        area.size.height -= 4;
                        area.size.width -= 2;
                        area.top_left.x += 1;
                        area.top_left.y += 3;
                        let mut area_clipped = target.clipped(&area.bounding_box());
                        area_clipped.fill_solid(&area, Gray4::BLACK)?;
                        let mut size = self.size;
                        size.width /= 2;
                        size.height = ((self.size.height as f64 - 8.0)
                            * self.current_temp_percentage)
                            .round() as u32;
                        size.width -= 6;
                        style.fill_color = Some(color);
                        let mut position =
                            self.position + Point::new(self.size.width as i32 / 2, 0);
                        position.x += 3;
                        position.y = self.position.y + (self.size.height - 6) as i32
                            - size.height as i32
                            + 2;
                        let mut area_filled = Rectangle::new(position, size);
                        area_filled.draw_styled(&style, target)?;
                        area_filled.size.width = self.size.width;
                        area_filled.top_left.x -= self.size.width as i32 / 2;
                        area_filled.top_left.y -= 1;
                        area_filled.size.height += 1;
                        let mut area_filled = target.clipped(&area_filled);
                        circle_bottom.diameter -= 6;
                        circle_bottom.top_left.y += 3;
                        circle_bottom.top_left.x += 3;
                        circle_bottom.draw_styled(&style, &mut area_filled)?;
                        let mut text: String<16> = String::new();
                        text.write_fmt(format_args!("{0:.1}°C", self.current_temp))
                            .ok();
                        let character_style = MonoTextStyle::new(&PROFONT_9_POINT, Gray4::WHITE);
                        let text_style = TextStyleBuilder::new()
                            .alignment(Alignment::Center)
                            .line_height(LineHeight::Percent(100))
                            .build();
                        let mut rotate_target = RotatedDrawTarget::new(target);
                        let text_position = Point::new(20, 26);
                        let text = Text::with_text_style(
                            text.as_str(),
                            text_position,
                            character_style,
                            text_style,
                        );
                        let text_box = Rectangle::with_center(
                            text_position - Point::new(1, 2),
                            Size::new(42, 12),
                        );
                        rotate_target.fill_solid(&text_box, Gray4::BLACK)?;
                        text.draw(&mut rotate_target)?;
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        mod gearbox_gear {
            use core::fmt::Write;
            use display_interface::DisplayError;
            use embedded_graphics::{
                mono_font::{
                    ascii::{FONT_10X20, FONT_6X10, FONT_6X13_BOLD, FONT_9X15_BOLD},
                    MonoTextStyle,
                },
                pixelcolor::Gray4,
                prelude::*,
                primitives::*,
                text::{Alignment, LineHeight, Text, TextStyleBuilder},
            };
            use heapless::String;
            use num_traits::float::FloatCore;
            use profont::*;
            use crate::display::RotatedDrawTarget;
            pub struct GearboxGear {
                position: Point,
                gear: &'static str,
                redraw: bool,
                bounding_box: Option<Rectangle>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for GearboxGear {
                #[inline]
                fn clone(&self) -> GearboxGear {
                    let _: ::core::clone::AssertParamIsClone<Point>;
                    let _: ::core::clone::AssertParamIsClone<&'static str>;
                    let _: ::core::clone::AssertParamIsClone<bool>;
                    let _: ::core::clone::AssertParamIsClone<Option<Rectangle>>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for GearboxGear {}
            #[automatically_derived]
            impl ::core::fmt::Debug for GearboxGear {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "GearboxGear",
                        "position",
                        &self.position,
                        "gear",
                        &self.gear,
                        "redraw",
                        &self.redraw,
                        "bounding_box",
                        &&self.bounding_box,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for GearboxGear {
                #[inline]
                fn default() -> GearboxGear {
                    GearboxGear {
                        position: ::core::default::Default::default(),
                        gear: ::core::default::Default::default(),
                        redraw: ::core::default::Default::default(),
                        bounding_box: ::core::default::Default::default(),
                    }
                }
            }
            impl GearboxGear {
                pub fn new(position: Point) -> Self {
                    Self {
                        position,
                        gear: "U",
                        redraw: true,
                        bounding_box: None,
                    }
                }
                pub fn update_gear(&mut self, gear: &'static str) {
                    if self.gear != gear {
                        self.gear = gear;
                        self.redraw = true;
                    }
                }
                pub fn force_redraw(&mut self) {
                    self.redraw = true;
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if self.redraw {
                        let mut text: String<16> = String::new();
                        text.write_fmt(format_args!("{0}", self.gear)).ok();
                        let character_style = MonoTextStyle::new(&PROFONT_18_POINT, Gray4::WHITE);
                        let text_style = TextStyleBuilder::new()
                            .alignment(Alignment::Center)
                            .line_height(LineHeight::Percent(100))
                            .build();
                        let text = Text::with_text_style(
                            text.as_str(),
                            self.position,
                            character_style,
                            text_style,
                        );
                        let new_bounding_box = text.bounding_box();
                        if new_bounding_box.size.width
                            > self.bounding_box.map(|bb| bb.size.width).unwrap_or(0)
                        {
                            self.bounding_box = Some(new_bounding_box);
                        }
                        if let Some(bb) = self.bounding_box {
                            bb.draw_styled(
                                &PrimitiveStyleBuilder::new()
                                    .fill_color(Gray4::BLACK)
                                    .build(),
                                target,
                            )?;
                        }
                        text.draw(target)?;
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        mod ice_fuel_rate {
            use core::fmt::Write;
            use display_interface::DisplayError;
            use embedded_graphics::{
                mono_font::{
                    ascii::{FONT_10X20, FONT_6X10, FONT_6X13_BOLD, FONT_9X15_BOLD},
                    MonoTextStyle,
                },
                pixelcolor::Gray4,
                prelude::*,
                primitives::*,
                text::{Alignment, LineHeight, Text, TextStyleBuilder},
            };
            use heapless::String;
            use num_traits::float::FloatCore;
            use profont::*;
            use crate::display::RotatedDrawTarget;
            pub struct IceFuelRate {
                position: Point,
                ice_fuel_rate: f32,
                vehicle_speed: f32,
                redraw: bool,
                bounding_box: Option<Rectangle>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IceFuelRate {
                #[inline]
                fn clone(&self) -> IceFuelRate {
                    let _: ::core::clone::AssertParamIsClone<Point>;
                    let _: ::core::clone::AssertParamIsClone<f32>;
                    let _: ::core::clone::AssertParamIsClone<bool>;
                    let _: ::core::clone::AssertParamIsClone<Option<Rectangle>>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for IceFuelRate {}
            #[automatically_derived]
            impl ::core::fmt::Debug for IceFuelRate {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "IceFuelRate",
                        "position",
                        &self.position,
                        "ice_fuel_rate",
                        &self.ice_fuel_rate,
                        "vehicle_speed",
                        &self.vehicle_speed,
                        "redraw",
                        &self.redraw,
                        "bounding_box",
                        &&self.bounding_box,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for IceFuelRate {
                #[inline]
                fn default() -> IceFuelRate {
                    IceFuelRate {
                        position: ::core::default::Default::default(),
                        ice_fuel_rate: ::core::default::Default::default(),
                        vehicle_speed: ::core::default::Default::default(),
                        redraw: ::core::default::Default::default(),
                        bounding_box: ::core::default::Default::default(),
                    }
                }
            }
            impl IceFuelRate {
                pub fn new(position: Point) -> Self {
                    Self {
                        position,
                        ice_fuel_rate: 0.0,
                        vehicle_speed: 0.0,
                        redraw: true,
                        bounding_box: None,
                    }
                }
                pub fn update_ice_fuel_rate(&mut self, ice_fuel_rate: f32) {
                    if self.ice_fuel_rate != ice_fuel_rate {
                        self.ice_fuel_rate = ice_fuel_rate;
                        self.redraw = true;
                    }
                }
                pub fn update_vehicle_speed(&mut self, vehicle_speed: f32) {
                    if self.vehicle_speed != vehicle_speed {
                        self.vehicle_speed = vehicle_speed;
                        self.redraw = true;
                    }
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if self.redraw {
                        let mut text: String<16> = String::new();
                        let mut fuel_per_100km = 0.0;
                        if self.vehicle_speed > 0.0 {
                            fuel_per_100km = self.ice_fuel_rate / self.vehicle_speed * 100.0;
                        }
                        text.write_fmt(format_args!("{0:.1}", fuel_per_100km)).ok();
                        let character_style = MonoTextStyle::new(&PROFONT_10_POINT, Gray4::WHITE);
                        let text_style = TextStyleBuilder::new()
                            .alignment(Alignment::Left)
                            .line_height(LineHeight::Percent(100))
                            .build();
                        let draw_text = Text::with_text_style(
                            text.as_str(),
                            self.position,
                            character_style,
                            text_style,
                        );
                        let new_bounding_box = draw_text.bounding_box();
                        if new_bounding_box.size.width
                            > self.bounding_box.map(|bb| bb.size.width).unwrap_or(0)
                        {
                            self.bounding_box = Some(new_bounding_box);
                        }
                        if let Some(bb) = self.bounding_box {
                            bb.draw_styled(
                                &PrimitiveStyleBuilder::new()
                                    .fill_color(Gray4::BLACK)
                                    .build(),
                                target,
                            )?;
                        }
                        draw_text.draw(target)?;
                        text.clear();
                        text.write_fmt(format_args!("l/100")).ok();
                        let character_style = MonoTextStyle::new(&PROFONT_7_POINT, Gray4::WHITE);
                        let text_style = TextStyleBuilder::new()
                            .alignment(Alignment::Left)
                            .line_height(LineHeight::Percent(100))
                            .build();
                        let draw_text = Text::with_text_style(
                            text.as_str(),
                            new_bounding_box.top_left
                                + Point::new(new_bounding_box.size.width as i32 + 4, 8),
                            character_style,
                            text_style,
                        );
                        let new_bounding_box = draw_text.bounding_box();
                        new_bounding_box.draw_styled(
                            &PrimitiveStyleBuilder::new()
                                .fill_color(Gray4::BLACK)
                                .build(),
                            target,
                        )?;
                        draw_text.draw(target)?;
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        mod icon {
            use alloc::{borrow::Cow, string::ToString as _};
            use core::fmt::Write;
            use display_interface::DisplayError;
            use embedded_graphics::{
                image::Image,
                pixelcolor::Gray4,
                prelude::*,
                primitives::{Rectangle, StyledDrawable as _},
            };
            use embedded_iconoir::prelude::IconoirNewIcon as _;
            pub struct Icon<I> {
                position: Point,
                size: u32,
                redraw: bool,
                last_enabled: bool,
                _icon: core::marker::PhantomData<I>,
            }
            #[automatically_derived]
            impl<I: ::core::clone::Clone> ::core::clone::Clone for Icon<I> {
                #[inline]
                fn clone(&self) -> Icon<I> {
                    Icon {
                        position: ::core::clone::Clone::clone(&self.position),
                        size: ::core::clone::Clone::clone(&self.size),
                        redraw: ::core::clone::Clone::clone(&self.redraw),
                        last_enabled: ::core::clone::Clone::clone(&self.last_enabled),
                        _icon: ::core::clone::Clone::clone(&self._icon),
                    }
                }
            }
            #[automatically_derived]
            impl<I: ::core::fmt::Debug> ::core::fmt::Debug for Icon<I> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Icon",
                        "position",
                        &self.position,
                        "size",
                        &self.size,
                        "redraw",
                        &self.redraw,
                        "last_enabled",
                        &self.last_enabled,
                        "_icon",
                        &&self._icon,
                    )
                }
            }
            impl<I> Default for Icon<I> {
                fn default() -> Self {
                    Self {
                        size: 0,
                        position: Point::zero(),
                        redraw: true,
                        last_enabled: true,
                        _icon: core::marker::PhantomData,
                    }
                }
            }
            impl<I: embedded_iconoir::prelude::IconoirIcon> Icon<I> {
                pub fn new(position: Point, enabled: bool) -> Self {
                    Self {
                        position,
                        last_enabled: enabled,
                        ..Default::default()
                    }
                }
                pub fn enabled(&mut self, enabled: bool) {
                    if self.last_enabled == enabled {
                        return;
                    }
                    self.last_enabled = enabled;
                    self.redraw = true;
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if self.redraw {
                        if self.last_enabled {
                            let icon = I::new(GrayColor::WHITE);
                            let image = Image::new(&icon, self.position);
                            image.draw(target)?;
                            self.size = image.bounding_box().size.width;
                        } else {
                            if self.size != 0 {
                                let style =
                                    embedded_graphics::primitives::PrimitiveStyleBuilder::new()
                                        .stroke_width(0)
                                        .stroke_color(Gray4::BLACK)
                                        .fill_color(Gray4::BLACK)
                                        .build();
                                let bounding_box = Rectangle::new(self.position, Size::new(18, 18));
                                bounding_box.draw_styled(&style, target)?;
                            }
                        }
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        mod motor_electric {
            use core::cell::UnsafeCell;
            use display_interface::DisplayError;
            use embedded_graphics::{
                image::Image,
                pixelcolor::{Gray4, Rgb565},
                prelude::*,
                primitives::*,
            };
            use once_cell::sync::{Lazy, OnceCell};
            use static_cell::StaticCell;
            use tinybmp::Bmp;
            pub struct MotorElectric {
                motor_im: Image<'static, Bmp<'static, Rgb565>>,
                motor_on_im: Image<'static, Bmp<'static, Rgb565>>,
                motor_off_im: Image<'static, Bmp<'static, Rgb565>>,
                on: bool,
                needs_update: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for MotorElectric {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "MotorElectric",
                        "motor_im",
                        &self.motor_im,
                        "motor_on_im",
                        &self.motor_on_im,
                        "motor_off_im",
                        &self.motor_off_im,
                        "on",
                        &self.on,
                        "needs_update",
                        &&self.needs_update,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for MotorElectric {
                #[inline]
                fn clone(&self) -> MotorElectric {
                    MotorElectric {
                        motor_im: ::core::clone::Clone::clone(&self.motor_im),
                        motor_on_im: ::core::clone::Clone::clone(&self.motor_on_im),
                        motor_off_im: ::core::clone::Clone::clone(&self.motor_off_im),
                        on: ::core::clone::Clone::clone(&self.on),
                        needs_update: ::core::clone::Clone::clone(&self.needs_update),
                    }
                }
            }
            impl Default for MotorElectric {
                fn default() -> Self {
                    Self::new(Point::zero())
                }
            }
            impl MotorElectric {
                pub fn new(position: Point) -> Self {
                    static MOTOR_BMP: OnceCell<Bmp<'static, Rgb565>> = OnceCell::new();
                    let motor_bmp =
                        MOTOR_BMP.get_or_init(||
                                unsafe {
                                    Bmp::from_slice(b"BM\x8a\x1e\x00\x00\x00\x00\x00\x00\x8a\x00\x00\x00|\x00\x00\x00;\x00\x00\x00@\x00\x00\x00\x01\x00\x10\x00\x03\x00\x00\x00\x00\x1e\x00\x00#.\x00\x00#.\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf8\x00\x00\xe0\x07\x00\x00\x1f\x00\x00\x00\x00\x00\x00\x00BGRs\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00A\x08\xef{\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x96\xb5\x00\x00\xc3\x18\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xcbZ\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa2\x10\x14\xa5\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x96\xb5\x00\x00\xc3\x18\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xcbZ\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04!\x17\xbe\xff\xffQ\x8c\x82\x10!\x08!\x08!\x08!\x08!\x08!\x08!\x08!\x08!\x08!\x08!\x08!\x08!\x08!\x08!\x08 \x00\x00\x00\xc3\x18\xff\xffq\x8c!\x08!\x08!\x08 \x00\x00\x00\x82\x10\xe3\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x861<\xe7\xff\xffmk!\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00)J\xde\xf7\xff\xff\xaaR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\xe3\x18\x861e)e)e)e)e)e)e)e)e)$!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xebZ\xff\xff]\xef\x08B\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00$!y\xce\xde\xf7\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x10\x84\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00A\x08\xcf{\xff\xff8\xc6e)\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\xe3\x188\xc6\xff\xff\xb2\x94\x10\x84\x10\x84\x10\x84\x10\x84\x10\x84\x10\x84\x10\x84q\x8c\xff\xff\x10\x84\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00b\x10\x92\x94\xff\xff\x96\xb5\x04!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xdf\xff0\x84\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xc3\x18\x17\xbe\xff\xff,c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff\x10\x84\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18u\xad\xff\xff\xd3\x9c\x82\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xb6\xb5\xff\xffMk \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff\x10\x84\x00\x00\x00\x00\x00\x00\x00\x00E)\x18\xc6\xff\xff\xef{A\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08B\xf3\x9c\x00\x00\xff\xff\x99\xce \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff\x96\xb5\xaaR\xaaR\xaaR\xebZ<\xe7\xff\xff,c \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8aR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00A\x08\x861\x861\x861\x861\x861U\xad\xff\xffb\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffb\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00b\x10\xc3\x18\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xaes\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffb\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe3\x18\xa61\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa3\x18E)\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\xaaR\x00\x00\x00\x00\x00\x00\xb2\x94\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xffY\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xffy\xceu\xadu\xadu\xad}\xef\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\xff\xff\x9d\xef\xc79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe79\x10\x84\x00\x00\xe79\xff\xff\xbe\xf7\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08B\xff\xff\x9d\xefIJ\xa61\xa61\xa61\xa61\xa61\xa61\xa61\x0cc\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00iJ\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8aR\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffb\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00A\x08b\x10\x00\x00\x00\x00\x00\x00\x00\x00IJMkMkMkMkMkMkMkMkMkMk\x861\x00\x00\x00\x00\x00\x00Q\x8c\xff\xffu\xadU\xadU\xadU\xadU\xadU\xadU\xadU\xadU\xadU\xadU\xad0\x84A\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00Q\x8c\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffq\x8cA\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x82\x10\xa3\x18\xa3\x18\xa3\x18\xa3\x18\xa3\x18\xa3\x18\xa3\x18\xa3\x18\xa3\x18\xa3\x18\xa3\x18\xc3\x18\xb2\x94\xff\xffq\x8ca\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00b\x10\xd3\x9c\xff\xffQ\x8cA\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x82\x10\xf3\x9c\xff\xffQ\x8cA\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x82\x10U\xad\xff\xff\x10\x84A\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x82\x104\xa5\xff\xff\xef{!\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc79\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa2\x10U\xad\xff\xff\xcf{\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xc3\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x82\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa2\x10u\xad\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff(B\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa2\x10,c,c,c,c,c,c,c,c,c,c,c,c\x92\x94\xff\xff(B\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08B\xff\xff(B\x00\x00\x00\x00\x00\x00\x00\x00\xe79\x10\x84\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08B\xff\xff(B\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00E)\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ0\x84\xff\xff(B\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00IJ\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff(B\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00IJ\xff\xff\xef{\x08B\x08B\x08B\x08B\x08B\x08B\x08B\x08B\x08B\x08B\x08B\x08B\xe4 \x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00IJ\xff\xff\xaaR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00IJ\xff\xff\xaaR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00IJ\xff\xff\xaaR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00IJ\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xebZ\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00IJ\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xcbZ\x00\x00\x00\x00\x00\x00\x00\x00").unwrap_unchecked()
                                });
                    static MOTOR_ON_BMP: OnceCell<Bmp<'static, Rgb565>> = OnceCell::new();
                    let motor_on_bmp =
                        MOTOR_ON_BMP.get_or_init(||
                                unsafe {
                                    Bmp::from_slice(b"BM\x02\x06\x00\x00\x00\x00\x00\x00\x8a\x00\x00\x00|\x00\x00\x00\x12\x00\x00\x00\x19\x00\x00\x00\x01\x00\x18\x00\x00\x00\x00\x00x\x05\x00\x00#.\x00\x00#.\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\xff\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00BGRs\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x04\x08! !! !! !! !\x08\x08\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x08\x08\xce\xca\xce\xff\xff\xff\xff\xff\xff\xff\xff\xffkik\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00kik\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)()\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00151\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa5\xa2\xa5\x08\x04\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x08\x08\xde\xdb\xde\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffRQR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00{y{\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\xef\xef\xde\xdf\xde\x19\x1c\x19\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00:9:\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x84\x86\x84\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x0c\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff:=:\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x84\x82\x84\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xbd\xbe\xbd\x10\x0c\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00151151151151151151kmk\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffkik\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00{}{\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)()\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00:9:\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa5\xa6\xa5\x08\x04\x08\x00\x00\x00\x00\x00\x00\x00\x00\x08\x08\x08\xce\xce\xce\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffRQR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00kik\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xde\xdb\xde\x19\x18\x19\x00\x00\x00\x00\x00\x00\x00\x00)()\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x84\x86\x84\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb5\xb6\xb5\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\xf3\xef\xbd\xc2\xbd\xbd\xc2\xbd\xbd\xc2\xbd\xbd\xc2\xbd\xbd\xc2\xbd\xbd\xc2\xbd151\x00\x00\x00\x00\x00\x00\x00\x00JMJ\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xd6\xd7\xd6\x08\x0c\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x19\x18\x19\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffBAB\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00{}{\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x94\x96\x94\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00111\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff!\x1c!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x08\x08\xc5\xca\xc5\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffZ]Z\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00cec\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf7\xf3\xf7\xc5\xc6\xc5\x08\x04\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00111\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\xef\xef\xff\xff\xff:5:\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\xc5\xc6\xc5\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x84\x86\x84\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x10\x10\x19\x18\x19\x19\x18\x19\x19\x18\x19\x19\x18\x19\x19\x18\x19\x19\x18\x19\x19\x18\x19\x19\x18\x19\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00").unwrap_unchecked()
                                });
                    static MOTOR_OFF_BMP: OnceCell<Bmp<'static, Rgb565>> = OnceCell::new();
                    let motor_off_bmp =
                        MOTOR_OFF_BMP.get_or_init(||
                                unsafe {
                                    Bmp::from_slice(b"BM\x9e\x05\x00\x00\x00\x00\x00\x00\x8a\x00\x00\x00|\x00\x00\x00\x11\x00\x00\x00\x19\x00\x00\x00\x01\x00\x18\x00\x00\x00\x00\x00\x14\x05\x00\x00#.\x00\x00#.\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\xff\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00BGRs\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00! !1-11-11-1\x10\x0c\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x0c\x101-1!\x1c!! !1-1\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x001-1\x10\x10\x10\x08\x04\x081-1\x19\x18\x19\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00)$))()\x00\x00\x00\x10\x14\x101-1\x08\x08\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x10\x101-1\x00\x04\x00\x00\x00\x00)())()\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x001-1\x10\x0c\x10\x00\x00\x00\x08\x08\x081-1\x10\x14\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x001-1! !\x00\x00\x00\x00\x00\x00\x19\x18\x191-1\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x10\x101-1\x00\x00\x00\x00\x00\x00\x00\x00\x001-1! !\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x04\x00\x00\x04\x00\x00\x04\x00\x00\x04\x00\x00\x04\x00\x10\x0c\x101-1\x08\x0c\x08\x00\x00\x00\x00\x00\x00\x10\x0c\x101-1\x10\x0c\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x10\x101-11-11-11-11-11-11-1!\x1c!\x00\x00\x00\x00\x00\x00\x00\x00\x00! !1-1\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x001-1)()\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x0c\x10\x08\x0c\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x04\x081-1\x19\x18\x19\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00!$!)()\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x14\x101-1\x08\x08\x08\x00\x00\x00\x00\x00\x00\x00\x10\x0c\x101-1\x08\x04\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x001-1)$)\x00\x00\x00\x00\x00\x00\x00\x00\x00\x001-1\x19\x14\x19\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x19\x14\x191-11-11-11-11-11-11-1\x10\x14\x10\x00\x00\x00\x00\x00\x00\x00!\x1c!1-1\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x04\x081-1)-)! !! !! !! !! !! !\x00\x00\x00\x00\x00\x00\x00\x08\x08\x081-1\x08\x08\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00)()!$!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x001-1!\x1c!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x0c\x101-1\x08\x04\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x10\x101-1\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x001-1\x19\x14\x19\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x001-1\x10\x10\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x19\x1c\x191-1\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00! !)-)\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x08\x081-1\x08\x08\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x0c\x081-1\x08\x04\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00)-)! !\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x001-1!\x1c!\x10\x14\x10\x10\x14\x10\x10\x14\x10\x10\x14\x10)()1-1\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00! !1-11-11-11-11-11-11-1\x10\x14\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00").unwrap_unchecked()
                                });
                    let motor_im: Image<Bmp<Rgb565>> = Image::new(motor_bmp, position);
                    let motor_on_im: Image<Bmp<Rgb565>> =
                        Image::new(motor_on_bmp, position).translate(Point::new(34, 24));
                    let motor_off_im: Image<Bmp<Rgb565>> =
                        Image::new(motor_off_bmp, position).translate(Point::new(34, 24));
                    Self {
                        motor_im,
                        motor_on_im,
                        motor_off_im,
                        on: false,
                        needs_update: true,
                    }
                }
                pub fn update_on(&mut self, on: bool) {
                    if self.on != on {
                        self.on = on;
                        self.needs_update = true;
                    }
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if self.needs_update {
                        self.motor_im.draw(&mut target.color_converted())?;
                        if self.on {
                            self.motor_on_im.draw(&mut target.color_converted())?;
                        } else {
                            self.motor_off_im.draw(&mut target.color_converted())?;
                        }
                        self.needs_update = false;
                    }
                    Ok(())
                }
            }
        }
        mod motor_ice {
            use display_interface::DisplayError;
            use embedded_graphics::{
                image::Image,
                pixelcolor::{Gray4, Rgb565},
                prelude::*,
                primitives::*,
            };
            use once_cell::sync::OnceCell;
            use static_cell::StaticCell;
            use tinybmp::Bmp;
            pub struct MotorIce {
                motor_im: Image<'static, Bmp<'static, Rgb565>>,
                motor_on_im: Image<'static, Bmp<'static, Rgb565>>,
                motor_off_im: Image<'static, Bmp<'static, Rgb565>>,
                on: bool,
                needs_update: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for MotorIce {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "MotorIce",
                        "motor_im",
                        &self.motor_im,
                        "motor_on_im",
                        &self.motor_on_im,
                        "motor_off_im",
                        &self.motor_off_im,
                        "on",
                        &self.on,
                        "needs_update",
                        &&self.needs_update,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for MotorIce {
                #[inline]
                fn clone(&self) -> MotorIce {
                    MotorIce {
                        motor_im: ::core::clone::Clone::clone(&self.motor_im),
                        motor_on_im: ::core::clone::Clone::clone(&self.motor_on_im),
                        motor_off_im: ::core::clone::Clone::clone(&self.motor_off_im),
                        on: ::core::clone::Clone::clone(&self.on),
                        needs_update: ::core::clone::Clone::clone(&self.needs_update),
                    }
                }
            }
            impl Default for MotorIce {
                fn default() -> Self {
                    Self::new(Point::zero())
                }
            }
            impl MotorIce {
                pub fn new(position: Point) -> Self {
                    static MOTOR_BMP: OnceCell<Bmp<'static, Rgb565>> = OnceCell::new();
                    let motor_bmp =
                        MOTOR_BMP.get_or_init(||
                                unsafe {
                                    Bmp::from_slice(b"BM\x8a\x1a\x00\x00\x00\x00\x00\x00\x8a\x00\x00\x00|\x00\x00\x004\x00\x00\x00@\x00\x00\x00\x01\x00\x10\x00\x03\x00\x00\x00\x00\x1a\x00\x00#.\x00\x00#.\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf8\x00\x00\xe0\x07\x00\x00\x1f\x00\x00\x00\x00\x00\x00\x00BGRs\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00iJ\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x96\xb5\xc3\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00iJ\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff8\xc6$!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe3\x18a\x08\x00\x00\x00\x00!\x08!\x08!\x08!\x08!\x08!\x08!\x08!\x08!\x08!\x08!\x08!\x08!\x08A\x08,c\xff\xffY\xceE)\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \x00\xcbZ\xff\xff\xfb\xde\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8aR\xff\xff\xdf\xff\xe8A\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08B\x9e\xf7\xff\xffIJ\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa61]\xef\xff\xff\xaaR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00e)<\xe7\xff\xff,c \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$!y\xce\xff\xff\x8es \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf3\x9ce)\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe3\x18\xb6\xb5\xff\xff\xef{\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xa61E)\x00\x00\x00\x00\x00\x00\xe4 \xa61\xa61\xa61\xa61\xa61\xa61 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18U\xad\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x82\x10\xaaR\xabZ\xabZ\xabZ\xabZ\xabZ\xabZ\xabZMk\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\xcf{\xaaR\xaaR\xff\xff\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xffa\x08\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xffa\x08\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xffa\x08\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xffa\x08\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xffa\x08\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xffa\x08\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xffa\x08\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xffa\x08\x00\x00\x00\x00\xc3\x18A\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xffa\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff\xb6\xb5\xcbZ\xcbZ\xcbZ\xb2\x94\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xffa\x08\x00\x00\x00\x00\xaes$!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xffa\x08\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff\x18\xc6\x08B\x08B\x08B\x92\x94\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xffa\x08\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xffu\xadb\x10b\x10b\x10\x8es\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xff\x0cc\xcbZ\xcbZ\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xffu\xad\x82\x10b\x10b\x10\x8es\xff\xff\x861\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xffu\xad\x82\x10\x82\x10b\x10\x8es\xff\xff\x861\x00\x00\x00\x00\x861\x861\x861<\xe7\xff\xff\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff\xba\xd6\xcf{\xcf{\xcf{\x96\xb5\xff\xff\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xde\xff\xff\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xde\xff\xff\xa61\xa2\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff\xf3\x9c\xa61\xa61\xa61\xcf{\xff\xff\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xde\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xde\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xde\xff\xffE)\x82\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xde\xff\xff\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xde\xff\xff\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xde\xff\xff\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xde\xff\xff\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xde\xff\xff\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xde\xff\xff\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xde\xff\xff\x10\x84E)\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdb\xde\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa3\x18\x861\x861\x861\x861\x861\x861\x861\x861\x861(B\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\xaaRe)e)e)e)e)\x1c\xe7\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00A\x08U\xad\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x84\x00\x00\x00\x00\x00\x00\xaaR\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\x10!\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xebZ\xff\xffU\xad\x10\x84\x10\x84\x10\x84\x10\x84\x10\x84\x10\x84\x10\x84\x10\x84\x10\x84\x10\x84\xebZ\x00\x00\x00\x00\x00\x00\x08B\x10\x84\x10\x84\x10\x84\x10\x84\x10\x84\x10\x84\x10\x84\x10\x84\x10\x84\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xff\xff\x9d\xef\xe4 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00Q\x8c\xff\xff\xaaR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00IJ\xff\xff\xb2\x94!\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\xba\xd6\x9d\xef\x04!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \x00\xb2\x94\xff\xffiJ\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00IJ\xff\xff\xf3\x9c \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc3\x18\x9e\xf7}\xef\x04!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x82\x10A\x08\x00\x00\x00\x00\x00\x00\x00\x00\xa2\x10\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xa61\xa61\x92\x94\xff\xff\xcbZ\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa61\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\xa5A\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa61\xff\xff\xf3\x9c,c,c,c,c,c,c,c,c,c,c,c,c\x04!\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x84E)\x00\x00\x00\x00\x00\x00\x00\x00\xa61\xff\xff\xcbZ\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\xa61\xff\xff\xcbZ\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\xa61\xff\xff\xb2\x94\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\xcbZ\x861\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\xa61\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xaaR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\xa3\x18\x08B\x08B\x08B\x08B\x08B\x08B\x08B\x08B\x08B\x08B\x08B\x08B\x0cc\xff\xff\xaaR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x861\xff\xff\xaaR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\xa61\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x861\xff\xff\xaaR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x861\x82\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x861\xff\xff\xaaR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00iJ\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xaaR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00iJ\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xaaR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00").unwrap_unchecked()
                                });
                    static MOTOR_ON_BMP: OnceCell<Bmp<'static, Rgb565>> = OnceCell::new();
                    let motor_on_bmp =
                        MOTOR_ON_BMP.get_or_init(||
                                unsafe {
                                    Bmp::from_slice(b"BM.\x07\x00\x00\x00\x00\x00\x00\x8a\x00\x00\x00|\x00\x00\x00\x16\x00\x00\x00\x19\x00\x00\x00\x01\x00\x18\x00\x00\x00\x00\x00\xa4\x06\x00\x00#.\x00\x00#.\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\xff\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00BGRs\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x08\x08! !! !! !! !! !! !! !! !! !! !! !! !! !\x19\x18\x19\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00!\x1c!\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x84\x82\x84\x00\x00\x00\x00\x00\x00! !111)()\x08\x04\x08\x00\x00\x00\x00\x00\x19\x14\x19\xa5\xa2\xa5\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffZ]Z\x00\x00\x00RQR\xff\xff\xff\xff\xff\xff\xff\xff\xff\x84\x82\x84\x00\x00\x00\x00\x00\x00\x00\x00B=B\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf7\xfb\xf7\xff\xfb\xff\x00\x04\x00\x00\x00\x00\xc5\xc6\xc5\xff\xff\xffsus\xc5\xc2\xc5\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00B=B\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf7\xfb\xf7\xff\xfb\xff\x00\x04\x00\x00\x00\x00\xf7\xfb\xf7\xff\xff\xff\x19\x14\x19\x8c\x8a\x8c\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00B=B\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf7\xfb\xf7\xff\xfb\xff\x00\x04\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\x19\x14\x19\x8c\x8a\x8c\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00B=B\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf7\xfb\xf7\xff\xfb\xff\x00\x04\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\x19\x14\x19\x8c\x8a\x8c\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00B=B\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf7\xfb\xf7\xff\xfb\xff\x00\x04\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\x19\x14\x19\x8c\x8a\x8c\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00B=B\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf7\xfb\xf7\xff\xfb\xff\x00\x04\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\x19\x14\x19\x8c\x8a\x8c\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00B=B\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf7\xfb\xf7\xff\xfb\xff\x00\x04\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\x19\x14\x19\x8c\x8a\x8c\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00B=B\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf7\xfb\xf7\xff\xff\xff\x84\x86\x84\x84\x82\x84\xff\xff\xff\xf7\xf7\xf7\x10\x10\x10\x8c\x8a\x8c\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00B=B\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf7\xfb\xf7\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffcec\x00\x00\x00\x8c\x8a\x8c\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00B=B\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf7\xfb\xf7\xff\xff\xff! !\x19\x1c\x19\x19\x18\x19\x00\x00\x00\x00\x00\x00\x8c\x8a\x8c\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00BAB\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf7\xfb\xf7\xff\xfb\xff\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8c\x8a\x8c\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00B=B\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf7\xfb\xf7\xff\xfb\xff\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8c\x8a\x8c\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00B=B\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfb\xff\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x08\x08\x08\x08\x08\x00\x00\x00\x00\x00\x00\x00\x00B=B\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfb\xff\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00JMJZ]Z\x10\x10\x10\x00\x00\x00\x00\x00B=B\xff\xff\xffRQR\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf7\xf3\xf7\xff\xfb\xff\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x9c\x9e\x9c\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00B=B\xff\xff\xffBAB\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xef\xf3\xef\xff\xfb\xff\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x9c\x9e\x9c\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00B=B\xff\xff\xffBAB\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xef\xf3\xef\xff\xfb\xff\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x9c\xa2\x9c\xff\xff\xff\x19\x18\x19\x00\x00\x00\x00\x00B=B\xff\xff\xffBAB\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xef\xf3\xef\xff\xfb\xff\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x10\x10\xe6\xeb\xe6\xde\xdb\xde\x10\x0c\x10\x00\x00\x00\x00\x00B=B\xff\xff\xffBAB\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xef\xf3\xef\xff\xfb\xff\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00ZUZ\xff\xff\xffcac\x00\x00\x00\x00\x00\x00\x00\x00:9:\xff\xff\xff\xb5\xb2\xb5\x84\x86\x84\x84\x86\x84\x84\x86\x84\x84\x86\x84\x84\x86\x84\x84\x86\x84\x84\x86\x84\x8c\x8a\x8c\xff\xff\xff\xce\xce\xce\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x0c\x10\xce\xca\xce\xff\xff\xff\x19\x14\x19\x00\x00\x00\x00\x00\x00\x00\x00\x08\x0c\x08\x9c\x9e\x9c\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffBEB\x00\x00\x00\x00\x00\x00\x00\x00\x00\x19\x14\x19suskik\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x19\x18\x19\x19\x18\x19\x19\x18\x19\x19\x18\x19\x19\x18\x19\x19\x18\x19\x19\x18\x19\x19\x18\x19\x19\x18\x19\x10\x10\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00").unwrap_unchecked()
                                });
                    static MOTOR_OFF_BMP: OnceCell<Bmp<'static, Rgb565>> = OnceCell::new();
                    let motor_off_bmp =
                        MOTOR_OFF_BMP.get_or_init(||
                                unsafe {
                                    Bmp::from_slice(b"BM.\x07\x00\x00\x00\x00\x00\x00\x8a\x00\x00\x00|\x00\x00\x00\x16\x00\x00\x00\x19\x00\x00\x00\x01\x00\x18\x00\x00\x00\x00\x00\xa4\x06\x00\x00#.\x00\x00#.\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\xff\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00BGRs\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\x0c\x0c\x0c\x00\x00\x00\x00\x00\x00\x01\x01\x01\x02\x02\x02\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x12\x12\x12\"\"\"\x15\x15\x15\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0f\x0e\x0f\"\"\"\"\"\"\x05\x06\x05\x00\x00\x00\x04\x04\x04\"\"\"\"\"\"\"\"\"\x0c\x0c\x0c\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x05\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 ! \"!\"\x00\x00\x00\x00\x00\x00\x17\x18\x17\"\"\"\t\t\t\x17\x17\x17\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x05\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 ! \"!\"\x00\x00\x00\x00\x00\x00 ! \"\"\"\x00\x00\x00\x0e\r\x0e\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x05\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 ! \"!\"\x00\x00\x00\x00\x00\x00\"\"\"\"\"\"\x00\x00\x00\x0e\r\x0e\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x05\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 ! \"!\"\x00\x00\x00\x00\x00\x00\"\"\"\"\"\"\x00\x00\x00\x0e\r\x0e\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x05\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 ! \"!\"\x00\x00\x00\x00\x00\x00\"\"\"\"\"\"\x00\x00\x00\x0e\r\x0e\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x05\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 ! \"!\"\x00\x00\x00\x00\x00\x00\"\"\"\"\"\"\x00\x00\x00\x0e\r\x0e\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x05\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 ! \"!\"\x00\x00\x00\x00\x00\x00\"\"\"\"\"\"\x00\x00\x00\x0e\r\x0e\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x05\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 ! \"\"\"\x0c\x0c\x0c\x0c\x0c\x0c\"\"\"   \x00\x00\x00\x0e\r\x0e\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x05\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 ! \"\"\"\"\"\"\"\"\"\"\"\"\x06\x07\x06\x00\x00\x00\x0e\r\x0e\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x05\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 ! \"\"\"\x01\x01\x01\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0e\r\x0e\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x03\x03\"\"\"\x05\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 ! \"!\"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0e\r\x0e\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x05\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 ! \"!\"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0e\r\x0e\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"   \x1d\x1e\x1d\x1d\x1e\x1d\x1d\x1e\x1d\x1d\x1e\x1d\x1d\x1e\x1d\x1d\x1e\x1d\x1d\x1e\x1d\x1d\x1e\x1d\"\"\"\"!\"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"!\"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x04\x03\x05\x06\x05\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x04\x04\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00   \"!\"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x10\x10\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x03\x03\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f \x1f\"!\"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x10\x10\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x03\x03\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f \x1f\"!\"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x12\x10\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x03\x03\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f \x1f\"!\"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1d\x1e\x1d\x1c\x1b\x1c\x00\x00\x00\x00\x00\x00\x00\x00\x03\x02\x03\"\"\"\x03\x03\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1f \x1f\"!\"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05\x05\x05\"\"\"\x06\x06\x06\x00\x00\x00\x00\x00\x00\x00\x00\x02\x02\x02\"\"\"\x15\x14\x15\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0e\r\x0e\"\"\"\x19\x19\x19\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x19\x19\x19\"\"\"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x10\x10\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\x03\x03\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\t\t\t\x07\x07\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00").unwrap_unchecked()
                                });
                    let motor_im: Image<Bmp<Rgb565>> = Image::new(motor_bmp, position);
                    let motor_on_im: Image<Bmp<Rgb565>> =
                        Image::new(motor_on_bmp, position).translate(Point::new(5, 24));
                    let motor_off_im: Image<Bmp<Rgb565>> =
                        Image::new(motor_off_bmp, position).translate(Point::new(5, 24));
                    Self {
                        motor_im,
                        motor_on_im,
                        motor_off_im,
                        on: false,
                        needs_update: true,
                    }
                }
                pub fn update_on(&mut self, on: bool) -> bool {
                    if self.on != on {
                        self.on = on;
                        self.needs_update = true;
                    }
                    self.needs_update
                }
                pub fn is_redraw(&self) -> bool {
                    self.needs_update
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if self.needs_update {
                        self.motor_im.draw(&mut target.color_converted())?;
                        if self.on {
                            self.motor_on_im.draw(&mut target.color_converted())?;
                        } else {
                            self.motor_off_im.draw(&mut target.color_converted())?;
                        }
                        self.needs_update = false;
                    }
                    Ok(())
                }
            }
        }
        mod obd2_debug_selector {
            use core::{fmt::Write, str::FromStr as _};
            use defmt::info;
            use display_interface::DisplayError;
            use embassy_time::Instant;
            use embedded_graphics::{
                mono_font::{
                    ascii::{FONT_10X20, FONT_6X10, FONT_6X13_BOLD, FONT_9X15_BOLD},
                    MonoTextStyle,
                },
                pixelcolor::Gray4,
                prelude::*,
                primitives::*,
                text::{Alignment, LineHeight, Text, TextStyleBuilder},
            };
            use heapless::String;
            use num_traits::float::FloatCore;
            use profont::*;
            use crate::{
                debug::{DEBUG_CHANNEL_LEN, DEBUG_STRING_LEN},
                tasks::obd2::Obd2Debug,
            };
            pub struct Obd2DebugSelector {
                pids: heapless::FnvIndexMap<&'static str, Obd2Debug, 16>,
                redraw: bool,
            }
            #[automatically_derived]
            impl ::core::default::Default for Obd2DebugSelector {
                #[inline]
                fn default() -> Obd2DebugSelector {
                    Obd2DebugSelector {
                        pids: ::core::default::Default::default(),
                        redraw: ::core::default::Default::default(),
                    }
                }
            }
            impl Obd2DebugSelector {
                pub fn new() -> Self {
                    Self {
                        pids: Default::default(),
                        redraw: false,
                    }
                }
                pub fn handle_obd2_debug(&mut self, debug: &Obd2Debug) {
                    if let Some(pid) = self.pids.get_mut(debug.type_id) {
                        pid.data = debug.data.clone();
                    } else {
                        self.pids.insert(debug.type_id, debug.clone()).ok();
                    }
                    self.redraw = true;
                }
                pub fn draw<D: DrawTarget<Color = Gray4>, D2: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                    target2: &mut D2,
                ) -> Result<(), ()> {
                    if self.redraw {
                        target.clear(Gray4::BLACK).map_err(|_| ())?;
                        target2.clear(Gray4::BLACK).map_err(|_| ())?;
                        let character_style = MonoTextStyle::new(&PROFONT_7_POINT, Gray4::WHITE);
                        let text_style = TextStyleBuilder::new()
                            .alignment(Alignment::Left)
                            .line_height(LineHeight::Percent(100))
                            .build();
                        let mut position = Point::new(0, 6);
                        for (pid, buffer) in &self.pids {
                            let mut text = String::<64>::new();
                            if let Some(data) = &buffer.data {
                                text.write_fmt(format_args!("{0}: {1:x?}", pid, data)).ok();
                            } else {
                                text.write_fmt(format_args!("{0}: None", pid)).ok();
                            }
                            let text =
                                Text::with_text_style(&text, position, character_style, text_style);
                            text.draw(target).map_err(|_| ())?;
                            position += Point::new(0, 8);
                        }
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        mod position {
            use alloc::{borrow::Cow, string::ToString as _};
            use core::fmt::Write;
            use display_interface::DisplayError;
            use embedded_graphics::{
                image::Image,
                pixelcolor::Gray4,
                prelude::*,
                primitives::{Rectangle, StyledDrawable as _},
            };
            use embedded_iconoir::prelude::IconoirNewIcon as _;
            pub struct Position {
                position: Point,
                redraw: bool,
                last_position: bool,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Position {
                #[inline]
                fn clone(&self) -> Position {
                    Position {
                        position: ::core::clone::Clone::clone(&self.position),
                        redraw: ::core::clone::Clone::clone(&self.redraw),
                        last_position: ::core::clone::Clone::clone(&self.last_position),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Position {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Position",
                        "position",
                        &self.position,
                        "redraw",
                        &self.redraw,
                        "last_position",
                        &&self.last_position,
                    )
                }
            }
            impl Default for Position {
                fn default() -> Self {
                    Self {
                        position: Point::zero(),
                        redraw: true,
                        last_position: false,
                    }
                }
            }
            impl Position {
                pub fn new(position: Point) -> Self {
                    Self {
                        position,
                        ..Default::default()
                    }
                }
                pub fn update_last_position(&mut self, last_position: bool) {
                    if self.last_position == last_position {
                        return;
                    }
                    self.last_position = last_position;
                    self.redraw = true;
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if self.redraw {
                        if self.last_position {
                            let icon = embedded_iconoir::icons::size18px::maps::Position::new(
                                GrayColor::WHITE,
                            );
                            let image = Image::new(&icon, self.position);
                            image.draw(target)?;
                        } else {
                            let style = embedded_graphics::primitives::PrimitiveStyleBuilder::new()
                                .stroke_width(0)
                                .stroke_color(Gray4::BLACK)
                                .fill_color(Gray4::BLACK)
                                .build();
                            let bounding_box = Rectangle::new(self.position, Size::new(18, 18));
                            bounding_box.draw_styled(&style, target)?;
                        }
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        mod power {
            use core::fmt::Write;
            use display_interface::DisplayError;
            use embedded_graphics::{
                mono_font::{
                    ascii::{FONT_10X20, FONT_6X10, FONT_6X13_BOLD, FONT_9X15_BOLD},
                    MonoTextStyle,
                },
                pixelcolor::Gray4,
                prelude::*,
                primitives::*,
                text::{Alignment, LineHeight, Text, TextStyleBuilder},
            };
            use heapless::String;
            use num_traits::float::FloatCore;
            use profont::*;
            use crate::display::RotatedDrawTarget;
            pub struct Power {
                position: Point,
                power: f32,
                current: f32,
                redraw: bool,
                bounding_box: Option<Rectangle>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Power {
                #[inline]
                fn clone(&self) -> Power {
                    let _: ::core::clone::AssertParamIsClone<Point>;
                    let _: ::core::clone::AssertParamIsClone<f32>;
                    let _: ::core::clone::AssertParamIsClone<bool>;
                    let _: ::core::clone::AssertParamIsClone<Option<Rectangle>>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Power {}
            #[automatically_derived]
            impl ::core::fmt::Debug for Power {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "Power",
                        "position",
                        &self.position,
                        "power",
                        &self.power,
                        "current",
                        &self.current,
                        "redraw",
                        &self.redraw,
                        "bounding_box",
                        &&self.bounding_box,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for Power {
                #[inline]
                fn default() -> Power {
                    Power {
                        position: ::core::default::Default::default(),
                        power: ::core::default::Default::default(),
                        current: ::core::default::Default::default(),
                        redraw: ::core::default::Default::default(),
                        bounding_box: ::core::default::Default::default(),
                    }
                }
            }
            impl Power {
                pub fn new(position: Point) -> Self {
                    Self {
                        position,
                        power: 0.0,
                        current: 0.0,
                        redraw: true,
                        bounding_box: None,
                    }
                }
                pub fn update_power(&mut self, power: f32) {
                    if self.power != power {
                        self.power = power;
                        self.redraw = true;
                    }
                }
                pub fn update_current(&mut self, current: f32) {
                    if self.current != current {
                        self.current = current;
                        self.redraw = true;
                    }
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if self.redraw {
                        let mut text: String<16> = String::new();
                        text.write_fmt(format_args!("{0:.2}kW", self.power / 1000.0))
                            .ok();
                        let character_style = MonoTextStyle::new(&PROFONT_12_POINT, Gray4::WHITE);
                        let text_style = TextStyleBuilder::new()
                            .alignment(Alignment::Center)
                            .line_height(LineHeight::Percent(100))
                            .build();
                        let text = Text::with_text_style(
                            text.as_str(),
                            self.position,
                            character_style,
                            text_style,
                        );
                        let new_bounding_box = text.bounding_box();
                        if new_bounding_box.size.width
                            > self.bounding_box.map(|bb| bb.size.width).unwrap_or(0)
                        {
                            self.bounding_box = Some(new_bounding_box);
                        }
                        if let Some(bb) = self.bounding_box {
                            bb.draw_styled(
                                &PrimitiveStyleBuilder::new()
                                    .fill_color(Gray4::BLACK)
                                    .build(),
                                target,
                            )?;
                        }
                        text.draw(target)?;
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        mod slider {
            use core::fmt::Write;
            use display_interface::DisplayError;
            use embedded_graphics::{
                mono_font::{
                    ascii::{FONT_10X20, FONT_6X10, FONT_6X13_BOLD, FONT_9X15_BOLD},
                    MonoTextStyle,
                },
                pixelcolor::Gray4,
                prelude::*,
                primitives::*,
                text::{Alignment, LineHeight, Text, TextStyleBuilder},
            };
            use heapless::String;
            use num_traits::float::FloatCore;
            use profont::*;
            pub struct Slider {
                percentage: f64,
                size: Size,
                position: Point,
                redraw: bool,
            }
            #[automatically_derived]
            impl ::core::default::Default for Slider {
                #[inline]
                fn default() -> Slider {
                    Slider {
                        percentage: ::core::default::Default::default(),
                        size: ::core::default::Default::default(),
                        position: ::core::default::Default::default(),
                        redraw: ::core::default::Default::default(),
                    }
                }
            }
            impl Slider {
                pub fn new(position: Point, size: Size) -> Self {
                    Self {
                        position,
                        size,
                        percentage: 0.0,
                        redraw: true,
                    }
                }
                pub fn update_percentage(&mut self, percentage: f64) {
                    if self.percentage != percentage {
                        self.percentage = percentage;
                        self.redraw = true;
                    }
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if self.redraw {
                        let style = PrimitiveStyleBuilder::new()
                            .stroke_width(1)
                            .stroke_color(Gray4::WHITE)
                            .fill_color(Gray4::BLACK)
                            .build();
                        Rectangle::new(self.position, self.size).draw_styled(&style, target)?;
                        let mut bar_style = style;
                        bar_style.stroke_color = Some(Gray4::new(0x01));
                        bar_style.fill_color = Some(Gray4::new(0x01));
                        let mut bar_size = Size::new(
                            (self.size.width as f64 * self.percentage / 100.0).round() as u32,
                            self.size.height,
                        );
                        if bar_size.width > 0 {
                            let mut bar_style = style;
                            bar_style.stroke_width = 0;
                            bar_style.fill_color = Some(Gray4::new(0x01));
                            bar_size.width = bar_size.width.saturating_sub(4);
                            bar_size.height = bar_size.height.saturating_sub(4);
                            let mut bar_position = self.position;
                            bar_position.x += 2;
                            bar_position.y += 2;
                            Rectangle::new(bar_position, bar_size)
                                .draw_styled(&bar_style, target)?;
                        }
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        mod temperature {
            use core::fmt::Write;
            use display_interface::DisplayError;
            use embedded_graphics::{
                mono_font::{
                    ascii::{FONT_10X20, FONT_6X10, FONT_6X13_BOLD, FONT_9X15_BOLD},
                    MonoTextStyle,
                },
                pixelcolor::Gray4,
                prelude::*,
                primitives::*,
                text::{Alignment, LineHeight, Text, TextStyleBuilder},
            };
            use heapless::String;
            use num_traits::float::FloatCore;
            use profont::*;
            use crate::display::RotatedDrawTarget;
            pub struct Temperature {
                max_temp: f32,
                min_temp: f32,
                current_temp: f32,
                current_temp_percentage: f32,
                size: Size,
                position: Point,
                bars: i32,
                redraw: bool,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Temperature {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "max_temp",
                        "min_temp",
                        "current_temp",
                        "current_temp_percentage",
                        "size",
                        "position",
                        "bars",
                        "redraw",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.max_temp,
                        &self.min_temp,
                        &self.current_temp,
                        &self.current_temp_percentage,
                        &self.size,
                        &self.position,
                        &self.bars,
                        &&self.redraw,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Temperature",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Temperature {
                #[inline]
                fn clone(&self) -> Temperature {
                    let _: ::core::clone::AssertParamIsClone<f32>;
                    let _: ::core::clone::AssertParamIsClone<Size>;
                    let _: ::core::clone::AssertParamIsClone<Point>;
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    let _: ::core::clone::AssertParamIsClone<bool>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Temperature {}
            #[automatically_derived]
            impl ::core::default::Default for Temperature {
                #[inline]
                fn default() -> Temperature {
                    Temperature {
                        max_temp: ::core::default::Default::default(),
                        min_temp: ::core::default::Default::default(),
                        current_temp: ::core::default::Default::default(),
                        current_temp_percentage: ::core::default::Default::default(),
                        size: ::core::default::Default::default(),
                        position: ::core::default::Default::default(),
                        bars: ::core::default::Default::default(),
                        redraw: ::core::default::Default::default(),
                    }
                }
            }
            impl Temperature {
                pub fn new(position: Point, size: Size, min: f32, max: f32, bars: i32) -> Self {
                    Self {
                        position,
                        size,
                        current_temp: 0.0,
                        current_temp_percentage: 0.0,
                        max_temp: max,
                        min_temp: min,
                        bars,
                        redraw: true,
                    }
                }
                pub fn update_temp(&mut self, temp: f32) {
                    if self.current_temp != temp {
                        self.current_temp = temp;
                        self.current_temp_percentage =
                            (temp - self.min_temp) / (self.max_temp - self.min_temp);
                        if self.current_temp > self.max_temp {
                            self.current_temp_percentage = 1.0;
                        } else if self.current_temp < self.min_temp {
                            self.current_temp_percentage = 0.0;
                        }
                        self.redraw = true;
                    }
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if self.redraw {
                        let color = Gray4::new(6);
                        let mut style = PrimitiveStyleBuilder::new()
                            .stroke_width(2)
                            .stroke_color(Gray4::WHITE)
                            .fill_color(Gray4::BLACK)
                            .build();
                        let mut size = self.size;
                        size.width /= 2;
                        size.height -= self.size.width / 2;
                        let mut area = Rectangle::new(
                            self.position + Point::new(self.size.width as i32 / 2, 0),
                            size,
                        );
                        area.draw_styled(&style, target)?;
                        let mut circle_bottom = Circle::with_center(
                            self.position
                                + Point::new(
                                    self.size.width as i32 / 4,
                                    self.size.height as i32 - (self.size.width as i32 / 2),
                                )
                                + Point::new(size.width as i32 - 1, -2),
                            self.size.width,
                        );
                        circle_bottom.draw_styled(&style, target)?;
                        let circle = Circle::with_center(
                            self.position + Point::new(self.size.width as i32 / 2 + 3, 4),
                            self.size.width / 2,
                        );
                        style.fill_color = Some(Gray4::BLACK);
                        let mut circle_box = circle.bounding_box();
                        circle_box.size.width += 2;
                        circle_box.size.height -= 1;
                        circle_box.top_left.x -= 1;
                        circle_box.top_left.y -= 1;
                        target.fill_solid(&circle_box, Gray4::BLACK)?;
                        circle.draw_styled(&style, target)?;
                        style.stroke_color = Some(color);
                        area.size.height -= 4;
                        area.size.width -= 2;
                        area.top_left.x += 1;
                        area.top_left.y += 3;
                        let mut area_clipped = target.clipped(&area.bounding_box());
                        area_clipped.fill_solid(&area, Gray4::BLACK)?;
                        let mut size = self.size;
                        size.width /= 2;
                        size.height = ((self.size.height as f32 - 8.0)
                            * self.current_temp_percentage)
                            .round() as u32;
                        size.width -= 6;
                        style.fill_color = Some(color);
                        let mut position =
                            self.position + Point::new(self.size.width as i32 / 2, 0);
                        position.x += 3;
                        position.y = self.position.y + (self.size.height - 6) as i32
                            - size.height as i32
                            + 2;
                        let mut area_filled = Rectangle::new(position, size);
                        area_filled.draw_styled(&style, target)?;
                        area_filled.size.width = self.size.width;
                        area_filled.top_left.x -= self.size.width as i32 / 2;
                        area_filled.top_left.y -= 1;
                        area_filled.size.height += 1;
                        let mut area_filled = target.clipped(&area_filled);
                        circle_bottom.diameter -= 6;
                        circle_bottom.top_left.y += 3;
                        circle_bottom.top_left.x += 3;
                        circle_bottom.draw_styled(&style, &mut area_filled)?;
                        let mut text: String<16> = String::new();
                        text.write_fmt(format_args!("{0:.0}°C", self.current_temp))
                            .ok();
                        let character_style = MonoTextStyle::new(&PROFONT_10_POINT, Gray4::WHITE);
                        let text_style = TextStyleBuilder::new()
                            .alignment(Alignment::Left)
                            .line_height(LineHeight::Percent(100))
                            .build();
                        let mut rotate_target = RotatedDrawTarget::new(target);
                        let text_position = Point::new(0, 256 - self.position.x + 5);
                        let text = Text::with_text_style(
                            text.as_str(),
                            text_position,
                            character_style,
                            text_style,
                        );
                        let text_box = Rectangle::with_center(
                            text_position - Point::new(1, 2),
                            Size::new(42, 12),
                        );
                        rotate_target.fill_solid(&text_box, Gray4::BLACK)?;
                        text.draw(&mut rotate_target)?;
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        mod text {
            use alloc::{borrow::Cow, string::ToString as _};
            use core::fmt::Write;
            use display_interface::DisplayError;
            use embedded_graphics::{
                mono_font::{
                    ascii::{FONT_10X20, FONT_6X10, FONT_6X13_BOLD, FONT_9X15_BOLD},
                    MonoFont, MonoTextStyle,
                },
                pixelcolor::Gray4,
                prelude::*,
                primitives::*,
                text::{Alignment, LineHeight, Text as EmbeddedText, TextStyleBuilder},
            };
            use heapless::String;
            use num_traits::float::FloatCore;
            use profont::*;
            use crate::display::RotatedDrawTarget;
            pub struct Text {
                position: Point,
                font: &'static MonoFont<'static>,
                text: Cow<'static, str>,
                selected: bool,
                redraw: bool,
                bounding_box: Option<Rectangle>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Text {
                #[inline]
                fn clone(&self) -> Text {
                    Text {
                        position: ::core::clone::Clone::clone(&self.position),
                        font: ::core::clone::Clone::clone(&self.font),
                        text: ::core::clone::Clone::clone(&self.text),
                        selected: ::core::clone::Clone::clone(&self.selected),
                        redraw: ::core::clone::Clone::clone(&self.redraw),
                        bounding_box: ::core::clone::Clone::clone(&self.bounding_box),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Text {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "position",
                        "font",
                        "text",
                        "selected",
                        "redraw",
                        "bounding_box",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.position,
                        &self.font,
                        &self.text,
                        &self.selected,
                        &self.redraw,
                        &&self.bounding_box,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(f, "Text", names, values)
                }
            }
            impl Default for Text {
                fn default() -> Self {
                    Self {
                        position: Point::zero(),
                        font: &PROFONT_9_POINT,
                        redraw: true,
                        selected: false,
                        bounding_box: None,
                        text: Cow::Borrowed(""),
                    }
                }
            }
            impl Text {
                pub fn new(
                    position: Point,
                    font: &'static MonoFont,
                    initial_str: Option<&'static str>,
                ) -> Self {
                    let mut ret = Self {
                        position,
                        redraw: true,
                        bounding_box: None,
                        font,
                        text: Cow::Borrowed(""),
                        selected: false,
                    };
                    if let Some(str) = initial_str {
                        ret.update_str(str);
                    }
                    ret
                }
                pub fn update_str(&mut self, str: &'static str) {
                    if self.text != str {
                        self.text = Cow::Borrowed(str);
                        self.redraw = true;
                    }
                }
                pub fn update_string(&mut self, str: &str) {
                    if self.text != str {
                        self.text = Cow::Owned(str.to_string());
                        self.redraw = true;
                    }
                }
                pub fn update_selected(&mut self, selected: bool) {
                    if self.selected != selected {
                        self.selected = selected;
                        self.redraw = true;
                    }
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if self.redraw {
                        let character_style = MonoTextStyle::new(&self.font, Gray4::WHITE);
                        let mut text_style = TextStyleBuilder::new()
                            .alignment(Alignment::Left)
                            .line_height(LineHeight::Percent(100))
                            .build();
                        let mut text = EmbeddedText::with_text_style(
                            self.text.as_ref(),
                            self.position,
                            character_style,
                            text_style,
                        );
                        if self.selected {
                            text.character_style.background_color = Some(Gray4::WHITE);
                            text.character_style.text_color = Some(Gray4::BLACK);
                        }
                        let new_bounding_box = text.bounding_box();
                        if new_bounding_box.size.width
                            > self.bounding_box.map(|bb| bb.size.width).unwrap_or(0)
                        {
                            self.bounding_box = Some(new_bounding_box);
                        }
                        if let Some(bb) = self.bounding_box {
                            bb.draw_styled(
                                &PrimitiveStyleBuilder::new()
                                    .fill_color(Gray4::BLACK)
                                    .build(),
                                target,
                            )?;
                        }
                        text.draw(target)?;
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        mod value {
            use core::fmt::Write;
            use display_interface::DisplayError;
            use embedded_graphics::{
                mono_font::{
                    ascii::{FONT_10X20, FONT_6X10, FONT_6X13_BOLD, FONT_9X15_BOLD},
                    MonoFont, MonoTextStyle,
                },
                pixelcolor::Gray4,
                prelude::*,
                primitives::*,
                text::{Alignment, LineHeight, Text, TextStyleBuilder},
            };
            use heapless::String;
            use num_traits::float::FloatCore;
            use profont::*;
            use crate::display::RotatedDrawTarget;
            pub struct Value {
                position: Point,
                value: f32,
                font: &'static MonoFont<'static>,
                unit: &'static str,
                precision: usize,
                redraw: bool,
                bounding_box: Option<Rectangle>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Value {
                #[inline]
                fn clone(&self) -> Value {
                    let _: ::core::clone::AssertParamIsClone<Point>;
                    let _: ::core::clone::AssertParamIsClone<f32>;
                    let _: ::core::clone::AssertParamIsClone<&'static MonoFont<'static>>;
                    let _: ::core::clone::AssertParamIsClone<&'static str>;
                    let _: ::core::clone::AssertParamIsClone<usize>;
                    let _: ::core::clone::AssertParamIsClone<bool>;
                    let _: ::core::clone::AssertParamIsClone<Option<Rectangle>>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Value {}
            #[automatically_derived]
            impl ::core::fmt::Debug for Value {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "position",
                        "value",
                        "font",
                        "unit",
                        "precision",
                        "redraw",
                        "bounding_box",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.position,
                        &self.value,
                        &self.font,
                        &self.unit,
                        &self.precision,
                        &self.redraw,
                        &&self.bounding_box,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(f, "Value", names, values)
                }
            }
            impl Default for Value {
                fn default() -> Self {
                    Self {
                        position: Point::zero(),
                        value: 0.0,
                        font: &PROFONT_9_POINT,
                        unit: "",
                        precision: 0,
                        redraw: true,
                        bounding_box: None,
                    }
                }
            }
            impl Value {
                pub fn new(
                    position: Point,
                    font: &'static MonoFont,
                    unit: &'static str,
                    precision: usize,
                ) -> Self {
                    Self {
                        position,
                        value: 0.0,
                        unit,
                        redraw: true,
                        bounding_box: None,
                        precision,
                        font,
                    }
                }
                pub fn update_value(&mut self, value: f32) {
                    if self.value != value {
                        self.value = value;
                        self.redraw = true;
                    }
                }
                pub fn draw<D: DrawTarget<Color = Gray4>>(
                    &mut self,
                    target: &mut D,
                ) -> Result<(), D::Error> {
                    if self.redraw {
                        let mut text: String<16> = String::new();
                        text.write_fmt(format_args!("{0:.1$}", self.value, self.precision))
                            .ok();
                        text.write_fmt(format_args!("{0}", self.unit)).ok();
                        let character_style = MonoTextStyle::new(&self.font, Gray4::WHITE);
                        let text_style = TextStyleBuilder::new()
                            .alignment(Alignment::Left)
                            .line_height(LineHeight::Percent(100))
                            .build();
                        let text = Text::with_text_style(
                            text.as_str(),
                            self.position,
                            character_style,
                            text_style,
                        );
                        let new_bounding_box = text.bounding_box();
                        if new_bounding_box.size.width
                            > self.bounding_box.map(|bb| bb.size.width).unwrap_or(0)
                        {
                            self.bounding_box = Some(new_bounding_box);
                        }
                        if let Some(bb) = self.bounding_box {
                            bb.draw_styled(
                                &PrimitiveStyleBuilder::new()
                                    .fill_color(Gray4::BLACK)
                                    .build(),
                                target,
                            )?;
                        }
                        text.draw(target)?;
                        self.redraw = false;
                    }
                    Ok(())
                }
            }
        }
        pub use arrow::{Arrow, ArrowDirection};
        pub use battery::{Battery, BatteryOrientation};
        pub use battery_12v::Battery12V;
        pub use connection::Connection;
        pub use debug::DebugScroll;
        pub use fuel::Fuel;
        pub use gearbox_gear::GearboxGear;
        pub use ice_fuel_rate::IceFuelRate;
        pub use icon::Icon;
        pub use motor_electric::MotorElectric;
        pub use motor_ice::MotorIce;
        pub use obd2_debug_selector::Obd2DebugSelector;
        pub use position::Position;
        pub use power::Power;
        pub use slider::Slider;
        pub use temperature::Temperature;
        pub use text::Text;
        pub use value::Value;
    }
    pub struct RotatedDrawTarget<'a, T>
    where
        T: DrawTarget,
    {
        parent: &'a mut T,
    }
    #[automatically_derived]
    impl<'a, T: ::core::fmt::Debug> ::core::fmt::Debug for RotatedDrawTarget<'a, T>
    where
        T: DrawTarget,
    {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "RotatedDrawTarget",
                "parent",
                &&self.parent,
            )
        }
    }
    impl<'a, T> RotatedDrawTarget<'a, T>
    where
        T: DrawTarget,
    {
        pub fn new(parent: &'a mut T) -> Self {
            Self { parent }
        }
    }
    impl<T> DrawTarget for RotatedDrawTarget<'_, T>
    where
        T: DrawTarget,
    {
        type Color = T::Color;
        type Error = T::Error;
        fn draw_iter<I>(&mut self, pixels: I) -> Result<(), Self::Error>
        where
            I: IntoIterator<Item = Pixel<Self::Color>>,
        {
            let parent_width = self.parent.bounding_box().size.width as i32;
            self.parent.draw_iter(
                pixels
                    .into_iter()
                    .map(|Pixel(p, c)| Pixel(Point::new(parent_width - p.y, p.x), c)),
            )
        }
    }
    impl<T> Dimensions for RotatedDrawTarget<'_, T>
    where
        T: DrawTarget,
    {
        fn bounding_box(&self) -> Rectangle {
            let parent_bb = self.parent.bounding_box();
            Rectangle::new(
                parent_bb.top_left,
                Size::new(parent_bb.size.height, parent_bb.size.width),
            )
        }
    }
}
mod event {
    use defmt::{unwrap, Format};
    use embassy_sync::{
        blocking_mutex::raw::CriticalSectionRawMutex,
        pubsub::{DynPublisher, DynSubscriber, PubSubChannel},
    };
    pub use crate::tasks::{
        lcd::{LcdEvent, EVENTS as LCD_EVENTS},
        obd2::{Obd2Error, Obd2Event},
        state::{KiaEvent, EVENTS as KIA_EVENTS},
    };
    pub enum Event {
        Lcd(LcdEvent),
        Obd2(Obd2Event),
        Kia(KiaEvent),
    }
    impl defmt::Format for Event
    where
        LcdEvent: defmt::Format,
        Obd2Event: defmt::Format,
        KiaEvent: defmt::Format,
    {
        fn format(&self, f: defmt::Formatter) {
            {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::event".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"14322613239957429495\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"14322613239957429495\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                defmt::export::panic()
            }
        }
        fn _format_tag() -> defmt::Str {
            {
                defmt::export::make_istr({
                    #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"Lcd({=?})|Obd2({=?})|Kia({=?})\",\"disambiguator\":\"15121056208259309650\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"Lcd({=?})|Obd2({=?})|Kia({=?})\",\"disambiguator\":\"15121056208259309650\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                    static S: u8 = 0;
                    &S as *const u8 as u16
                })
            }
        }
        fn _format_data(&self) {
            match self {
                Event::Lcd { 0: arg0 } => {
                    defmt::export::u8(&0u8);
                    defmt::export::fmt(arg0);
                }
                Event::Obd2 { 0: arg0 } => {
                    defmt::export::u8(&1u8);
                    defmt::export::fmt(arg0);
                }
                Event::Kia { 0: arg0 } => {
                    defmt::export::u8(&2u8);
                    defmt::export::fmt(arg0);
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Event {
        #[inline]
        fn clone(&self) -> Event {
            match self {
                Event::Lcd(__self_0) => Event::Lcd(::core::clone::Clone::clone(__self_0)),
                Event::Obd2(__self_0) => Event::Obd2(::core::clone::Clone::clone(__self_0)),
                Event::Kia(__self_0) => Event::Kia(::core::clone::Clone::clone(__self_0)),
            }
        }
    }
    static EVENT_BUS: PubSubChannel<CriticalSectionRawMutex, Event, 128, 32, 32> =
        PubSubChannel::new();
    pub fn event_bus_sub() -> EventBusSub {
        match defmt::export::into_result(EVENT_BUS.dyn_subscriber()) {
            ::core::result::Result::Ok(res) => res,
            ::core::result::Result::Err(_unwrap_err) => {
                match (&(_unwrap_err)) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::event".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe {
                                defmt::export::acquire_and_header(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: EVENT_BUS.dyn_subscriber()'\\nerror: `{:?}`\",\"disambiguator\":\"17495576261828646627\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: EVENT_BUS.dyn_subscriber()'\\nerror: `{:?}`\",\"disambiguator\":\"17495576261828646627\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            };
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                defmt::export::panic()
            }
        }
    }
    pub type EventBusPub = DynPublisher<'static, Event>;
    pub type EventBusSub = DynSubscriber<'static, Event>;
}
mod hal {
    use defmt::{info, unwrap, warn};
    use display_interface_spi::SPIInterface;
    use embassy_embedded_hal::shared_bus::asynch::spi::{SpiDevice, SpiDeviceWithConfig};
    use embassy_sync::{blocking_mutex::raw::CriticalSectionRawMutex, mutex::Mutex};
    use embassy_time::Instant;
    use esp_backtrace as _;
    use esp_hal::{
        aes::dma::AesDma,
        clock::{Clocks, CpuClock},
        delay::Delay,
        dma::{DmaChannel0, DmaPriority, DmaRxBuf, DmaTxBuf},
        dma_buffers, dma_descriptors,
        gpio::{Input, Io, Output, Pull},
        peripherals::Peripherals,
        rtc_cntl::{Rtc, Rwdt, RwdtStage},
        spi::{
            master::{Spi, SpiDmaBus},
            Mode as SpiMode,
        },
        time::RateExtU32,
        timer::{timg::TimerGroup, OneShotTimer},
        usb_serial_jtag::UsbSerialJtag,
        Async,
    };
    use esp_ieee802154::{Config, Frame, Ieee802154};
    use fugit::{ExtU32, HertzU32};
    use sh1122::{display::DisplayRotation, AsyncDisplay, PixelCoord};
    use static_cell::StaticCell;
    use crate::{cap1188::Cap1188, mcp2515::Mcp2515, obd2, power, types};
    const _: () = {
        #[export_name = "_defmt_timestamp"]
        #[inline(never)]
        fn defmt_timestamp(fmt: defmt::Formatter<'_>) {
            match (&({ embassy_time::Instant::from_ticks(0).elapsed().as_micros() as u32 })) {
                (arg0) => {
                    defmt::export::u32(arg0);
                }
            }
        }
        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_timestamp\",\"data\":\"{=u32:us}\",\"disambiguator\":\"7632057125323884805\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_timestamp\",\"data\":\"{=u32:us}\",\"disambiguator\":\"7632057125323884805\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
        static S: u8 = 0;;
        #[no_mangle]
        #[link_section = ".defmt.end.timestamp"]
        static __DEFMT_MARKER_TIMESTAMP_WAS_DEFINED: &u8 = &S;
    };
    pub struct Hal {
        pub display1: types::Display1,
        pub display2: types::Display2,
        pub buttons: types::Cap1188,
        pub obd2: obd2::Obd2,
        pub can_listen: types::Mcp2515,
        pub power: power::Power,
        pub led: types::Led,
        pub ieee802154: Ieee802154<'static>,
        pub rtc: types::Rtc,
        pub temperature: types::TemperatureSensor,
    }
    macro_rules! mk_static {
        ($t:ty,$val:expr) => {{
            static STATIC_CELL: static_cell::StaticCell<$t> = static_cell::StaticCell::new();
            #[deny(unused_attributes)]
            let x = STATIC_CELL.uninit().write(($val));
            x
        }};
    }
    pub struct SpiBus {
        spi: SpiDmaBus<'static, Async>,
        speed: Option<HertzU32>,
        elapsed: Instant,
    }
    impl SpiBus {
        pub fn new(spi: SpiDmaBus<'static, Async>) -> Self {
            Self {
                spi,
                speed: None,
                elapsed: Instant::now(),
            }
        }
    }
    impl embedded_hal_async::spi::ErrorType for SpiBus {
        type Error = esp_hal::spi::Error;
    }
    impl embedded_hal_async::spi::SpiBus for SpiBus {
        async fn read(&mut self, words: &mut [u8]) -> Result<(), Self::Error> {
            self.spi.read_async(words).await
        }
        async fn write(&mut self, words: &[u8]) -> Result<(), Self::Error> {
            self.spi.write_async(words).await
        }
        async fn transfer(&mut self, read: &mut [u8], write: &[u8]) -> Result<(), Self::Error> {
            self.spi.transfer_async(read, write).await
        }
        async fn transfer_in_place(&mut self, words: &mut [u8]) -> Result<(), Self::Error> {
            self.spi.transfer_in_place_async(words).await
        }
        async fn flush(&mut self) -> Result<(), Self::Error> {
            Ok(())
        }
    }
    impl embassy_embedded_hal::SetConfig for SpiBus {
        type Config = u32;
        type ConfigError = ();
        fn set_config(&mut self, config: &Self::Config) -> Result<(), Self::ConfigError> {
            let khz = config.kHz();
            if self.speed == Some(khz) {
                return Ok(());
            }
            let config = esp_hal::spi::master::Config::default()
                .with_frequency(config.MHz())
                .with_mode(SpiMode::_0);
            self.spi.apply_config(&config).ok();
            self.speed = Some(khz);
            Ok(())
        }
    }
    pub fn init() -> Hal {
        let mut config = esp_hal::Config::default();
        config.cpu_clock = CpuClock::max();
        let peripherals = esp_hal::init(config);
        let delay = Delay::new();
        match () {
            () => {
                if {
                    const CHECK: bool = {
                        const fn check() -> bool {
                            let module_path = "kia_obd2_esp32c3_v2::hal".as_bytes();
                            if if 19usize > module_path.len() {
                                false
                            } else {
                                module_path[0usize] == 107u8
                                    && module_path[1usize] == 105u8
                                    && module_path[2usize] == 97u8
                                    && module_path[3usize] == 95u8
                                    && module_path[4usize] == 111u8
                                    && module_path[5usize] == 98u8
                                    && module_path[6usize] == 100u8
                                    && module_path[7usize] == 50u8
                                    && module_path[8usize] == 95u8
                                    && module_path[9usize] == 101u8
                                    && module_path[10usize] == 115u8
                                    && module_path[11usize] == 112u8
                                    && module_path[12usize] == 51u8
                                    && module_path[13usize] == 50u8
                                    && module_path[14usize] == 99u8
                                    && module_path[15usize] == 51u8
                                    && module_path[16usize] == 95u8
                                    && module_path[17usize] == 118u8
                                    && module_path[18usize] == 50u8
                                    && if 19usize == module_path.len() {
                                        true
                                    } else {
                                        module_path[19usize] == b':'
                                    }
                            } {
                                return true;
                            }
                            false
                        }
                        check()
                    };
                    CHECK
                } {
                    defmt::export::acquire_header_and_release(&{
                        defmt::export::make_istr({
                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"delay init\",\"disambiguator\":\"12384538394324524366\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"delay init\",\"disambiguator\":\"12384538394324524366\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                            static DEFMT_LOG_STATEMENT: u8 = 0;
                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                        })
                    });
                }
            }
        };
        delay.delay_millis(10u32);
        match () {
            () => {
                if {
                    const CHECK: bool = {
                        const fn check() -> bool {
                            let module_path = "kia_obd2_esp32c3_v2::hal".as_bytes();
                            if if 19usize > module_path.len() {
                                false
                            } else {
                                module_path[0usize] == 107u8
                                    && module_path[1usize] == 105u8
                                    && module_path[2usize] == 97u8
                                    && module_path[3usize] == 95u8
                                    && module_path[4usize] == 111u8
                                    && module_path[5usize] == 98u8
                                    && module_path[6usize] == 100u8
                                    && module_path[7usize] == 50u8
                                    && module_path[8usize] == 95u8
                                    && module_path[9usize] == 101u8
                                    && module_path[10usize] == 115u8
                                    && module_path[11usize] == 112u8
                                    && module_path[12usize] == 51u8
                                    && module_path[13usize] == 50u8
                                    && module_path[14usize] == 99u8
                                    && module_path[15usize] == 51u8
                                    && module_path[16usize] == 95u8
                                    && module_path[17usize] == 118u8
                                    && module_path[18usize] == 50u8
                                    && if 19usize == module_path.len() {
                                        true
                                    } else {
                                        module_path[19usize] == b':'
                                    }
                            } {
                                return true;
                            }
                            false
                        }
                        check()
                    };
                    CHECK
                } {
                    defmt::export::acquire_header_and_release(&{
                        defmt::export::make_istr({
                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"delay done\",\"disambiguator\":\"17778005887113678054\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"delay done\",\"disambiguator\":\"17778005887113678054\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                            static DEFMT_LOG_STATEMENT: u8 = 0;
                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                        })
                    });
                }
            }
        };
        let timg0 = TimerGroup::new(peripherals.TIMG0);
        esp_hal_embassy::init(timg0.timer0);
        let mut rtc = Rtc::new(peripherals.LPWR);
        let sclk = peripherals.GPIO6;
        let mosi = peripherals.GPIO7;
        let miso = peripherals.GPIO2;
        let (rx_buffer, rx_descriptors, tx_buffer, tx_descriptors) = {
            {
                let rx = {
                    static mut BUFFER: [u32; (32000 + 3) / 4] = [0; (32000 + 3) / 4];
                    unsafe {
                        (
                            unsafe { &mut *(BUFFER.as_mut_ptr() as *mut [u8; 32000]) },
                            {
                                const COUNT: usize = {
                                    const {
                                        if !(::esp_hal::dma::CHUNK_SIZE <= 4095) {
                                            {
                                                ::core::panicking::panic_fmt(format_args!(
                                                    "chunk size must be <= 4095"
                                                ));
                                            }
                                        };
                                        if !(::esp_hal::dma::CHUNK_SIZE > 0) {
                                            {
                                                ::core::panicking::panic_fmt(format_args!(
                                                    "chunk size must be > 0"
                                                ));
                                            }
                                        };
                                    }
                                    if 32000 == 0 {
                                        0
                                    } else {
                                        ::esp_hal::dma::descriptor_count(
                                            32000,
                                            ::esp_hal::dma::CHUNK_SIZE,
                                            false,
                                        )
                                    }
                                };
                                static mut DESCRIPTORS: [::esp_hal::dma::DmaDescriptor; COUNT] =
                                    [::esp_hal::dma::DmaDescriptor::EMPTY; COUNT];
                                unsafe { &mut DESCRIPTORS }
                            },
                        )
                    }
                };
                let tx = {
                    static mut BUFFER: [u32; (32000 + 3) / 4] = [0; (32000 + 3) / 4];
                    unsafe {
                        (
                            unsafe { &mut *(BUFFER.as_mut_ptr() as *mut [u8; 32000]) },
                            {
                                const COUNT: usize = {
                                    const {
                                        if !(::esp_hal::dma::CHUNK_SIZE <= 4095) {
                                            {
                                                ::core::panicking::panic_fmt(format_args!(
                                                    "chunk size must be <= 4095"
                                                ));
                                            }
                                        };
                                        if !(::esp_hal::dma::CHUNK_SIZE > 0) {
                                            {
                                                ::core::panicking::panic_fmt(format_args!(
                                                    "chunk size must be > 0"
                                                ));
                                            }
                                        };
                                    }
                                    if 32000 == 0 {
                                        0
                                    } else {
                                        ::esp_hal::dma::descriptor_count(
                                            32000,
                                            ::esp_hal::dma::CHUNK_SIZE,
                                            false,
                                        )
                                    }
                                };
                                static mut DESCRIPTORS: [::esp_hal::dma::DmaDescriptor; COUNT] =
                                    [::esp_hal::dma::DmaDescriptor::EMPTY; COUNT];
                                unsafe { &mut DESCRIPTORS }
                            },
                        )
                    }
                };
                (rx.0, rx.1, tx.0, tx.1)
            }
        };
        let dma_rx_buf = match defmt::export::into_result(
            DmaRxBuf::new(rx_descriptors, rx_buffer).ok(),
        ) {
            ::core::result::Result::Ok(res) => res,
            ::core::result::Result::Err(_unwrap_err) => {
                match (&(_unwrap_err)) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::hal".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe {
                                defmt::export::acquire_and_header(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: DmaRxBuf :: new(rx_descriptors, rx_buffer).ok()'\\nerror: `{:?}`\",\"disambiguator\":\"480255863154385506\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: DmaRxBuf :: new(rx_descriptors, rx_buffer).ok()'\\nerror: `{:?}`\",\"disambiguator\":\"480255863154385506\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            };
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                defmt::export::panic()
            }
        };
        let dma_tx_buf = match defmt::export::into_result(
            DmaTxBuf::new(tx_descriptors, tx_buffer).ok(),
        ) {
            ::core::result::Result::Ok(res) => res,
            ::core::result::Result::Err(_unwrap_err) => {
                match (&(_unwrap_err)) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::hal".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe {
                                defmt::export::acquire_and_header(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: DmaTxBuf :: new(tx_descriptors, tx_buffer).ok()'\\nerror: `{:?}`\",\"disambiguator\":\"17158473947302067363\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: DmaTxBuf :: new(tx_descriptors, tx_buffer).ok()'\\nerror: `{:?}`\",\"disambiguator\":\"17158473947302067363\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            };
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                defmt::export::panic()
            }
        };
        let dma_channel = peripherals.DMA_CH0;
        let spi = Spi::new(
            peripherals.SPI2,
            esp_hal::spi::master::Config::default().with_frequency(1.MHz()),
        )
        .unwrap()
        .with_sck(sclk)
        .with_mosi(mosi)
        .with_miso(miso)
        .with_dma(dma_channel)
        .with_buffers(dma_rx_buf, dma_tx_buf)
        .into_async();
        let mut dc = Output::new(peripherals.GPIO23, false.into());
        let mut cs_display1 = Output::new(peripherals.GPIO18, false.into());
        let mut cs_display2 = Output::new(peripherals.GPIO19, false.into());
        let mut cs_cap1188 = Output::new(peripherals.GPIO20, false.into());
        let mut cs_mcp2515 = Output::new(peripherals.GPIO17, false.into());
        let mut cs_mcp2515_2 = Output::new(peripherals.GPIO16, false.into());
        let int_mcp2515 = Input::new(peripherals.GPIO4, Pull::Up);
        let int_mcp2515_2 = Input::new(peripherals.GPIO1, Pull::Up);
        let mut rs = Output::new(peripherals.GPIO22, true.into());
        let ing = Input::new(peripherals.GPIO5, Pull::Up);
        let int_cap1188 = Input::new(peripherals.GPIO3, Pull::Up);
        let led = Output::new(peripherals.GPIO0, false.into());
        dc.set_high();
        rs.set_low();
        cs_display1.set_high();
        cs_display2.set_high();
        cs_cap1188.set_high();
        cs_mcp2515.set_high();
        cs_mcp2515_2.set_high();
        delay.delay_micros(20u32);
        rs.set_high();
        delay.delay_micros(20u32);
        rs.set_low();
        delay.delay_micros(20u32);
        rs.set_high();
        delay.delay_micros(20u32);
        let dc2 = unsafe { core::ptr::read(&dc) };
        static SPI_BUS: StaticCell<Mutex<CriticalSectionRawMutex, SpiBus>> = StaticCell::new();
        let spi_bus = SPI_BUS.init(Mutex::new(SpiBus::new(spi)));
        let display1_spi = SpiDeviceWithConfig::new(spi_bus, cs_display1, 20);
        let display2_spi = SpiDeviceWithConfig::new(spi_bus, cs_display2, 20);
        let cap1188_spi = SpiDeviceWithConfig::new(spi_bus, cs_cap1188, 5);
        let mcp2515_spi = SpiDeviceWithConfig::new(spi_bus, cs_mcp2515, 10);
        let mcp2515_2_spi = SpiDeviceWithConfig::new(spi_bus, cs_mcp2515_2, 10);
        let interface1 = SPIInterface::new(display1_spi, dc);
        let interface2 = SPIInterface::new(display2_spi, dc2);
        let display1 = AsyncDisplay::new(
            interface1,
            PixelCoord(256, 64),
            PixelCoord(0, 0),
            DisplayRotation::Rotate180,
        )
        .into_buffered_graphics_mode();
        let display2 = AsyncDisplay::new(
            interface2,
            PixelCoord(256, 64),
            PixelCoord(0, 0),
            DisplayRotation::Rotate0,
        )
        .into_buffered_graphics_mode();
        let cap1188 = Cap1188::new(cap1188_spi, int_cap1188);
        let mcp2515 = Mcp2515::new(mcp2515_spi, int_mcp2515);
        let mcp2515_2 = Mcp2515::new(mcp2515_2_spi, int_mcp2515_2);
        match () {
            () => {
                if {
                    const CHECK: bool = {
                        const fn check() -> bool {
                            let module_path = "kia_obd2_esp32c3_v2::hal".as_bytes();
                            if if 19usize > module_path.len() {
                                false
                            } else {
                                module_path[0usize] == 107u8
                                    && module_path[1usize] == 105u8
                                    && module_path[2usize] == 97u8
                                    && module_path[3usize] == 95u8
                                    && module_path[4usize] == 111u8
                                    && module_path[5usize] == 98u8
                                    && module_path[6usize] == 100u8
                                    && module_path[7usize] == 50u8
                                    && module_path[8usize] == 95u8
                                    && module_path[9usize] == 101u8
                                    && module_path[10usize] == 115u8
                                    && module_path[11usize] == 112u8
                                    && module_path[12usize] == 51u8
                                    && module_path[13usize] == 50u8
                                    && module_path[14usize] == 99u8
                                    && module_path[15usize] == 51u8
                                    && module_path[16usize] == 95u8
                                    && module_path[17usize] == 118u8
                                    && module_path[18usize] == 50u8
                                    && if 19usize == module_path.len() {
                                        true
                                    } else {
                                        module_path[19usize] == b':'
                                    }
                            } {
                                return true;
                            }
                            false
                        }
                        check()
                    };
                    CHECK
                } {
                    defmt::export::acquire_header_and_release(&{
                        defmt::export::make_istr({
                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"HAL initialized\",\"disambiguator\":\"13284023188380133938\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"HAL initialized\",\"disambiguator\":\"13284023188380133938\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                            static DEFMT_LOG_STATEMENT: u8 = 0;
                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                        })
                    });
                }
            }
        };
        let ieee802154 = Ieee802154::new(peripherals.IEEE802154, peripherals.RADIO_CLK);
        rtc.rwdt.enable();
        rtc.rwdt
            .set_timeout(RwdtStage::Stage0, (5 * 60u32).secs().into());
        rtc.rwdt.listen();
        static RTC: StaticCell<Mutex<CriticalSectionRawMutex, Rtc<'static>>> = StaticCell::new();
        let rtc = RTC.init(Mutex::new(rtc));
        let temperature = match defmt::export::into_result(
            esp_hal::tsens::TemperatureSensor::new(peripherals.TSENS, Default::default()).ok(),
        ) {
            ::core::result::Result::Ok(res) => res,
            ::core::result::Result::Err(_unwrap_err) => {
                match (&(_unwrap_err)) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::hal".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe {
                                defmt::export::acquire_and_header(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: esp_hal :: tsens :: TemperatureSensor ::\\nnew(peripherals.TSENS, Default :: default()).ok()'\\nerror: `{:?}`\",\"disambiguator\":\"13260651347703022161\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: esp_hal :: tsens :: TemperatureSensor ::\\nnew(peripherals.TSENS, Default :: default()).ok()'\\nerror: `{:?}`\",\"disambiguator\":\"13260651347703022161\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            };
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                defmt::export::panic()
            }
        };
        Hal {
            display1,
            display2,
            buttons: cap1188,
            obd2: obd2::Obd2::new(mcp2515),
            can_listen: mcp2515_2,
            power: power::Power::new(ing, delay, rtc, rs),
            led,
            ieee802154,
            rtc,
            temperature,
        }
    }
    pub fn reset() {
        esp_hal::reset::software_reset();
    }
}
mod locks {
    use embassy_sync::{blocking_mutex::raw::CriticalSectionRawMutex, mutex::Mutex};
    pub static SPI_BUS: Mutex<CriticalSectionRawMutex, ()> = Mutex::new(());
}
mod mcp2515 {
    use defmt::{error, info, warn};
    use display_interface_spi::SPIInterface;
    use embassy_sync::blocking_mutex::raw::CriticalSectionRawMutex;
    use embassy_time::{Delay, Duration, Timer};
    use embedded_can::{Frame as _, StandardId};
    use embedded_hal_async::spi::{Operation, SpiDevice};
    use embedded_hal_bus::spi::{ExclusiveDevice, NoDelay};
    use esp_hal::{gpio::InputPin, peripherals::SPI2, spi::master::SpiDma};
    mod bitrates {
        /// Preconfigured CNF registers for 8 Mhz oscillators
        use super::registers;
        pub mod clock_8mhz {
            use super::registers::CNF;
            pub const CNF_1000K_BPS: CNF = CNF::from_bytes([0x80, 0x80, 0x00]);
            pub const CNF_500K_BPS: CNF = CNF::from_bytes([0x82, 0x90, 0x00]);
            pub const CNF_250K_BPS: CNF = CNF::from_bytes([0x85, 0xB1, 0x00]);
            pub const CNF_200K_BPS: CNF = CNF::from_bytes([0x86, 0xB4, 0x00]);
            pub const CNF_125K_BPS: CNF = CNF::from_bytes([0x85, 0xB1, 0x01]);
            pub const CNF_100K_BPS: CNF = CNF::from_bytes([0x86, 0xB4, 0x01]);
            pub const CNF_80K_BPS: CNF = CNF::from_bytes([0x87, 0xBF, 0x01]);
            pub const CNF_50K_BPS: CNF = CNF::from_bytes([0x86, 0xB4, 0x03]);
            pub const CNF_40K_BPS: CNF = CNF::from_bytes([0x87, 0xBF, 0x03]);
            pub const CNF_33K3_BPS: CNF = CNF::from_bytes([0x85, 0xE2, 0x47]);
            pub const CNF_31K25_BPS: CNF = CNF::from_bytes([0x84, 0xA4, 0x07]);
            pub const CNF_20K_BPS: CNF = CNF::from_bytes([0x87, 0xBF, 0x07]);
            pub const CNF_10K_BPS: CNF = CNF::from_bytes([0x87, 0xBF, 0x0F]);
            pub const CNF_5K_BPS: CNF = CNF::from_bytes([0x87, 0xBF, 0x1F]);
        }
        /// Preconfigured CNF registers for 16 Mhz oscillators
        pub mod clock_16mhz {
            use super::registers::CNF;
            pub const CNF_1000K_BPS: CNF = CNF::from_bytes([0x82, 0xD0, 0x00]);
            pub const CNF_500K_BPS: CNF = CNF::from_bytes([0x05, 0xB8, 0x00]);
            pub const CNF_250K_BPS: CNF = CNF::from_bytes([0x85, 0xF1, 0x41]);
            pub const CNF_200K_BPS: CNF = CNF::from_bytes([0x87, 0xFA, 0x01]);
            pub const CNF_125K_BPS: CNF = CNF::from_bytes([0x86, 0xF0, 0x03]);
            pub const CNF_100K_BPS: CNF = CNF::from_bytes([0x87, 0xFA, 0x03]);
            pub const CNF_80K_BPS: CNF = CNF::from_bytes([0x87, 0xFF, 0x03]);
            pub const CNF_83K3_BPS: CNF = CNF::from_bytes([0x07, 0xBE, 0x03]);
            pub const CNF_50K_BPS: CNF = CNF::from_bytes([0x87, 0xFA, 0x07]);
            pub const CNF_40K_BPS: CNF = CNF::from_bytes([0x87, 0xFF, 0x07]);
            pub const CNF_33K3_BPS: CNF = CNF::from_bytes([0x85, 0xF1, 0x4E]);
            pub const CNF_20K_BPS: CNF = CNF::from_bytes([0x87, 0xFF, 0x0F]);
            pub const CNF_10K_BPS: CNF = CNF::from_bytes([0x87, 0xFF, 0x1F]);
            pub const CNF_5K_BPS: CNF = CNF::from_bytes([0x87, 0xFF, 0x3F]);
        }
        /// Preconfigured CNF registers for 20 Mhz oscillators
        pub mod clock_20mhz {
            use super::registers::CNF;
            pub const CNF_1000K_BPS: CNF = CNF::from_bytes([0x82, 0xD9, 0x00]);
            pub const CNF_500K_BPS: CNF = CNF::from_bytes([0x45, 0xF8, 0x00]);
            pub const CNF_250K_BPS: CNF = CNF::from_bytes([0x86, 0xFB, 0x41]);
            pub const CNF_200K_BPS: CNF = CNF::from_bytes([0x87, 0xFF, 0x01]);
            pub const CNF_125K_BPS: CNF = CNF::from_bytes([0x87, 0xFA, 0x03]);
            pub const CNF_100K_BPS: CNF = CNF::from_bytes([0x87, 0xFA, 0x04]);
            pub const CNF_83K3_BPS: CNF = CNF::from_bytes([0x87, 0xFE, 0x04]);
            pub const CNF_80K_BPS: CNF = CNF::from_bytes([0x87, 0xFF, 0x04]);
            pub const CNF_50K_BPS: CNF = CNF::from_bytes([0x87, 0xFA, 0x09]);
            pub const CNF_40K_BPS: CNF = CNF::from_bytes([0x87, 0xFF, 0x09]);
            pub const CNF_33K3_BPS: CNF = CNF::from_bytes([0x87, 0xFF, 0x0B]);
        }
    }
    mod config {
        use defmt::info;
        use super::{
            registers::{OperationMode, CANCTRL, CNF, RXB0CTRL, RXB1CTRL},
            AcceptanceFilter, IdHeader, CLKPRE,
        };
        /// Configuration for:
        /// * Clock settings
        /// * Operation Mode
        /// * Receive buffers
        /// * Receive buffer filters and masks
        /// * Other flags inside the CANCTRL, CNF, RXB0CTRL, RXB1CTRL registers
        pub struct Config<'a> {
            pub canctrl: CANCTRL,
            pub cnf: CNF,
            pub rxb0ctrl: RXB0CTRL,
            pub rxb1ctrl: RXB1CTRL,
            pub filters: &'a [(AcceptanceFilter, IdHeader)],
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Config<'a> {
            #[inline]
            fn clone(&self) -> Config<'a> {
                Config {
                    canctrl: ::core::clone::Clone::clone(&self.canctrl),
                    cnf: ::core::clone::Clone::clone(&self.cnf),
                    rxb0ctrl: ::core::clone::Clone::clone(&self.rxb0ctrl),
                    rxb1ctrl: ::core::clone::Clone::clone(&self.rxb1ctrl),
                    filters: ::core::clone::Clone::clone(&self.filters),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Config<'a> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "Config",
                    "canctrl",
                    &self.canctrl,
                    "cnf",
                    &self.cnf,
                    "rxb0ctrl",
                    &self.rxb0ctrl,
                    "rxb1ctrl",
                    &self.rxb1ctrl,
                    "filters",
                    &&self.filters,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::default::Default for Config<'a> {
            #[inline]
            fn default() -> Config<'a> {
                Config {
                    canctrl: ::core::default::Default::default(),
                    cnf: ::core::default::Default::default(),
                    rxb0ctrl: ::core::default::Default::default(),
                    rxb1ctrl: ::core::default::Default::default(),
                    filters: ::core::default::Default::default(),
                }
            }
        }
        impl<'a> Config<'a> {
            #[inline]
            pub fn mode(mut self, mode: OperationMode) -> Self {
                self.canctrl.set_reqop(mode);
                self
            }
            pub fn set_clk_prescaler(mut self, clkpre: CLKPRE) -> Self {
                self.canctrl.set_clkpre(clkpre);
                self
            }
            #[inline]
            pub fn can_control_register(mut self, canctrl: CANCTRL) -> Self {
                self.canctrl = canctrl;
                self
            }
            #[inline]
            pub fn bitrate(mut self, cnf: CNF) -> Self {
                self.cnf = cnf;
                self.cnf.cnf2.set_sam(true);
                self.cnf.cnf2.set_btlmode(true);
                match (&(self.canctrl.clken())) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path =
                                        "kia_obd2_esp32c3_v2::mcp2515::config".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe {
                                defmt::export::acquire_and_header(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"self.canctrl.clken: {:?}\",\"disambiguator\":\"16185597854973022849\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"self.canctrl.clken: {:?}\",\"disambiguator\":\"16185597854973022849\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            };
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                self
            }
            #[inline]
            pub fn receive_buffer_0(mut self, rxb0ctrl: RXB0CTRL) -> Self {
                self.rxb0ctrl = rxb0ctrl;
                self
            }
            #[inline]
            pub fn receive_buffer_1(mut self, rxb1ctrl: RXB1CTRL) -> Self {
                self.rxb1ctrl = rxb1ctrl;
                self
            }
            #[inline]
            pub fn filters(mut self, filters: &'a [(AcceptanceFilter, IdHeader)]) -> Self {
                self.filters = filters;
                self
            }
        }
    }
    mod frame {
        use core::fmt::Debug;
        use embedded_can::{Frame, Id};
        use super::registers::DLC;
        use super::IdHeader;
        use defmt::Format;
        /// CAN frame with the same in memory representation as the registers of the CAN controller
        #[repr(C)]
        pub struct CanFrame {
            pub(crate) id_header: IdHeader,
            pub(crate) dlc: DLC,
            pub(crate) data: [u8; 8],
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CanFrame {
            #[inline]
            fn clone(&self) -> CanFrame {
                CanFrame {
                    id_header: ::core::clone::Clone::clone(&self.id_header),
                    dlc: ::core::clone::Clone::clone(&self.dlc),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for CanFrame {
            #[inline]
            fn default() -> CanFrame {
                CanFrame {
                    id_header: ::core::default::Default::default(),
                    dlc: ::core::default::Default::default(),
                    data: ::core::default::Default::default(),
                }
            }
        }
        impl defmt::Format for CanFrame
        where
            IdHeader: defmt::Format,
            DLC: defmt::Format,
            [u8; 8]: defmt::Format,
        {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::mcp2515::frame".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"15399134084175668237\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"15399134084175668237\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"CanFrame {{ id_header: {=?:?}, dlc: {=?:?}, data: {=?:?} }}\",\"disambiguator\":\"8504376927998585181\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"CanFrame {{ id_header: {=?:?}, dlc: {=?:?}, data: {=?:?} }}\",\"disambiguator\":\"8504376927998585181\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    Self {
                        id_header,
                        dlc,
                        data,
                    } => {
                        defmt::export::fmt(id_header);
                        defmt::export::fmt(dlc);
                        defmt::export::fmt(data);
                    }
                }
            }
        }
        impl CanFrame {
            pub(crate) fn as_bytes(&self) -> &[u8; 13] {
                unsafe {
                    &*(self as *const CanFrame as *const [u8; core::mem::size_of::<CanFrame>()])
                }
            }
        }
        impl Frame for CanFrame {
            fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
                if data.len() > 8 {
                    return None;
                }
                let mut frame = CanFrame {
                    id_header: IdHeader::from(id.into()),
                    dlc: DLC::new().with_dlc(data.len() as u8),
                    data: [0; 8],
                };
                frame.data[..data.len()].copy_from_slice(data);
                Some(frame)
            }
            fn new_remote(id: impl Into<Id>, dlc: usize) -> Option<Self> {
                if dlc > 8 {
                    return None;
                }
                Some(CanFrame {
                    id_header: IdHeader::from(id.into()),
                    dlc: DLC::new().with_dlc(dlc as u8).with_rtr(true),
                    data: [0; 8],
                })
            }
            #[inline]
            fn is_extended(&self) -> bool {
                self.id_header.exide()
            }
            #[inline]
            fn is_remote_frame(&self) -> bool {
                self.dlc.rtr()
            }
            fn id(&self) -> Id {
                self.id_header.id()
            }
            #[inline]
            fn dlc(&self) -> usize {
                self.dlc.dlc() as usize
            }
            #[inline]
            fn data(&self) -> &[u8] {
                &self.data[0..self.dlc()]
            }
        }
        impl Debug for CanFrame {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                f.debug_struct("CanFrame")
                    .field(
                        "id",
                        match &self.id() {
                            Id::Standard(id) => id,
                            Id::Extended(id) => id,
                        },
                    )
                    .field("is_remote_frame", &self.is_remote_frame())
                    .field("data", &self.data())
                    .finish()
            }
        }
    }
    mod idheader {
        use defmt::Format;
        use embedded_can::{ExtendedId, Id, StandardId};
        /// Id header used in filters and masks
        #[repr(C)]
        pub struct IdHeader {
            sidh: u8,
            sidl: u8,
            eid8: u8,
            eid0: u8,
        }
        #[automatically_derived]
        impl ::core::marker::Copy for IdHeader {}
        #[automatically_derived]
        impl ::core::clone::Clone for IdHeader {
            #[inline]
            fn clone(&self) -> IdHeader {
                let _: ::core::clone::AssertParamIsClone<u8>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for IdHeader {
            #[inline]
            fn default() -> IdHeader {
                IdHeader {
                    sidh: ::core::default::Default::default(),
                    sidl: ::core::default::Default::default(),
                    eid8: ::core::default::Default::default(),
                    eid0: ::core::default::Default::default(),
                }
            }
        }
        impl defmt::Format for IdHeader {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::mcp2515::idheader".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"17322725333216157768\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"17322725333216157768\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"IdHeader {{ sidh: {=u8:?}, sidl: {=u8:?}, eid8: {=u8:?}, eid0: {=u8:?} }}\",\"disambiguator\":\"16847199593933814273\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"IdHeader {{ sidh: {=u8:?}, sidl: {=u8:?}, eid8: {=u8:?}, eid0: {=u8:?} }}\",\"disambiguator\":\"16847199593933814273\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    Self {
                        sidh,
                        sidl,
                        eid8,
                        eid0,
                    } => {
                        defmt::export::u8(sidh);
                        defmt::export::u8(sidl);
                        defmt::export::u8(eid8);
                        defmt::export::u8(eid0);
                    }
                }
            }
        }
        impl IdHeader {
            pub fn with_two_data_bytes(id: StandardId, bytes: [u8; 2]) -> Self {
                let id = id.as_raw();
                IdHeader {
                    sidh: (id >> 3) as u8,
                    sidl: (id as u8 & 0b0000_0111) << 5,
                    eid8: bytes[0],
                    eid0: bytes[1],
                }
            }
            pub fn id(&self) -> Id {
                if self.exide() {
                    let id = ((self.sidh as u32) << 21)
                        | ((self.sidl as u32 & 0xE0) << 13)
                        | (((self.sidl & 0b11) as u32) << 16)
                        | ((self.eid8 as u32) << 8)
                        | self.eid0 as u32;
                    unsafe { Id::Extended(embedded_can::ExtendedId::new_unchecked(id)) }
                } else {
                    let id = ((self.sidh as u16) << 3) | ((self.sidl as u16) >> 5);
                    unsafe { Id::Standard(embedded_can::StandardId::new_unchecked(id)) }
                }
            }
            #[inline]
            pub(crate) fn exide(&self) -> bool {
                self.sidl & 0b0000_1000 > 0
            }
            pub(crate) fn into_bytes(self) -> [u8; 4] {
                [self.sidh, self.sidl, self.eid8, self.eid0]
            }
            pub fn get_i32(&self) -> i32 {
                let id = self.id();
                match id {
                    Id::Standard(id) => id.as_raw() as i32,
                    Id::Extended(id) => id.as_raw() as i32,
                }
            }
        }
        impl From<Id> for IdHeader {
            fn from(id: Id) -> Self {
                match id {
                    Id::Standard(id) => id.into(),
                    Id::Extended(id) => id.into(),
                }
            }
        }
        impl From<StandardId> for IdHeader {
            #[inline]
            fn from(id: StandardId) -> Self {
                let id = id.as_raw();
                IdHeader {
                    sidh: (id >> 3) as u8,
                    sidl: (id as u8 & 0b0000_0111) << 5,
                    eid8: 0,
                    eid0: 0,
                }
            }
        }
        impl From<ExtendedId> for IdHeader {
            #[inline]
            fn from(id: ExtendedId) -> Self {
                let id = id.as_raw();
                IdHeader {
                    sidh: (id >> 21) as u8,
                    sidl: (((id >> 13) & 0b11100000) as u8)
                        | 0b0000_1000
                        | (((id >> 16) & 0b0000_0011) as u8),
                    eid8: (id >> 8) as u8,
                    eid0: id as u8,
                }
            }
        }
        impl core::fmt::Debug for IdHeader {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                f.debug_struct("IdHeader").field("id", &self.id()).finish()
            }
        }
    }
    mod registers {
        #![allow(clippy::identity_op)]
        use defmt::Format;
        use modular_bitfield::prelude::*;
        /// 8 bit Register
        pub trait Register: From<u8> + Into<u8> {
            /// Address of the register
            const ADDRESS: u8;
        }
        /// Marker trait for Registers that support the `Modify` instruction.
        pub trait Modify {}
        /// Receive Buffer 0 Control Register
        #[allow(clippy::identity_op)]
        pub struct RXB0CTRL {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <RXM as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for RXB0CTRL {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for RXB0CTRL {
            #[inline]
            fn clone(&self) -> RXB0CTRL {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <RXM as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for RXB0CTRL {
            #[inline]
            fn default() -> RXB0CTRL {
                RXB0CTRL {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for RXB0CTRL {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <RXM as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl RXB0CTRL {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <RXM as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl RXB0CTRL {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                           + <RXM as ::modular_bitfield::Specifier>::BITS
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <RXM as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl RXB0CTRL {
            ///Returns the value of filhit.
            #[inline]
            /// Filter Hit bit (indicates which acceptance filter enabled reception of message)
            /// Note: If a rollover from RXB0 to RXB1 occurs, the `filhit0` bit will reflect the filter that accepted the message that rolled over
            pub fn filhit(&self) -> <B1 as ::modular_bitfield::Specifier>::InOut {
                self.filhit_or_err()
                    .expect("value contains invalid bit pattern for field RXB0CTRL.filhit")
            }
            ///Returns the value of filhit.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for filhit.
            #[inline]
            #[allow(dead_code)]
            /// Filter Hit bit (indicates which acceptance filter enabled reception of message)
            /// Note: If a rollover from RXB0 to RXB1 occurs, the `filhit0` bit will reflect the filter that accepted the message that rolled over
            pub fn filhit_or_err(
                &self,
            ) -> ::core::result::Result<
                <B1 as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <B1 as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <B1 as ::modular_bitfield::Specifier>::Bytes =
                    { ::modular_bitfield::private::read_specifier::<B1>(&self.bytes[..], 0usize) };
                <B1 as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns the value of bukt1.
            #[inline]
            /// Read-Only Copy of BUKT bit (used internally)
            pub fn bukt1(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.bukt1_or_err()
                    .expect("value contains invalid bit pattern for field RXB0CTRL.bukt1")
            }
            ///Returns the value of bukt1.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for bukt1.
            #[inline]
            #[allow(dead_code)]
            /// Read-Only Copy of BUKT bit (used internally)
            pub fn bukt1_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize + <B1 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns the value of bukt.
            #[inline]
            /// Rollover Enable
            pub fn bukt(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.bukt_or_err()
                    .expect("value contains invalid bit pattern for field RXB0CTRL.bukt")
            }
            ///Returns the value of bukt.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for bukt.
            #[inline]
            #[allow(dead_code)]
            /// Rollover Enable
            pub fn bukt_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of bukt set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for bukt.
            #[inline]
            #[allow(dead_code)]
            /// Rollover Enable
            pub fn with_bukt(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_bukt(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of bukt set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for bukt.
            #[inline]
            #[allow(dead_code)]
            /// Rollover Enable
            pub fn with_bukt_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_bukt_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of bukt to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for bukt.
            #[inline]
            #[allow(dead_code)]
            /// Rollover Enable
            pub fn set_bukt(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_bukt_checked(new_val)
                    .expect("value out of bounds for field RXB0CTRL.bukt")
            }
            ///Sets the value of bukt to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for bukt.
            #[inline]
            /// Rollover Enable
            pub fn set_bukt_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of rxrtr.
            #[inline]
            /// Received Remote Transfer Request
            pub fn rxrtr(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rxrtr_or_err()
                    .expect("value contains invalid bit pattern for field RXB0CTRL.rxrtr")
            }
            ///Returns the value of rxrtr.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rxrtr.
            #[inline]
            #[allow(dead_code)]
            /// Received Remote Transfer Request
            pub fn rxrtr_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns the value of rxm.
            #[inline]
            /// Receive Buffer Operating Mode
            pub fn rxm(&self) -> <RXM as ::modular_bitfield::Specifier>::InOut {
                self.rxm_or_err()
                    .expect("value contains invalid bit pattern for field RXB0CTRL.rxm")
            }
            ///Returns the value of rxm.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rxm.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer Operating Mode
            pub fn rxm_or_err(
                &self,
            ) -> ::core::result::Result<
                <RXM as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <RXM as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <RXM as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<RXM>(
                        &self.bytes[..],
                        0usize
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <RXM as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rxm set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rxm.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer Operating Mode
            pub fn with_rxm(
                mut self,
                new_val: <RXM as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rxm(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rxm set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rxm.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer Operating Mode
            pub fn with_rxm_checked(
                mut self,
                new_val: <RXM as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rxm_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rxm to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rxm.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer Operating Mode
            pub fn set_rxm(&mut self, new_val: <RXM as ::modular_bitfield::Specifier>::InOut) {
                self.set_rxm_checked(new_val)
                    .expect("value out of bounds for field RXB0CTRL.rxm")
            }
            ///Sets the value of rxm to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rxm.
            #[inline]
            /// Receive Buffer Operating Mode
            pub fn set_rxm_checked(
                &mut self,
                new_val: <RXM as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<RXM as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <RXM as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <RXM as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <RXM as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <RXM as ::modular_bitfield::Specifier>::Bytes =
                    { <RXM as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<RXM>(
                    &mut self.bytes[..],
                    0usize
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for RXB0CTRL
        where
            [(); {
                0usize
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <RXM as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<RXB0CTRL> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <RXM as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: RXB0CTRL) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for RXB0CTRL {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("RXB0CTRL")
                    .field(
                        "filhit",
                        self.filhit_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "bukt1",
                        self.bukt1_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "bukt",
                        self.bukt_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "rxrtr",
                        self.rxrtr_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "rxm",
                        self.rxm_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Receive Buffer 1 Control Register
        #[allow(clippy::identity_op)]
        pub struct RXB1CTRL {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <RXM as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for RXB1CTRL {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for RXB1CTRL {
            #[inline]
            fn clone(&self) -> RXB1CTRL {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <B3 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <RXM as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for RXB1CTRL {
            #[inline]
            fn default() -> RXB1CTRL {
                RXB1CTRL {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for RXB1CTRL {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <RXM as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl RXB1CTRL {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <B3 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <RXM as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl RXB1CTRL {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <B3 as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                           + <RXM as ::modular_bitfield::Specifier>::BITS
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <RXM as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl RXB1CTRL {
            ///Returns the value of filhit.
            #[inline]
            /// Filter Hit bits (indicates which acceptance filter enabled reception of message)
            pub fn filhit(&self) -> <B3 as ::modular_bitfield::Specifier>::InOut {
                self.filhit_or_err()
                    .expect("value contains invalid bit pattern for field RXB1CTRL.filhit")
            }
            ///Returns the value of filhit.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for filhit.
            #[inline]
            #[allow(dead_code)]
            /// Filter Hit bits (indicates which acceptance filter enabled reception of message)
            pub fn filhit_or_err(
                &self,
            ) -> ::core::result::Result<
                <B3 as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <B3 as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <B3 as ::modular_bitfield::Specifier>::Bytes =
                    { ::modular_bitfield::private::read_specifier::<B3>(&self.bytes[..], 0usize) };
                <B3 as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns the value of rxrtr.
            #[inline]
            /// Received Remote Transfer Request bit
            pub fn rxrtr(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rxrtr_or_err()
                    .expect("value contains invalid bit pattern for field RXB1CTRL.rxrtr")
            }
            ///Returns the value of rxrtr.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rxrtr.
            #[inline]
            #[allow(dead_code)]
            /// Received Remote Transfer Request bit
            pub fn rxrtr_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize + <B3 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns the value of rxm.
            #[inline]
            /// Receive Buffer Operating Mode
            pub fn rxm(&self) -> <RXM as ::modular_bitfield::Specifier>::InOut {
                self.rxm_or_err()
                    .expect("value contains invalid bit pattern for field RXB1CTRL.rxm")
            }
            ///Returns the value of rxm.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rxm.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer Operating Mode
            pub fn rxm_or_err(
                &self,
            ) -> ::core::result::Result<
                <RXM as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <RXM as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <RXM as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<RXM>(
                        &self.bytes[..],
                        0usize
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <RXM as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rxm set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rxm.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer Operating Mode
            pub fn with_rxm(
                mut self,
                new_val: <RXM as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rxm(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rxm set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rxm.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer Operating Mode
            pub fn with_rxm_checked(
                mut self,
                new_val: <RXM as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rxm_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rxm to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rxm.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer Operating Mode
            pub fn set_rxm(&mut self, new_val: <RXM as ::modular_bitfield::Specifier>::InOut) {
                self.set_rxm_checked(new_val)
                    .expect("value out of bounds for field RXB1CTRL.rxm")
            }
            ///Sets the value of rxm to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rxm.
            #[inline]
            /// Receive Buffer Operating Mode
            pub fn set_rxm_checked(
                &mut self,
                new_val: <RXM as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<RXM as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <RXM as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <RXM as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <RXM as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <RXM as ::modular_bitfield::Specifier>::Bytes =
                    { <RXM as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<RXM>(
                    &mut self.bytes[..],
                    0usize
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for RXB1CTRL
        where
            [(); {
                0usize
                    + <B3 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <RXM as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<RXB1CTRL> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <B3 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <RXM as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: RXB1CTRL) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for RXB1CTRL {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("RXB1CTRL")
                    .field(
                        "filhit",
                        self.filhit_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "rxrtr",
                        self.rxrtr_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "rxm",
                        self.rxm_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Receive Buffer Operating Mode
        #[bits = 2]
        pub enum RXM {
            /// Receive all valid messages using either standard or extended identifiers that meet filter criteria
            Filter = 0b00,
            Reserved1 = 0b01,
            Reserved2 = 0b10,

            /// Turn mask/filters off; receive any message
            ReceiveAny = 0b11,
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::Filter as usize],
            > for RXM
        {
            type CheckType = [(); ((Self::Filter as usize) < (0x01_usize << 2usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::Reserved1 as usize],
            > for RXM
        {
            type CheckType = [(); ((Self::Reserved1 as usize) < (0x01_usize << 2usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::Reserved2 as usize],
            > for RXM
        {
            type CheckType = [(); ((Self::Reserved2 as usize) < (0x01_usize << 2usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::ReceiveAny as usize],
            > for RXM
        {
            type CheckType = [(); ((Self::ReceiveAny as usize) < (0x01_usize << 2usize)) as usize];
        }
        impl ::modular_bitfield::Specifier for RXM {
            const BITS: usize = 2usize;
            type Bytes = <[(); 2usize] as ::modular_bitfield::private::SpecifierBytes>::Bytes;
            type InOut = Self;
            #[inline]
            fn into_bytes(
                input: Self::InOut,
            ) -> ::core::result::Result<Self::Bytes, ::modular_bitfield::error::OutOfBounds>
            {
                ::core::result::Result::Ok(input as Self::Bytes)
            }
            #[inline]
            fn from_bytes(
                bytes: Self::Bytes,
            ) -> ::core::result::Result<
                Self::InOut,
                ::modular_bitfield::error::InvalidBitPattern<Self::Bytes>,
            > {
                match bytes {
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::Filter as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::Filter)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::Reserved1
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::Reserved1)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::Reserved2
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::Reserved2)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::ReceiveAny
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::ReceiveAny)
                    }
                    invalid_bytes => {
                        ::core::result::Result::Err(<::modular_bitfield::error::InvalidBitPattern<
                            Self::Bytes,
                        >>::new(invalid_bytes))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for RXM {}
        #[automatically_derived]
        impl ::core::clone::Clone for RXM {
            #[inline]
            fn clone(&self) -> RXM {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RXM {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        RXM::Filter => "Filter",
                        RXM::Reserved1 => "Reserved1",
                        RXM::Reserved2 => "Reserved2",
                        RXM::ReceiveAny => "ReceiveAny",
                    },
                )
            }
        }
        /// Can Control Register
        #[allow(clippy::identity_op)]
        pub struct CANCTRL {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <CLKPRE as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <OperationMode as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for CANCTRL {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for CANCTRL {
            #[inline]
            fn clone(&self) -> CANCTRL {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <CLKPRE as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <OperationMode as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for CANCTRL {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <CLKPRE as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <OperationMode as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl CANCTRL {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <CLKPRE as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <OperationMode as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl CANCTRL {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <CLKPRE as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <OperationMode as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <CLKPRE as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <OperationMode as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl CANCTRL {
            ///Returns the value of clkpre.
            #[inline]
            /// CLKOUT Pin Prescaler
            pub fn clkpre(&self) -> <CLKPRE as ::modular_bitfield::Specifier>::InOut {
                self.clkpre_or_err()
                    .expect("value contains invalid bit pattern for field CANCTRL.clkpre")
            }
            ///Returns the value of clkpre.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for clkpre.
            #[inline]
            #[allow(dead_code)]
            /// CLKOUT Pin Prescaler
            pub fn clkpre_or_err(
                &self,
            ) -> ::core::result::Result<
                <CLKPRE as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <CLKPRE as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <CLKPRE as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<CLKPRE>(&self.bytes[..], 0usize)
                };
                <CLKPRE as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of clkpre set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for clkpre.
            #[inline]
            #[allow(dead_code)]
            /// CLKOUT Pin Prescaler
            pub fn with_clkpre(
                mut self,
                new_val: <CLKPRE as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_clkpre(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of clkpre set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for clkpre.
            #[inline]
            #[allow(dead_code)]
            /// CLKOUT Pin Prescaler
            pub fn with_clkpre_checked(
                mut self,
                new_val: <CLKPRE as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_clkpre_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of clkpre to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for clkpre.
            #[inline]
            #[allow(dead_code)]
            /// CLKOUT Pin Prescaler
            pub fn set_clkpre(
                &mut self,
                new_val: <CLKPRE as ::modular_bitfield::Specifier>::InOut,
            ) {
                self.set_clkpre_checked(new_val)
                    .expect("value out of bounds for field CANCTRL.clkpre")
            }
            ///Sets the value of clkpre to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for clkpre.
            #[inline]
            /// CLKOUT Pin Prescaler
            pub fn set_clkpre_checked(
                &mut self,
                new_val: <CLKPRE as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<CLKPRE as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <CLKPRE as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <CLKPRE as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <CLKPRE as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <CLKPRE as ::modular_bitfield::Specifier>::Bytes =
                    { <CLKPRE as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<CLKPRE>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of clken.
            #[inline]
            ///  CLKOUT Pin Enable
            pub fn clken(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.clken_or_err()
                    .expect("value contains invalid bit pattern for field CANCTRL.clken")
            }
            ///Returns the value of clken.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for clken.
            #[inline]
            #[allow(dead_code)]
            ///  CLKOUT Pin Enable
            pub fn clken_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize + <CLKPRE as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of clken set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for clken.
            #[inline]
            #[allow(dead_code)]
            ///  CLKOUT Pin Enable
            pub fn with_clken(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_clken(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of clken set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for clken.
            #[inline]
            #[allow(dead_code)]
            ///  CLKOUT Pin Enable
            pub fn with_clken_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_clken_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of clken to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for clken.
            #[inline]
            #[allow(dead_code)]
            ///  CLKOUT Pin Enable
            pub fn set_clken(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_clken_checked(new_val)
                    .expect("value out of bounds for field CANCTRL.clken")
            }
            ///Sets the value of clken to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for clken.
            #[inline]
            ///  CLKOUT Pin Enable
            pub fn set_clken_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize + <CLKPRE as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of osm.
            #[inline]
            /// One-Shot Mode
            pub fn osm(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.osm_or_err()
                    .expect("value contains invalid bit pattern for field CANCTRL.osm")
            }
            ///Returns the value of osm.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for osm.
            #[inline]
            #[allow(dead_code)]
            /// One-Shot Mode
            pub fn osm_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <CLKPRE as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of osm set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for osm.
            #[inline]
            #[allow(dead_code)]
            /// One-Shot Mode
            pub fn with_osm(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_osm(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of osm set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for osm.
            #[inline]
            #[allow(dead_code)]
            /// One-Shot Mode
            pub fn with_osm_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_osm_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of osm to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for osm.
            #[inline]
            #[allow(dead_code)]
            /// One-Shot Mode
            pub fn set_osm(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_osm_checked(new_val)
                    .expect("value out of bounds for field CANCTRL.osm")
            }
            ///Sets the value of osm to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for osm.
            #[inline]
            /// One-Shot Mode
            pub fn set_osm_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <CLKPRE as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of abat.
            #[inline]
            /// Abort All Pending Transmissions
            pub fn abat(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.abat_or_err()
                    .expect("value contains invalid bit pattern for field CANCTRL.abat")
            }
            ///Returns the value of abat.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for abat.
            #[inline]
            #[allow(dead_code)]
            /// Abort All Pending Transmissions
            pub fn abat_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <CLKPRE as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of abat set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for abat.
            #[inline]
            #[allow(dead_code)]
            /// Abort All Pending Transmissions
            pub fn with_abat(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_abat(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of abat set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for abat.
            #[inline]
            #[allow(dead_code)]
            /// Abort All Pending Transmissions
            pub fn with_abat_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_abat_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of abat to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for abat.
            #[inline]
            #[allow(dead_code)]
            /// Abort All Pending Transmissions
            pub fn set_abat(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_abat_checked(new_val)
                    .expect("value out of bounds for field CANCTRL.abat")
            }
            ///Sets the value of abat to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for abat.
            #[inline]
            /// Abort All Pending Transmissions
            pub fn set_abat_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <CLKPRE as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of reqop.
            #[inline]
            /// Request Operation Mode
            pub fn reqop(&self) -> <OperationMode as ::modular_bitfield::Specifier>::InOut {
                self.reqop_or_err()
                    .expect("value contains invalid bit pattern for field CANCTRL.reqop")
            }
            ///Returns the value of reqop.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for reqop.
            #[inline]
            #[allow(dead_code)]
            /// Request Operation Mode
            pub fn reqop_or_err(
                &self,
            ) -> ::core::result::Result<
                <OperationMode as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <OperationMode as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <OperationMode as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<OperationMode>(
                        &self.bytes[..],
                        0usize
                            + <CLKPRE as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <OperationMode as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of reqop set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for reqop.
            #[inline]
            #[allow(dead_code)]
            /// Request Operation Mode
            pub fn with_reqop(
                mut self,
                new_val: <OperationMode as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_reqop(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of reqop set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for reqop.
            #[inline]
            #[allow(dead_code)]
            /// Request Operation Mode
            pub fn with_reqop_checked(
                mut self,
                new_val: <OperationMode as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_reqop_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of reqop to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for reqop.
            #[inline]
            #[allow(dead_code)]
            /// Request Operation Mode
            pub fn set_reqop(
                &mut self,
                new_val: <OperationMode as ::modular_bitfield::Specifier>::InOut,
            ) {
                self.set_reqop_checked(new_val)
                    .expect("value out of bounds for field CANCTRL.reqop")
            }
            ///Sets the value of reqop to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for reqop.
            #[inline]
            /// Request Operation Mode
            pub fn set_reqop_checked(
                &mut self,
                new_val: <OperationMode as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<OperationMode as ::modular_bitfield::Specifier>::Bytes>(
                    );
                let __bf_max_value: <OperationMode as ::modular_bitfield::Specifier>::Bytes = {
                    !0 >> (__bf_base_bits - <OperationMode as ::modular_bitfield::Specifier>::BITS)
                };
                let __bf_spec_bits: ::core::primitive::usize =
                    <OperationMode as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <OperationMode as ::modular_bitfield::Specifier>::Bytes =
                    { <OperationMode as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<OperationMode>(
                    &mut self.bytes[..],
                    0usize
                        + <CLKPRE as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for CANCTRL
        where
            [(); {
                0usize
                    + <CLKPRE as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <OperationMode as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<CANCTRL> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <CLKPRE as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <OperationMode as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: CANCTRL) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for CANCTRL {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("CANCTRL")
                    .field(
                        "clkpre",
                        self.clkpre_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "clken",
                        self.clken_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "osm",
                        self.osm_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "abat",
                        self.abat_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "reqop",
                        self.reqop_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Request Operation mode
        #[bits = 3]
        pub enum OperationMode {
            NormalOperation = 0b000,
            Sleep = 0b001,
            Loopback = 0b010,
            ListenOnly = 0b011,
            Configuration = 0b100,
            Invalid1 = 0b101,
            Invalid2 = 0b110,
            Invalid3 = 0b111,
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::NormalOperation as usize],
            > for OperationMode
        {
            type CheckType =
                [(); ((Self::NormalOperation as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::Sleep as usize],
            > for OperationMode
        {
            type CheckType = [(); ((Self::Sleep as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::Loopback as usize],
            > for OperationMode
        {
            type CheckType = [(); ((Self::Loopback as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::ListenOnly as usize],
            > for OperationMode
        {
            type CheckType = [(); ((Self::ListenOnly as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::Configuration as usize],
            > for OperationMode
        {
            type CheckType =
                [(); ((Self::Configuration as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::Invalid1 as usize],
            > for OperationMode
        {
            type CheckType = [(); ((Self::Invalid1 as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::Invalid2 as usize],
            > for OperationMode
        {
            type CheckType = [(); ((Self::Invalid2 as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::Invalid3 as usize],
            > for OperationMode
        {
            type CheckType = [(); ((Self::Invalid3 as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl ::modular_bitfield::Specifier for OperationMode {
            const BITS: usize = 3usize;
            type Bytes = <[(); 3usize] as ::modular_bitfield::private::SpecifierBytes>::Bytes;
            type InOut = Self;
            #[inline]
            fn into_bytes(
                input: Self::InOut,
            ) -> ::core::result::Result<Self::Bytes, ::modular_bitfield::error::OutOfBounds>
            {
                ::core::result::Result::Ok(input as Self::Bytes)
            }
            #[inline]
            fn from_bytes(
                bytes: Self::Bytes,
            ) -> ::core::result::Result<
                Self::InOut,
                ::modular_bitfield::error::InvalidBitPattern<Self::Bytes>,
            > {
                match bytes {
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::NormalOperation
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::NormalOperation)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::Sleep as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::Sleep)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::Loopback as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::Loopback)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::ListenOnly
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::ListenOnly)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::Configuration
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::Configuration)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::Invalid1 as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::Invalid1)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::Invalid2 as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::Invalid2)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::Invalid3 as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::Invalid3)
                    }
                    invalid_bytes => {
                        ::core::result::Result::Err(<::modular_bitfield::error::InvalidBitPattern<
                            Self::Bytes,
                        >>::new(invalid_bytes))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for OperationMode {}
        #[automatically_derived]
        impl ::core::clone::Clone for OperationMode {
            #[inline]
            fn clone(&self) -> OperationMode {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for OperationMode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        OperationMode::NormalOperation => "NormalOperation",
                        OperationMode::Sleep => "Sleep",
                        OperationMode::Loopback => "Loopback",
                        OperationMode::ListenOnly => "ListenOnly",
                        OperationMode::Configuration => "Configuration",
                        OperationMode::Invalid1 => "Invalid1",
                        OperationMode::Invalid2 => "Invalid2",
                        OperationMode::Invalid3 => "Invalid3",
                    },
                )
            }
        }
        impl defmt::Format for OperationMode {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::mcp2515::registers".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"1882818497032354202\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"1882818497032354202\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"NormalOperation|Sleep|Loopback|ListenOnly|Configuration|Invalid1|Invalid2|Invalid3\",\"disambiguator\":\"5487849130262652134\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"NormalOperation|Sleep|Loopback|ListenOnly|Configuration|Invalid1|Invalid2|Invalid3\",\"disambiguator\":\"5487849130262652134\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    OperationMode::NormalOperation {} => {
                        defmt::export::u8(&0u8);
                    }
                    OperationMode::Sleep {} => {
                        defmt::export::u8(&1u8);
                    }
                    OperationMode::Loopback {} => {
                        defmt::export::u8(&2u8);
                    }
                    OperationMode::ListenOnly {} => {
                        defmt::export::u8(&3u8);
                    }
                    OperationMode::Configuration {} => {
                        defmt::export::u8(&4u8);
                    }
                    OperationMode::Invalid1 {} => {
                        defmt::export::u8(&5u8);
                    }
                    OperationMode::Invalid2 {} => {
                        defmt::export::u8(&6u8);
                    }
                    OperationMode::Invalid3 {} => {
                        defmt::export::u8(&7u8);
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for OperationMode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for OperationMode {
            #[inline]
            fn eq(&self, other: &OperationMode) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for OperationMode {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        /// CLKOUT Pin Prescaler
        #[bits = 2]
        pub enum CLKPRE {
            SystemClockDiv1 = 0b000,
            SystemClockDiv2 = 0b001,
            SystemClockDiv4 = 0b010,
            SystemClockDiv8 = 0b011,
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::SystemClockDiv1 as usize],
            > for CLKPRE
        {
            type CheckType =
                [(); ((Self::SystemClockDiv1 as usize) < (0x01_usize << 2usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::SystemClockDiv2 as usize],
            > for CLKPRE
        {
            type CheckType =
                [(); ((Self::SystemClockDiv2 as usize) < (0x01_usize << 2usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::SystemClockDiv4 as usize],
            > for CLKPRE
        {
            type CheckType =
                [(); ((Self::SystemClockDiv4 as usize) < (0x01_usize << 2usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::SystemClockDiv8 as usize],
            > for CLKPRE
        {
            type CheckType =
                [(); ((Self::SystemClockDiv8 as usize) < (0x01_usize << 2usize)) as usize];
        }
        impl ::modular_bitfield::Specifier for CLKPRE {
            const BITS: usize = 2usize;
            type Bytes = <[(); 2usize] as ::modular_bitfield::private::SpecifierBytes>::Bytes;
            type InOut = Self;
            #[inline]
            fn into_bytes(
                input: Self::InOut,
            ) -> ::core::result::Result<Self::Bytes, ::modular_bitfield::error::OutOfBounds>
            {
                ::core::result::Result::Ok(input as Self::Bytes)
            }
            #[inline]
            fn from_bytes(
                bytes: Self::Bytes,
            ) -> ::core::result::Result<
                Self::InOut,
                ::modular_bitfield::error::InvalidBitPattern<Self::Bytes>,
            > {
                match bytes {
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::SystemClockDiv1
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::SystemClockDiv1)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::SystemClockDiv2
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::SystemClockDiv2)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::SystemClockDiv4
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::SystemClockDiv4)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::SystemClockDiv8
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::SystemClockDiv8)
                    }
                    invalid_bytes => {
                        ::core::result::Result::Err(<::modular_bitfield::error::InvalidBitPattern<
                            Self::Bytes,
                        >>::new(invalid_bytes))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for CLKPRE {}
        #[automatically_derived]
        impl ::core::clone::Clone for CLKPRE {
            #[inline]
            fn clone(&self) -> CLKPRE {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CLKPRE {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        CLKPRE::SystemClockDiv1 => "SystemClockDiv1",
                        CLKPRE::SystemClockDiv2 => "SystemClockDiv2",
                        CLKPRE::SystemClockDiv4 => "SystemClockDiv4",
                        CLKPRE::SystemClockDiv8 => "SystemClockDiv8",
                    },
                )
            }
        }
        /// ```ignore
        /// CANCTRL {
        ///     clkpre: CLKPRE::SystemClockDiv8,
        ///     clken: true,
        ///     osm: false, // field not present on MCP2510
        ///     abat: false,
        ///     reqop: OperationMode::Configuration,
        /// }
        /// ```
        impl Default for CANCTRL {
            fn default() -> Self {
                0b1000_0011.into()
            }
        }
        /// CAN Status Register
        ///
        /// Note: Read only
        #[allow(clippy::identity_op)]
        pub struct CANSTAT {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <InterruptFlagCode as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <OperationMode as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for CANSTAT {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for CANSTAT {
            #[inline]
            fn clone(&self) -> CANSTAT {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <InterruptFlagCode as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <OperationMode as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for CANSTAT {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <InterruptFlagCode as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <OperationMode as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl CANSTAT {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <InterruptFlagCode as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <OperationMode as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl CANSTAT {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                           + <InterruptFlagCode as ::modular_bitfield::Specifier>::BITS
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                           + <OperationMode as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <InterruptFlagCode as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <OperationMode as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl CANSTAT {
            ///Returns the value of icod.
            #[inline]
            /// Interrupt Flag Code
            pub fn icod(&self) -> <InterruptFlagCode as ::modular_bitfield::Specifier>::InOut {
                self.icod_or_err()
                    .expect("value contains invalid bit pattern for field CANSTAT.icod")
            }
            ///Returns the value of icod.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for icod.
            #[inline]
            #[allow(dead_code)]
            /// Interrupt Flag Code
            pub fn icod_or_err(
                &self,
            ) -> ::core::result::Result<
                <InterruptFlagCode as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <InterruptFlagCode as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <InterruptFlagCode as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<InterruptFlagCode>(
                        &self.bytes[..],
                        0usize + <B1 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <InterruptFlagCode as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of icod set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for icod.
            #[inline]
            #[allow(dead_code)]
            /// Interrupt Flag Code
            pub fn with_icod(
                mut self,
                new_val: <InterruptFlagCode as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_icod(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of icod set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for icod.
            #[inline]
            #[allow(dead_code)]
            /// Interrupt Flag Code
            pub fn with_icod_checked(
                mut self,
                new_val: <InterruptFlagCode as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_icod_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of icod to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for icod.
            #[inline]
            #[allow(dead_code)]
            /// Interrupt Flag Code
            pub fn set_icod(
                &mut self,
                new_val: <InterruptFlagCode as ::modular_bitfield::Specifier>::InOut,
            ) {
                self.set_icod_checked(new_val)
                    .expect("value out of bounds for field CANSTAT.icod")
            }
            ///Sets the value of icod to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for icod.
            #[inline]
            /// Interrupt Flag Code
            pub fn set_icod_checked(
                &mut self,
                new_val: <InterruptFlagCode as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<
                        <InterruptFlagCode as ::modular_bitfield::Specifier>::Bytes,
                    >();
                let __bf_max_value: <InterruptFlagCode as ::modular_bitfield::Specifier>::Bytes = {
                    !0 >> (__bf_base_bits
                        - <InterruptFlagCode as ::modular_bitfield::Specifier>::BITS)
                };
                let __bf_spec_bits: ::core::primitive::usize =
                    <InterruptFlagCode as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <InterruptFlagCode as ::modular_bitfield::Specifier>::Bytes =
                    { <InterruptFlagCode as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<InterruptFlagCode>(
                    &mut self.bytes[..],
                    0usize + <B1 as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of opmod.
            #[inline]
            /// Operation Mode
            pub fn opmod(&self) -> <OperationMode as ::modular_bitfield::Specifier>::InOut {
                self.opmod_or_err()
                    .expect("value contains invalid bit pattern for field CANSTAT.opmod")
            }
            ///Returns the value of opmod.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for opmod.
            #[inline]
            #[allow(dead_code)]
            /// Operation Mode
            pub fn opmod_or_err(
                &self,
            ) -> ::core::result::Result<
                <OperationMode as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <OperationMode as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <OperationMode as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<OperationMode>(
                        &self.bytes[..],
                        0usize
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <InterruptFlagCode as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <OperationMode as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of opmod set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for opmod.
            #[inline]
            #[allow(dead_code)]
            /// Operation Mode
            pub fn with_opmod(
                mut self,
                new_val: <OperationMode as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_opmod(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of opmod set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for opmod.
            #[inline]
            #[allow(dead_code)]
            /// Operation Mode
            pub fn with_opmod_checked(
                mut self,
                new_val: <OperationMode as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_opmod_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of opmod to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for opmod.
            #[inline]
            #[allow(dead_code)]
            /// Operation Mode
            pub fn set_opmod(
                &mut self,
                new_val: <OperationMode as ::modular_bitfield::Specifier>::InOut,
            ) {
                self.set_opmod_checked(new_val)
                    .expect("value out of bounds for field CANSTAT.opmod")
            }
            ///Sets the value of opmod to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for opmod.
            #[inline]
            /// Operation Mode
            pub fn set_opmod_checked(
                &mut self,
                new_val: <OperationMode as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<OperationMode as ::modular_bitfield::Specifier>::Bytes>(
                    );
                let __bf_max_value: <OperationMode as ::modular_bitfield::Specifier>::Bytes = {
                    !0 >> (__bf_base_bits - <OperationMode as ::modular_bitfield::Specifier>::BITS)
                };
                let __bf_spec_bits: ::core::primitive::usize =
                    <OperationMode as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <OperationMode as ::modular_bitfield::Specifier>::Bytes =
                    { <OperationMode as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<OperationMode>(
                    &mut self.bytes[..],
                    0usize
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <InterruptFlagCode as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for CANSTAT
        where
            [(); {
                0usize
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <InterruptFlagCode as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <OperationMode as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<CANSTAT> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <InterruptFlagCode as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <OperationMode as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: CANSTAT) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for CANSTAT {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("CANSTAT")
                    .field(
                        "icod",
                        self.icod_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "opmod",
                        self.opmod_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Interrupt Flag Code
        #[bits = 3]
        pub enum InterruptFlagCode {
            NoInterrupt = 0b000,
            ErrorInterrupt = 0b001,
            WakeUpInterrupt = 0b010,
            TXB0Interrupt = 0b011,
            TXB1Interrupt = 0b100,
            TXB2Interrupt = 0b101,
            RXB0Interrupt = 0b110,
            RXB1Interrupt = 0b111,
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::NoInterrupt as usize],
            > for InterruptFlagCode
        {
            type CheckType = [(); ((Self::NoInterrupt as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::ErrorInterrupt as usize],
            > for InterruptFlagCode
        {
            type CheckType =
                [(); ((Self::ErrorInterrupt as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::WakeUpInterrupt as usize],
            > for InterruptFlagCode
        {
            type CheckType =
                [(); ((Self::WakeUpInterrupt as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::TXB0Interrupt as usize],
            > for InterruptFlagCode
        {
            type CheckType =
                [(); ((Self::TXB0Interrupt as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::TXB1Interrupt as usize],
            > for InterruptFlagCode
        {
            type CheckType =
                [(); ((Self::TXB1Interrupt as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::TXB2Interrupt as usize],
            > for InterruptFlagCode
        {
            type CheckType =
                [(); ((Self::TXB2Interrupt as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::RXB0Interrupt as usize],
            > for InterruptFlagCode
        {
            type CheckType =
                [(); ((Self::RXB0Interrupt as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::RXB1Interrupt as usize],
            > for InterruptFlagCode
        {
            type CheckType =
                [(); ((Self::RXB1Interrupt as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl ::modular_bitfield::Specifier for InterruptFlagCode {
            const BITS: usize = 3usize;
            type Bytes = <[(); 3usize] as ::modular_bitfield::private::SpecifierBytes>::Bytes;
            type InOut = Self;
            #[inline]
            fn into_bytes(
                input: Self::InOut,
            ) -> ::core::result::Result<Self::Bytes, ::modular_bitfield::error::OutOfBounds>
            {
                ::core::result::Result::Ok(input as Self::Bytes)
            }
            #[inline]
            fn from_bytes(
                bytes: Self::Bytes,
            ) -> ::core::result::Result<
                Self::InOut,
                ::modular_bitfield::error::InvalidBitPattern<Self::Bytes>,
            > {
                match bytes {
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::NoInterrupt
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::NoInterrupt)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::ErrorInterrupt
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::ErrorInterrupt)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::WakeUpInterrupt
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::WakeUpInterrupt)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::TXB0Interrupt
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::TXB0Interrupt)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::TXB1Interrupt
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::TXB1Interrupt)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::TXB2Interrupt
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::TXB2Interrupt)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::RXB0Interrupt
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::RXB0Interrupt)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::RXB1Interrupt
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::RXB1Interrupt)
                    }
                    invalid_bytes => {
                        ::core::result::Result::Err(<::modular_bitfield::error::InvalidBitPattern<
                            Self::Bytes,
                        >>::new(invalid_bytes))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for InterruptFlagCode {}
        #[automatically_derived]
        impl ::core::clone::Clone for InterruptFlagCode {
            #[inline]
            fn clone(&self) -> InterruptFlagCode {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for InterruptFlagCode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        InterruptFlagCode::NoInterrupt => "NoInterrupt",
                        InterruptFlagCode::ErrorInterrupt => "ErrorInterrupt",
                        InterruptFlagCode::WakeUpInterrupt => "WakeUpInterrupt",
                        InterruptFlagCode::TXB0Interrupt => "TXB0Interrupt",
                        InterruptFlagCode::TXB1Interrupt => "TXB1Interrupt",
                        InterruptFlagCode::TXB2Interrupt => "TXB2Interrupt",
                        InterruptFlagCode::RXB0Interrupt => "RXB0Interrupt",
                        InterruptFlagCode::RXB1Interrupt => "RXB1Interrupt",
                    },
                )
            }
        }
        impl Default for CANSTAT {
            fn default() -> Self {
                0b1000_0000.into()
            }
        }
        /// Configuration Registers
        ///
        /// Note: Write operations require Configuration mode
        pub struct CNF {
            /// Configuration 3 Register
            pub cnf3: CNF3,
            /// Configuration 2 Register
            pub cnf2: CNF2,
            /// Configuration 1 Register
            pub cnf1: CNF1,
        }
        #[automatically_derived]
        impl ::core::marker::Copy for CNF {}
        #[automatically_derived]
        impl ::core::clone::Clone for CNF {
            #[inline]
            fn clone(&self) -> CNF {
                let _: ::core::clone::AssertParamIsClone<CNF3>;
                let _: ::core::clone::AssertParamIsClone<CNF2>;
                let _: ::core::clone::AssertParamIsClone<CNF1>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CNF {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "CNF",
                    "cnf3",
                    &self.cnf3,
                    "cnf2",
                    &self.cnf2,
                    "cnf1",
                    &&self.cnf1,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for CNF {
            #[inline]
            fn default() -> CNF {
                CNF {
                    cnf3: ::core::default::Default::default(),
                    cnf2: ::core::default::Default::default(),
                    cnf1: ::core::default::Default::default(),
                }
            }
        }
        impl defmt::Format for CNF
        where
            CNF3: defmt::Format,
            CNF2: defmt::Format,
            CNF1: defmt::Format,
        {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::mcp2515::registers".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"10522829767410933559\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"10522829767410933559\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"CNF {{ cnf3: {=?:?}, cnf2: {=?:?}, cnf1: {=?:?} }}\",\"disambiguator\":\"6063378443225877378\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"CNF {{ cnf3: {=?:?}, cnf2: {=?:?}, cnf1: {=?:?} }}\",\"disambiguator\":\"6063378443225877378\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    Self { cnf3, cnf2, cnf1 } => {
                        defmt::export::fmt(cnf3);
                        defmt::export::fmt(cnf2);
                        defmt::export::fmt(cnf1);
                    }
                }
            }
        }
        impl CNF {
            pub const fn from_bytes(bytes: [u8; 3]) -> Self {
                CNF {
                    cnf3: CNF3::from_bytes([bytes[0]]),
                    cnf2: CNF2::from_bytes([bytes[1]]),
                    cnf1: CNF1::from_bytes([bytes[2]]),
                }
            }
            pub const fn into_bytes(self) -> [u8; 3] {
                [
                    self.cnf3.into_bytes()[0],
                    self.cnf2.into_bytes()[0],
                    self.cnf1.into_bytes()[0],
                ]
            }
        }
        /// Configuration 1 Register
        ///
        /// Note: Write operations require Configuration mode
        #[allow(clippy::identity_op)]
        pub struct CNF1 {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <B6 as ::modular_bitfield::Specifier>::BITS
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for CNF1 {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for CNF1 {
            #[inline]
            fn clone(&self) -> CNF1 {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <B6 as ::modular_bitfield::Specifier>::BITS
                                + <B2 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for CNF1 {
            #[inline]
            fn default() -> CNF1 {
                CNF1 {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        impl defmt::Format for CNF1
        where
            [::core::primitive::u8; {
                ((({
                    0usize
                        + <B6 as ::modular_bitfield::Specifier>::BITS
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize]: defmt::Format,
        {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::mcp2515::registers".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"3382182924224909485\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"3382182924224909485\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"CNF1 {{ bytes: {=?:?} }}\",\"disambiguator\":\"3400368740779350968\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"CNF1 {{ bytes: {=?:?} }}\",\"disambiguator\":\"3400368740779350968\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    Self { bytes } => {
                        defmt::export::fmt(bytes);
                    }
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for CNF1 {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <B6 as ::modular_bitfield::Specifier>::BITS
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl CNF1 {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <B6 as ::modular_bitfield::Specifier>::BITS
                                + <B2 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl CNF1 {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <B6 as ::modular_bitfield::Specifier>::BITS
                           + <B2 as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <B6 as ::modular_bitfield::Specifier>::BITS
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
        };
        impl CNF1 {
            ///Returns the value of brp.
            #[inline]
            /// Baud Rate Prescaler
            pub fn brp(&self) -> <B6 as ::modular_bitfield::Specifier>::InOut {
                self.brp_or_err()
                    .expect("value contains invalid bit pattern for field CNF1.brp")
            }
            ///Returns the value of brp.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for brp.
            #[inline]
            #[allow(dead_code)]
            /// Baud Rate Prescaler
            pub fn brp_or_err(
                &self,
            ) -> ::core::result::Result<
                <B6 as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <B6 as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <B6 as ::modular_bitfield::Specifier>::Bytes =
                    { ::modular_bitfield::private::read_specifier::<B6>(&self.bytes[..], 0usize) };
                <B6 as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of brp set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for brp.
            #[inline]
            #[allow(dead_code)]
            /// Baud Rate Prescaler
            pub fn with_brp(
                mut self,
                new_val: <B6 as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_brp(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of brp set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for brp.
            #[inline]
            #[allow(dead_code)]
            /// Baud Rate Prescaler
            pub fn with_brp_checked(
                mut self,
                new_val: <B6 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_brp_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of brp to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for brp.
            #[inline]
            #[allow(dead_code)]
            /// Baud Rate Prescaler
            pub fn set_brp(&mut self, new_val: <B6 as ::modular_bitfield::Specifier>::InOut) {
                self.set_brp_checked(new_val)
                    .expect("value out of bounds for field CNF1.brp")
            }
            ///Sets the value of brp to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for brp.
            #[inline]
            /// Baud Rate Prescaler
            pub fn set_brp_checked(
                &mut self,
                new_val: <B6 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize =
                    8usize * ::core::mem::size_of::<<B6 as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <B6 as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <B6 as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <B6 as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <B6 as ::modular_bitfield::Specifier>::Bytes =
                    { <B6 as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<B6>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of sjw.
            #[inline]
            /// Synchronization Jump Width Length
            pub fn sjw(&self) -> <B2 as ::modular_bitfield::Specifier>::InOut {
                self.sjw_or_err()
                    .expect("value contains invalid bit pattern for field CNF1.sjw")
            }
            ///Returns the value of sjw.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for sjw.
            #[inline]
            #[allow(dead_code)]
            /// Synchronization Jump Width Length
            pub fn sjw_or_err(
                &self,
            ) -> ::core::result::Result<
                <B2 as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <B2 as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <B2 as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<B2>(
                        &self.bytes[..],
                        0usize + <B6 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <B2 as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of sjw set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for sjw.
            #[inline]
            #[allow(dead_code)]
            /// Synchronization Jump Width Length
            pub fn with_sjw(
                mut self,
                new_val: <B2 as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_sjw(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of sjw set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for sjw.
            #[inline]
            #[allow(dead_code)]
            /// Synchronization Jump Width Length
            pub fn with_sjw_checked(
                mut self,
                new_val: <B2 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_sjw_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of sjw to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for sjw.
            #[inline]
            #[allow(dead_code)]
            /// Synchronization Jump Width Length
            pub fn set_sjw(&mut self, new_val: <B2 as ::modular_bitfield::Specifier>::InOut) {
                self.set_sjw_checked(new_val)
                    .expect("value out of bounds for field CNF1.sjw")
            }
            ///Sets the value of sjw to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for sjw.
            #[inline]
            /// Synchronization Jump Width Length
            pub fn set_sjw_checked(
                &mut self,
                new_val: <B2 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize =
                    8usize * ::core::mem::size_of::<<B2 as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <B2 as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <B2 as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <B2 as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <B2 as ::modular_bitfield::Specifier>::Bytes =
                    { <B2 as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<B2>(
                    &mut self.bytes[..],
                    0usize + <B6 as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for CNF1
        where
            [(); {
                0usize
                    + <B6 as ::modular_bitfield::Specifier>::BITS
                    + <B2 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<CNF1> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <B6 as ::modular_bitfield::Specifier>::BITS
                    + <B2 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: CNF1) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for CNF1 {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("CNF1")
                    .field(
                        "brp",
                        self.brp_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "sjw",
                        self.sjw_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Configuration 2 Register
        ///
        /// Note: Write operations require Configuration mode
        #[allow(clippy::identity_op)]
        pub struct CNF2 {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for CNF2 {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for CNF2 {
            #[inline]
            fn clone(&self) -> CNF2 {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <B3 as ::modular_bitfield::Specifier>::BITS
                                + <B3 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for CNF2 {
            #[inline]
            fn default() -> CNF2 {
                CNF2 {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        impl defmt::Format for CNF2
        where
            [::core::primitive::u8; {
                ((({
                    0usize
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize]: defmt::Format,
        {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::mcp2515::registers".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"17494657964708773864\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"17494657964708773864\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"CNF2 {{ bytes: {=?:?} }}\",\"disambiguator\":\"15161261577349295306\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"CNF2 {{ bytes: {=?:?} }}\",\"disambiguator\":\"15161261577349295306\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    Self { bytes } => {
                        defmt::export::fmt(bytes);
                    }
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for CNF2 {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl CNF2 {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <B3 as ::modular_bitfield::Specifier>::BITS
                                + <B3 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl CNF2 {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <B3 as ::modular_bitfield::Specifier>::BITS
                           + <B3 as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl CNF2 {
            ///Returns the value of prseg.
            #[inline]
            /// Propagation Segment Length
            pub fn prseg(&self) -> <B3 as ::modular_bitfield::Specifier>::InOut {
                self.prseg_or_err()
                    .expect("value contains invalid bit pattern for field CNF2.prseg")
            }
            ///Returns the value of prseg.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for prseg.
            #[inline]
            #[allow(dead_code)]
            /// Propagation Segment Length
            pub fn prseg_or_err(
                &self,
            ) -> ::core::result::Result<
                <B3 as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <B3 as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <B3 as ::modular_bitfield::Specifier>::Bytes =
                    { ::modular_bitfield::private::read_specifier::<B3>(&self.bytes[..], 0usize) };
                <B3 as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of prseg set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for prseg.
            #[inline]
            #[allow(dead_code)]
            /// Propagation Segment Length
            pub fn with_prseg(
                mut self,
                new_val: <B3 as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_prseg(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of prseg set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for prseg.
            #[inline]
            #[allow(dead_code)]
            /// Propagation Segment Length
            pub fn with_prseg_checked(
                mut self,
                new_val: <B3 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_prseg_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of prseg to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for prseg.
            #[inline]
            #[allow(dead_code)]
            /// Propagation Segment Length
            pub fn set_prseg(&mut self, new_val: <B3 as ::modular_bitfield::Specifier>::InOut) {
                self.set_prseg_checked(new_val)
                    .expect("value out of bounds for field CNF2.prseg")
            }
            ///Sets the value of prseg to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for prseg.
            #[inline]
            /// Propagation Segment Length
            pub fn set_prseg_checked(
                &mut self,
                new_val: <B3 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize =
                    8usize * ::core::mem::size_of::<<B3 as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <B3 as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <B3 as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <B3 as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <B3 as ::modular_bitfield::Specifier>::Bytes =
                    { <B3 as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<B3>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of phseg1.
            #[inline]
            /// PS1 Length
            pub fn phseg1(&self) -> <B3 as ::modular_bitfield::Specifier>::InOut {
                self.phseg1_or_err()
                    .expect("value contains invalid bit pattern for field CNF2.phseg1")
            }
            ///Returns the value of phseg1.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for phseg1.
            #[inline]
            #[allow(dead_code)]
            /// PS1 Length
            pub fn phseg1_or_err(
                &self,
            ) -> ::core::result::Result<
                <B3 as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <B3 as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <B3 as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<B3>(
                        &self.bytes[..],
                        0usize + <B3 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <B3 as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of phseg1 set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for phseg1.
            #[inline]
            #[allow(dead_code)]
            /// PS1 Length
            pub fn with_phseg1(
                mut self,
                new_val: <B3 as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_phseg1(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of phseg1 set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for phseg1.
            #[inline]
            #[allow(dead_code)]
            /// PS1 Length
            pub fn with_phseg1_checked(
                mut self,
                new_val: <B3 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_phseg1_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of phseg1 to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for phseg1.
            #[inline]
            #[allow(dead_code)]
            /// PS1 Length
            pub fn set_phseg1(&mut self, new_val: <B3 as ::modular_bitfield::Specifier>::InOut) {
                self.set_phseg1_checked(new_val)
                    .expect("value out of bounds for field CNF2.phseg1")
            }
            ///Sets the value of phseg1 to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for phseg1.
            #[inline]
            /// PS1 Length
            pub fn set_phseg1_checked(
                &mut self,
                new_val: <B3 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize =
                    8usize * ::core::mem::size_of::<<B3 as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <B3 as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <B3 as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <B3 as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <B3 as ::modular_bitfield::Specifier>::Bytes =
                    { <B3 as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<B3>(
                    &mut self.bytes[..],
                    0usize + <B3 as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of sam.
            #[inline]
            /// Sample Point Configuration
            pub fn sam(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.sam_or_err()
                    .expect("value contains invalid bit pattern for field CNF2.sam")
            }
            ///Returns the value of sam.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for sam.
            #[inline]
            #[allow(dead_code)]
            /// Sample Point Configuration
            pub fn sam_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <B3 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of sam set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for sam.
            #[inline]
            #[allow(dead_code)]
            /// Sample Point Configuration
            pub fn with_sam(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_sam(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of sam set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for sam.
            #[inline]
            #[allow(dead_code)]
            /// Sample Point Configuration
            pub fn with_sam_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_sam_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of sam to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for sam.
            #[inline]
            #[allow(dead_code)]
            /// Sample Point Configuration
            pub fn set_sam(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_sam_checked(new_val)
                    .expect("value out of bounds for field CNF2.sam")
            }
            ///Sets the value of sam to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for sam.
            #[inline]
            /// Sample Point Configuration
            pub fn set_sam_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <B3 as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of btlmode.
            #[inline]
            /// PS2 Bit Time Length
            pub fn btlmode(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.btlmode_or_err()
                    .expect("value contains invalid bit pattern for field CNF2.btlmode")
            }
            ///Returns the value of btlmode.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for btlmode.
            #[inline]
            #[allow(dead_code)]
            /// PS2 Bit Time Length
            pub fn btlmode_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of btlmode set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for btlmode.
            #[inline]
            #[allow(dead_code)]
            /// PS2 Bit Time Length
            pub fn with_btlmode(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_btlmode(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of btlmode set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for btlmode.
            #[inline]
            #[allow(dead_code)]
            /// PS2 Bit Time Length
            pub fn with_btlmode_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_btlmode_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of btlmode to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for btlmode.
            #[inline]
            #[allow(dead_code)]
            /// PS2 Bit Time Length
            pub fn set_btlmode(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_btlmode_checked(new_val)
                    .expect("value out of bounds for field CNF2.btlmode")
            }
            ///Sets the value of btlmode to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for btlmode.
            #[inline]
            /// PS2 Bit Time Length
            pub fn set_btlmode_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for CNF2
        where
            [(); {
                0usize
                    + <B3 as ::modular_bitfield::Specifier>::BITS
                    + <B3 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<CNF2> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <B3 as ::modular_bitfield::Specifier>::BITS
                    + <B3 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: CNF2) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for CNF2 {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("CNF2")
                    .field(
                        "prseg",
                        self.prseg_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "phseg1",
                        self.phseg1_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "sam",
                        self.sam_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "btlmode",
                        self.btlmode_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Configuration 3 Register
        ///
        /// Note: Write operations require Configuration mode
        #[allow(clippy::identity_op)]
        pub struct CNF3 {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for CNF3 {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for CNF3 {
            #[inline]
            fn clone(&self) -> CNF3 {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <B3 as ::modular_bitfield::Specifier>::BITS
                                + <B3 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for CNF3 {
            #[inline]
            fn default() -> CNF3 {
                CNF3 {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        impl defmt::Format for CNF3
        where
            [::core::primitive::u8; {
                ((({
                    0usize
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize]: defmt::Format,
        {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::mcp2515::registers".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"14999008207607299689\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"14999008207607299689\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"CNF3 {{ bytes: {=?:?} }}\",\"disambiguator\":\"17977522292167904568\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"CNF3 {{ bytes: {=?:?} }}\",\"disambiguator\":\"17977522292167904568\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    Self { bytes } => {
                        defmt::export::fmt(bytes);
                    }
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for CNF3 {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl CNF3 {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <B3 as ::modular_bitfield::Specifier>::BITS
                                + <B3 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl CNF3 {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <B3 as ::modular_bitfield::Specifier>::BITS
                           + <B3 as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl CNF3 {
            ///Returns the value of phseg2.
            #[inline]
            /// PS2 Length
            /// Note: Minimum valid setting is 1
            pub fn phseg2(&self) -> <B3 as ::modular_bitfield::Specifier>::InOut {
                self.phseg2_or_err()
                    .expect("value contains invalid bit pattern for field CNF3.phseg2")
            }
            ///Returns the value of phseg2.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for phseg2.
            #[inline]
            #[allow(dead_code)]
            /// PS2 Length
            /// Note: Minimum valid setting is 1
            pub fn phseg2_or_err(
                &self,
            ) -> ::core::result::Result<
                <B3 as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <B3 as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <B3 as ::modular_bitfield::Specifier>::Bytes =
                    { ::modular_bitfield::private::read_specifier::<B3>(&self.bytes[..], 0usize) };
                <B3 as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of phseg2 set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for phseg2.
            #[inline]
            #[allow(dead_code)]
            /// PS2 Length
            /// Note: Minimum valid setting is 1
            pub fn with_phseg2(
                mut self,
                new_val: <B3 as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_phseg2(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of phseg2 set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for phseg2.
            #[inline]
            #[allow(dead_code)]
            /// PS2 Length
            /// Note: Minimum valid setting is 1
            pub fn with_phseg2_checked(
                mut self,
                new_val: <B3 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_phseg2_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of phseg2 to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for phseg2.
            #[inline]
            #[allow(dead_code)]
            /// PS2 Length
            /// Note: Minimum valid setting is 1
            pub fn set_phseg2(&mut self, new_val: <B3 as ::modular_bitfield::Specifier>::InOut) {
                self.set_phseg2_checked(new_val)
                    .expect("value out of bounds for field CNF3.phseg2")
            }
            ///Sets the value of phseg2 to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for phseg2.
            #[inline]
            /// PS2 Length
            /// Note: Minimum valid setting is 1
            pub fn set_phseg2_checked(
                &mut self,
                new_val: <B3 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize =
                    8usize * ::core::mem::size_of::<<B3 as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <B3 as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <B3 as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <B3 as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <B3 as ::modular_bitfield::Specifier>::Bytes =
                    { <B3 as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<B3>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of wakfil.
            #[inline]
            /// Wake-up Filter
            pub fn wakfil(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.wakfil_or_err()
                    .expect("value contains invalid bit pattern for field CNF3.wakfil")
            }
            ///Returns the value of wakfil.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for wakfil.
            #[inline]
            #[allow(dead_code)]
            /// Wake-up Filter
            pub fn wakfil_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <B3 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of wakfil set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for wakfil.
            #[inline]
            #[allow(dead_code)]
            /// Wake-up Filter
            pub fn with_wakfil(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_wakfil(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of wakfil set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for wakfil.
            #[inline]
            #[allow(dead_code)]
            /// Wake-up Filter
            pub fn with_wakfil_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_wakfil_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of wakfil to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for wakfil.
            #[inline]
            #[allow(dead_code)]
            /// Wake-up Filter
            pub fn set_wakfil(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_wakfil_checked(new_val)
                    .expect("value out of bounds for field CNF3.wakfil")
            }
            ///Sets the value of wakfil to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for wakfil.
            #[inline]
            /// Wake-up Filter
            pub fn set_wakfil_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <B3 as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of sof.
            #[inline]
            /// Start-of-Frame Signal
            pub fn sof(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.sof_or_err()
                    .expect("value contains invalid bit pattern for field CNF3.sof")
            }
            ///Returns the value of sof.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for sof.
            #[inline]
            #[allow(dead_code)]
            /// Start-of-Frame Signal
            pub fn sof_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <B3 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of sof set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for sof.
            #[inline]
            #[allow(dead_code)]
            /// Start-of-Frame Signal
            pub fn with_sof(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_sof(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of sof set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for sof.
            #[inline]
            #[allow(dead_code)]
            /// Start-of-Frame Signal
            pub fn with_sof_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_sof_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of sof to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for sof.
            #[inline]
            #[allow(dead_code)]
            /// Start-of-Frame Signal
            pub fn set_sof(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_sof_checked(new_val)
                    .expect("value out of bounds for field CNF3.sof")
            }
            ///Sets the value of sof to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for sof.
            #[inline]
            /// Start-of-Frame Signal
            pub fn set_sof_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <B3 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for CNF3
        where
            [(); {
                0usize
                    + <B3 as ::modular_bitfield::Specifier>::BITS
                    + <B3 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<CNF3> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <B3 as ::modular_bitfield::Specifier>::BITS
                    + <B3 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: CNF3) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for CNF3 {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("CNF3")
                    .field(
                        "phseg2",
                        self.phseg2_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "wakfil",
                        self.wakfil_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "sof",
                        self.sof_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Data Length Code Register
        #[allow(clippy::identity_op)]
        pub struct DLC {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <B4 as ::modular_bitfield::Specifier>::BITS
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for DLC {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for DLC {
            #[inline]
            fn clone(&self) -> DLC {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <B4 as ::modular_bitfield::Specifier>::BITS
                                + <B2 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for DLC {
            #[inline]
            fn default() -> DLC {
                DLC {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        impl defmt::Format for DLC
        where
            [::core::primitive::u8; {
                ((({
                    0usize
                        + <B4 as ::modular_bitfield::Specifier>::BITS
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize]: defmt::Format,
        {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::mcp2515::registers".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"11162338324807480803\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"11162338324807480803\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"DLC {{ bytes: {=?:?} }}\",\"disambiguator\":\"13414942303427674861\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"DLC {{ bytes: {=?:?} }}\",\"disambiguator\":\"13414942303427674861\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    Self { bytes } => {
                        defmt::export::fmt(bytes);
                    }
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for DLC {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <B4 as ::modular_bitfield::Specifier>::BITS
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl DLC {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <B4 as ::modular_bitfield::Specifier>::BITS
                                + <B2 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl DLC {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <B4 as ::modular_bitfield::Specifier>::BITS
                           + <B2 as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <B4 as ::modular_bitfield::Specifier>::BITS
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl DLC {
            ///Returns the value of dlc.
            #[inline]
            /// Data Length Code
            pub fn dlc(&self) -> <B4 as ::modular_bitfield::Specifier>::InOut {
                self.dlc_or_err()
                    .expect("value contains invalid bit pattern for field DLC.dlc")
            }
            ///Returns the value of dlc.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for dlc.
            #[inline]
            #[allow(dead_code)]
            /// Data Length Code
            pub fn dlc_or_err(
                &self,
            ) -> ::core::result::Result<
                <B4 as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <B4 as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <B4 as ::modular_bitfield::Specifier>::Bytes =
                    { ::modular_bitfield::private::read_specifier::<B4>(&self.bytes[..], 0usize) };
                <B4 as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of dlc set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for dlc.
            #[inline]
            #[allow(dead_code)]
            /// Data Length Code
            pub fn with_dlc(
                mut self,
                new_val: <B4 as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_dlc(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of dlc set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for dlc.
            #[inline]
            #[allow(dead_code)]
            /// Data Length Code
            pub fn with_dlc_checked(
                mut self,
                new_val: <B4 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_dlc_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of dlc to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for dlc.
            #[inline]
            #[allow(dead_code)]
            /// Data Length Code
            pub fn set_dlc(&mut self, new_val: <B4 as ::modular_bitfield::Specifier>::InOut) {
                self.set_dlc_checked(new_val)
                    .expect("value out of bounds for field DLC.dlc")
            }
            ///Sets the value of dlc to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for dlc.
            #[inline]
            /// Data Length Code
            pub fn set_dlc_checked(
                &mut self,
                new_val: <B4 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize =
                    8usize * ::core::mem::size_of::<<B4 as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <B4 as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <B4 as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <B4 as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <B4 as ::modular_bitfield::Specifier>::Bytes =
                    { <B4 as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<B4>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of rtr.
            #[inline]
            /// Remote Transmission Request
            pub fn rtr(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rtr_or_err()
                    .expect("value contains invalid bit pattern for field DLC.rtr")
            }
            ///Returns the value of rtr.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rtr.
            #[inline]
            #[allow(dead_code)]
            /// Remote Transmission Request
            pub fn rtr_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B4 as ::modular_bitfield::Specifier>::BITS
                            + <B2 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rtr set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rtr.
            #[inline]
            #[allow(dead_code)]
            /// Remote Transmission Request
            pub fn with_rtr(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rtr(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rtr set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rtr.
            #[inline]
            #[allow(dead_code)]
            /// Remote Transmission Request
            pub fn with_rtr_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rtr_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rtr to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rtr.
            #[inline]
            #[allow(dead_code)]
            /// Remote Transmission Request
            pub fn set_rtr(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_rtr_checked(new_val)
                    .expect("value out of bounds for field DLC.rtr")
            }
            ///Sets the value of rtr to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rtr.
            #[inline]
            /// Remote Transmission Request
            pub fn set_rtr_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B4 as ::modular_bitfield::Specifier>::BITS
                        + <B2 as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for DLC
        where
            [(); {
                0usize
                    + <B4 as ::modular_bitfield::Specifier>::BITS
                    + <B2 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<DLC> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <B4 as ::modular_bitfield::Specifier>::BITS
                    + <B2 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: DLC) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for DLC {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("DLC")
                    .field(
                        "dlc",
                        self.dlc_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "rtr",
                        self.rtr_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Transmit Buffer 0 Control Register
        #[allow(clippy::identity_op)]
        pub struct TXB0CTRL {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for TXB0CTRL {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for TXB0CTRL {
            #[inline]
            fn clone(&self) -> TXB0CTRL {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <B2 as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for TXB0CTRL {
            #[inline]
            fn default() -> TXB0CTRL {
                TXB0CTRL {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for TXB0CTRL {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl TXB0CTRL {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <B2 as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl TXB0CTRL {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <B2 as ::modular_bitfield::Specifier>::BITS
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl TXB0CTRL {
            ///Returns the value of txp.
            #[inline]
            /// Transmit Buffer Priority
            pub fn txp(&self) -> <B2 as ::modular_bitfield::Specifier>::InOut {
                self.txp_or_err()
                    .expect("value contains invalid bit pattern for field TXB0CTRL.txp")
            }
            ///Returns the value of txp.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txp.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer Priority
            pub fn txp_or_err(
                &self,
            ) -> ::core::result::Result<
                <B2 as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <B2 as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <B2 as ::modular_bitfield::Specifier>::Bytes =
                    { ::modular_bitfield::private::read_specifier::<B2>(&self.bytes[..], 0usize) };
                <B2 as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txp set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txp.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer Priority
            pub fn with_txp(
                mut self,
                new_val: <B2 as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txp(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txp set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txp.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer Priority
            pub fn with_txp_checked(
                mut self,
                new_val: <B2 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txp_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txp to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txp.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer Priority
            pub fn set_txp(&mut self, new_val: <B2 as ::modular_bitfield::Specifier>::InOut) {
                self.set_txp_checked(new_val)
                    .expect("value out of bounds for field TXB0CTRL.txp")
            }
            ///Sets the value of txp to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txp.
            #[inline]
            /// Transmit Buffer Priority
            pub fn set_txp_checked(
                &mut self,
                new_val: <B2 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize =
                    8usize * ::core::mem::size_of::<<B2 as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <B2 as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <B2 as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <B2 as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <B2 as ::modular_bitfield::Specifier>::Bytes =
                    { <B2 as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<B2>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of txreq.
            #[inline]
            /// Message Transmit Request
            pub fn txreq(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.txreq_or_err()
                    .expect("value contains invalid bit pattern for field TXB0CTRL.txreq")
            }
            ///Returns the value of txreq.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txreq.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request
            pub fn txreq_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txreq set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txreq.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request
            pub fn with_txreq(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txreq(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txreq set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txreq.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request
            pub fn with_txreq_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txreq_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txreq to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txreq.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request
            pub fn set_txreq(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_txreq_checked(new_val)
                    .expect("value out of bounds for field TXB0CTRL.txreq")
            }
            ///Sets the value of txreq to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txreq.
            #[inline]
            /// Message Transmit Request
            pub fn set_txreq_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of txerr.
            #[inline]
            /// Transmission Error Detected
            pub fn txerr(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.txerr_or_err()
                    .expect("value contains invalid bit pattern for field TXB0CTRL.txerr")
            }
            ///Returns the value of txerr.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txerr.
            #[inline]
            #[allow(dead_code)]
            /// Transmission Error Detected
            pub fn txerr_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txerr set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txerr.
            #[inline]
            #[allow(dead_code)]
            /// Transmission Error Detected
            pub fn with_txerr(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txerr(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txerr set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txerr.
            #[inline]
            #[allow(dead_code)]
            /// Transmission Error Detected
            pub fn with_txerr_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txerr_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txerr to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txerr.
            #[inline]
            #[allow(dead_code)]
            /// Transmission Error Detected
            pub fn set_txerr(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_txerr_checked(new_val)
                    .expect("value out of bounds for field TXB0CTRL.txerr")
            }
            ///Sets the value of txerr to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txerr.
            #[inline]
            /// Transmission Error Detected
            pub fn set_txerr_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of mloa.
            #[inline]
            /// : Message Lost Arbitration
            pub fn mloa(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.mloa_or_err()
                    .expect("value contains invalid bit pattern for field TXB0CTRL.mloa")
            }
            ///Returns the value of mloa.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for mloa.
            #[inline]
            #[allow(dead_code)]
            /// : Message Lost Arbitration
            pub fn mloa_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of mloa set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for mloa.
            #[inline]
            #[allow(dead_code)]
            /// : Message Lost Arbitration
            pub fn with_mloa(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_mloa(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of mloa set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for mloa.
            #[inline]
            #[allow(dead_code)]
            /// : Message Lost Arbitration
            pub fn with_mloa_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_mloa_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of mloa to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for mloa.
            #[inline]
            #[allow(dead_code)]
            /// : Message Lost Arbitration
            pub fn set_mloa(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_mloa_checked(new_val)
                    .expect("value out of bounds for field TXB0CTRL.mloa")
            }
            ///Sets the value of mloa to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for mloa.
            #[inline]
            /// : Message Lost Arbitration
            pub fn set_mloa_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of abtf.
            #[inline]
            /// Message Aborted Flag
            pub fn abtf(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.abtf_or_err()
                    .expect("value contains invalid bit pattern for field TXB0CTRL.abtf")
            }
            ///Returns the value of abtf.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for abtf.
            #[inline]
            #[allow(dead_code)]
            /// Message Aborted Flag
            pub fn abtf_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of abtf set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for abtf.
            #[inline]
            #[allow(dead_code)]
            /// Message Aborted Flag
            pub fn with_abtf(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_abtf(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of abtf set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for abtf.
            #[inline]
            #[allow(dead_code)]
            /// Message Aborted Flag
            pub fn with_abtf_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_abtf_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of abtf to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for abtf.
            #[inline]
            #[allow(dead_code)]
            /// Message Aborted Flag
            pub fn set_abtf(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_abtf_checked(new_val)
                    .expect("value out of bounds for field TXB0CTRL.abtf")
            }
            ///Sets the value of abtf to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for abtf.
            #[inline]
            /// Message Aborted Flag
            pub fn set_abtf_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for TXB0CTRL
        where
            [(); {
                0usize
                    + <B2 as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<TXB0CTRL> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <B2 as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: TXB0CTRL) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for TXB0CTRL {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("TXB0CTRL")
                    .field(
                        "txp",
                        self.txp_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "txreq",
                        self.txreq_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "txerr",
                        self.txerr_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "mloa",
                        self.mloa_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "abtf",
                        self.abtf_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Transmit Buffer 1 Control Register
        #[allow(clippy::identity_op)]
        pub struct TXB1CTRL {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for TXB1CTRL {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for TXB1CTRL {
            #[inline]
            fn clone(&self) -> TXB1CTRL {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <B2 as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for TXB1CTRL {
            #[inline]
            fn default() -> TXB1CTRL {
                TXB1CTRL {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for TXB1CTRL {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl TXB1CTRL {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <B2 as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl TXB1CTRL {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <B2 as ::modular_bitfield::Specifier>::BITS
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl TXB1CTRL {
            ///Returns the value of txp.
            #[inline]
            /// Transmit Buffer Priority
            pub fn txp(&self) -> <B2 as ::modular_bitfield::Specifier>::InOut {
                self.txp_or_err()
                    .expect("value contains invalid bit pattern for field TXB1CTRL.txp")
            }
            ///Returns the value of txp.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txp.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer Priority
            pub fn txp_or_err(
                &self,
            ) -> ::core::result::Result<
                <B2 as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <B2 as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <B2 as ::modular_bitfield::Specifier>::Bytes =
                    { ::modular_bitfield::private::read_specifier::<B2>(&self.bytes[..], 0usize) };
                <B2 as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txp set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txp.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer Priority
            pub fn with_txp(
                mut self,
                new_val: <B2 as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txp(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txp set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txp.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer Priority
            pub fn with_txp_checked(
                mut self,
                new_val: <B2 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txp_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txp to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txp.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer Priority
            pub fn set_txp(&mut self, new_val: <B2 as ::modular_bitfield::Specifier>::InOut) {
                self.set_txp_checked(new_val)
                    .expect("value out of bounds for field TXB1CTRL.txp")
            }
            ///Sets the value of txp to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txp.
            #[inline]
            /// Transmit Buffer Priority
            pub fn set_txp_checked(
                &mut self,
                new_val: <B2 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize =
                    8usize * ::core::mem::size_of::<<B2 as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <B2 as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <B2 as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <B2 as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <B2 as ::modular_bitfield::Specifier>::Bytes =
                    { <B2 as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<B2>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of txreq.
            #[inline]
            /// Message Transmit Request
            pub fn txreq(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.txreq_or_err()
                    .expect("value contains invalid bit pattern for field TXB1CTRL.txreq")
            }
            ///Returns the value of txreq.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txreq.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request
            pub fn txreq_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txreq set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txreq.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request
            pub fn with_txreq(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txreq(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txreq set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txreq.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request
            pub fn with_txreq_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txreq_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txreq to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txreq.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request
            pub fn set_txreq(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_txreq_checked(new_val)
                    .expect("value out of bounds for field TXB1CTRL.txreq")
            }
            ///Sets the value of txreq to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txreq.
            #[inline]
            /// Message Transmit Request
            pub fn set_txreq_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of txerr.
            #[inline]
            /// Transmission Error Detected
            pub fn txerr(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.txerr_or_err()
                    .expect("value contains invalid bit pattern for field TXB1CTRL.txerr")
            }
            ///Returns the value of txerr.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txerr.
            #[inline]
            #[allow(dead_code)]
            /// Transmission Error Detected
            pub fn txerr_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txerr set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txerr.
            #[inline]
            #[allow(dead_code)]
            /// Transmission Error Detected
            pub fn with_txerr(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txerr(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txerr set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txerr.
            #[inline]
            #[allow(dead_code)]
            /// Transmission Error Detected
            pub fn with_txerr_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txerr_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txerr to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txerr.
            #[inline]
            #[allow(dead_code)]
            /// Transmission Error Detected
            pub fn set_txerr(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_txerr_checked(new_val)
                    .expect("value out of bounds for field TXB1CTRL.txerr")
            }
            ///Sets the value of txerr to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txerr.
            #[inline]
            /// Transmission Error Detected
            pub fn set_txerr_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of mloa.
            #[inline]
            /// : Message Lost Arbitration
            pub fn mloa(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.mloa_or_err()
                    .expect("value contains invalid bit pattern for field TXB1CTRL.mloa")
            }
            ///Returns the value of mloa.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for mloa.
            #[inline]
            #[allow(dead_code)]
            /// : Message Lost Arbitration
            pub fn mloa_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of mloa set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for mloa.
            #[inline]
            #[allow(dead_code)]
            /// : Message Lost Arbitration
            pub fn with_mloa(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_mloa(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of mloa set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for mloa.
            #[inline]
            #[allow(dead_code)]
            /// : Message Lost Arbitration
            pub fn with_mloa_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_mloa_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of mloa to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for mloa.
            #[inline]
            #[allow(dead_code)]
            /// : Message Lost Arbitration
            pub fn set_mloa(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_mloa_checked(new_val)
                    .expect("value out of bounds for field TXB1CTRL.mloa")
            }
            ///Sets the value of mloa to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for mloa.
            #[inline]
            /// : Message Lost Arbitration
            pub fn set_mloa_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of abtf.
            #[inline]
            /// Message Aborted Flag
            pub fn abtf(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.abtf_or_err()
                    .expect("value contains invalid bit pattern for field TXB1CTRL.abtf")
            }
            ///Returns the value of abtf.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for abtf.
            #[inline]
            #[allow(dead_code)]
            /// Message Aborted Flag
            pub fn abtf_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of abtf set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for abtf.
            #[inline]
            #[allow(dead_code)]
            /// Message Aborted Flag
            pub fn with_abtf(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_abtf(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of abtf set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for abtf.
            #[inline]
            #[allow(dead_code)]
            /// Message Aborted Flag
            pub fn with_abtf_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_abtf_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of abtf to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for abtf.
            #[inline]
            #[allow(dead_code)]
            /// Message Aborted Flag
            pub fn set_abtf(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_abtf_checked(new_val)
                    .expect("value out of bounds for field TXB1CTRL.abtf")
            }
            ///Sets the value of abtf to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for abtf.
            #[inline]
            /// Message Aborted Flag
            pub fn set_abtf_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for TXB1CTRL
        where
            [(); {
                0usize
                    + <B2 as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<TXB1CTRL> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <B2 as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: TXB1CTRL) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for TXB1CTRL {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("TXB1CTRL")
                    .field(
                        "txp",
                        self.txp_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "txreq",
                        self.txreq_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "txerr",
                        self.txerr_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "mloa",
                        self.mloa_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "abtf",
                        self.abtf_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Transmit Buffer 2 Control Register
        #[allow(clippy::identity_op)]
        pub struct TXB2CTRL {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for TXB2CTRL {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for TXB2CTRL {
            #[inline]
            fn clone(&self) -> TXB2CTRL {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <B2 as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for TXB2CTRL {
            #[inline]
            fn default() -> TXB2CTRL {
                TXB2CTRL {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for TXB2CTRL {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl TXB2CTRL {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <B2 as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl TXB2CTRL {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <B2 as ::modular_bitfield::Specifier>::BITS
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl TXB2CTRL {
            ///Returns the value of txp.
            #[inline]
            /// Transmit Buffer Priority
            pub fn txp(&self) -> <B2 as ::modular_bitfield::Specifier>::InOut {
                self.txp_or_err()
                    .expect("value contains invalid bit pattern for field TXB2CTRL.txp")
            }
            ///Returns the value of txp.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txp.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer Priority
            pub fn txp_or_err(
                &self,
            ) -> ::core::result::Result<
                <B2 as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <B2 as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <B2 as ::modular_bitfield::Specifier>::Bytes =
                    { ::modular_bitfield::private::read_specifier::<B2>(&self.bytes[..], 0usize) };
                <B2 as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txp set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txp.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer Priority
            pub fn with_txp(
                mut self,
                new_val: <B2 as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txp(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txp set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txp.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer Priority
            pub fn with_txp_checked(
                mut self,
                new_val: <B2 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txp_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txp to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txp.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer Priority
            pub fn set_txp(&mut self, new_val: <B2 as ::modular_bitfield::Specifier>::InOut) {
                self.set_txp_checked(new_val)
                    .expect("value out of bounds for field TXB2CTRL.txp")
            }
            ///Sets the value of txp to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txp.
            #[inline]
            /// Transmit Buffer Priority
            pub fn set_txp_checked(
                &mut self,
                new_val: <B2 as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize =
                    8usize * ::core::mem::size_of::<<B2 as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <B2 as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <B2 as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <B2 as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <B2 as ::modular_bitfield::Specifier>::Bytes =
                    { <B2 as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<B2>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of txreq.
            #[inline]
            /// Message Transmit Request
            pub fn txreq(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.txreq_or_err()
                    .expect("value contains invalid bit pattern for field TXB2CTRL.txreq")
            }
            ///Returns the value of txreq.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txreq.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request
            pub fn txreq_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txreq set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txreq.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request
            pub fn with_txreq(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txreq(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txreq set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txreq.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request
            pub fn with_txreq_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txreq_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txreq to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txreq.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request
            pub fn set_txreq(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_txreq_checked(new_val)
                    .expect("value out of bounds for field TXB2CTRL.txreq")
            }
            ///Sets the value of txreq to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txreq.
            #[inline]
            /// Message Transmit Request
            pub fn set_txreq_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of txerr.
            #[inline]
            /// Transmission Error Detected
            pub fn txerr(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.txerr_or_err()
                    .expect("value contains invalid bit pattern for field TXB2CTRL.txerr")
            }
            ///Returns the value of txerr.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txerr.
            #[inline]
            #[allow(dead_code)]
            /// Transmission Error Detected
            pub fn txerr_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txerr set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txerr.
            #[inline]
            #[allow(dead_code)]
            /// Transmission Error Detected
            pub fn with_txerr(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txerr(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txerr set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txerr.
            #[inline]
            #[allow(dead_code)]
            /// Transmission Error Detected
            pub fn with_txerr_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txerr_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txerr to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txerr.
            #[inline]
            #[allow(dead_code)]
            /// Transmission Error Detected
            pub fn set_txerr(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_txerr_checked(new_val)
                    .expect("value out of bounds for field TXB2CTRL.txerr")
            }
            ///Sets the value of txerr to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txerr.
            #[inline]
            /// Transmission Error Detected
            pub fn set_txerr_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of mloa.
            #[inline]
            /// : Message Lost Arbitration
            pub fn mloa(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.mloa_or_err()
                    .expect("value contains invalid bit pattern for field TXB2CTRL.mloa")
            }
            ///Returns the value of mloa.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for mloa.
            #[inline]
            #[allow(dead_code)]
            /// : Message Lost Arbitration
            pub fn mloa_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of mloa set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for mloa.
            #[inline]
            #[allow(dead_code)]
            /// : Message Lost Arbitration
            pub fn with_mloa(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_mloa(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of mloa set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for mloa.
            #[inline]
            #[allow(dead_code)]
            /// : Message Lost Arbitration
            pub fn with_mloa_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_mloa_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of mloa to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for mloa.
            #[inline]
            #[allow(dead_code)]
            /// : Message Lost Arbitration
            pub fn set_mloa(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_mloa_checked(new_val)
                    .expect("value out of bounds for field TXB2CTRL.mloa")
            }
            ///Sets the value of mloa to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for mloa.
            #[inline]
            /// : Message Lost Arbitration
            pub fn set_mloa_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of abtf.
            #[inline]
            /// Message Aborted Flag
            pub fn abtf(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.abtf_or_err()
                    .expect("value contains invalid bit pattern for field TXB2CTRL.abtf")
            }
            ///Returns the value of abtf.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for abtf.
            #[inline]
            #[allow(dead_code)]
            /// Message Aborted Flag
            pub fn abtf_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of abtf set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for abtf.
            #[inline]
            #[allow(dead_code)]
            /// Message Aborted Flag
            pub fn with_abtf(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_abtf(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of abtf set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for abtf.
            #[inline]
            #[allow(dead_code)]
            /// Message Aborted Flag
            pub fn with_abtf_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_abtf_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of abtf to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for abtf.
            #[inline]
            #[allow(dead_code)]
            /// Message Aborted Flag
            pub fn set_abtf(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_abtf_checked(new_val)
                    .expect("value out of bounds for field TXB2CTRL.abtf")
            }
            ///Sets the value of abtf to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for abtf.
            #[inline]
            /// Message Aborted Flag
            pub fn set_abtf_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for TXB2CTRL
        where
            [(); {
                0usize
                    + <B2 as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<TXB2CTRL> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <B2 as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: TXB2CTRL) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for TXB2CTRL {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("TXB2CTRL")
                    .field(
                        "txp",
                        self.txp_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "txreq",
                        self.txreq_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "txerr",
                        self.txerr_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "mloa",
                        self.mloa_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "abtf",
                        self.abtf_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Interrupt Enable Register
        #[allow(clippy::identity_op)]
        pub struct CANINTE {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for CANINTE {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for CANINTE {
            #[inline]
            fn clone(&self) -> CANINTE {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for CANINTE {
            #[inline]
            fn default() -> CANINTE {
                CANINTE {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for CANINTE {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl CANINTE {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl CANINTE {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl CANINTE {
            ///Returns the value of rx0ie.
            #[inline]
            /// Receive Buffer 0 Full Interrupt Enable
            pub fn rx0ie(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rx0ie_or_err()
                    .expect("value contains invalid bit pattern for field CANINTE.rx0ie")
            }
            ///Returns the value of rx0ie.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rx0ie.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Enable
            pub fn rx0ie_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(&self.bytes[..], 0usize)
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rx0ie set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx0ie.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Enable
            pub fn with_rx0ie(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rx0ie(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rx0ie set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx0ie.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Enable
            pub fn with_rx0ie_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rx0ie_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rx0ie to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx0ie.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Enable
            pub fn set_rx0ie(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_rx0ie_checked(new_val)
                    .expect("value out of bounds for field CANINTE.rx0ie")
            }
            ///Sets the value of rx0ie to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx0ie.
            #[inline]
            /// Receive Buffer 0 Full Interrupt Enable
            pub fn set_rx0ie_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of rx1ie.
            #[inline]
            /// Receive Buffer 1 Full Interrupt Enable
            pub fn rx1ie(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rx1ie_or_err()
                    .expect("value contains invalid bit pattern for field CANINTE.rx1ie")
            }
            ///Returns the value of rx1ie.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rx1ie.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Enable
            pub fn rx1ie_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rx1ie set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx1ie.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Enable
            pub fn with_rx1ie(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rx1ie(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rx1ie set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx1ie.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Enable
            pub fn with_rx1ie_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rx1ie_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rx1ie to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx1ie.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Enable
            pub fn set_rx1ie(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_rx1ie_checked(new_val)
                    .expect("value out of bounds for field CANINTE.rx1ie")
            }
            ///Sets the value of rx1ie to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx1ie.
            #[inline]
            /// Receive Buffer 1 Full Interrupt Enable
            pub fn set_rx1ie_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of tx0ie.
            #[inline]
            /// Transmit Buffer 0 Empty Interrupt Enable
            pub fn tx0ie(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.tx0ie_or_err()
                    .expect("value contains invalid bit pattern for field CANINTE.tx0ie")
            }
            ///Returns the value of tx0ie.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for tx0ie.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 0 Empty Interrupt Enable
            pub fn tx0ie_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of tx0ie set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx0ie.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 0 Empty Interrupt Enable
            pub fn with_tx0ie(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_tx0ie(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of tx0ie set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx0ie.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 0 Empty Interrupt Enable
            pub fn with_tx0ie_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_tx0ie_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of tx0ie to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx0ie.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 0 Empty Interrupt Enable
            pub fn set_tx0ie(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_tx0ie_checked(new_val)
                    .expect("value out of bounds for field CANINTE.tx0ie")
            }
            ///Sets the value of tx0ie to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx0ie.
            #[inline]
            /// Transmit Buffer 0 Empty Interrupt Enable
            pub fn set_tx0ie_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of tx1ie.
            #[inline]
            /// Transmit Buffer 1 Empty Interrupt Enable
            pub fn tx1ie(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.tx1ie_or_err()
                    .expect("value contains invalid bit pattern for field CANINTE.tx1ie")
            }
            ///Returns the value of tx1ie.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for tx1ie.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 1 Empty Interrupt Enable
            pub fn tx1ie_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of tx1ie set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx1ie.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 1 Empty Interrupt Enable
            pub fn with_tx1ie(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_tx1ie(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of tx1ie set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx1ie.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 1 Empty Interrupt Enable
            pub fn with_tx1ie_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_tx1ie_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of tx1ie to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx1ie.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 1 Empty Interrupt Enable
            pub fn set_tx1ie(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_tx1ie_checked(new_val)
                    .expect("value out of bounds for field CANINTE.tx1ie")
            }
            ///Sets the value of tx1ie to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx1ie.
            #[inline]
            /// Transmit Buffer 1 Empty Interrupt Enable
            pub fn set_tx1ie_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of tx2ie.
            #[inline]
            /// Transmit Buffer 2 Empty Interrupt Enable
            pub fn tx2ie(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.tx2ie_or_err()
                    .expect("value contains invalid bit pattern for field CANINTE.tx2ie")
            }
            ///Returns the value of tx2ie.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for tx2ie.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 2 Empty Interrupt Enable
            pub fn tx2ie_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of tx2ie set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx2ie.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 2 Empty Interrupt Enable
            pub fn with_tx2ie(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_tx2ie(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of tx2ie set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx2ie.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 2 Empty Interrupt Enable
            pub fn with_tx2ie_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_tx2ie_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of tx2ie to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx2ie.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 2 Empty Interrupt Enable
            pub fn set_tx2ie(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_tx2ie_checked(new_val)
                    .expect("value out of bounds for field CANINTE.tx2ie")
            }
            ///Sets the value of tx2ie to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx2ie.
            #[inline]
            /// Transmit Buffer 2 Empty Interrupt Enable
            pub fn set_tx2ie_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of errie.
            #[inline]
            /// Error Interrupt Enable (multiple sources in the [`EFLG`] register)
            pub fn errie(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.errie_or_err()
                    .expect("value contains invalid bit pattern for field CANINTE.errie")
            }
            ///Returns the value of errie.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for errie.
            #[inline]
            #[allow(dead_code)]
            /// Error Interrupt Enable (multiple sources in the [`EFLG`] register)
            pub fn errie_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of errie set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for errie.
            #[inline]
            #[allow(dead_code)]
            /// Error Interrupt Enable (multiple sources in the [`EFLG`] register)
            pub fn with_errie(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_errie(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of errie set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for errie.
            #[inline]
            #[allow(dead_code)]
            /// Error Interrupt Enable (multiple sources in the [`EFLG`] register)
            pub fn with_errie_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_errie_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of errie to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for errie.
            #[inline]
            #[allow(dead_code)]
            /// Error Interrupt Enable (multiple sources in the [`EFLG`] register)
            pub fn set_errie(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_errie_checked(new_val)
                    .expect("value out of bounds for field CANINTE.errie")
            }
            ///Sets the value of errie to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for errie.
            #[inline]
            /// Error Interrupt Enable (multiple sources in the [`EFLG`] register)
            pub fn set_errie_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of wakie.
            #[inline]
            /// Wake-up Interrupt Enable
            pub fn wakie(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.wakie_or_err()
                    .expect("value contains invalid bit pattern for field CANINTE.wakie")
            }
            ///Returns the value of wakie.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for wakie.
            #[inline]
            #[allow(dead_code)]
            /// Wake-up Interrupt Enable
            pub fn wakie_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of wakie set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for wakie.
            #[inline]
            #[allow(dead_code)]
            /// Wake-up Interrupt Enable
            pub fn with_wakie(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_wakie(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of wakie set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for wakie.
            #[inline]
            #[allow(dead_code)]
            /// Wake-up Interrupt Enable
            pub fn with_wakie_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_wakie_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of wakie to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for wakie.
            #[inline]
            #[allow(dead_code)]
            /// Wake-up Interrupt Enable
            pub fn set_wakie(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_wakie_checked(new_val)
                    .expect("value out of bounds for field CANINTE.wakie")
            }
            ///Sets the value of wakie to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for wakie.
            #[inline]
            /// Wake-up Interrupt Enable
            pub fn set_wakie_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of merre.
            #[inline]
            /// Message Error Interrupt Enable
            pub fn merre(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.merre_or_err()
                    .expect("value contains invalid bit pattern for field CANINTE.merre")
            }
            ///Returns the value of merre.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for merre.
            #[inline]
            #[allow(dead_code)]
            /// Message Error Interrupt Enable
            pub fn merre_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of merre set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for merre.
            #[inline]
            #[allow(dead_code)]
            /// Message Error Interrupt Enable
            pub fn with_merre(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_merre(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of merre set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for merre.
            #[inline]
            #[allow(dead_code)]
            /// Message Error Interrupt Enable
            pub fn with_merre_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_merre_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of merre to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for merre.
            #[inline]
            #[allow(dead_code)]
            /// Message Error Interrupt Enable
            pub fn set_merre(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_merre_checked(new_val)
                    .expect("value out of bounds for field CANINTE.merre")
            }
            ///Sets the value of merre to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for merre.
            #[inline]
            /// Message Error Interrupt Enable
            pub fn set_merre_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for CANINTE
        where
            [(); {
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<CANINTE> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: CANINTE) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for CANINTE {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("CANINTE")
                    .field(
                        "rx0ie",
                        self.rx0ie_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "rx1ie",
                        self.rx1ie_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "tx0ie",
                        self.tx0ie_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "tx1ie",
                        self.tx1ie_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "tx2ie",
                        self.tx2ie_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "errie",
                        self.errie_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "wakie",
                        self.wakie_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "merre",
                        self.merre_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Interrupt Flag Register
        #[allow(clippy::identity_op)]
        pub struct CANINTF {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for CANINTF {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for CANINTF {
            #[inline]
            fn clone(&self) -> CANINTF {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for CANINTF {
            #[inline]
            fn default() -> CANINTF {
                CANINTF {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for CANINTF {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl CANINTF {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl CANINTF {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl CANINTF {
            ///Returns the value of rx0if.
            #[inline]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn rx0if(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rx0if_or_err()
                    .expect("value contains invalid bit pattern for field CANINTF.rx0if")
            }
            ///Returns the value of rx0if.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rx0if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn rx0if_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(&self.bytes[..], 0usize)
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rx0if set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx0if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn with_rx0if(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rx0if(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rx0if set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx0if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn with_rx0if_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rx0if_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rx0if to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx0if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn set_rx0if(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_rx0if_checked(new_val)
                    .expect("value out of bounds for field CANINTF.rx0if")
            }
            ///Sets the value of rx0if to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx0if.
            #[inline]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn set_rx0if_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of rx1if.
            #[inline]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn rx1if(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rx1if_or_err()
                    .expect("value contains invalid bit pattern for field CANINTF.rx1if")
            }
            ///Returns the value of rx1if.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rx1if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn rx1if_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rx1if set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx1if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn with_rx1if(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rx1if(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rx1if set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx1if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn with_rx1if_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rx1if_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rx1if to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx1if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn set_rx1if(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_rx1if_checked(new_val)
                    .expect("value out of bounds for field CANINTF.rx1if")
            }
            ///Sets the value of rx1if to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx1if.
            #[inline]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn set_rx1if_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of tx0if.
            #[inline]
            /// Transmit Buffer 0 Empty Interrupt Flag
            pub fn tx0if(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.tx0if_or_err()
                    .expect("value contains invalid bit pattern for field CANINTF.tx0if")
            }
            ///Returns the value of tx0if.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for tx0if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 0 Empty Interrupt Flag
            pub fn tx0if_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of tx0if set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx0if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 0 Empty Interrupt Flag
            pub fn with_tx0if(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_tx0if(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of tx0if set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx0if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 0 Empty Interrupt Flag
            pub fn with_tx0if_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_tx0if_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of tx0if to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx0if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 0 Empty Interrupt Flag
            pub fn set_tx0if(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_tx0if_checked(new_val)
                    .expect("value out of bounds for field CANINTF.tx0if")
            }
            ///Sets the value of tx0if to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx0if.
            #[inline]
            /// Transmit Buffer 0 Empty Interrupt Flag
            pub fn set_tx0if_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of tx1if.
            #[inline]
            /// Transmit Buffer 1 Empty Interrupt Flag
            pub fn tx1if(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.tx1if_or_err()
                    .expect("value contains invalid bit pattern for field CANINTF.tx1if")
            }
            ///Returns the value of tx1if.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for tx1if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 1 Empty Interrupt Flag
            pub fn tx1if_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of tx1if set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx1if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 1 Empty Interrupt Flag
            pub fn with_tx1if(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_tx1if(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of tx1if set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx1if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 1 Empty Interrupt Flag
            pub fn with_tx1if_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_tx1if_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of tx1if to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx1if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 1 Empty Interrupt Flag
            pub fn set_tx1if(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_tx1if_checked(new_val)
                    .expect("value out of bounds for field CANINTF.tx1if")
            }
            ///Sets the value of tx1if to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx1if.
            #[inline]
            /// Transmit Buffer 1 Empty Interrupt Flag
            pub fn set_tx1if_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of tx2if.
            #[inline]
            /// Transmit Buffer 2 Empty Interrupt Flag
            pub fn tx2if(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.tx2if_or_err()
                    .expect("value contains invalid bit pattern for field CANINTF.tx2if")
            }
            ///Returns the value of tx2if.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for tx2if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 2 Empty Interrupt Flag
            pub fn tx2if_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of tx2if set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx2if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 2 Empty Interrupt Flag
            pub fn with_tx2if(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_tx2if(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of tx2if set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx2if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 2 Empty Interrupt Flag
            pub fn with_tx2if_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_tx2if_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of tx2if to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx2if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 2 Empty Interrupt Flag
            pub fn set_tx2if(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_tx2if_checked(new_val)
                    .expect("value out of bounds for field CANINTF.tx2if")
            }
            ///Sets the value of tx2if to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx2if.
            #[inline]
            /// Transmit Buffer 2 Empty Interrupt Flag
            pub fn set_tx2if_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of errif.
            #[inline]
            /// Error Interrupt Flag (multiple sources in the [`EFLG`] register)
            pub fn errif(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.errif_or_err()
                    .expect("value contains invalid bit pattern for field CANINTF.errif")
            }
            ///Returns the value of errif.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for errif.
            #[inline]
            #[allow(dead_code)]
            /// Error Interrupt Flag (multiple sources in the [`EFLG`] register)
            pub fn errif_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of errif set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for errif.
            #[inline]
            #[allow(dead_code)]
            /// Error Interrupt Flag (multiple sources in the [`EFLG`] register)
            pub fn with_errif(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_errif(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of errif set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for errif.
            #[inline]
            #[allow(dead_code)]
            /// Error Interrupt Flag (multiple sources in the [`EFLG`] register)
            pub fn with_errif_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_errif_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of errif to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for errif.
            #[inline]
            #[allow(dead_code)]
            /// Error Interrupt Flag (multiple sources in the [`EFLG`] register)
            pub fn set_errif(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_errif_checked(new_val)
                    .expect("value out of bounds for field CANINTF.errif")
            }
            ///Sets the value of errif to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for errif.
            #[inline]
            /// Error Interrupt Flag (multiple sources in the [`EFLG`] register)
            pub fn set_errif_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of wakif.
            #[inline]
            /// Wake-up Interrupt Flag
            pub fn wakif(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.wakif_or_err()
                    .expect("value contains invalid bit pattern for field CANINTF.wakif")
            }
            ///Returns the value of wakif.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for wakif.
            #[inline]
            #[allow(dead_code)]
            /// Wake-up Interrupt Flag
            pub fn wakif_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of wakif set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for wakif.
            #[inline]
            #[allow(dead_code)]
            /// Wake-up Interrupt Flag
            pub fn with_wakif(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_wakif(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of wakif set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for wakif.
            #[inline]
            #[allow(dead_code)]
            /// Wake-up Interrupt Flag
            pub fn with_wakif_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_wakif_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of wakif to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for wakif.
            #[inline]
            #[allow(dead_code)]
            /// Wake-up Interrupt Flag
            pub fn set_wakif(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_wakif_checked(new_val)
                    .expect("value out of bounds for field CANINTF.wakif")
            }
            ///Sets the value of wakif to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for wakif.
            #[inline]
            /// Wake-up Interrupt Flag
            pub fn set_wakif_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of merrf.
            #[inline]
            /// Message Error Interrupt Flag
            pub fn merrf(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.merrf_or_err()
                    .expect("value contains invalid bit pattern for field CANINTF.merrf")
            }
            ///Returns the value of merrf.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for merrf.
            #[inline]
            #[allow(dead_code)]
            /// Message Error Interrupt Flag
            pub fn merrf_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of merrf set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for merrf.
            #[inline]
            #[allow(dead_code)]
            /// Message Error Interrupt Flag
            pub fn with_merrf(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_merrf(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of merrf set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for merrf.
            #[inline]
            #[allow(dead_code)]
            /// Message Error Interrupt Flag
            pub fn with_merrf_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_merrf_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of merrf to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for merrf.
            #[inline]
            #[allow(dead_code)]
            /// Message Error Interrupt Flag
            pub fn set_merrf(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_merrf_checked(new_val)
                    .expect("value out of bounds for field CANINTF.merrf")
            }
            ///Sets the value of merrf to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for merrf.
            #[inline]
            /// Message Error Interrupt Flag
            pub fn set_merrf_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for CANINTF
        where
            [(); {
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<CANINTF> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: CANINTF) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for CANINTF {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("CANINTF")
                    .field(
                        "rx0if",
                        self.rx0if_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "rx1if",
                        self.rx1if_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "tx0if",
                        self.tx0if_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "tx1if",
                        self.tx1if_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "tx2if",
                        self.tx2if_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "errif",
                        self.errif_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "wakif",
                        self.wakif_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "merrf",
                        self.merrf_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Error Flag Register
        #[allow(clippy::identity_op)]
        pub struct EFLG {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for EFLG {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for EFLG {
            #[inline]
            fn clone(&self) -> EFLG {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for EFLG {
            #[inline]
            fn default() -> EFLG {
                EFLG {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        impl defmt::Format for EFLG
        where
            [::core::primitive::u8; {
                ((({
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize]: defmt::Format,
        {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::mcp2515::registers".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"13182124339242806551\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"13182124339242806551\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"EFLG {{ bytes: {=?:?} }}\",\"disambiguator\":\"7397328984307916221\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"EFLG {{ bytes: {=?:?} }}\",\"disambiguator\":\"7397328984307916221\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    Self { bytes } => {
                        defmt::export::fmt(bytes);
                    }
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for EFLG {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl EFLG {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl EFLG {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl EFLG {
            ///Returns the value of ewarn.
            #[inline]
            /// Error Warning Flag bit
            pub fn ewarn(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.ewarn_or_err()
                    .expect("value contains invalid bit pattern for field EFLG.ewarn")
            }
            ///Returns the value of ewarn.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for ewarn.
            #[inline]
            #[allow(dead_code)]
            /// Error Warning Flag bit
            pub fn ewarn_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(&self.bytes[..], 0usize)
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of ewarn set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for ewarn.
            #[inline]
            #[allow(dead_code)]
            /// Error Warning Flag bit
            pub fn with_ewarn(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_ewarn(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of ewarn set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for ewarn.
            #[inline]
            #[allow(dead_code)]
            /// Error Warning Flag bit
            pub fn with_ewarn_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_ewarn_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of ewarn to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for ewarn.
            #[inline]
            #[allow(dead_code)]
            /// Error Warning Flag bit
            pub fn set_ewarn(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_ewarn_checked(new_val)
                    .expect("value out of bounds for field EFLG.ewarn")
            }
            ///Sets the value of ewarn to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for ewarn.
            #[inline]
            /// Error Warning Flag bit
            pub fn set_ewarn_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of rxwar.
            #[inline]
            /// Receive Error Warning Flag bit
            pub fn rxwar(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rxwar_or_err()
                    .expect("value contains invalid bit pattern for field EFLG.rxwar")
            }
            ///Returns the value of rxwar.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rxwar.
            #[inline]
            #[allow(dead_code)]
            /// Receive Error Warning Flag bit
            pub fn rxwar_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rxwar set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rxwar.
            #[inline]
            #[allow(dead_code)]
            /// Receive Error Warning Flag bit
            pub fn with_rxwar(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rxwar(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rxwar set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rxwar.
            #[inline]
            #[allow(dead_code)]
            /// Receive Error Warning Flag bit
            pub fn with_rxwar_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rxwar_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rxwar to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rxwar.
            #[inline]
            #[allow(dead_code)]
            /// Receive Error Warning Flag bit
            pub fn set_rxwar(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_rxwar_checked(new_val)
                    .expect("value out of bounds for field EFLG.rxwar")
            }
            ///Sets the value of rxwar to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rxwar.
            #[inline]
            /// Receive Error Warning Flag bit
            pub fn set_rxwar_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of txwar.
            #[inline]
            /// Transmit Error Warning Flag bit
            pub fn txwar(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.txwar_or_err()
                    .expect("value contains invalid bit pattern for field EFLG.txwar")
            }
            ///Returns the value of txwar.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txwar.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Error Warning Flag bit
            pub fn txwar_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txwar set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txwar.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Error Warning Flag bit
            pub fn with_txwar(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txwar(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txwar set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txwar.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Error Warning Flag bit
            pub fn with_txwar_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txwar_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txwar to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txwar.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Error Warning Flag bit
            pub fn set_txwar(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_txwar_checked(new_val)
                    .expect("value out of bounds for field EFLG.txwar")
            }
            ///Sets the value of txwar to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txwar.
            #[inline]
            /// Transmit Error Warning Flag bit
            pub fn set_txwar_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of rxep.
            #[inline]
            /// Receive Error-Passive Flag bit
            pub fn rxep(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rxep_or_err()
                    .expect("value contains invalid bit pattern for field EFLG.rxep")
            }
            ///Returns the value of rxep.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rxep.
            #[inline]
            #[allow(dead_code)]
            /// Receive Error-Passive Flag bit
            pub fn rxep_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rxep set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rxep.
            #[inline]
            #[allow(dead_code)]
            /// Receive Error-Passive Flag bit
            pub fn with_rxep(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rxep(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rxep set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rxep.
            #[inline]
            #[allow(dead_code)]
            /// Receive Error-Passive Flag bit
            pub fn with_rxep_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rxep_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rxep to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rxep.
            #[inline]
            #[allow(dead_code)]
            /// Receive Error-Passive Flag bit
            pub fn set_rxep(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_rxep_checked(new_val)
                    .expect("value out of bounds for field EFLG.rxep")
            }
            ///Sets the value of rxep to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rxep.
            #[inline]
            /// Receive Error-Passive Flag bit
            pub fn set_rxep_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of txep.
            #[inline]
            /// Transmit Error-Passive Flag bit
            pub fn txep(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.txep_or_err()
                    .expect("value contains invalid bit pattern for field EFLG.txep")
            }
            ///Returns the value of txep.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txep.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Error-Passive Flag bit
            pub fn txep_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txep set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txep.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Error-Passive Flag bit
            pub fn with_txep(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txep(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txep set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txep.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Error-Passive Flag bit
            pub fn with_txep_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txep_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txep to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txep.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Error-Passive Flag bit
            pub fn set_txep(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_txep_checked(new_val)
                    .expect("value out of bounds for field EFLG.txep")
            }
            ///Sets the value of txep to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txep.
            #[inline]
            /// Transmit Error-Passive Flag bit
            pub fn set_txep_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of txbo.
            #[inline]
            /// Bus-Off Error Flag bit
            pub fn txbo(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.txbo_or_err()
                    .expect("value contains invalid bit pattern for field EFLG.txbo")
            }
            ///Returns the value of txbo.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txbo.
            #[inline]
            #[allow(dead_code)]
            /// Bus-Off Error Flag bit
            pub fn txbo_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txbo set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txbo.
            #[inline]
            #[allow(dead_code)]
            /// Bus-Off Error Flag bit
            pub fn with_txbo(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txbo(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txbo set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txbo.
            #[inline]
            #[allow(dead_code)]
            /// Bus-Off Error Flag bit
            pub fn with_txbo_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txbo_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txbo to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txbo.
            #[inline]
            #[allow(dead_code)]
            /// Bus-Off Error Flag bit
            pub fn set_txbo(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_txbo_checked(new_val)
                    .expect("value out of bounds for field EFLG.txbo")
            }
            ///Sets the value of txbo to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txbo.
            #[inline]
            /// Bus-Off Error Flag bit
            pub fn set_txbo_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of rx0ovr.
            #[inline]
            /// Receive Buffer 0 Overflow Flag bit
            pub fn rx0ovr(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rx0ovr_or_err()
                    .expect("value contains invalid bit pattern for field EFLG.rx0ovr")
            }
            ///Returns the value of rx0ovr.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rx0ovr.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Overflow Flag bit
            pub fn rx0ovr_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rx0ovr set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx0ovr.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Overflow Flag bit
            pub fn with_rx0ovr(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rx0ovr(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rx0ovr set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx0ovr.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Overflow Flag bit
            pub fn with_rx0ovr_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rx0ovr_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rx0ovr to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx0ovr.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Overflow Flag bit
            pub fn set_rx0ovr(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_rx0ovr_checked(new_val)
                    .expect("value out of bounds for field EFLG.rx0ovr")
            }
            ///Sets the value of rx0ovr to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx0ovr.
            #[inline]
            /// Receive Buffer 0 Overflow Flag bit
            pub fn set_rx0ovr_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of rx1ovr.
            #[inline]
            /// Receive Buffer 1 Overflow Flag bit
            pub fn rx1ovr(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rx1ovr_or_err()
                    .expect("value contains invalid bit pattern for field EFLG.rx1ovr")
            }
            ///Returns the value of rx1ovr.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rx1ovr.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Overflow Flag bit
            pub fn rx1ovr_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rx1ovr set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx1ovr.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Overflow Flag bit
            pub fn with_rx1ovr(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rx1ovr(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rx1ovr set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx1ovr.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Overflow Flag bit
            pub fn with_rx1ovr_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rx1ovr_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rx1ovr to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx1ovr.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Overflow Flag bit
            pub fn set_rx1ovr(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_rx1ovr_checked(new_val)
                    .expect("value out of bounds for field EFLG.rx1ovr")
            }
            ///Sets the value of rx1ovr to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx1ovr.
            #[inline]
            /// Receive Buffer 1 Overflow Flag bit
            pub fn set_rx1ovr_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for EFLG
        where
            [(); {
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<EFLG> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: EFLG) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for EFLG {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("EFLG")
                    .field(
                        "ewarn",
                        self.ewarn_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "rxwar",
                        self.rxwar_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "txwar",
                        self.txwar_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "rxep",
                        self.rxep_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "txep",
                        self.txep_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "txbo",
                        self.txbo_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "rx0ovr",
                        self.rx0ovr_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "rx1ovr",
                        self.rx1ovr_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// RXnBF Pin Control and Status Register
        #[allow(clippy::identity_op)]
        pub struct BFPCTRL {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for BFPCTRL {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for BFPCTRL {
            #[inline]
            fn clone(&self) -> BFPCTRL {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B2 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for BFPCTRL {
            #[inline]
            fn default() -> BFPCTRL {
                BFPCTRL {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for BFPCTRL {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl BFPCTRL {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B2 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl BFPCTRL {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <B2 as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl BFPCTRL {
            ///Returns the value of b0bfm.
            #[inline]
            pub fn b0bfm(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.b0bfm_or_err()
                    .expect("value contains invalid bit pattern for field BFPCTRL.b0bfm")
            }
            ///Returns the value of b0bfm.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for b0bfm.
            #[inline]
            #[allow(dead_code)]
            pub fn b0bfm_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(&self.bytes[..], 0usize)
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of b0bfm set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b0bfm.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b0bfm(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_b0bfm(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of b0bfm set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b0bfm.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b0bfm_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_b0bfm_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of b0bfm to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b0bfm.
            #[inline]
            #[allow(dead_code)]
            pub fn set_b0bfm(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_b0bfm_checked(new_val)
                    .expect("value out of bounds for field BFPCTRL.b0bfm")
            }
            ///Sets the value of b0bfm to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b0bfm.
            #[inline]
            pub fn set_b0bfm_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of b1bfm.
            #[inline]
            pub fn b1bfm(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.b1bfm_or_err()
                    .expect("value contains invalid bit pattern for field BFPCTRL.b1bfm")
            }
            ///Returns the value of b1bfm.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for b1bfm.
            #[inline]
            #[allow(dead_code)]
            pub fn b1bfm_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of b1bfm set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b1bfm.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b1bfm(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_b1bfm(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of b1bfm set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b1bfm.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b1bfm_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_b1bfm_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of b1bfm to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b1bfm.
            #[inline]
            #[allow(dead_code)]
            pub fn set_b1bfm(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_b1bfm_checked(new_val)
                    .expect("value out of bounds for field BFPCTRL.b1bfm")
            }
            ///Sets the value of b1bfm to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b1bfm.
            #[inline]
            pub fn set_b1bfm_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of b0bfe.
            #[inline]
            pub fn b0bfe(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.b0bfe_or_err()
                    .expect("value contains invalid bit pattern for field BFPCTRL.b0bfe")
            }
            ///Returns the value of b0bfe.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for b0bfe.
            #[inline]
            #[allow(dead_code)]
            pub fn b0bfe_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of b0bfe set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b0bfe.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b0bfe(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_b0bfe(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of b0bfe set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b0bfe.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b0bfe_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_b0bfe_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of b0bfe to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b0bfe.
            #[inline]
            #[allow(dead_code)]
            pub fn set_b0bfe(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_b0bfe_checked(new_val)
                    .expect("value out of bounds for field BFPCTRL.b0bfe")
            }
            ///Sets the value of b0bfe to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b0bfe.
            #[inline]
            pub fn set_b0bfe_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of b1bfe.
            #[inline]
            pub fn b1bfe(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.b1bfe_or_err()
                    .expect("value contains invalid bit pattern for field BFPCTRL.b1bfe")
            }
            ///Returns the value of b1bfe.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for b1bfe.
            #[inline]
            #[allow(dead_code)]
            pub fn b1bfe_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of b1bfe set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b1bfe.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b1bfe(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_b1bfe(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of b1bfe set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b1bfe.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b1bfe_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_b1bfe_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of b1bfe to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b1bfe.
            #[inline]
            #[allow(dead_code)]
            pub fn set_b1bfe(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_b1bfe_checked(new_val)
                    .expect("value out of bounds for field BFPCTRL.b1bfe")
            }
            ///Sets the value of b1bfe to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b1bfe.
            #[inline]
            pub fn set_b1bfe_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of b0bfs.
            #[inline]
            pub fn b0bfs(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.b0bfs_or_err()
                    .expect("value contains invalid bit pattern for field BFPCTRL.b0bfs")
            }
            ///Returns the value of b0bfs.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for b0bfs.
            #[inline]
            #[allow(dead_code)]
            pub fn b0bfs_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of b0bfs set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b0bfs.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b0bfs(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_b0bfs(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of b0bfs set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b0bfs.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b0bfs_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_b0bfs_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of b0bfs to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b0bfs.
            #[inline]
            #[allow(dead_code)]
            pub fn set_b0bfs(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_b0bfs_checked(new_val)
                    .expect("value out of bounds for field BFPCTRL.b0bfs")
            }
            ///Sets the value of b0bfs to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b0bfs.
            #[inline]
            pub fn set_b0bfs_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of b1bfs.
            #[inline]
            pub fn b1bfs(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.b1bfs_or_err()
                    .expect("value contains invalid bit pattern for field BFPCTRL.b1bfs")
            }
            ///Returns the value of b1bfs.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for b1bfs.
            #[inline]
            #[allow(dead_code)]
            pub fn b1bfs_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of b1bfs set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b1bfs.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b1bfs(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_b1bfs(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of b1bfs set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b1bfs.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b1bfs_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_b1bfs_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of b1bfs to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b1bfs.
            #[inline]
            #[allow(dead_code)]
            pub fn set_b1bfs(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_b1bfs_checked(new_val)
                    .expect("value out of bounds for field BFPCTRL.b1bfs")
            }
            ///Sets the value of b1bfs to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b1bfs.
            #[inline]
            pub fn set_b1bfs_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for BFPCTRL
        where
            [(); {
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B2 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<BFPCTRL> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B2 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: BFPCTRL) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for BFPCTRL {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("BFPCTRL")
                    .field(
                        "b0bfm",
                        self.b0bfm_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "b1bfm",
                        self.b1bfm_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "b0bfe",
                        self.b0bfe_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "b1bfe",
                        self.b1bfe_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "b0bfs",
                        self.b0bfs_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "b1bfs",
                        self.b1bfs_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// TXnRTS Pin Control and Status Register
        ///
        /// Note: Write operations require Configuration mode
        #[allow(clippy::identity_op)]
        pub struct TXRTSCTRL {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B2 as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for TXRTSCTRL {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for TXRTSCTRL {
            #[inline]
            fn clone(&self) -> TXRTSCTRL {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B2 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for TXRTSCTRL {
            #[inline]
            fn default() -> TXRTSCTRL {
                TXRTSCTRL {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for TXRTSCTRL {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl TXRTSCTRL {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B2 as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl TXRTSCTRL {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <B2 as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B2 as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl TXRTSCTRL {
            ///Returns the value of b0rtsm.
            #[inline]
            pub fn b0rtsm(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.b0rtsm_or_err()
                    .expect("value contains invalid bit pattern for field TXRTSCTRL.b0rtsm")
            }
            ///Returns the value of b0rtsm.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for b0rtsm.
            #[inline]
            #[allow(dead_code)]
            pub fn b0rtsm_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(&self.bytes[..], 0usize)
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of b0rtsm set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b0rtsm.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b0rtsm(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_b0rtsm(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of b0rtsm set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b0rtsm.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b0rtsm_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_b0rtsm_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of b0rtsm to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b0rtsm.
            #[inline]
            #[allow(dead_code)]
            pub fn set_b0rtsm(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_b0rtsm_checked(new_val)
                    .expect("value out of bounds for field TXRTSCTRL.b0rtsm")
            }
            ///Sets the value of b0rtsm to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b0rtsm.
            #[inline]
            pub fn set_b0rtsm_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of b1rtsm.
            #[inline]
            pub fn b1rtsm(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.b1rtsm_or_err()
                    .expect("value contains invalid bit pattern for field TXRTSCTRL.b1rtsm")
            }
            ///Returns the value of b1rtsm.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for b1rtsm.
            #[inline]
            #[allow(dead_code)]
            pub fn b1rtsm_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of b1rtsm set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b1rtsm.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b1rtsm(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_b1rtsm(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of b1rtsm set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b1rtsm.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b1rtsm_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_b1rtsm_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of b1rtsm to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b1rtsm.
            #[inline]
            #[allow(dead_code)]
            pub fn set_b1rtsm(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_b1rtsm_checked(new_val)
                    .expect("value out of bounds for field TXRTSCTRL.b1rtsm")
            }
            ///Sets the value of b1rtsm to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b1rtsm.
            #[inline]
            pub fn set_b1rtsm_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of b2rtsm.
            #[inline]
            pub fn b2rtsm(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.b2rtsm_or_err()
                    .expect("value contains invalid bit pattern for field TXRTSCTRL.b2rtsm")
            }
            ///Returns the value of b2rtsm.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for b2rtsm.
            #[inline]
            #[allow(dead_code)]
            pub fn b2rtsm_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of b2rtsm set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b2rtsm.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b2rtsm(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_b2rtsm(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of b2rtsm set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b2rtsm.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b2rtsm_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_b2rtsm_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of b2rtsm to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b2rtsm.
            #[inline]
            #[allow(dead_code)]
            pub fn set_b2rtsm(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_b2rtsm_checked(new_val)
                    .expect("value out of bounds for field TXRTSCTRL.b2rtsm")
            }
            ///Sets the value of b2rtsm to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b2rtsm.
            #[inline]
            pub fn set_b2rtsm_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of b0rts.
            #[inline]
            pub fn b0rts(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.b0rts_or_err()
                    .expect("value contains invalid bit pattern for field TXRTSCTRL.b0rts")
            }
            ///Returns the value of b0rts.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for b0rts.
            #[inline]
            #[allow(dead_code)]
            pub fn b0rts_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of b0rts set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b0rts.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b0rts(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_b0rts(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of b0rts set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b0rts.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b0rts_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_b0rts_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of b0rts to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b0rts.
            #[inline]
            #[allow(dead_code)]
            pub fn set_b0rts(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_b0rts_checked(new_val)
                    .expect("value out of bounds for field TXRTSCTRL.b0rts")
            }
            ///Sets the value of b0rts to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b0rts.
            #[inline]
            pub fn set_b0rts_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of b1rts.
            #[inline]
            pub fn b1rts(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.b1rts_or_err()
                    .expect("value contains invalid bit pattern for field TXRTSCTRL.b1rts")
            }
            ///Returns the value of b1rts.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for b1rts.
            #[inline]
            #[allow(dead_code)]
            pub fn b1rts_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of b1rts set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b1rts.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b1rts(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_b1rts(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of b1rts set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b1rts.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b1rts_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_b1rts_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of b1rts to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b1rts.
            #[inline]
            #[allow(dead_code)]
            pub fn set_b1rts(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_b1rts_checked(new_val)
                    .expect("value out of bounds for field TXRTSCTRL.b1rts")
            }
            ///Sets the value of b1rts to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b1rts.
            #[inline]
            pub fn set_b1rts_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of b2rts.
            #[inline]
            pub fn b2rts(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.b2rts_or_err()
                    .expect("value contains invalid bit pattern for field TXRTSCTRL.b2rts")
            }
            ///Returns the value of b2rts.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for b2rts.
            #[inline]
            #[allow(dead_code)]
            pub fn b2rts_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of b2rts set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b2rts.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b2rts(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_b2rts(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of b2rts set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b2rts.
            #[inline]
            #[allow(dead_code)]
            pub fn with_b2rts_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_b2rts_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of b2rts to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for b2rts.
            #[inline]
            #[allow(dead_code)]
            pub fn set_b2rts(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_b2rts_checked(new_val)
                    .expect("value out of bounds for field TXRTSCTRL.b2rts")
            }
            ///Sets the value of b2rts to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for b2rts.
            #[inline]
            pub fn set_b2rts_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for TXRTSCTRL
        where
            [(); {
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B2 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<TXRTSCTRL> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B2 as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: TXRTSCTRL) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for TXRTSCTRL {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("TXRTSCTRL")
                    .field(
                        "b0rtsm",
                        self.b0rtsm_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "b1rtsm",
                        self.b1rtsm_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "b2rtsm",
                        self.b2rtsm_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "b0rts",
                        self.b0rts_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "b1rts",
                        self.b1rts_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "b2rts",
                        self.b2rts_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Transmit Error Counter Register
        pub struct TEC(pub u8);
        #[automatically_derived]
        impl ::core::marker::Copy for TEC {}
        #[automatically_derived]
        impl ::core::clone::Clone for TEC {
            #[inline]
            fn clone(&self) -> TEC {
                let _: ::core::clone::AssertParamIsClone<u8>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TEC {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "TEC", &&self.0)
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for TEC {
            #[inline]
            fn default() -> TEC {
                TEC(::core::default::Default::default())
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for TEC {
            #[inline]
            fn cmp(&self, other: &TEC) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for TEC {
            #[inline]
            fn partial_cmp(&self, other: &TEC) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for TEC {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u8>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TEC {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TEC {
            #[inline]
            fn eq(&self, other: &TEC) -> bool {
                self.0 == other.0
            }
        }
        impl From<u8> for TEC {
            fn from(val: u8) -> Self {
                TEC(val)
            }
        }
        impl From<TEC> for u8 {
            fn from(val: TEC) -> Self {
                val.0
            }
        }
        /// Receive Error Counter Register
        pub struct REC(pub u8);
        #[automatically_derived]
        impl ::core::marker::Copy for REC {}
        #[automatically_derived]
        impl ::core::clone::Clone for REC {
            #[inline]
            fn clone(&self) -> REC {
                let _: ::core::clone::AssertParamIsClone<u8>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for REC {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "REC", &&self.0)
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for REC {
            #[inline]
            fn default() -> REC {
                REC(::core::default::Default::default())
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for REC {
            #[inline]
            fn cmp(&self, other: &REC) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for REC {
            #[inline]
            fn partial_cmp(&self, other: &REC) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for REC {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u8>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for REC {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for REC {
            #[inline]
            fn eq(&self, other: &REC) -> bool {
                self.0 == other.0
            }
        }
        impl From<u8> for REC {
            fn from(val: u8) -> Self {
                REC(val)
            }
        }
        impl From<REC> for u8 {
            fn from(val: REC) -> Self {
                val.0
            }
        }
        /// Read Status Response Bitfield
        #[allow(clippy::identity_op)]
        pub struct ReadStatusResponse {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for ReadStatusResponse {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for ReadStatusResponse {
            #[inline]
            fn clone(&self) -> ReadStatusResponse {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for ReadStatusResponse {
            #[inline]
            fn default() -> ReadStatusResponse {
                ReadStatusResponse {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for ReadStatusResponse {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl ReadStatusResponse {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl ReadStatusResponse {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl ReadStatusResponse {
            ///Returns the value of rx0if.
            #[inline]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn rx0if(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rx0if_or_err()
                    .expect("value contains invalid bit pattern for field ReadStatusResponse.rx0if")
            }
            ///Returns the value of rx0if.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rx0if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn rx0if_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(&self.bytes[..], 0usize)
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rx0if set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx0if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn with_rx0if(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rx0if(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rx0if set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx0if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn with_rx0if_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rx0if_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rx0if to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx0if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn set_rx0if(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_rx0if_checked(new_val)
                    .expect("value out of bounds for field ReadStatusResponse.rx0if")
            }
            ///Sets the value of rx0if to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx0if.
            #[inline]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn set_rx0if_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of rx1if.
            #[inline]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn rx1if(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rx1if_or_err()
                    .expect("value contains invalid bit pattern for field ReadStatusResponse.rx1if")
            }
            ///Returns the value of rx1if.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rx1if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn rx1if_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rx1if set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx1if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn with_rx1if(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rx1if(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rx1if set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx1if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn with_rx1if_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rx1if_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rx1if to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx1if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn set_rx1if(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_rx1if_checked(new_val)
                    .expect("value out of bounds for field ReadStatusResponse.rx1if")
            }
            ///Sets the value of rx1if to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx1if.
            #[inline]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn set_rx1if_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of txreq0.
            #[inline]
            /// Message Transmit Request bit
            pub fn txreq0(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.txreq0_or_err().expect(
                    "value contains invalid bit pattern for field ReadStatusResponse.txreq0",
                )
            }
            ///Returns the value of txreq0.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txreq0.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request bit
            pub fn txreq0_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txreq0 set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txreq0.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request bit
            pub fn with_txreq0(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txreq0(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txreq0 set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txreq0.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request bit
            pub fn with_txreq0_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txreq0_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txreq0 to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txreq0.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request bit
            pub fn set_txreq0(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_txreq0_checked(new_val)
                    .expect("value out of bounds for field ReadStatusResponse.txreq0")
            }
            ///Sets the value of txreq0 to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txreq0.
            #[inline]
            /// Message Transmit Request bit
            pub fn set_txreq0_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of tx0if.
            #[inline]
            /// Transmit Buffer 0 Empty Interrupt Flag
            pub fn tx0if(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.tx0if_or_err()
                    .expect("value contains invalid bit pattern for field ReadStatusResponse.tx0if")
            }
            ///Returns the value of tx0if.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for tx0if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 0 Empty Interrupt Flag
            pub fn tx0if_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of tx0if set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx0if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 0 Empty Interrupt Flag
            pub fn with_tx0if(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_tx0if(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of tx0if set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx0if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 0 Empty Interrupt Flag
            pub fn with_tx0if_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_tx0if_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of tx0if to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx0if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 0 Empty Interrupt Flag
            pub fn set_tx0if(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_tx0if_checked(new_val)
                    .expect("value out of bounds for field ReadStatusResponse.tx0if")
            }
            ///Sets the value of tx0if to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx0if.
            #[inline]
            /// Transmit Buffer 0 Empty Interrupt Flag
            pub fn set_tx0if_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of txreq1.
            #[inline]
            /// Message Transmit Request bit
            pub fn txreq1(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.txreq1_or_err().expect(
                    "value contains invalid bit pattern for field ReadStatusResponse.txreq1",
                )
            }
            ///Returns the value of txreq1.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txreq1.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request bit
            pub fn txreq1_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txreq1 set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txreq1.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request bit
            pub fn with_txreq1(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txreq1(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txreq1 set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txreq1.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request bit
            pub fn with_txreq1_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txreq1_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txreq1 to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txreq1.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request bit
            pub fn set_txreq1(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_txreq1_checked(new_val)
                    .expect("value out of bounds for field ReadStatusResponse.txreq1")
            }
            ///Sets the value of txreq1 to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txreq1.
            #[inline]
            /// Message Transmit Request bit
            pub fn set_txreq1_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of tx1if.
            #[inline]
            /// Transmit Buffer 1 Empty Interrupt Flag
            pub fn tx1if(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.tx1if_or_err()
                    .expect("value contains invalid bit pattern for field ReadStatusResponse.tx1if")
            }
            ///Returns the value of tx1if.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for tx1if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 1 Empty Interrupt Flag
            pub fn tx1if_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of tx1if set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx1if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 1 Empty Interrupt Flag
            pub fn with_tx1if(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_tx1if(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of tx1if set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx1if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 1 Empty Interrupt Flag
            pub fn with_tx1if_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_tx1if_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of tx1if to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx1if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 1 Empty Interrupt Flag
            pub fn set_tx1if(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_tx1if_checked(new_val)
                    .expect("value out of bounds for field ReadStatusResponse.tx1if")
            }
            ///Sets the value of tx1if to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx1if.
            #[inline]
            /// Transmit Buffer 1 Empty Interrupt Flag
            pub fn set_tx1if_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of txreq2.
            #[inline]
            /// Message Transmit Request bit
            pub fn txreq2(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.txreq2_or_err().expect(
                    "value contains invalid bit pattern for field ReadStatusResponse.txreq2",
                )
            }
            ///Returns the value of txreq2.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for txreq2.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request bit
            pub fn txreq2_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of txreq2 set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txreq2.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request bit
            pub fn with_txreq2(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_txreq2(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of txreq2 set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txreq2.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request bit
            pub fn with_txreq2_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_txreq2_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of txreq2 to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for txreq2.
            #[inline]
            #[allow(dead_code)]
            /// Message Transmit Request bit
            pub fn set_txreq2(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_txreq2_checked(new_val)
                    .expect("value out of bounds for field ReadStatusResponse.txreq2")
            }
            ///Sets the value of txreq2 to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for txreq2.
            #[inline]
            /// Message Transmit Request bit
            pub fn set_txreq2_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of tx2if.
            #[inline]
            /// Transmit Buffer 2 Empty Interrupt Flag
            pub fn tx2if(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.tx2if_or_err()
                    .expect("value contains invalid bit pattern for field ReadStatusResponse.tx2if")
            }
            ///Returns the value of tx2if.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for tx2if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 2 Empty Interrupt Flag
            pub fn tx2if_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of tx2if set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx2if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 2 Empty Interrupt Flag
            pub fn with_tx2if(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_tx2if(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of tx2if set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx2if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 2 Empty Interrupt Flag
            pub fn with_tx2if_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_tx2if_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of tx2if to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for tx2if.
            #[inline]
            #[allow(dead_code)]
            /// Transmit Buffer 2 Empty Interrupt Flag
            pub fn set_tx2if(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_tx2if_checked(new_val)
                    .expect("value out of bounds for field ReadStatusResponse.tx2if")
            }
            ///Sets the value of tx2if to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for tx2if.
            #[inline]
            /// Transmit Buffer 2 Empty Interrupt Flag
            pub fn set_tx2if_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for ReadStatusResponse
        where
            [(); {
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<ReadStatusResponse> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: ReadStatusResponse) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for ReadStatusResponse {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("ReadStatusResponse")
                    .field(
                        "rx0if",
                        self.rx0if_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "rx1if",
                        self.rx1if_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "txreq0",
                        self.txreq0_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "tx0if",
                        self.tx0if_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "txreq1",
                        self.txreq1_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "tx1if",
                        self.tx1if_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "txreq2",
                        self.txreq2_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "tx2if",
                        self.tx2if_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// Read Status Response Bitfield
        #[allow(clippy::identity_op)]
        pub struct RxStatusResponse {
            bytes: [::core::primitive::u8; {
                ((({
                    0usize
                        + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize],
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::marker::Copy for RxStatusResponse {}
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::clone::Clone for RxStatusResponse {
            #[inline]
            fn clone(&self) -> RxStatusResponse {
                let _: ::core::clone::AssertParamIsClone<
                    [::core::primitive::u8; {
                        ((({
                            0usize
                                + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                >;
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::identity_op)]
        impl ::core::default::Default for RxStatusResponse {
            #[inline]
            fn default() -> RxStatusResponse {
                RxStatusResponse {
                    bytes: ::core::default::Default::default(),
                }
            }
        }
        impl defmt::Format for RxStatusResponse
        where
            [::core::primitive::u8; {
                ((({
                    0usize
                        + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                } - 1)
                    / 8)
                    + 1)
                    * 8
            } / 8usize]: defmt::Format,
        {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::mcp2515::registers".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"12894232470986657630\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"12894232470986657630\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"RxStatusResponse {{ bytes: {=?:?} }}\",\"disambiguator\":\"8957208992610073891\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"RxStatusResponse {{ bytes: {=?:?} }}\",\"disambiguator\":\"8957208992610073891\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    Self { bytes } => {
                        defmt::export::fmt(bytes);
                    }
                }
            }
        }
        #[allow(clippy::identity_op)]
        const _: () = {
            impl ::modular_bitfield::private::checks::CheckTotalSizeMultipleOf8 for RxStatusResponse {
                type Size = ::modular_bitfield::private::checks::TotalSize<
                    [(); {
                        0usize
                            + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } % 8usize],
                >;
            }
        };
        impl RxStatusResponse {
            /// Returns an instance with zero initialized data.
            #[allow(clippy::identity_op)]
            pub const fn new() -> Self {
                Self {
                    bytes: [0u8; {
                        ((({
                            0usize
                                + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <B1 as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                                + <bool as ::modular_bitfield::Specifier>::BITS
                        } - 1)
                            / 8)
                            + 1)
                            * 8
                    } / 8usize],
                }
            }
        }
        impl RxStatusResponse {
            /// Returns the underlying bits.
            ///
            /// # Layout
            ///
            /// The returned byte array is layed out in the same way as described
            /// [here](https://docs.rs/modular-bitfield/#generated-structure).
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn into_bytes(
                self,
            ) -> [::core::primitive::u8; {
                   ((({
                       0usize
                           + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <B1 as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                           + <bool as ::modular_bitfield::Specifier>::BITS
                   } - 1)
                       / 8)
                       + 1)
                       * 8
               } / 8usize] {
                self.bytes
            }
            /// Converts the given bytes directly into the bitfield struct.
            #[inline]
            #[allow(clippy::identity_op)]
            pub const fn from_bytes(
                bytes: [::core::primitive::u8; {
                    ((({
                        0usize
                            + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                    } - 1)
                        / 8)
                        + 1)
                        * 8
                } / 8usize],
            ) -> Self {
                Self { bytes }
            }
        }
        const _: () = {
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
            const _: () = {};
        };
        impl RxStatusResponse {
            ///Returns the value of filter_match.
            #[inline]
            pub fn filter_match(&self) -> <FilterMatch as ::modular_bitfield::Specifier>::InOut {
                self.filter_match_or_err().expect(
                    "value contains invalid bit pattern for field RxStatusResponse.filter_match",
                )
            }
            ///Returns the value of filter_match.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for filter_match.
            #[inline]
            #[allow(dead_code)]
            pub fn filter_match_or_err(
                &self,
            ) -> ::core::result::Result<
                <FilterMatch as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <FilterMatch as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <FilterMatch as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<FilterMatch>(
                        &self.bytes[..],
                        0usize,
                    )
                };
                <FilterMatch as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of filter_match set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for filter_match.
            #[inline]
            #[allow(dead_code)]
            pub fn with_filter_match(
                mut self,
                new_val: <FilterMatch as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_filter_match(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of filter_match set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for filter_match.
            #[inline]
            #[allow(dead_code)]
            pub fn with_filter_match_checked(
                mut self,
                new_val: <FilterMatch as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_filter_match_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of filter_match to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for filter_match.
            #[inline]
            #[allow(dead_code)]
            pub fn set_filter_match(
                &mut self,
                new_val: <FilterMatch as ::modular_bitfield::Specifier>::InOut,
            ) {
                self.set_filter_match_checked(new_val)
                    .expect("value out of bounds for field RxStatusResponse.filter_match")
            }
            ///Sets the value of filter_match to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for filter_match.
            #[inline]
            pub fn set_filter_match_checked(
                &mut self,
                new_val: <FilterMatch as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<FilterMatch as ::modular_bitfield::Specifier>::Bytes>(
                    );
                let __bf_max_value: <FilterMatch as ::modular_bitfield::Specifier>::Bytes = {
                    !0 >> (__bf_base_bits - <FilterMatch as ::modular_bitfield::Specifier>::BITS)
                };
                let __bf_spec_bits: ::core::primitive::usize =
                    <FilterMatch as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <FilterMatch as ::modular_bitfield::Specifier>::Bytes =
                    { <FilterMatch as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<FilterMatch>(
                    &mut self.bytes[..],
                    0usize,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of is_remote.
            #[inline]
            pub fn is_remote(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.is_remote_or_err().expect(
                    "value contains invalid bit pattern for field RxStatusResponse.is_remote",
                )
            }
            ///Returns the value of is_remote.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for is_remote.
            #[inline]
            #[allow(dead_code)]
            pub fn is_remote_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize + <FilterMatch as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of is_remote set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for is_remote.
            #[inline]
            #[allow(dead_code)]
            pub fn with_is_remote(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_is_remote(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of is_remote set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for is_remote.
            #[inline]
            #[allow(dead_code)]
            pub fn with_is_remote_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_is_remote_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of is_remote to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for is_remote.
            #[inline]
            #[allow(dead_code)]
            pub fn set_is_remote(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) {
                self.set_is_remote_checked(new_val)
                    .expect("value out of bounds for field RxStatusResponse.is_remote")
            }
            ///Sets the value of is_remote to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for is_remote.
            #[inline]
            pub fn set_is_remote_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize + <FilterMatch as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of is_extended.
            #[inline]
            pub fn is_extended(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.is_extended_or_err().expect(
                    "value contains invalid bit pattern for field RxStatusResponse.is_extended",
                )
            }
            ///Returns the value of is_extended.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for is_extended.
            #[inline]
            #[allow(dead_code)]
            pub fn is_extended_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of is_extended set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for is_extended.
            #[inline]
            #[allow(dead_code)]
            pub fn with_is_extended(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_is_extended(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of is_extended set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for is_extended.
            #[inline]
            #[allow(dead_code)]
            pub fn with_is_extended_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_is_extended_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of is_extended to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for is_extended.
            #[inline]
            #[allow(dead_code)]
            pub fn set_is_extended(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) {
                self.set_is_extended_checked(new_val)
                    .expect("value out of bounds for field RxStatusResponse.is_extended")
            }
            ///Sets the value of is_extended to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for is_extended.
            #[inline]
            pub fn set_is_extended_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of rx0if.
            #[inline]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn rx0if(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rx0if_or_err()
                    .expect("value contains invalid bit pattern for field RxStatusResponse.rx0if")
            }
            ///Returns the value of rx0if.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rx0if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn rx0if_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rx0if set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx0if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn with_rx0if(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rx0if(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rx0if set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx0if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn with_rx0if_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rx0if_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rx0if to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx0if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn set_rx0if(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_rx0if_checked(new_val)
                    .expect("value out of bounds for field RxStatusResponse.rx0if")
            }
            ///Sets the value of rx0if to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx0if.
            #[inline]
            /// Receive Buffer 0 Full Interrupt Flag
            pub fn set_rx0if_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
            ///Returns the value of rx1if.
            #[inline]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn rx1if(&self) -> <bool as ::modular_bitfield::Specifier>::InOut {
                self.rx1if_or_err()
                    .expect("value contains invalid bit pattern for field RxStatusResponse.rx1if")
            }
            ///Returns the value of rx1if.
            ///
            ///#Errors
            ///
            ///If the returned value contains an invalid bit pattern for rx1if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn rx1if_or_err(
                &self,
            ) -> ::core::result::Result<
                <bool as ::modular_bitfield::Specifier>::InOut,
                ::modular_bitfield::error::InvalidBitPattern<
                    <bool as ::modular_bitfield::Specifier>::Bytes,
                >,
            > {
                let __bf_read: <bool as ::modular_bitfield::Specifier>::Bytes = {
                    ::modular_bitfield::private::read_specifier::<bool>(
                        &self.bytes[..],
                        0usize
                            + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS
                            + <B1 as ::modular_bitfield::Specifier>::BITS
                            + <bool as ::modular_bitfield::Specifier>::BITS,
                    )
                };
                <bool as ::modular_bitfield::Specifier>::from_bytes(__bf_read)
            }
            ///Returns a copy of the bitfield with the value of rx1if set to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx1if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn with_rx1if(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> Self {
                self.set_rx1if(new_val);
                self
            }
            ///Returns a copy of the bitfield with the value of rx1if set to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx1if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn with_rx1if_checked(
                mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<Self, ::modular_bitfield::error::OutOfBounds> {
                self.set_rx1if_checked(new_val)?;
                ::core::result::Result::Ok(self)
            }
            ///Sets the value of rx1if to the given value.
            ///
            ///#Panics
            ///
            ///If the given value is out of bounds for rx1if.
            #[inline]
            #[allow(dead_code)]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn set_rx1if(&mut self, new_val: <bool as ::modular_bitfield::Specifier>::InOut) {
                self.set_rx1if_checked(new_val)
                    .expect("value out of bounds for field RxStatusResponse.rx1if")
            }
            ///Sets the value of rx1if to the given value.
            ///
            ///#Errors
            ///
            ///If the given value is out of bounds for rx1if.
            #[inline]
            /// Receive Buffer 1 Full Interrupt Flag
            pub fn set_rx1if_checked(
                &mut self,
                new_val: <bool as ::modular_bitfield::Specifier>::InOut,
            ) -> ::core::result::Result<(), ::modular_bitfield::error::OutOfBounds> {
                let __bf_base_bits: ::core::primitive::usize = 8usize
                    * ::core::mem::size_of::<<bool as ::modular_bitfield::Specifier>::Bytes>();
                let __bf_max_value: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { !0 >> (__bf_base_bits - <bool as ::modular_bitfield::Specifier>::BITS) };
                let __bf_spec_bits: ::core::primitive::usize =
                    <bool as ::modular_bitfield::Specifier>::BITS;
                let __bf_raw_val: <bool as ::modular_bitfield::Specifier>::Bytes =
                    { <bool as ::modular_bitfield::Specifier>::into_bytes(new_val) }?;
                if !(__bf_base_bits == __bf_spec_bits || __bf_raw_val <= __bf_max_value) {
                    return ::core::result::Result::Err(::modular_bitfield::error::OutOfBounds);
                }
                ::modular_bitfield::private::write_specifier::<bool>(
                    &mut self.bytes[..],
                    0usize
                        + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS
                        + <B1 as ::modular_bitfield::Specifier>::BITS
                        + <bool as ::modular_bitfield::Specifier>::BITS,
                    __bf_raw_val,
                );
                ::core::result::Result::Ok(())
            }
        }
        impl ::core::convert::From<::core::primitive::u8> for RxStatusResponse
        where
            [(); {
                0usize
                    + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_prim: ::core::primitive::u8) -> Self {
                Self {
                    bytes: <::core::primitive::u8>::to_le_bytes(__bf_prim),
                }
            }
        }
        impl ::core::convert::From<RxStatusResponse> for ::core::primitive::u8
        where
            [(); {
                0usize
                    + <FilterMatch as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <B1 as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
                    + <bool as ::modular_bitfield::Specifier>::BITS
            }]: ::modular_bitfield::private::IsU8Compatible,
        {
            #[inline]
            fn from(__bf_bitfield: RxStatusResponse) -> Self {
                <Self>::from_le_bytes(__bf_bitfield.bytes)
            }
        }
        impl ::core::fmt::Debug for RxStatusResponse {
            fn fmt(&self, __bf_f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                __bf_f
                    .debug_struct("RxStatusResponse")
                    .field(
                        "filter_match",
                        self.filter_match_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "is_remote",
                        self.is_remote_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "is_extended",
                        self.is_extended_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "rx0if",
                        self.rx0if_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .field(
                        "rx1if",
                        self.rx1if_or_err()
                            .as_ref()
                            .map(|__bf_field| __bf_field as &dyn ::core::fmt::Debug)
                            .unwrap_or_else(|__bf_err| __bf_err as &dyn ::core::fmt::Debug),
                    )
                    .finish()
            }
        }
        /// The filter that matched the received message
        #[bits = 3]
        pub enum FilterMatch {
            RXF0,
            RXF1,
            RXF2,
            RXF3,
            RXF4,
            RXF5,
            RXF0Rollover,
            RXF1Rollover,
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<[(); Self::RXF0 as usize]>
            for FilterMatch
        {
            type CheckType = [(); ((Self::RXF0 as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<[(); Self::RXF1 as usize]>
            for FilterMatch
        {
            type CheckType = [(); ((Self::RXF1 as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<[(); Self::RXF2 as usize]>
            for FilterMatch
        {
            type CheckType = [(); ((Self::RXF2 as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<[(); Self::RXF3 as usize]>
            for FilterMatch
        {
            type CheckType = [(); ((Self::RXF3 as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<[(); Self::RXF4 as usize]>
            for FilterMatch
        {
            type CheckType = [(); ((Self::RXF4 as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<[(); Self::RXF5 as usize]>
            for FilterMatch
        {
            type CheckType = [(); ((Self::RXF5 as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::RXF0Rollover as usize],
            > for FilterMatch
        {
            type CheckType =
                [(); ((Self::RXF0Rollover as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl
            ::modular_bitfield::private::checks::CheckDiscriminantInRange<
                [(); Self::RXF1Rollover as usize],
            > for FilterMatch
        {
            type CheckType =
                [(); ((Self::RXF1Rollover as usize) < (0x01_usize << 3usize)) as usize];
        }
        impl ::modular_bitfield::Specifier for FilterMatch {
            const BITS: usize = 3usize;
            type Bytes = <[(); 3usize] as ::modular_bitfield::private::SpecifierBytes>::Bytes;
            type InOut = Self;
            #[inline]
            fn into_bytes(
                input: Self::InOut,
            ) -> ::core::result::Result<Self::Bytes, ::modular_bitfield::error::OutOfBounds>
            {
                ::core::result::Result::Ok(input as Self::Bytes)
            }
            #[inline]
            fn from_bytes(
                bytes: Self::Bytes,
            ) -> ::core::result::Result<
                Self::InOut,
                ::modular_bitfield::error::InvalidBitPattern<Self::Bytes>,
            > {
                match bytes {
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::RXF0 as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::RXF0)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::RXF1 as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::RXF1)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::RXF2 as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::RXF2)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::RXF3 as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::RXF3)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::RXF4 as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::RXF4)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::RXF5 as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::RXF5)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::RXF0Rollover
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::RXF0Rollover)
                    }
                    __bitfield_binding
                        if __bitfield_binding
                            == Self::RXF1Rollover
                                as <Self as ::modular_bitfield::Specifier>::Bytes =>
                    {
                        ::core::result::Result::Ok(Self::RXF1Rollover)
                    }
                    invalid_bytes => {
                        ::core::result::Result::Err(<::modular_bitfield::error::InvalidBitPattern<
                            Self::Bytes,
                        >>::new(invalid_bytes))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for FilterMatch {}
        #[automatically_derived]
        impl ::core::clone::Clone for FilterMatch {
            #[inline]
            fn clone(&self) -> FilterMatch {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for FilterMatch {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        FilterMatch::RXF0 => "RXF0",
                        FilterMatch::RXF1 => "RXF1",
                        FilterMatch::RXF2 => "RXF2",
                        FilterMatch::RXF3 => "RXF3",
                        FilterMatch::RXF4 => "RXF4",
                        FilterMatch::RXF5 => "RXF5",
                        FilterMatch::RXF0Rollover => "RXF0Rollover",
                        FilterMatch::RXF1Rollover => "RXF1Rollover",
                    },
                )
            }
        }
        impl Register for RXB0CTRL {
            const ADDRESS: u8 = 0x60;
        }
        impl Register for RXB1CTRL {
            const ADDRESS: u8 = 0x70;
        }
        impl Register for CANCTRL {
            const ADDRESS: u8 = 0x0F;
        }
        impl Register for CANSTAT {
            const ADDRESS: u8 = 0x0E;
        }
        impl Register for CNF1 {
            const ADDRESS: u8 = 0x2A;
        }
        impl Register for CNF2 {
            const ADDRESS: u8 = 0x29;
        }
        impl Register for CNF3 {
            const ADDRESS: u8 = 0x28;
        }
        impl Register for TXB0CTRL {
            const ADDRESS: u8 = 0x30;
        }
        impl Register for TXB1CTRL {
            const ADDRESS: u8 = 0x40;
        }
        impl Register for TXB2CTRL {
            const ADDRESS: u8 = 0x50;
        }
        impl Register for CANINTE {
            const ADDRESS: u8 = 0x2B;
        }
        impl Register for CANINTF {
            const ADDRESS: u8 = 0x2C;
        }
        impl Register for EFLG {
            const ADDRESS: u8 = 0x2D;
        }
        impl Register for BFPCTRL {
            const ADDRESS: u8 = 0x0C;
        }
        impl Register for TXRTSCTRL {
            const ADDRESS: u8 = 0x0D;
        }
        impl Register for TEC {
            const ADDRESS: u8 = 0x1C;
        }
        impl Register for REC {
            const ADDRESS: u8 = 0x1D;
        }
        impl Modify for CANCTRL {}
        impl Modify for CNF1 {}
        impl Modify for CNF2 {}
        impl Modify for CNF3 {}
        impl Modify for TXB0CTRL {}
        impl Modify for TXB1CTRL {}
        impl Modify for TXB2CTRL {}
        impl Modify for RXB0CTRL {}
        impl Modify for RXB1CTRL {}
        impl Modify for CANINTE {}
        impl Modify for CANINTF {}
        impl Modify for EFLG {}
        impl Modify for BFPCTRL {}
        impl Modify for TXRTSCTRL {}
    }
    pub use bitrates::*;
    pub use config::*;
    pub use frame::*;
    pub use idheader::*;
    pub use registers::*;
    use crate::event::{KiaEvent, KIA_EVENTS};
    pub struct Mcp2515<SPI, INT> {
        spi: SPI,
        int: INT,
    }
    impl<SPI, INT> Mcp2515<SPI, INT>
    where
        SPI: SpiDevice<u8>,
        INT: embedded_hal_async::digital::Wait,
    {
        pub fn new(spi: SPI, int: INT) -> Self {
            Self { spi, int }
        }
        pub async fn apply_canctrl(&mut self, canctrl: CANCTRL, mut debug: bool) -> bool {
            self.write_register(canctrl).await.ok();
            let mut canctrl_read = [0u8; 1];
            self.read_registers(CANCTRL::ADDRESS, &mut canctrl_read)
                .await
                .ok();
            let written_canctrl: u8 = canctrl.into();
            let canctrl_read_parsed = CANCTRL::from_bytes(canctrl_read);
            if canctrl_read[0] != written_canctrl
                && !(canctrl_read_parsed.reqop() == OperationMode::ListenOnly
                    && canctrl.reqop() == OperationMode::Sleep)
            {
                if debug {
                    match (
                        &(written_canctrl),
                        &(canctrl_read[0]),
                        &(canctrl_read_parsed.reqop()),
                    ) {
                        (arg0, arg1, arg2) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "kia_obd2_esp32c3_v2::mcp2515".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"MCP2515 canctrl config failed, expected: {:b}, got: {:b} with mode: {:?}\",\"disambiguator\":\"14472053349827958694\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"MCP2515 canctrl config failed, expected: {:b}, got: {:b} with mode: {:?}\",\"disambiguator\":\"14472053349827958694\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                defmt::export::fmt(arg1);
                                defmt::export::fmt(arg2);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                }
                false
            } else {
                true
            }
        }
        pub async fn apply_config(
            &mut self,
            config: &Config<'_>,
            obd2: bool,
        ) -> Result<(), SPI::Error> {
            let mut ok_inits = 0u8;
            let mut previous_canctrl = 0;
            let mut last_init_state_event = embassy_time::Instant::now();
            loop {
                self.reset().await?;
                let mut canctrl = [0u8; 1];
                embassy_time::Timer::after_millis(100).await;
                self.read_registers(0x0F, &mut canctrl).await?;
                let mut debug = false;
                if previous_canctrl != canctrl[0] {
                    debug = true;
                    previous_canctrl = canctrl[0];
                    match (&(canctrl[0])) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "kia_obd2_esp32c3_v2::mcp2515".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"canctrl: {:b}\",\"disambiguator\":\"4033484088348285165\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"canctrl: {:b}\",\"disambiguator\":\"4033484088348285165\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    if canctrl[0] != 0b10000111 {
                        match () {
                            () => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::mcp2515".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    defmt::export::acquire_header_and_release(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"MCP2515 is not in configuration mode\",\"disambiguator\":\"8245467763438859999\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"MCP2515 is not in configuration mode\",\"disambiguator\":\"8245467763438859999\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                }
                            }
                        };
                    }
                }
                self.set_bitrate(config.cnf).await?;
                self.write_register(config.rxb0ctrl).await?;
                self.write_register(config.rxb1ctrl).await?;
                for &(filter, id_header) in config.filters {
                    self.set_filter(filter, id_header).await?;
                }
                if self.apply_canctrl(config.canctrl, debug).await {
                    ok_inits += 1;
                    if ok_inits >= 2 {
                        break;
                    }
                } else {
                    if obd2 && last_init_state_event.elapsed().as_secs() > 10 {
                        KIA_EVENTS.send(KiaEvent::Obd2Init(false)).await;
                        last_init_state_event = embassy_time::Instant::now();
                    }
                    Timer::after(Duration::from_millis(10)).await;
                }
            }
            Ok(())
        }
        pub async fn apply_interrupts_config(
            &mut self,
            interputs_config: CANINTE,
        ) -> Result<(), SPI::Error> {
            let caninte: u8 = interputs_config.into();
            self.write_register(interputs_config).await?;
            let mut caninte_read = [0u8; 1];
            self.read_registers(CANINTE::ADDRESS, &mut caninte_read)
                .await?;
            if caninte_read[0] != caninte {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::mcp2515".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"MCP2515 interrupts config failed\",\"disambiguator\":\"15503292200102591207\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"MCP2515 interrupts config failed\",\"disambiguator\":\"15503292200102591207\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
            }
            Ok(())
        }
        pub async fn clear_interrupts(&mut self) -> Result<(), SPI::Error> {
            let mut data = [0u8; 1];
            data[0] = 0x00;
            self.write_registers(CANINTF::ADDRESS, &data).await?;
            Ok(())
        }
        pub async fn set_bitrate(&mut self, cnf: CNF) -> Result<(), SPI::Error> {
            let bytes = cnf.into_bytes();
            self.write_registers(CNF3::ADDRESS, &bytes).await?;
            Ok(())
        }
        pub async fn set_filter(
            &mut self,
            filter: AcceptanceFilter,
            id: IdHeader,
        ) -> Result<(), SPI::Error> {
            self.write_registers(filter as u8, &id.into_bytes()).await?;
            Ok(())
        }
        pub async fn reset(&mut self) -> Result<(), SPI::Error> {
            let mut reset_buf = [0; 1];
            reset_buf[0] = Instruction::Reset as u8;
            self.spi.write(&reset_buf).await?;
            embassy_time::Timer::after_millis(50).await;
            Ok(())
        }
        pub async fn shutdown(&mut self) {
            self.reset().await;
            let mut config = crate::mcp2515::Config::default().mode(OperationMode::Configuration);
            config.canctrl.set_abat(true);
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::mcp2515".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        defmt::export::acquire_header_and_release(&{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"Set config mode\",\"disambiguator\":\"7976939810848216952\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"Set config mode\",\"disambiguator\":\"7976939810848216952\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        });
                    }
                }
            };
            self.apply_canctrl(config.canctrl, true).await;
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::mcp2515".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        defmt::export::acquire_header_and_release(&{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"Set config mode end\",\"disambiguator\":\"11030878267244469625\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"Set config mode end\",\"disambiguator\":\"11030878267244469625\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        });
                    }
                }
            };
            self.write_registers(CNF3::ADDRESS, &[0]).await;
            self.write_registers(CNF2::ADDRESS, &[0]).await;
            self.write_registers(CNF1::ADDRESS, &[0]).await;
            config.canctrl.set_reqop(OperationMode::Sleep);
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::mcp2515".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        defmt::export::acquire_header_and_release(&{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"Shutting down MCP2515\",\"disambiguator\":\"5989580740257935173\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"Shutting down MCP2515\",\"disambiguator\":\"5989580740257935173\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        });
                    }
                }
            };
            match (&(config.canctrl.clken())) {
                (arg0) => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::mcp2515".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe {
                            defmt::export::acquire_and_header(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"config.canctrl.clken: {:?}\",\"disambiguator\":\"2848718013213475169\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"config.canctrl.clken: {:?}\",\"disambiguator\":\"2848718013213475169\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        };
                        defmt::export::fmt(arg0);
                        unsafe { defmt::export::release() }
                    }
                }
            };
            while !self.apply_canctrl(config.canctrl, true).await {
                self.reset().await;
                Timer::after(Duration::from_secs(1)).await;
            }
        }
        pub async fn rx_status(&mut self) -> Result<RxStatusResponse, SPI::Error> {
            let mut rx_status_buf = [0; 1];
            rx_status_buf[0] = Instruction::RxStatus as u8;
            let mut buf = [0];
            self.spi
                .transaction(&mut [Operation::Write(&rx_status_buf), Operation::Read(&mut buf)])
                .await?;
            Ok(RxStatusResponse::from_bytes(buf))
        }
        pub async fn status(&mut self) -> Result<ReadStatusResponse, SPI::Error> {
            let mut status_buf = [0; 1];
            status_buf[0] = Instruction::ReadStatus as u8;
            let mut buf = [0];
            self.spi
                .transaction(&mut [Operation::Write(&status_buf), Operation::Read(&mut buf)])
                .await?;
            Ok(ReadStatusResponse::from_bytes(buf))
        }
        pub async fn errors(&mut self) -> Result<EFLG, SPI::Error> {
            let mut eflg_buf = [0; 1];
            eflg_buf[0] = Instruction::Read as u8 | EFLG::ADDRESS;
            let mut buf = [0];
            self.spi
                .transaction(&mut [Operation::Write(&eflg_buf), Operation::Read(&mut buf)])
                .await?;
            self.modify_register(EFLG::new(), 1 << 7 as u8).await?;
            self.modify_register(EFLG::new(), 1 << 6 as u8).await?;
            Ok(EFLG::from_bytes(buf))
        }
        pub async fn read_rx_buffer(
            &mut self,
            buf_idx: RxBuffer,
        ) -> Result<frame::CanFrame, SPI::Error> {
            let mut frame_buffer = [0; core::mem::size_of::<frame::CanFrame>()];
            let mut rx_buf = [0; 1];
            rx_buf[0] = Instruction::ReadRxBuffer as u8 | (buf_idx as u8 * 2);
            self.spi
                .transaction(&mut [
                    Operation::Write(&rx_buf),
                    Operation::Read(&mut frame_buffer),
                ])
                .await?;
            let mut frame: frame::CanFrame = unsafe { core::mem::transmute(frame_buffer) };
            let mut dlc = frame.dlc();
            if dlc > 8 {
                dlc = 8;
                frame.dlc.set_dlc(8);
            }
            Ok(frame)
        }
        pub async fn load_tx_buffer(
            &mut self,
            buf_idx: TxBuffer,
            frame: &frame::CanFrame,
        ) -> Result<(), SPI::Error> {
            let mut load_tx_buf = [0; 1];
            load_tx_buf[0] = Instruction::LoadTxBuffer as u8 | (buf_idx as u8 * 2);
            let data = &frame.as_bytes()[0..5 + frame.dlc()];
            self.spi
                .transaction(&mut [Operation::Write(&load_tx_buf), Operation::Write(data)])
                .await?;
            Ok(())
        }
        pub async fn request_to_send(&mut self, buf_idx: TxBuffer) -> Result<(), SPI::Error> {
            let mut request_to_send_buf = [0; 1];
            request_to_send_buf[0] = Instruction::Rts as u8 | (1 << buf_idx as u8);
            self.spi
                .transaction(&mut [Operation::Write(&request_to_send_buf)])
                .await?;
            Ok(())
        }
        async fn read_registers(
            &mut self,
            start_address: u8,
            buf: &mut [u8],
        ) -> Result<(), SPI::Error> {
            let mut read_buf = [0; 2];
            read_buf[0] = Instruction::Read as u8;
            read_buf[1] = start_address;
            self.spi
                .transaction(&mut [Operation::Write(&read_buf), Operation::Read(buf)])
                .await?;
            Ok(())
        }
        async fn write_register<R: Register + Into<u8>>(&mut self, r: R) -> Result<(), SPI::Error> {
            let mut write_buf = [0; 3];
            write_buf[0] = Instruction::Write as u8;
            write_buf[1] = R::ADDRESS;
            write_buf[2] = r.into();
            self.spi
                .transaction(&mut [Operation::Write(&write_buf)])
                .await?;
            Ok(())
        }
        async fn write_registers(
            &mut self,
            start_address: u8,
            data: &[u8],
        ) -> Result<(), SPI::Error> {
            let mut write_buf = [0; 2];
            write_buf[0] = Instruction::Write as u8;
            write_buf[1] = start_address;
            self.spi
                .transaction(&mut [Operation::Write(&write_buf), Operation::Write(data)])
                .await?;
            Ok(())
        }
        pub async fn modify_register<R: Register + Modify + Into<u8>>(
            &mut self,
            reg: R,
            mask: u8,
        ) -> Result<(), SPI::Error> {
            let mut modify_buf = [0; 4];
            modify_buf[0] = Instruction::BitModify as u8;
            modify_buf[1] = R::ADDRESS;
            modify_buf[2] = mask;
            modify_buf[3] = reg.into();
            self.spi.write(&modify_buf).await?;
            Ok(())
        }
        pub async fn interrupt(&mut self) {
            self.int.wait_for_falling_edge().await.ok();
        }
    }
    /// Filters and Masks of the two receive buffers
    pub enum AcceptanceFilter {
        /// Associated with Receive Buffer 0
        Filter0 = 0x00,

        /// Associated with Receive Buffer 0
        Filter1 = 0x04,

        /// Associated with Receive Buffer 1
        Filter2 = 0x08,

        /// Associated with Receive Buffer 1
        Filter3 = 0x10,

        /// Associated with Receive Buffer 1
        Filter4 = 0x14,

        /// Associated with Receive Buffer 1
        Filter5 = 0x18,

        /// Associated with Receive Buffer 0
        Mask0 = 0x20,

        /// Associated with Receive Buffer 1
        Mask1 = 0x24,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for AcceptanceFilter {}
    #[automatically_derived]
    impl ::core::clone::Clone for AcceptanceFilter {
        #[inline]
        fn clone(&self) -> AcceptanceFilter {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AcceptanceFilter {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    AcceptanceFilter::Filter0 => "Filter0",
                    AcceptanceFilter::Filter1 => "Filter1",
                    AcceptanceFilter::Filter2 => "Filter2",
                    AcceptanceFilter::Filter3 => "Filter3",
                    AcceptanceFilter::Filter4 => "Filter4",
                    AcceptanceFilter::Filter5 => "Filter5",
                    AcceptanceFilter::Mask0 => "Mask0",
                    AcceptanceFilter::Mask1 => "Mask1",
                },
            )
        }
    }
    /// Transmit buffer
    pub enum TxBuffer {
        /// Transmit buffer 0
        TXB0 = 0,

        /// Transmit buffer 1
        TXB1 = 1,

        /// Transmit buffer 2
        TXB2 = 2,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TxBuffer {}
    #[automatically_derived]
    impl ::core::clone::Clone for TxBuffer {
        #[inline]
        fn clone(&self) -> TxBuffer {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TxBuffer {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TxBuffer::TXB0 => "TXB0",
                    TxBuffer::TXB1 => "TXB1",
                    TxBuffer::TXB2 => "TXB2",
                },
            )
        }
    }
    /// Receive buffer
    pub enum RxBuffer {
        /// Receive Buffer 0
        RXB0 = 0,

        /// Receive Buffer 1
        RXB1 = 1,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for RxBuffer {}
    #[automatically_derived]
    impl ::core::clone::Clone for RxBuffer {
        #[inline]
        fn clone(&self) -> RxBuffer {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RxBuffer {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    RxBuffer::RXB0 => "RXB0",
                    RxBuffer::RXB1 => "RXB1",
                },
            )
        }
    }
    /// Instruction supported by the CAN controller
    #[repr(u8)]
    pub enum Instruction {
        /// Resets internal registers to the default state, sets Configuration mode.
        Reset = 0b1100_0000,

        /// Reads data from the register beginning at the selected address.
        Read = 0b0000_0011,

        /// Writes data to the register beginning at the selected address.
        Write = 0b0000_0010,

        /// Instructs the controller to begin the message transmission sequence for
        /// any of the transmit buffers specified in `0b1000_0nnn`.
        Rts = 0b1000_0000,

        /// Quick polling command that reads several Status bits for transmit and receive functions.
        ReadStatus = 0b1010_0000,

        /// Allows the user to set or clear individual bits in a particular register.
        ///
        /// Note: Not all registers can be bit modified with this command.
        /// Executing this command on registers that are not bit modifiable will force the mask to FFh.
        ///
        /// Registers that can be modified with this command implement [`Modify`].
        BitModify = 0b0000_0101,

        /// Quick polling command that indicates a filter match and message type
        /// (standard, extended and/or remote) of the received message.
        RxStatus = 0b1011_0000,

        /// When reading a receive buffer, reduces the overhead of a normal `Read`
        /// command by placing the Address Pointer at one of four locations, as
        /// indicated by ‘nm’ in `0b1001_0nm0`.
        ///
        /// Note: The associated RX flag bit (`rxNif` bits in the [`CANINTF`] register) will be cleared after bringing CS high.
        ReadRxBuffer = 0b1001_0000,

        /// When loading a transmit buffer, reduces the overhead of a normal `Write`
        /// command by placing the Address Pointer at one of six locations, as
        /// indicated by ‘abc’ in `0b0100_0abc`.
        LoadTxBuffer = 0b0100_0000,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Instruction {}
    #[automatically_derived]
    impl ::core::clone::Clone for Instruction {
        #[inline]
        fn clone(&self) -> Instruction {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Instruction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Instruction::Reset => "Reset",
                    Instruction::Read => "Read",
                    Instruction::Write => "Write",
                    Instruction::Rts => "Rts",
                    Instruction::ReadStatus => "ReadStatus",
                    Instruction::BitModify => "BitModify",
                    Instruction::RxStatus => "RxStatus",
                    Instruction::ReadRxBuffer => "ReadRxBuffer",
                    Instruction::LoadTxBuffer => "LoadTxBuffer",
                },
            )
        }
    }
}
mod obd2 {
    use core::{any::TypeId, convert::Infallible};
    use defmt::{error, info, unwrap, warn};
    use embassy_embedded_hal::shared_bus::SpiDeviceError;
    use embassy_time::{with_timeout, Duration, Instant};
    use embedded_can::{Frame as _, StandardId};
    use heapless::Entry;
    use static_cell::make_static;
    use types::Obd2Frame;
    use crate::{
        debug::internal_debug,
        event::{Event, EventBusPub, KiaEvent, Obd2Event, KIA_EVENTS},
        mcp2515::{
            clock_16mhz, clock_8mhz, CanFrame, OperationMode, RxBuffer, TxBuffer, CANINTE, CLKPRE,
            RXB0CTRL, RXB1CTRL, RXM,
        },
        prelude::*,
        tasks::{
            ieee802154::{insert_send_pid, insert_send_pid_error},
            lcd::obd2_debug_pids_enabled,
            obd2::Obd2Debug,
        },
        types::Mcp2515,
    };
    pub enum Obd2Error {
        Spi(SpiDeviceError<esp_hal::spi::Error, Infallible>),
        Parse,
        DataNotFound,
        FrameToShort,
    }
    impl From<SpiDeviceError<esp_hal::spi::Error, Infallible>> for Obd2Error {
        fn from(e: SpiDeviceError<esp_hal::spi::Error, Infallible>) -> Self {
            Self::Spi(e)
        }
    }
    pub struct Obd2 {
        mcp2515: Mcp2515,
        obd2_message_buffer: &'static mut heapless::Vec<u8, 4095>,
        obd2_pid_errors: heapless::FnvIndexMap<TypeId, usize, 32>,
        obd2_pid_errors_periods: heapless::FnvIndexMap<TypeId, Instant, 32>,
        obd2_pid_periods: heapless::FnvIndexMap<TypeId, Instant, 32>,
        obd2_pid_periods_disable: bool,
    }
    impl Obd2 {
        pub fn new(mcp2515: Mcp2515) -> Self {
            static OBD2_MESSAGE_BUFFER_STATIC: static_cell::StaticCell<heapless::Vec<u8, 4095>> =
                static_cell::StaticCell::new();
            let obd2_message_buffer = OBD2_MESSAGE_BUFFER_STATIC.init_with(|| heapless::Vec::new());
            let obd2_pid_errors = heapless::FnvIndexMap::new();
            let obd2_pid_errors_periods = heapless::FnvIndexMap::new();
            let obd2_pid_periods = heapless::FnvIndexMap::new();
            Self {
                mcp2515,
                obd2_message_buffer,
                obd2_pid_errors_periods,
                obd2_pid_errors,
                obd2_pid_periods,
                obd2_pid_periods_disable: false,
            }
        }
        pub fn enable_obd2_pid_periods(&mut self) {
            self.obd2_pid_periods_disable = false;
        }
        pub fn disable_obd2_pid_periods(&mut self) {
            self.obd2_pid_periods_disable = true;
        }
        pub async fn init(
            &mut self,
        ) -> Result<(), SpiDeviceError<esp_hal::spi::Error, Infallible>> {
            let config = crate::mcp2515::Config::default()
                .mode(OperationMode::NormalOperation)
                .bitrate(clock_16mhz::CNF_500K_BPS)
                .set_clk_prescaler(CLKPRE::SystemClockDiv2)
                .receive_buffer_0(
                    RXB0CTRL::default()
                        .with_rxm(RXM::ReceiveAny)
                        .with_bukt(true),
                )
                .receive_buffer_1(RXB1CTRL::default().with_rxm(RXM::ReceiveAny));
            self.mcp2515.apply_config(&config, true).await?;
            let interputs_config = CANINTE::default().with_rx0ie(true).with_rx1ie(true);
            self.mcp2515
                .apply_interrupts_config(interputs_config)
                .await?;
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::obd2".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        defmt::export::acquire_header_and_release(&{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"obd2 init done\",\"disambiguator\":\"8299851705240358405\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"obd2 init done\",\"disambiguator\":\"8299851705240358405\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        });
                    }
                }
            };
            Ok(())
        }
        pub async fn shutdown(&mut self) {
            self.mcp2515.shutdown().await;
        }
        async fn request<'a>(&'a mut self, request: &CanFrame) -> Result<&'a [u8], Obd2Error> {
            let mut _lock = Some(crate::locks::SPI_BUS.lock().await);
            self.mcp2515.clear_interrupts().await?;
            let flow_control = match defmt::export::into_result(CanFrame::new(
                request.id(),
                &[0x30, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
            )) {
                ::core::result::Result::Ok(res) => res,
                ::core::result::Result::Err(_unwrap_err) => {
                    match (&(_unwrap_err)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "kia_obd2_esp32c3_v2::obd2".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame ::\\nnew(request.id(), & [0x30, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"2131413773370995948\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame ::\\nnew(request.id(), & [0x30, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"2131413773370995948\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    defmt::export::panic()
                }
            };
            self.mcp2515
                .load_tx_buffer(TxBuffer::TXB0, &request)
                .await?;
            self.mcp2515.request_to_send(TxBuffer::TXB0).await?;
            let mut can_frames = [None, None];
            let obd2_data: Option<&[u8]>;
            let mut obd2_message_length = None;
            let mut obd2_message_id = 0;
            'outer: loop {
                let rx_status = self.mcp2515.rx_status().await?;
                if rx_status.rx0if() {
                    let frame = self.mcp2515.read_rx_buffer(RxBuffer::RXB0).await?;
                    can_frames[0] = Some(frame);
                }
                if rx_status.rx1if() {
                    let frame = self.mcp2515.read_rx_buffer(RxBuffer::RXB1).await?;
                    can_frames[1] = Some(frame);
                }
                for can_frame in can_frames.iter().flatten() {
                    let obd2_frame_type = can_frame.data[0] & 0xF0;
                    match obd2_frame_type {
                        0x02 | 0x04 | 0x00 => {
                            self.obd2_message_buffer.clear();
                            self.obd2_message_buffer.extend_from_slice(&can_frame.data);
                            obd2_data = Some(self.obd2_message_buffer.as_slice());
                            break 'outer;
                        }
                        0x10 => {
                            self.obd2_message_buffer.clear();
                            obd2_message_length = Some(
                                ((can_frame.data[0] & 0x0F) as usize) << 8
                                    | can_frame.data[1] as usize,
                            );
                            self.mcp2515
                                .load_tx_buffer(TxBuffer::TXB0, &flow_control)
                                .await?;
                            self.mcp2515.request_to_send(TxBuffer::TXB0).await?;
                            match defmt::export::into_result(
                                self.obd2_message_buffer
                                    .extend_from_slice(&can_frame.data[2..]),
                            ) {
                                ::core::result::Result::Ok(res) => res,
                                ::core::result::Result::Err(_unwrap_err) => {
                                    match (&(_unwrap_err)) {
                                        (arg0) => {
                                            if {
                                                const CHECK: bool = {
                                                    const fn check() -> bool {
                                                        let module_path =
                                                            "kia_obd2_esp32c3_v2::obd2".as_bytes();
                                                        if if 19usize > module_path.len() {
                                                            false
                                                        } else {
                                                            module_path[0usize] == 107u8
                                                                && module_path[1usize] == 105u8
                                                                && module_path[2usize] == 97u8
                                                                && module_path[3usize] == 95u8
                                                                && module_path[4usize] == 111u8
                                                                && module_path[5usize] == 98u8
                                                                && module_path[6usize] == 100u8
                                                                && module_path[7usize] == 50u8
                                                                && module_path[8usize] == 95u8
                                                                && module_path[9usize] == 101u8
                                                                && module_path[10usize] == 115u8
                                                                && module_path[11usize] == 112u8
                                                                && module_path[12usize] == 51u8
                                                                && module_path[13usize] == 50u8
                                                                && module_path[14usize] == 99u8
                                                                && module_path[15usize] == 51u8
                                                                && module_path[16usize] == 95u8
                                                                && module_path[17usize] == 118u8
                                                                && module_path[18usize] == 50u8
                                                                && if 19usize == module_path.len() {
                                                                    true
                                                                } else {
                                                                    module_path[19usize] == b':'
                                                                }
                                                        } {
                                                            return true;
                                                        }
                                                        false
                                                    }
                                                    check()
                                                };
                                                CHECK
                                            } {
                                                unsafe {
                                                    defmt::export::acquire_and_header(&{
                                                        defmt::export::make_istr({
                                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: self.obd2_message_buffer.extend_from_slice(& can_frame.data [2 ..])'\\nerror: `{:?}`\",\"disambiguator\":\"12492084546551175211\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: self.obd2_message_buffer.extend_from_slice(& can_frame.data [2 ..])'\\nerror: `{:?}`\",\"disambiguator\":\"12492084546551175211\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                        })
                                                    });
                                                };
                                                defmt::export::fmt(arg0);
                                                unsafe { defmt::export::release() }
                                            }
                                        }
                                    };
                                    defmt::export::panic()
                                }
                            };
                            obd2_message_id = 0;
                        }
                        0x30 => {
                            let timeout_ms = can_frame.data[2];
                        }
                        0x20 => {
                            if let Some(obd2_message_length) = obd2_message_length {
                                let new_obd2_message_id = can_frame.data[0] & 0x0F;
                                if new_obd2_message_id == obd2_message_id + 1 {
                                    match defmt::export::into_result(
                                        self.obd2_message_buffer
                                            .extend_from_slice(&can_frame.data[1..]),
                                    ) {
                                        ::core::result::Result::Ok(res) => res,
                                        ::core::result::Result::Err(_unwrap_err) => {
                                            match (&(_unwrap_err)) {
                                                (arg0) => {
                                                    if {
                                                        const CHECK: bool = {
                                                            const fn check() -> bool {
                                                                let module_path =
                                                                    "kia_obd2_esp32c3_v2::obd2"
                                                                        .as_bytes();
                                                                if if 19usize > module_path.len() {
                                                                    false
                                                                } else {
                                                                    module_path[0usize] == 107u8
                                                                        && module_path[1usize]
                                                                            == 105u8
                                                                        && module_path[2usize]
                                                                            == 97u8
                                                                        && module_path[3usize]
                                                                            == 95u8
                                                                        && module_path[4usize]
                                                                            == 111u8
                                                                        && module_path[5usize]
                                                                            == 98u8
                                                                        && module_path[6usize]
                                                                            == 100u8
                                                                        && module_path[7usize]
                                                                            == 50u8
                                                                        && module_path[8usize]
                                                                            == 95u8
                                                                        && module_path[9usize]
                                                                            == 101u8
                                                                        && module_path[10usize]
                                                                            == 115u8
                                                                        && module_path[11usize]
                                                                            == 112u8
                                                                        && module_path[12usize]
                                                                            == 51u8
                                                                        && module_path[13usize]
                                                                            == 50u8
                                                                        && module_path[14usize]
                                                                            == 99u8
                                                                        && module_path[15usize]
                                                                            == 51u8
                                                                        && module_path[16usize]
                                                                            == 95u8
                                                                        && module_path[17usize]
                                                                            == 118u8
                                                                        && module_path[18usize]
                                                                            == 50u8
                                                                        && if 19usize
                                                                            == module_path.len()
                                                                        {
                                                                            true
                                                                        } else {
                                                                            module_path[19usize]
                                                                                == b':'
                                                                        }
                                                                } {
                                                                    return true;
                                                                }
                                                                false
                                                            }
                                                            check()
                                                        };
                                                        CHECK
                                                    } {
                                                        unsafe {
                                                            defmt::export::acquire_and_header(&{
                                                                defmt::export::make_istr({
                                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: self.obd2_message_buffer.extend_from_slice(& can_frame.data [1 ..])'\\nerror: `{:?}`\",\"disambiguator\":\"9630670476530393451\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: self.obd2_message_buffer.extend_from_slice(& can_frame.data [1 ..])'\\nerror: `{:?}`\",\"disambiguator\":\"9630670476530393451\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                    static DEFMT_LOG_STATEMENT: u8 =
                                                                        0;
                                                                    &DEFMT_LOG_STATEMENT
                                                                        as *const u8
                                                                        as u16
                                                                })
                                                            });
                                                        };
                                                        defmt::export::fmt(arg0);
                                                        unsafe { defmt::export::release() }
                                                    }
                                                }
                                            };
                                            defmt::export::panic()
                                        }
                                    };
                                    if self.obd2_message_buffer.len() >= obd2_message_length {
                                        obd2_data = Some(self.obd2_message_buffer.as_slice());
                                        break 'outer;
                                    }
                                    obd2_message_id = new_obd2_message_id;
                                } else {
                                    match (&(new_obd2_message_id), &(obd2_message_id)) {
                                        (arg0, arg1) => {
                                            if {
                                                const CHECK: bool = {
                                                    const fn check() -> bool {
                                                        let module_path =
                                                            "kia_obd2_esp32c3_v2::obd2".as_bytes();
                                                        if if 19usize > module_path.len() {
                                                            false
                                                        } else {
                                                            module_path[0usize] == 107u8
                                                                && module_path[1usize] == 105u8
                                                                && module_path[2usize] == 97u8
                                                                && module_path[3usize] == 95u8
                                                                && module_path[4usize] == 111u8
                                                                && module_path[5usize] == 98u8
                                                                && module_path[6usize] == 100u8
                                                                && module_path[7usize] == 50u8
                                                                && module_path[8usize] == 95u8
                                                                && module_path[9usize] == 101u8
                                                                && module_path[10usize] == 115u8
                                                                && module_path[11usize] == 112u8
                                                                && module_path[12usize] == 51u8
                                                                && module_path[13usize] == 50u8
                                                                && module_path[14usize] == 99u8
                                                                && module_path[15usize] == 51u8
                                                                && module_path[16usize] == 95u8
                                                                && module_path[17usize] == 118u8
                                                                && module_path[18usize] == 50u8
                                                                && if 19usize == module_path.len() {
                                                                    true
                                                                } else {
                                                                    module_path[19usize] == b':'
                                                                }
                                                        } {
                                                            return true;
                                                        }
                                                        false
                                                    }
                                                    check()
                                                };
                                                CHECK
                                            } {
                                                unsafe {
                                                    defmt::export::acquire_and_header(&{
                                                        defmt::export::make_istr({
                                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"consecutive frame id mismatch: {} != {}\",\"disambiguator\":\"1365330456657744139\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"consecutive frame id mismatch: {} != {}\",\"disambiguator\":\"1365330456657744139\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                        })
                                                    });
                                                };
                                                defmt::export::fmt(arg0);
                                                defmt::export::fmt(arg1);
                                                unsafe { defmt::export::release() }
                                            }
                                        }
                                    };
                                }
                            } else {
                                match () {
                                    () => {
                                        if {
                                            const CHECK: bool = {
                                                const fn check() -> bool {
                                                    let module_path =
                                                        "kia_obd2_esp32c3_v2::obd2".as_bytes();
                                                    if if 19usize > module_path.len() {
                                                        false
                                                    } else {
                                                        module_path[0usize] == 107u8
                                                            && module_path[1usize] == 105u8
                                                            && module_path[2usize] == 97u8
                                                            && module_path[3usize] == 95u8
                                                            && module_path[4usize] == 111u8
                                                            && module_path[5usize] == 98u8
                                                            && module_path[6usize] == 100u8
                                                            && module_path[7usize] == 50u8
                                                            && module_path[8usize] == 95u8
                                                            && module_path[9usize] == 101u8
                                                            && module_path[10usize] == 115u8
                                                            && module_path[11usize] == 112u8
                                                            && module_path[12usize] == 51u8
                                                            && module_path[13usize] == 50u8
                                                            && module_path[14usize] == 99u8
                                                            && module_path[15usize] == 51u8
                                                            && module_path[16usize] == 95u8
                                                            && module_path[17usize] == 118u8
                                                            && module_path[18usize] == 50u8
                                                            && if 19usize == module_path.len() {
                                                                true
                                                            } else {
                                                                module_path[19usize] == b':'
                                                            }
                                                    } {
                                                        return true;
                                                    }
                                                    false
                                                }
                                                check()
                                            };
                                            CHECK
                                        } {
                                            defmt::export::acquire_header_and_release(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"no first frame\",\"disambiguator\":\"6223462268141374077\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"no first frame\",\"disambiguator\":\"6223462268141374077\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        }
                                    }
                                };
                            }
                        }
                        _ => {
                            if can_frame.data[0] == 0x03 {
                                self.obd2_message_buffer.clear();
                                self.obd2_message_buffer.extend_from_slice(&can_frame.data);
                                obd2_data = Some(self.obd2_message_buffer.as_slice());
                                break 'outer;
                            } else {
                                {
                                    use heapless::String as InternalDebugString;
                                    use core::fmt::Write as _;
                                    let mut string = InternalDebugString::new();
                                    (&mut string)
                                        .write_fmt(format_args!(
                                            "{0:.1}: ",
                                            embassy_time::Instant::from_ticks(0)
                                                .elapsed()
                                                .as_millis()
                                                as f64
                                                / 1000.0
                                        ))
                                        .ok();
                                    (&mut string)
                                        .write_fmt(format_args!(
                                            "unknown frame {0:x?}",
                                            can_frame.data
                                        ))
                                        .ok();
                                    crate::debug::debug(string);
                                };
                                match (&(obd2_frame_type), &(can_frame.data)) {
                                    (arg0, arg1) => {
                                        if {
                                            const CHECK: bool = {
                                                const fn check() -> bool {
                                                    let module_path =
                                                        "kia_obd2_esp32c3_v2::obd2".as_bytes();
                                                    if if 19usize > module_path.len() {
                                                        false
                                                    } else {
                                                        module_path[0usize] == 107u8
                                                            && module_path[1usize] == 105u8
                                                            && module_path[2usize] == 97u8
                                                            && module_path[3usize] == 95u8
                                                            && module_path[4usize] == 111u8
                                                            && module_path[5usize] == 98u8
                                                            && module_path[6usize] == 100u8
                                                            && module_path[7usize] == 50u8
                                                            && module_path[8usize] == 95u8
                                                            && module_path[9usize] == 101u8
                                                            && module_path[10usize] == 115u8
                                                            && module_path[11usize] == 112u8
                                                            && module_path[12usize] == 51u8
                                                            && module_path[13usize] == 50u8
                                                            && module_path[14usize] == 99u8
                                                            && module_path[15usize] == 51u8
                                                            && module_path[16usize] == 95u8
                                                            && module_path[17usize] == 118u8
                                                            && module_path[18usize] == 50u8
                                                            && if 19usize == module_path.len() {
                                                                true
                                                            } else {
                                                                module_path[19usize] == b':'
                                                            }
                                                    } {
                                                        return true;
                                                    }
                                                    false
                                                }
                                                check()
                                            };
                                            CHECK
                                        } {
                                            unsafe {
                                                defmt::export::acquire_and_header(&{
                                                    defmt::export::make_istr({
                                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"unknown frame: {} {=[u8]:#04x}\",\"disambiguator\":\"14487642130238863980\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"unknown frame: {} {=[u8]:#04x}\",\"disambiguator\":\"14487642130238863980\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                    })
                                                });
                                            };
                                            defmt::export::fmt(arg0);
                                            defmt::export::slice(arg1);
                                            unsafe { defmt::export::release() }
                                        }
                                    }
                                };
                            }
                        }
                    }
                }
                while embassy_time::with_timeout(
                    embassy_time::Duration::from_millis(50),
                    self.mcp2515.interrupt(),
                )
                .await
                .is_err()
                {
                    if _lock.is_some() {
                        _lock = None;
                    }
                }
            }
            if let Some(obd2_data) = obd2_data {
                Ok(obd2_data)
            } else {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::obd2".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"no obd2_data found\",\"disambiguator\":\"18072421628920208780\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"no obd2_data found\",\"disambiguator\":\"18072421628920208780\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                Err(Obd2Error::DataNotFound)
            }
        }
        pub async fn request_pid<PID: Pid>(
            &mut self,
        ) -> Result<(PID, alloc::vec::Vec<u8>), Obd2Error> {
            let request = PID::request();
            let obd2_data = self.request(&request).await?;
            let pid = PID::parse(&obd2_data)?;
            Ok((
                pid,
                if obd2_debug_pids_enabled() {
                    obd2_data.to_vec()
                } else {
                    alloc::vec::Vec::new()
                },
            ))
        }
        pub async fn reset(&mut self) {
            self.init().await.ok();
        }
        pub async fn handle_pid<PID: Pid + core::any::Any>(&mut self) -> bool {
            if !self.obd2_pid_errors.is_empty()
                && self.obd2_pid_errors.iter().all(|(_, errors)| *errors >= 10)
            {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::obd2".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"too many errors, clearing errors\",\"disambiguator\":\"8984042548070022869\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"too many errors, clearing errors\",\"disambiguator\":\"8984042548070022869\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                self.init().await.ok();
                self.obd2_pid_errors.clear();
            }
            let type_id = TypeId::of::<PID>();
            if let Some(period) = PID::period() {
                if !self.obd2_pid_periods_disable {
                    if let Some(last_time) = self.obd2_pid_periods.get(&type_id).map(|time| *time) {
                        if Instant::now() - last_time < period {
                            return true;
                        }
                    }
                    self.obd2_pid_periods.insert(type_id, Instant::now()).ok();
                }
            }
            let mut errors = self
                .obd2_pid_errors
                .get(&type_id)
                .map(|errors| *errors)
                .unwrap_or(0);
            let obd2_debug_pids_enabled = obd2_debug_pids_enabled();
            let mut ret = false;
            if errors < 10 {
                match with_timeout(Duration::from_millis(350), self.request_pid::<PID>()).await {
                    Ok(Ok((pid_result, buffer))) => {
                        let pid_result = pid_result.into_event();
                        insert_send_pid(&pid_result).await;
                        let event = KiaEvent::Obd2Event(pid_result);
                        KIA_EVENTS.send(event.clone()).timeout_millis(10).await.ok();
                        if obd2_debug_pids_enabled {
                            KIA_EVENTS
                                .try_send(KiaEvent::Obd2Debug(Obd2Debug::new::<PID>(Some(buffer))))
                                .ok();
                        }
                        embassy_time::Timer::after(embassy_time::Duration::from_millis(25)).await;
                        errors = 0;
                        ret = true;
                    }
                    Ok(Err(_e)) => {
                        insert_send_pid_error(&PID::into_error())
                            .timeout_millis(10)
                            .await
                            .ok();
                        match () {
                            () => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::obd2".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    defmt::export::acquire_header_and_release(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"error requesting pid\",\"disambiguator\":\"8857683989373359404\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"error requesting pid\",\"disambiguator\":\"8857683989373359404\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                }
                            }
                        };
                        {
                            use heapless::String as InternalDebugString;
                            use core::fmt::Write as _;
                            let mut string = InternalDebugString::new();
                            (&mut string)
                                .write_fmt(format_args!(
                                    "{0:.1}: ",
                                    embassy_time::Instant::from_ticks(0).elapsed().as_millis()
                                        as f64
                                        / 1000.0
                                ))
                                .ok();
                            (&mut string)
                                .write_fmt(format_args!("error requesting pid"))
                                .ok();
                            crate::debug::debug(string);
                        };
                        if obd2_debug_pids_enabled {
                            KIA_EVENTS
                                .try_send(KiaEvent::Obd2Debug(Obd2Debug::new::<PID>(None)))
                                .ok();
                        }
                        errors += 1;
                    }
                    Err(_) => {
                        insert_send_pid_error(&PID::into_error()).await;
                        match (&(core::any::type_name::<PID>())) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::obd2".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"timeout requesting pid: {}\",\"disambiguator\":\"7715305738365108234\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"timeout requesting pid: {}\",\"disambiguator\":\"7715305738365108234\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        {
                            use heapless::String as InternalDebugString;
                            use core::fmt::Write as _;
                            let mut string = InternalDebugString::new();
                            (&mut string)
                                .write_fmt(format_args!(
                                    "{0:.1}: ",
                                    embassy_time::Instant::from_ticks(0).elapsed().as_millis()
                                        as f64
                                        / 1000.0
                                ))
                                .ok();
                            (&mut string)
                                .write_fmt(format_args!("timeout requesting pid"))
                                .ok();
                            crate::debug::debug(string);
                        };
                        if obd2_debug_pids_enabled {
                            KIA_EVENTS
                                .try_send(KiaEvent::Obd2Debug(Obd2Debug::new::<PID>(None)))
                                .ok();
                        }
                        errors += 1;
                    }
                }
            } else {
                ret = true;
                if obd2_debug_pids_enabled {
                    KIA_EVENTS
                        .try_send(KiaEvent::Obd2Debug(Obd2Debug::new::<PID>(None)))
                        .ok();
                }
                let last_time = self
                    .obd2_pid_errors_periods
                    .get(&type_id)
                    .map(|time| *time)
                    .unwrap_or(Instant::from_millis(0));
                if last_time.elapsed() > Duration::from_secs(5 * 60) {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "kia_obd2_esp32c3_v2::obd2".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"last error was more then 5*60s ago, clearing errors\",\"disambiguator\":\"5556298432600062966\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"last error was more then 5*60s ago, clearing errors\",\"disambiguator\":\"5556298432600062966\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    errors = 0;
                }
                self.obd2_pid_errors_periods
                    .insert(type_id, Instant::now())
                    .ok();
            }
            self.obd2_pid_errors.insert(type_id, errors).ok();
            return ret;
        }
        pub fn clear_pids_cache(&mut self) {
            self.obd2_pid_errors.clear();
            self.obd2_pid_errors_periods.clear();
            self.obd2_pid_periods.clear();
        }
        pub async fn send_custom_frame(
            &mut self,
            frame: Obd2Frame,
        ) -> Result<Obd2Frame, Obd2Error> {
            let can_id = match defmt::export::into_result(StandardId::new(frame.pid)) {
                ::core::result::Result::Ok(res) => res,
                ::core::result::Result::Err(_unwrap_err) => {
                    match (&(_unwrap_err)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "kia_obd2_esp32c3_v2::obd2".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(frame.pid)'\\nerror: `{:?}`\",\"disambiguator\":\"11504900067804707640\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(frame.pid)'\\nerror: `{:?}`\",\"disambiguator\":\"11504900067804707640\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    defmt::export::panic()
                }
            };
            let can_frame = match defmt::export::into_result(CanFrame::new(can_id, &frame.data)) {
                ::core::result::Result::Ok(res) => res,
                ::core::result::Result::Err(_unwrap_err) => {
                    match (&(_unwrap_err)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "kia_obd2_esp32c3_v2::obd2".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & frame.data)'\\nerror: `{:?}`\",\"disambiguator\":\"4259117880405959217\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & frame.data)'\\nerror: `{:?}`\",\"disambiguator\":\"4259117880405959217\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    defmt::export::panic()
                }
            };
            let response = self.request(&can_frame).await?;
            Ok(Obd2Frame {
                pid: frame.pid,
                data: response.to_vec(),
            })
        }
    }
    pub trait Pid {
        fn request() -> CanFrame;
        fn parse(data: &[u8]) -> Result<Self, Obd2Error>
        where
            Self: Sized;
        fn into_event(self) -> Obd2Event;
        fn into_error() -> types::PidError;
        fn period() -> Option<Duration> {
            None
        }
    }
}
mod pid {
    mod ac {
        use defmt::*;
        use embassy_time::Duration;
        use embedded_can::{Frame as _, StandardId};
        pub use types::AcPid;
        use crate::{
            debug::internal_debug,
            event::Obd2Event,
            mcp2515::CanFrame,
            obd2::{Obd2Error, Pid},
        };
        impl Pid for AcPid {
            fn request() -> CanFrame {
                let can_id = match defmt::export::into_result(StandardId::new(0x7b3)) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::ac".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7b3)'\\nerror: `{:?}`\",\"disambiguator\":\"5165213935922403484\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7b3)'\\nerror: `{:?}`\",\"disambiguator\":\"5165213935922403484\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(CanFrame::new(
                    can_id,
                    &[0x03, 0x22, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00],
                )) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::ac".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x03, 0x22, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"2319049120111843356\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x03, 0x22, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"2319049120111843356\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                }
            }
            fn parse(data: &[u8]) -> Result<Self, Obd2Error> {
                if data.len() < 36 {
                    return Err(Obd2Error::FrameToShort);
                }
                let vehicle_front_temp = (data[8] as f32 / 255.0) * (87.5 + 40.0) - 40.0;
                let surround_temp = (data[9] as f32 / 255.0) * (87.5 + 40.0) - 40.0;
                let evaporator_temp = (data[10] as f32 / 255.0) * (87.5 + 40.0) - 40.0;
                let driver_mixing_air = (data[12] as f32 / 255.0) * 100.0;
                let passenger_air_direction = (data[13] as f32 / 255.0) * 100.0;
                let passenger_mixing_air = (data[15] as f32 / 255.0) * 100.0;
                let air_direction = (data[16] as f32 / 255.0) * 100.0;
                let input = (data[18] as f32 / 255.0) * 100.0;
                let humidity = data[28];
                let defrost_open = (data[29] as f32 / 255.0) * 100.0;
                let driver_vent_temp = (data[30] as f32 / 255.0) * (87.5 + 40.0) - 40.0;
                let driver_floor_temp = (data[31] as f32 / 255.0) * (87.5 + 40.0) - 40.0;
                let speed = data[32];
                let ice_cooling_temp = (data[33] as f32 / 255.0) * (143.25 + 48.0) - 48.0;
                let compressor_on = data[35] != 0;
                let ret = Self {
                    vehicle_front_temp,
                    surround_temp,
                    evaporator_temp,
                    driver_mixing_air,
                    passenger_air_direction,
                    passenger_mixing_air,
                    air_direction,
                    input,
                    humidity,
                    defrost_open,
                    driver_vent_temp,
                    driver_floor_temp,
                    speed,
                    ice_cooling_temp,
                    compressor_on,
                };
                match (&(ret)) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::pid::ac".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe {
                                defmt::export::acquire_and_header(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"AC PID ret: {:?}\",\"disambiguator\":\"5415215118373359774\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"AC PID ret: {:?}\",\"disambiguator\":\"5415215118373359774\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            };
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                Ok(ret)
            }
            fn into_error() -> types::PidError {
                types::PidError::AcPid
            }
            fn into_event(self) -> Obd2Event {
                Obd2Event::AcPid(self)
            }
            fn period() -> Option<Duration> {
                Some(Duration::from_secs(10))
            }
        }
    }
    mod bms {
        use defmt::*;
        use embedded_can::{Frame as _, StandardId};
        pub use types::BmsPid;
        use crate::{
            event::Obd2Event,
            mcp2515::CanFrame,
            obd2::{Obd2Error, Pid},
        };
        impl Pid for BmsPid {
            fn request() -> CanFrame {
                let can_id = match defmt::export::into_result(StandardId::new(0x7e4)) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::bms".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7e4)'\\nerror: `{:?}`\",\"disambiguator\":\"18297297718372876043\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7e4)'\\nerror: `{:?}`\",\"disambiguator\":\"18297297718372876043\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(CanFrame::new(
                    can_id,
                    &[0x02, 0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00],
                )) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::bms".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x02, 0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"16106311333401726568\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x02, 0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"16106311333401726568\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                }
            }
            fn parse(data: &[u8]) -> Result<Self, Obd2Error> {
                if data.len() < 60 {
                    return Err(Obd2Error::FrameToShort);
                }
                let hv_max_temp = data[16] as i8 as f32;
                let hv_min_temp = data[17] as i8 as f32;
                let hv_dc_voltage = (((data[14] as u32) << 8) as f32 + data[15] as f32) / 10.0;
                let hv_soc = data[6] as f32 / 2.0;
                let hv_cell_voltage_deviation = data[22] as f32 / 50.0;
                let aux_dc_voltage = data[31] as f32 * 0.1;
                let hv_battery_current =
                    (data[12] as i8 as i32 * 256 + data[13] as i32) as f32 / 10.0;
                let hv_min_cell_voltage = (data[27] as f32) / 50.0;
                let hv_max_cell_voltage = (data[25] as f32) / 50.0;
                let motor_electric_rpm = (data[55] as i32 * 256) as f32 + data[56] as f32;
                Ok(Self {
                    hv_max_temp,
                    hv_min_temp,
                    hv_dc_voltage,
                    hv_soc,
                    hv_cell_voltage_deviation,
                    hv_min_cell_voltage,
                    hv_max_cell_voltage,
                    hv_battery_current,
                    aux_dc_voltage,
                    motor_electric_rpm,
                })
            }
            fn into_error() -> types::PidError {
                types::PidError::BmsPid
            }
            fn into_event(self) -> Obd2Event {
                Obd2Event::BmsPid(self)
            }
        }
    }
    mod hybrid_dc_dc {
        use defmt::*;
        use embedded_can::{Frame as _, StandardId};
        pub use types::HybridDcDcPid;
        use crate::{
            event::Obd2Event,
            mcp2515::CanFrame,
            obd2::{Obd2Error, Pid},
        };
        impl Pid for HybridDcDcPid {
            fn request() -> CanFrame {
                let can_id = match defmt::export::into_result(StandardId::new(0x7e2)) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::hybrid_dc_dc".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7e2)'\\nerror: `{:?}`\",\"disambiguator\":\"7617876223624748974\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7e2)'\\nerror: `{:?}`\",\"disambiguator\":\"7617876223624748974\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(CanFrame::new(
                    can_id,
                    &[0x02, 0x21, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00],
                )) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::hybrid_dc_dc".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x02, 0x21, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"10043351035804417569\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x02, 0x21, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"10043351035804417569\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                }
            }
            fn parse(data: &[u8]) -> Result<Self, Obd2Error> {
                if data.len() < 7 {
                    return Err(Obd2Error::FrameToShort);
                }
                Ok(Self {
                    gear: data[2] as i32,
                })
            }
            fn into_error() -> types::PidError {
                types::PidError::HybridDcDcPid
            }
            fn into_event(self) -> Obd2Event {
                Obd2Event::HybridDcDcPid(self)
            }
        }
    }
    mod ice_engine {
        use defmt::*;
        use embedded_can::{Frame as _, StandardId};
        pub use types::IceEnginePid;
        use crate::{
            event::Obd2Event,
            mcp2515::CanFrame,
            obd2::{Obd2Error, Pid},
        };
        impl Pid for IceEnginePid {
            fn request() -> CanFrame {
                let can_id = match defmt::export::into_result(StandardId::new(0x7e0)) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::ice_engine".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7e0)'\\nerror: `{:?}`\",\"disambiguator\":\"9402139081728497742\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7e0)'\\nerror: `{:?}`\",\"disambiguator\":\"9402139081728497742\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(CanFrame::new(
                    can_id,
                    &[0x03, 0x22, 0xe0, 0x01, 0x00, 0x00, 0x00, 0x00],
                )) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::ice_engine".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x03, 0x22, 0xe0, 0x01, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"5110344149783963926\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x03, 0x22, 0xe0, 0x01, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"5110344149783963926\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                }
            }
            fn parse(data: &[u8]) -> Result<Self, Obd2Error> {
                if data.len() < 7 {
                    return Err(Obd2Error::FrameToShort);
                }
                Ok(Self {
                    gear: data[2] as i32,
                })
            }
            fn into_error() -> types::PidError {
                types::PidError::IceEnginePid
            }
            fn into_event(self) -> Obd2Event {
                Obd2Event::IceEnginePid(self)
            }
        }
    }
    mod ice_fuel_rate {
        use defmt::*;
        use embedded_can::{Frame as _, StandardId};
        pub use types::IceFuelRatePid;
        use crate::{
            event::Obd2Event,
            mcp2515::CanFrame,
            obd2::{Obd2Error, Pid},
        };
        impl Pid for IceFuelRatePid {
            fn request() -> CanFrame {
                let can_id = match defmt::export::into_result(StandardId::new(0x7df)) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::ice_fuel_rate"
                                                    .as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7df)'\\nerror: `{:?}`\",\"disambiguator\":\"17629199890977438364\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7df)'\\nerror: `{:?}`\",\"disambiguator\":\"17629199890977438364\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(CanFrame::new(
                    can_id,
                    &[0x02, 0x01, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x00],
                )) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::ice_fuel_rate"
                                                    .as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x02, 0x01, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"15307255269928076984\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x02, 0x01, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"15307255269928076984\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                }
            }
            fn parse(data: &[u8]) -> Result<Self, Obd2Error> {
                if data.len() < 7 {
                    return Err(Obd2Error::FrameToShort);
                }
                Ok(Self {
                    fuel_rate: (data[3] as i32 * 256 + data[4] as i32) as f32 / 20.0,
                })
            }
            fn into_error() -> types::PidError {
                types::PidError::IceFuelRatePid
            }
            fn into_event(self) -> Obd2Event {
                Obd2Event::IceFuelRatePid(self)
            }
        }
    }
    mod ice_temperature {
        use defmt::*;
        use embassy_time::Duration;
        use embedded_can::{Frame as _, StandardId};
        pub use types::IceTemperaturePid;
        use crate::{
            event::Obd2Event,
            mcp2515::CanFrame,
            obd2::{Obd2Error, Pid},
        };
        impl Pid for IceTemperaturePid {
            fn request() -> CanFrame {
                let can_id = match defmt::export::into_result(StandardId::new(0x7df)) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::ice_temperature"
                                                    .as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7df)'\\nerror: `{:?}`\",\"disambiguator\":\"1064257711983481605\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7df)'\\nerror: `{:?}`\",\"disambiguator\":\"1064257711983481605\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(CanFrame::new(
                    can_id,
                    &[0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00],
                )) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::ice_temperature"
                                                    .as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"7097406078060929532\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"7097406078060929532\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                }
            }
            fn parse(data: &[u8]) -> Result<Self, Obd2Error> {
                if data.len() < 7 {
                    return Err(Obd2Error::FrameToShort);
                }
                Ok(Self {
                    temperature: (data[3] as i8 - 40) as f32,
                })
            }
            fn into_error() -> types::PidError {
                types::PidError::IceTemperaturePid
            }
            fn into_event(self) -> Obd2Event {
                Obd2Event::IceTemperaturePid(self)
            }
            fn period() -> Option<Duration> {
                Some(Duration::from_secs(1))
            }
        }
    }
    mod icu {
        use defmt::*;
        use embedded_can::{Frame as _, StandardId};
        pub use types::IcuPid;
        use crate::{
            event::Obd2Event,
            mcp2515::CanFrame,
            obd2::{Obd2Error, Pid},
        };
        impl Pid for IcuPid {
            fn request() -> CanFrame {
                let can_id = match defmt::export::into_result(StandardId::new(0x770)) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::icu".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x770)'\\nerror: `{:?}`\",\"disambiguator\":\"15522893408637988816\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x770)'\\nerror: `{:?}`\",\"disambiguator\":\"15522893408637988816\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(CanFrame::new(
                    can_id,
                    &[0x03, 0x22, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00],
                )) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::icu".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x03, 0x22, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"6887440798351603514\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x03, 0x22, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"6887440798351603514\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                }
            }
            fn parse(data: &[u8]) -> Result<Self, Obd2Error> {
                if data.len() < 18 {
                    return Err(Obd2Error::FrameToShort);
                }
                let bat_discharge_warning_first_event_milage =
                    data[7] as f32 * 6553.6 + data[8] as f32 * 25.55 + data[9] as f32 * 0.1;
                let bat_discharge_warning_first_event_soc = data[10];
                let bat_discharge_warning_final_event_milage =
                    data[11] as f32 * 6553.6 + data[12] as f32 * 25.55 + data[13] as f32 * 0.1;
                let bat_discharge_warning_final_event_soc = data[14];
                let ret = Self {
                    bat_discharge_warning_first_event_milage,
                    bat_discharge_warning_first_event_soc,
                    bat_discharge_warning_final_event_milage,
                    bat_discharge_warning_final_event_soc,
                };
                Ok(ret)
            }
            fn into_error() -> types::PidError {
                types::PidError::IcuPid
            }
            fn into_event(self) -> Obd2Event {
                Obd2Event::IcuPid(self)
            }
            fn period() -> Option<embassy_time::Duration> {
                Some(embassy_time::Duration::from_secs(1))
            }
        }
    }
    mod icu2 {
        use defmt::*;
        use embedded_can::{Frame as _, StandardId};
        pub use types::Icu2Pid;
        use crate::{
            event::Obd2Event,
            mcp2515::CanFrame,
            obd2::{Obd2Error, Pid},
        };
        impl Pid for Icu2Pid {
            fn request() -> CanFrame {
                let can_id = match defmt::export::into_result(StandardId::new(0x770)) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::icu2".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x770)'\\nerror: `{:?}`\",\"disambiguator\":\"9733355351956469354\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x770)'\\nerror: `{:?}`\",\"disambiguator\":\"9733355351956469354\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(CanFrame::new(
                    can_id,
                    &[0x03, 0x22, 0xbc, 0x03, 0x00, 0x00, 0x00, 0x00],
                )) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::icu2".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x03, 0x22, 0xbc, 0x03, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"12846500936418954419\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x03, 0x22, 0xbc, 0x03, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"12846500936418954419\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                }
            }
            fn parse(data: &[u8]) -> Result<Self, Obd2Error> {
                if data.len() < 12 {
                    return Err(Obd2Error::FrameToShort);
                }
                let back_door_driver_side_open = data[7] & 0b00000001 != 0;
                let actuator_back_door_driver_side_unlock = data[7] & 0b00000010 != 0;
                let back_door_passenger_side_open = data[7] & 0b00000100 != 0;
                let actuator_back_door_passenger_side_unlock = data[7] & 0b00001000 != 0;
                let front_door_passenger_side_open = data[7] & 0b00010000 != 0;
                let front_door_driver_side_open = data[7] & 0b00100000 != 0;
                let trunk_open = data[7] & 0b10000000 != 0;
                let engine_hood_open = data[8] & 0b00000001 != 0;
                let driver_buckled = data[8] & 0b00000010 != 0;
                let passenger_buckled = data[8] & 0b00000100 != 0;
                let breaking_fluid = data[8] & 0b00010000 != 0;
                let ignition_1_on = data[8] & 0b00100000 != 0;
                let ignition_2_on = data[8] & 0b01000000 != 0;
                let signal_back_av = data[9] & 0b00000100 != 0;
                let ret = Self {
                    back_door_driver_side_open,
                    actuator_back_door_driver_side_unlock,
                    back_door_passenger_side_open,
                    actuator_back_door_passenger_side_unlock,
                    front_door_passenger_side_open,
                    front_door_driver_side_open,
                    trunk_open,
                    engine_hood_open,
                    driver_buckled,
                    passenger_buckled,
                    breaking_fluid,
                    ignition_1_on,
                    ignition_2_on,
                    signal_back_av,
                };
                Ok(ret)
            }
            fn into_error() -> types::PidError {
                types::PidError::Icu2Pid
            }
            fn into_event(self) -> Obd2Event {
                Obd2Event::Icu2Pid(self)
            }
            fn period() -> Option<embassy_time::Duration> {
                Some(embassy_time::Duration::from_secs(1))
            }
        }
    }
    mod icu3 {
        use defmt::*;
        use embedded_can::{Frame as _, StandardId};
        pub use types::Icu3Pid;
        use crate::{
            event::Obd2Event,
            mcp2515::CanFrame,
            obd2::{Obd2Error, Pid},
        };
        impl Pid for Icu3Pid {
            fn request() -> CanFrame {
                let can_id = match defmt::export::into_result(StandardId::new(0x770)) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::icu3".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x770)'\\nerror: `{:?}`\",\"disambiguator\":\"8890697530336251487\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x770)'\\nerror: `{:?}`\",\"disambiguator\":\"8890697530336251487\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(CanFrame::new(
                    can_id,
                    &[0x03, 0x22, 0xbc, 0x10, 0x00, 0x00, 0x00, 0x00],
                )) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::icu3".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x03, 0x22, 0xbc, 0x10, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"17315402661146502468\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x03, 0x22, 0xbc, 0x10, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"17315402661146502468\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                }
            }
            fn parse(data: &[u8]) -> Result<Self, Obd2Error> {
                if data.len() < 12 {
                    return Err(Obd2Error::FrameToShort);
                }
                let on_board_charger_wakeup_output = data[8] & 0b00010000 != 0;
                let ret = Self {
                    on_board_charger_wakeup_output,
                };
                Ok(ret)
            }
            fn into_error() -> types::PidError {
                types::PidError::Icu3Pid
            }
            fn into_event(self) -> Obd2Event {
                Obd2Event::Icu3Pid(self)
            }
            fn period() -> Option<embassy_time::Duration> {
                Some(embassy_time::Duration::from_secs(1))
            }
        }
    }
    mod icu_smk_1 {
        use defmt::*;
        use embedded_can::{Frame as _, StandardId};
        pub use types::Icu1Smk;
        use crate::{
            event::Obd2Event,
            mcp2515::CanFrame,
            obd2::{Obd2Error, Pid},
        };
        impl Pid for Icu1Smk {
            fn request() -> CanFrame {
                let can_id = match defmt::export::into_result(StandardId::new(0x7a0)) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::icu_smk_1".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7a0)'\\nerror: `{:?}`\",\"disambiguator\":\"8958866878500258524\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7a0)'\\nerror: `{:?}`\",\"disambiguator\":\"8958866878500258524\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(CanFrame::new(
                    can_id,
                    &[0x03, 0x22, 0xd0, 0x06, 0x00, 0x00, 0x00, 0x00],
                )) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::icu_smk_1".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x03, 0x22, 0xd0, 0x06, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"7591555244259822033\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x03, 0x22, 0xd0, 0x06, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"7591555244259822033\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                }
            }
            fn parse(data: &[u8]) -> Result<Self, Obd2Error> {
                if data.len() < 26 {
                    return Err(Obd2Error::FrameToShort);
                }
                fn u8_to_voltage(v: u8) -> f32 {
                    v as f32 * 0.08
                }
                let aux_battery_voltage_power_load = u8_to_voltage(data[7]);
                let aux_battery_voltage_signal_cpu = u8_to_voltage(data[8]);
                let ground_voltage_power = u8_to_voltage(data[9]);
                let ground_voltage_ecu = u8_to_voltage(data[10]);
                let ign1_voltage = u8_to_voltage(data[11]);
                let ign2_voltage = u8_to_voltage(data[12]);
                let acc_voltage = u8_to_voltage(data[13]);
                let engine_rpm = data[15] as u16 * 32;
                let vehicle_speed = data[16];
                let ret = Self {
                    aux_battery_voltage_power_load,
                    aux_battery_voltage_signal_cpu,
                    ground_voltage_power,
                    ground_voltage_ecu,
                    ign1_voltage,
                    ign2_voltage,
                    acc_voltage,
                    engine_rpm,
                    vehicle_speed,
                };
                Ok(ret)
            }
            fn into_error() -> types::PidError {
                types::PidError::Icu1Smk
            }
            fn into_event(self) -> Obd2Event {
                Obd2Event::Icu1Smk(self)
            }
            fn period() -> Option<embassy_time::Duration> {
                Some(embassy_time::Duration::from_secs(1))
            }
        }
    }
    mod on_board_charger {
        use defmt::*;
        use embassy_time::Duration;
        use embedded_can::{Frame as _, StandardId};
        pub use types::OnBoardChargerPid;
        use crate::{
            event::{Obd2Error as PidError, Obd2Event},
            mcp2515::CanFrame,
            obd2::{Obd2Error, Pid},
        };
        impl Pid for OnBoardChargerPid {
            fn request() -> CanFrame {
                let can_id = match defmt::export::into_result(StandardId::new(0x7e5)) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::on_board_charger"
                                                    .as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7e5)'\\nerror: `{:?}`\",\"disambiguator\":\"7816795579291421882\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7e5)'\\nerror: `{:?}`\",\"disambiguator\":\"7816795579291421882\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(CanFrame::new(
                    can_id,
                    &[0x02, 0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00],
                )) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::on_board_charger"
                                                    .as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x02, 0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"10791894812256505055\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x02, 0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"10791894812256505055\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                }
            }
            fn parse(data: &[u8]) -> Result<Self, Obd2Error> {
                if data.len() < 54 {
                    return Err(Obd2Error::FrameToShort);
                }
                let ac_input_voltage_instant = data[6] as f32 * 2.56 + data[7] as f32 / 100.0;
                let ac_input_voltage_rms = data[8] as f32 * 2.56 + data[9] as f32 / 100.0;
                let pfc_output_voltage = data[10] as f32 * 25.6 + data[11] as f32 / 10.0;
                let obc_output_voltage = data[12] as f32 * 25.6 + data[13] as f32 / 10.0;
                let ac_input_current = data[14] as f32 * 2.56 + data[15] as f32 / 100.0;
                let obc_output_current = data[16] as f32 * 2.56 + data[17] as f32 / 100.0;
                let ac_input_frequency = data[18];
                let obc_temperature_a = data[19] as i8 - 100;
                let cp_voltage = data[21] as f32 * 2.56 + data[22] as f32 / 100.0;
                let cp_duty = data[23] as f32 * 25.6 + data[24] as f32 / 10.0;
                let cp_frequency = data[25] as f32 * 25.6 + data[26] as f32 / 10.0;
                let pd_voltage = data[27] as f32 * 2.56 + data[28] as f32 / 100.0;
                let interlock_voltage = data[29] as f32 * 2.56 + data[30] as f32 / 100.0;
                let aux_dc_voltage = data[31] as f32 * 2.56 + data[32] as f32 / 100.0;
                let ig3_voltage = data[33] as f32 * 2.56 + data[34] as f32 / 100.0;
                let pfc1_current_sensor_offset = data[51] as f32 - data[36] as f32 / 100.0;
                let ret = Self {
                    ac_input_voltage_instant,
                    ac_input_voltage_rms,
                    pfc_output_voltage,
                    obc_output_voltage,
                    ac_input_current,
                    obc_output_current,
                    ac_input_frequency,
                    obc_temperature_a,
                    cp_voltage,
                    cp_duty,
                    cp_frequency,
                    pd_voltage,
                    interlock_voltage,
                    aux_dc_voltage,
                    ig3_voltage,
                    pfc1_current_sensor_offset,
                };
                Ok(ret)
            }
            fn into_event(self) -> Obd2Event {
                Obd2Event::OnBoardChargerPid(self)
            }
            fn into_error() -> types::PidError {
                types::PidError::OnBoardChargerPid
            }
            fn period() -> Option<Duration> {
                Some(Duration::from_secs(1))
            }
        }
    }
    mod transaxle {
        use defmt::*;
        use embedded_can::{Frame as _, StandardId};
        pub use types::{Gear, TransaxlePid};
        use crate::{
            debug::internal_debug,
            event::Obd2Event,
            mcp2515::CanFrame,
            obd2::{Obd2Error, Pid},
        };
        impl Pid for TransaxlePid {
            fn request() -> CanFrame {
                let can_id = match defmt::export::into_result(StandardId::new(0x7e1)) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::transaxle".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7e1)'\\nerror: `{:?}`\",\"disambiguator\":\"15646412349864576574\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7e1)'\\nerror: `{:?}`\",\"disambiguator\":\"15646412349864576574\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(CanFrame::new(
                    can_id,
                    &[0x03, 0x22, 0x01, 0xa4, 0x00, 0x00, 0x00, 0x00],
                )) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::transaxle".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x03, 0x22, 0x01, 0xa4, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"5091049641955214321\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x03, 0x22, 0x01, 0xa4, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"5091049641955214321\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                }
            }
            fn parse(data: &[u8]) -> Result<Self, Obd2Error> {
                if data.len() < 17 {
                    return Err(Obd2Error::FrameToShort);
                }
                let gear_byte = data[16];
                let gear = match gear_byte {
                    04 => Gear::PN,
                    69 => Gear::R,
                    68 => Gear::D1,
                    39 => Gear::D2,
                    24 => Gear::D3,
                    16 => Gear::D4,
                    12 => Gear::D5,
                    09 => Gear::D6,
                    _ => {
                        {
                            use heapless::String as InternalDebugString;
                            use core::fmt::Write as _;
                            let mut string = InternalDebugString::new();
                            (&mut string)
                                .write_fmt(format_args!(
                                    "{0:.1}: ",
                                    embassy_time::Instant::from_ticks(0).elapsed().as_millis()
                                        as f64
                                        / 1000.0
                                ))
                                .ok();
                            (&mut string)
                                .write_fmt(format_args!("unknown gear byte: {0}", gear_byte))
                                .ok();
                            crate::debug::debug(string);
                        };
                        match (&(gear_byte)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::transaxle".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"unknown gear byte: {}\",\"disambiguator\":\"12907543822868316047\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"unknown gear byte: {}\",\"disambiguator\":\"12907543822868316047\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        Gear::U
                    }
                };
                Ok(Self { gear })
            }
            fn into_error() -> types::PidError {
                types::PidError::TransaxlePid
            }
            fn into_event(self) -> Obd2Event {
                Obd2Event::TransaxlePid(self)
            }
        }
    }
    mod vehicle_speed {
        use defmt::*;
        use embedded_can::{Frame as _, StandardId};
        pub use types::VehicleSpeedPid;
        use crate::{
            event::Obd2Event,
            mcp2515::CanFrame,
            obd2::{Obd2Error, Pid},
        };
        impl Pid for VehicleSpeedPid {
            fn request() -> CanFrame {
                let can_id = match defmt::export::into_result(StandardId::new(0x7df)) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::vehicle_speed"
                                                    .as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7df)'\\nerror: `{:?}`\",\"disambiguator\":\"10022239155778406656\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: StandardId :: new(0x7df)'\\nerror: `{:?}`\",\"disambiguator\":\"10022239155778406656\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(CanFrame::new(
                    can_id,
                    &[0x02, 0x01, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00],
                )) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::pid::vehicle_speed"
                                                    .as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x02, 0x01, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"14881259396321463598\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: CanFrame :: new(can_id, & [0x02, 0x01, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00])'\\nerror: `{:?}`\",\"disambiguator\":\"14881259396321463598\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                }
            }
            fn parse(data: &[u8]) -> Result<Self, Obd2Error> {
                if data.len() < 7 {
                    return Err(Obd2Error::FrameToShort);
                }
                Ok(Self {
                    vehicle_speed: data[3],
                })
            }
            fn into_error() -> types::PidError {
                types::PidError::VehicleSpeedPid
            }
            fn into_event(self) -> Obd2Event {
                Obd2Event::VehicleSpeedPid(self)
            }
        }
    }
    pub use ac::AcPid;
    pub use bms::BmsPid;
    pub use hybrid_dc_dc::HybridDcDcPid;
    pub use ice_engine::IceEnginePid;
    pub use ice_fuel_rate::IceFuelRatePid;
    pub use ice_temperature::IceTemperaturePid;
    pub use icu::IcuPid;
    pub use icu2::Icu2Pid;
    pub use icu3::Icu3Pid;
    pub use icu_smk_1::Icu1Smk;
    pub use on_board_charger::OnBoardChargerPid;
    pub use transaxle::TransaxlePid;
    pub use vehicle_speed::VehicleSpeedPid;
}
mod power {
    use defmt::*;
    use embassy_time::Duration;
    use embedded_hal::delay::DelayNs;
    use esp_hal::{
        delay::Delay,
        gpio::{self, InputPin, Pin, RtcPin, RtcPinWithResistors},
        rtc_cntl::sleep::{Ext1WakeupSource, TimerWakeupSource, WakeupLevel},
    };
    use crate::{
        debug::internal_debug,
        types::{IngGpio, Rs, Rtc},
    };
    pub struct Power {
        ing_gpio: IngGpio,
        rs_gpio: Rs,
        delay: Delay,
        rtc: Rtc,
    }
    pub enum Ignition {
        On,
        Off,
    }
    impl Power {
        pub fn new(ing_gpio: IngGpio, delay: Delay, rtc: Rtc, rs_gpio: Rs) -> Self {
            Self {
                ing_gpio,
                delay,
                rtc,
                rs_gpio,
            }
        }
        pub fn deep_sleep(&mut self, duration: Duration) {
            if esp_hal::debugger::debugger_connected() {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::power".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"debugger connected, not going to deep sleep\",\"disambiguator\":\"13469548779861599847\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"debugger connected, not going to deep sleep\",\"disambiguator\":\"13469548779861599847\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                esp_hal::reset::software_reset();
            }
            let timer = TimerWakeupSource::new(duration.into());
            match (&(defmt::Debug2Format(&timer))) {
                (arg0) => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::power".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe {
                            defmt::export::acquire_and_header(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"going to deep sleep with timer wakeup: {:?}\",\"disambiguator\":\"14484829084903287614\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"going to deep sleep with timer wakeup: {:?}\",\"disambiguator\":\"14484829084903287614\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        };
                        defmt::export::fmt(arg0);
                        unsafe { defmt::export::release() }
                    }
                }
            };
            let mut ing_pin: esp_hal::gpio::GpioPin<5> = unsafe { esp_hal::gpio::GpioPin::steal() };
            let wakeup_pins: &mut [(&mut dyn RtcPinWithResistors, WakeupLevel)] =
                &mut [(&mut ing_pin, WakeupLevel::High)];
            let rtcio = Ext1WakeupSource::new(wakeup_pins);
            self.rs_gpio.set_low();
            let mut rtc = match defmt::export::into_result(self.rtc.try_lock()) {
                ::core::result::Result::Ok(res) => res,
                ::core::result::Result::Err(_unwrap_err) => {
                    match (&(_unwrap_err)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "kia_obd2_esp32c3_v2::power".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: self.rtc.try_lock()'\\nerror: `{:?}`\",\"disambiguator\":\"4988970361907936032\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: self.rtc.try_lock()'\\nerror: `{:?}`\",\"disambiguator\":\"4988970361907936032\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    defmt::export::panic()
                }
            };
            rtc.sleep_deep(&[&timer, &rtcio]);
        }
        pub fn is_ignition_on(&self) -> bool {
            self.ing_gpio.is_high()
        }
        pub fn is_ignition_off(&self) -> bool {
            self.ing_gpio.is_low()
        }
        pub async fn wait_for_ignition_off(&mut self) {
            self.ing_gpio.wait_for_falling_edge().await;
        }
        pub async fn wait_for_ignition_on(&mut self) {
            self.ing_gpio.wait_for_rising_edge().await;
        }
        pub async fn wait_for_ignition_change(&mut self) -> Ignition {
            self.ing_gpio.wait_for_any_edge().await;
            if self.is_ignition_on() {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::power".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"ignition on\",\"disambiguator\":\"14943655167516927374\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"ignition on\",\"disambiguator\":\"14943655167516927374\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                Ignition::On
            } else {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::power".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"ignition off\",\"disambiguator\":\"8230778299086768220\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"ignition off\",\"disambiguator\":\"8230778299086768220\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                Ignition::Off
            }
        }
        pub fn rwdt_feed(&mut self) {
            if let Ok(mut rtc) = self.rtc.try_lock() {
                rtc.rwdt.feed();
            } else {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::power".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"failed to feed rwdt\",\"disambiguator\":\"10277799086231525820\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"failed to feed rwdt\",\"disambiguator\":\"10277799086231525820\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
            }
        }
    }
}
mod prelude {
    use embassy_time::Duration;
    pub trait FutureTimeout {
        type Output;
        async fn timeout(
            self,
            dur: embassy_time::Duration,
        ) -> Result<Self::Output, embassy_time::TimeoutError>;
        async fn timeout_secs(self, secs: u64) -> Result<Self::Output, embassy_time::TimeoutError>;
        async fn timeout_millis(
            self,
            millis: u64,
        ) -> Result<Self::Output, embassy_time::TimeoutError>;
    }
    impl<F> FutureTimeout for F
    where
        F: core::future::Future,
    {
        type Output = F::Output;
        async fn timeout(
            self,
            dur: embassy_time::Duration,
        ) -> Result<Self::Output, embassy_time::TimeoutError> {
            embassy_time::with_timeout(dur, self).await
        }
        async fn timeout_secs(self, secs: u64) -> Result<Self::Output, embassy_time::TimeoutError> {
            self.timeout(Duration::from_secs(secs)).await
        }
        async fn timeout_millis(
            self,
            millis: u64,
        ) -> Result<Self::Output, embassy_time::TimeoutError> {
            self.timeout(Duration::from_millis(millis)).await
        }
    }
}
mod tasks {
    pub mod buttons {
        use defmt::{error, info, unwrap, warn, Format};
        use embassy_futures::select::{select, Either};
        use embassy_sync::{blocking_mutex::raw::CriticalSectionRawMutex, signal::Signal};
        use embassy_time::Timer;
        use crate::{
            event::{KiaEvent, LcdEvent, KIA_EVENTS, LCD_EVENTS},
            tasks::power::get_shutdown_signal,
            types::Cap1188,
        };
        pub enum Button {
            B0,
            B1,
            B2,
            B3,
            B4,
            B5,
            B6,
            B7,
        }
        impl defmt::Format for Button {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"9504122244529117628\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"9504122244529117628\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"B0|B1|B2|B3|B4|B5|B6|B7\",\"disambiguator\":\"217421495555063746\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"B0|B1|B2|B3|B4|B5|B6|B7\",\"disambiguator\":\"217421495555063746\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    Button::B0 {} => {
                        defmt::export::u8(&0u8);
                    }
                    Button::B1 {} => {
                        defmt::export::u8(&1u8);
                    }
                    Button::B2 {} => {
                        defmt::export::u8(&2u8);
                    }
                    Button::B3 {} => {
                        defmt::export::u8(&3u8);
                    }
                    Button::B4 {} => {
                        defmt::export::u8(&4u8);
                    }
                    Button::B5 {} => {
                        defmt::export::u8(&5u8);
                    }
                    Button::B6 {} => {
                        defmt::export::u8(&6u8);
                    }
                    Button::B7 {} => {
                        defmt::export::u8(&7u8);
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Button {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Button {
            #[inline]
            fn eq(&self, other: &Button) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Button {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Button {
            #[inline]
            fn clone(&self) -> Button {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Button {}
        pub enum Action {
            Pressed(Button),
            Released(Button),
        }
        impl defmt::Format for Action
        where
            Button: defmt::Format,
        {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"758174979923814138\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"758174979923814138\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"Pressed({=?})|Released({=?})\",\"disambiguator\":\"6511796702249911076\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"Pressed({=?})|Released({=?})\",\"disambiguator\":\"6511796702249911076\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    Action::Pressed { 0: arg0 } => {
                        defmt::export::u8(&0u8);
                        defmt::export::fmt(arg0);
                    }
                    Action::Released { 0: arg0 } => {
                        defmt::export::u8(&1u8);
                        defmt::export::fmt(arg0);
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Action {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Action {
            #[inline]
            fn eq(&self, other: &Action) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (Action::Pressed(__self_0), Action::Pressed(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (Action::Released(__self_0), Action::Released(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Action {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Button>;
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Action {
            #[inline]
            fn clone(&self) -> Action {
                let _: ::core::clone::AssertParamIsClone<Button>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Action {}
        static INIT_BUTTONS: Signal<CriticalSectionRawMutex, ()> = Signal::new();
        #[doc(hidden)]
        async fn __run_task(mut cap1188: Cap1188) {
            let mut shutdown_on_init = false;
            embassy_time::Timer::after(embassy_time::Duration::from_secs(1)).await;
            cap1188.reset().await.ok();
            loop {
                match cap1188.init().await {
                    Ok(true) => {
                        match () {
                            () => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    defmt::export::acquire_header_and_release(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"cap1188 init success\",\"disambiguator\":\"9553016151465392512\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"cap1188 init success\",\"disambiguator\":\"9553016151465392512\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                }
                            }
                        };
                        break;
                    }
                    Ok(false) => {
                        match () {
                            () => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    defmt::export::acquire_header_and_release(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"cap1188 init failed\",\"disambiguator\":\"4407750850882098226\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"cap1188 init failed\",\"disambiguator\":\"4407750850882098226\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                }
                            }
                        };
                        Timer::after(embassy_time::Duration::from_secs(1)).await;
                    }
                    Err(e) => {
                        match (&(e)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"cap1188 init error: {:?}\",\"disambiguator\":\"5875388184106479994\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"cap1188 init error: {:?}\",\"disambiguator\":\"5875388184106479994\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        Timer::after(embassy_time::Duration::from_secs(1)).await;
                    }
                }
            }
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        defmt::export::acquire_header_and_release(&{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"cap1188 task started\",\"disambiguator\":\"6917054801012565039\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"cap1188 task started\",\"disambiguator\":\"6917054801012565039\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        });
                    }
                }
            };
            let mut old_touched = match defmt::export::into_result(cap1188.touched().await) {
                ::core::result::Result::Ok(res) => res,
                ::core::result::Result::Err(_unwrap_err) => {
                    match (&(_unwrap_err)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: cap1188.touched().await'\\nerror: `{:?}`\",\"disambiguator\":\"8218043659725236309\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: cap1188.touched().await'\\nerror: `{:?}`\",\"disambiguator\":\"8218043659725236309\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    defmt::export::panic()
                }
            };
            let mut old_touched_bytes = old_touched.into_bytes()[0];
            let mut last_touched = embassy_time::Instant::now();
            let mut fast_loops = 0;
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        defmt::export::acquire_header_and_release(&{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"cap1188 task running\",\"disambiguator\":\"13802544921023565154\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"cap1188 task running\",\"disambiguator\":\"13802544921023565154\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        });
                    }
                }
            };
            select(async {
                        loop {
                            if old_touched_bytes > 0 {
                                    embassy_time::with_timeout(embassy_time::Duration::from_millis(100),
                                                cap1188.wait_for_touched()).await.ok();
                                    match (&(old_touched_bytes)) {
                                        (arg0) => {
                                            if {
                                                        const CHECK: bool =
                                                            {
                                                                const fn check() -> bool {
                                                                    let module_path =
                                                                        "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                    if if 19usize > module_path.len() {
                                                                                    false
                                                                                } else {
                                                                                   module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                           && module_path[2usize] == 97u8 &&
                                                                                                                                                       module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                               && module_path[5usize] == 98u8 &&
                                                                                                                                           module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                   && module_path[8usize] == 95u8 &&
                                                                                                                               module_path[9usize] == 101u8 &&
                                                                                                                           module_path[10usize] == 115u8 &&
                                                                                                                       module_path[11usize] == 112u8 &&
                                                                                                                   module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                           && module_path[14usize] == 99u8 &&
                                                                                                       module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                               && module_path[17usize] == 118u8 &&
                                                                                           module_path[18usize] == 50u8 &&
                                                                                       if 19usize == module_path.len() {
                                                                                               true
                                                                                           } else { module_path[19usize] == b':' }
                                                                               } {
                                                                            return true;
                                                                        }
                                                                    false
                                                                }
                                                                check()
                                                            };
                                                        CHECK
                                                    } {
                                                    unsafe {
                                                        defmt::export::acquire_and_header(&{
                                                                    defmt::export::make_istr({
                                                                            #[link_section =
                                                                            ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"cap1188 touched timeout on bytes: {:?}\",\"disambiguator\":\"10469495709549776584\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            #[export_name =
                                                                            "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"cap1188 touched timeout on bytes: {:?}\",\"disambiguator\":\"10469495709549776584\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                        })
                                                                });
                                                    };
                                                    defmt::export::fmt(arg0);
                                                    unsafe { defmt::export::release() }
                                                }
                                        }
                                    };
                                    cap1188.calibrate().await.ok();
                                } else { cap1188.wait_for_touched().await; }
                            let new_touched =
                                match defmt::export::into_result(cap1188.touched().await) {
                                    ::core::result::Result::Ok(res) => res,
                                    ::core::result::Result::Err(_unwrap_err) => {
                                        match (&(_unwrap_err)) {
                                            (arg0) => {
                                                if {
                                                            const CHECK: bool =
                                                                {
                                                                    const fn check() -> bool {
                                                                        let module_path =
                                                                            "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                        if if 19usize > module_path.len() {
                                                                                        false
                                                                                    } else {
                                                                                       module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                               && module_path[2usize] == 97u8 &&
                                                                                                                                                           module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                   && module_path[5usize] == 98u8 &&
                                                                                                                                               module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                       && module_path[8usize] == 95u8 &&
                                                                                                                                   module_path[9usize] == 101u8 &&
                                                                                                                               module_path[10usize] == 115u8 &&
                                                                                                                           module_path[11usize] == 112u8 &&
                                                                                                                       module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                               && module_path[14usize] == 99u8 &&
                                                                                                           module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                   && module_path[17usize] == 118u8 &&
                                                                                               module_path[18usize] == 50u8 &&
                                                                                           if 19usize == module_path.len() {
                                                                                                   true
                                                                                               } else { module_path[19usize] == b':' }
                                                                                   } {
                                                                                return true;
                                                                            }
                                                                        false
                                                                    }
                                                                    check()
                                                                };
                                                            CHECK
                                                        } {
                                                        unsafe {
                                                            defmt::export::acquire_and_header(&{
                                                                        defmt::export::make_istr({
                                                                                #[link_section =
                                                                                ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: cap1188.touched().await'\\nerror: `{:?}`\",\"disambiguator\":\"10724776381712834718\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                #[export_name =
                                                                                "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: cap1188.touched().await'\\nerror: `{:?}`\",\"disambiguator\":\"10724776381712834718\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                            })
                                                                    });
                                                        };
                                                        defmt::export::fmt(arg0);
                                                        unsafe { defmt::export::release() }
                                                    }
                                            }
                                        };
                                        defmt::export::panic()
                                    }
                                };
                            let new_touched_bytes = new_touched.into_bytes()[0];
                            if new_touched_bytes != old_touched_bytes {
                                    if new_touched.b0() != old_touched.b0() {
                                            if new_touched.b0() {
                                                    match () {
                                                        () => {
                                                            if {
                                                                        const CHECK: bool =
                                                                            {
                                                                                const fn check() -> bool {
                                                                                    let module_path =
                                                                                        "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                    if if 19usize > module_path.len() {
                                                                                                    false
                                                                                                } else {
                                                                                                   module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                           && module_path[2usize] == 97u8 &&
                                                                                                                                                                       module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                               && module_path[5usize] == 98u8 &&
                                                                                                                                                           module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                   && module_path[8usize] == 95u8 &&
                                                                                                                                               module_path[9usize] == 101u8 &&
                                                                                                                                           module_path[10usize] == 115u8 &&
                                                                                                                                       module_path[11usize] == 112u8 &&
                                                                                                                                   module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                           && module_path[14usize] == 99u8 &&
                                                                                                                       module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                               && module_path[17usize] == 118u8 &&
                                                                                                           module_path[18usize] == 50u8 &&
                                                                                                       if 19usize == module_path.len() {
                                                                                                               true
                                                                                                           } else { module_path[19usize] == b':' }
                                                                                               } {
                                                                                            return true;
                                                                                        }
                                                                                    false
                                                                                }
                                                                                check()
                                                                            };
                                                                        CHECK
                                                                    } {
                                                                    defmt::export::acquire_header_and_release(&{
                                                                                defmt::export::make_istr({
                                                                                        #[link_section =
                                                                                        ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b0 pressed\",\"disambiguator\":\"6265264279744669761\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        #[export_name =
                                                                                        "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b0 pressed\",\"disambiguator\":\"6265264279744669761\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                    })
                                                                            });
                                                                }
                                                        }
                                                    };
                                                    KIA_EVENTS.send(KiaEvent::Button(Action::Pressed(Button::B0))).await;
                                                    LCD_EVENTS.send(LcdEvent::Button(Action::Pressed(Button::B0))).await;
                                                } else {
                                                   match () {
                                                       () => {
                                                           if {
                                                                       const CHECK: bool =
                                                                           {
                                                                               const fn check() -> bool {
                                                                                   let module_path =
                                                                                       "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                   if if 19usize > module_path.len() {
                                                                                                   false
                                                                                               } else {
                                                                                                  module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                          && module_path[2usize] == 97u8 &&
                                                                                                                                                                      module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                              && module_path[5usize] == 98u8 &&
                                                                                                                                                          module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                  && module_path[8usize] == 95u8 &&
                                                                                                                                              module_path[9usize] == 101u8 &&
                                                                                                                                          module_path[10usize] == 115u8 &&
                                                                                                                                      module_path[11usize] == 112u8 &&
                                                                                                                                  module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                          && module_path[14usize] == 99u8 &&
                                                                                                                      module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                              && module_path[17usize] == 118u8 &&
                                                                                                          module_path[18usize] == 50u8 &&
                                                                                                      if 19usize == module_path.len() {
                                                                                                              true
                                                                                                          } else { module_path[19usize] == b':' }
                                                                                              } {
                                                                                           return true;
                                                                                       }
                                                                                   false
                                                                               }
                                                                               check()
                                                                           };
                                                                       CHECK
                                                                   } {
                                                                   defmt::export::acquire_header_and_release(&{
                                                                               defmt::export::make_istr({
                                                                                       #[link_section =
                                                                                       ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b0 released\",\"disambiguator\":\"13253102167513140392\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       #[export_name =
                                                                                       "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b0 released\",\"disambiguator\":\"13253102167513140392\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                       &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                   })
                                                                           });
                                                               }
                                                       }
                                                   };
                                                   KIA_EVENTS.send(KiaEvent::Button(Action::Released(Button::B0))).await;
                                                   LCD_EVENTS.send(LcdEvent::Button(Action::Released(Button::B0))).await;
                                               }
                                        }
                                    if new_touched.b1() != old_touched.b1() {
                                            if new_touched.b1() {
                                                    match () {
                                                        () => {
                                                            if {
                                                                        const CHECK: bool =
                                                                            {
                                                                                const fn check() -> bool {
                                                                                    let module_path =
                                                                                        "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                    if if 19usize > module_path.len() {
                                                                                                    false
                                                                                                } else {
                                                                                                   module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                           && module_path[2usize] == 97u8 &&
                                                                                                                                                                       module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                               && module_path[5usize] == 98u8 &&
                                                                                                                                                           module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                   && module_path[8usize] == 95u8 &&
                                                                                                                                               module_path[9usize] == 101u8 &&
                                                                                                                                           module_path[10usize] == 115u8 &&
                                                                                                                                       module_path[11usize] == 112u8 &&
                                                                                                                                   module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                           && module_path[14usize] == 99u8 &&
                                                                                                                       module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                               && module_path[17usize] == 118u8 &&
                                                                                                           module_path[18usize] == 50u8 &&
                                                                                                       if 19usize == module_path.len() {
                                                                                                               true
                                                                                                           } else { module_path[19usize] == b':' }
                                                                                               } {
                                                                                            return true;
                                                                                        }
                                                                                    false
                                                                                }
                                                                                check()
                                                                            };
                                                                        CHECK
                                                                    } {
                                                                    defmt::export::acquire_header_and_release(&{
                                                                                defmt::export::make_istr({
                                                                                        #[link_section =
                                                                                        ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b1 pressed\",\"disambiguator\":\"1766143575026588732\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        #[export_name =
                                                                                        "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b1 pressed\",\"disambiguator\":\"1766143575026588732\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                    })
                                                                            });
                                                                }
                                                        }
                                                    };
                                                    KIA_EVENTS.send(KiaEvent::Button(Action::Pressed(Button::B1))).await;
                                                    LCD_EVENTS.send(LcdEvent::Button(Action::Pressed(Button::B1))).await;
                                                } else {
                                                   match () {
                                                       () => {
                                                           if {
                                                                       const CHECK: bool =
                                                                           {
                                                                               const fn check() -> bool {
                                                                                   let module_path =
                                                                                       "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                   if if 19usize > module_path.len() {
                                                                                                   false
                                                                                               } else {
                                                                                                  module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                          && module_path[2usize] == 97u8 &&
                                                                                                                                                                      module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                              && module_path[5usize] == 98u8 &&
                                                                                                                                                          module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                  && module_path[8usize] == 95u8 &&
                                                                                                                                              module_path[9usize] == 101u8 &&
                                                                                                                                          module_path[10usize] == 115u8 &&
                                                                                                                                      module_path[11usize] == 112u8 &&
                                                                                                                                  module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                          && module_path[14usize] == 99u8 &&
                                                                                                                      module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                              && module_path[17usize] == 118u8 &&
                                                                                                          module_path[18usize] == 50u8 &&
                                                                                                      if 19usize == module_path.len() {
                                                                                                              true
                                                                                                          } else { module_path[19usize] == b':' }
                                                                                              } {
                                                                                           return true;
                                                                                       }
                                                                                   false
                                                                               }
                                                                               check()
                                                                           };
                                                                       CHECK
                                                                   } {
                                                                   defmt::export::acquire_header_and_release(&{
                                                                               defmt::export::make_istr({
                                                                                       #[link_section =
                                                                                       ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b1 released\",\"disambiguator\":\"13984107256015740653\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       #[export_name =
                                                                                       "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b1 released\",\"disambiguator\":\"13984107256015740653\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                       &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                   })
                                                                           });
                                                               }
                                                       }
                                                   };
                                                   KIA_EVENTS.send(KiaEvent::Button(Action::Released(Button::B1))).await;
                                                   LCD_EVENTS.send(LcdEvent::Button(Action::Released(Button::B1))).await;
                                               }
                                        }
                                    if new_touched.b2() != old_touched.b2() {
                                            if new_touched.b2() {
                                                    match () {
                                                        () => {
                                                            if {
                                                                        const CHECK: bool =
                                                                            {
                                                                                const fn check() -> bool {
                                                                                    let module_path =
                                                                                        "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                    if if 19usize > module_path.len() {
                                                                                                    false
                                                                                                } else {
                                                                                                   module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                           && module_path[2usize] == 97u8 &&
                                                                                                                                                                       module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                               && module_path[5usize] == 98u8 &&
                                                                                                                                                           module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                   && module_path[8usize] == 95u8 &&
                                                                                                                                               module_path[9usize] == 101u8 &&
                                                                                                                                           module_path[10usize] == 115u8 &&
                                                                                                                                       module_path[11usize] == 112u8 &&
                                                                                                                                   module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                           && module_path[14usize] == 99u8 &&
                                                                                                                       module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                               && module_path[17usize] == 118u8 &&
                                                                                                           module_path[18usize] == 50u8 &&
                                                                                                       if 19usize == module_path.len() {
                                                                                                               true
                                                                                                           } else { module_path[19usize] == b':' }
                                                                                               } {
                                                                                            return true;
                                                                                        }
                                                                                    false
                                                                                }
                                                                                check()
                                                                            };
                                                                        CHECK
                                                                    } {
                                                                    defmt::export::acquire_header_and_release(&{
                                                                                defmt::export::make_istr({
                                                                                        #[link_section =
                                                                                        ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b2 pressed\",\"disambiguator\":\"16922986506628752584\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        #[export_name =
                                                                                        "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b2 pressed\",\"disambiguator\":\"16922986506628752584\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                    })
                                                                            });
                                                                }
                                                        }
                                                    };
                                                    KIA_EVENTS.send(KiaEvent::Button(Action::Pressed(Button::B2))).await;
                                                    LCD_EVENTS.send(LcdEvent::Button(Action::Pressed(Button::B2))).await;
                                                } else {
                                                   match () {
                                                       () => {
                                                           if {
                                                                       const CHECK: bool =
                                                                           {
                                                                               const fn check() -> bool {
                                                                                   let module_path =
                                                                                       "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                   if if 19usize > module_path.len() {
                                                                                                   false
                                                                                               } else {
                                                                                                  module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                          && module_path[2usize] == 97u8 &&
                                                                                                                                                                      module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                              && module_path[5usize] == 98u8 &&
                                                                                                                                                          module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                  && module_path[8usize] == 95u8 &&
                                                                                                                                              module_path[9usize] == 101u8 &&
                                                                                                                                          module_path[10usize] == 115u8 &&
                                                                                                                                      module_path[11usize] == 112u8 &&
                                                                                                                                  module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                          && module_path[14usize] == 99u8 &&
                                                                                                                      module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                              && module_path[17usize] == 118u8 &&
                                                                                                          module_path[18usize] == 50u8 &&
                                                                                                      if 19usize == module_path.len() {
                                                                                                              true
                                                                                                          } else { module_path[19usize] == b':' }
                                                                                              } {
                                                                                           return true;
                                                                                       }
                                                                                   false
                                                                               }
                                                                               check()
                                                                           };
                                                                       CHECK
                                                                   } {
                                                                   defmt::export::acquire_header_and_release(&{
                                                                               defmt::export::make_istr({
                                                                                       #[link_section =
                                                                                       ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b2 released\",\"disambiguator\":\"4724047777853935399\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       #[export_name =
                                                                                       "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b2 released\",\"disambiguator\":\"4724047777853935399\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                       &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                   })
                                                                           });
                                                               }
                                                       }
                                                   };
                                                   KIA_EVENTS.send(KiaEvent::Button(Action::Released(Button::B2))).await;
                                                   LCD_EVENTS.send(LcdEvent::Button(Action::Released(Button::B2))).await;
                                               }
                                        }
                                    if new_touched.b3() != old_touched.b3() {
                                            if new_touched.b3() {
                                                    match () {
                                                        () => {
                                                            if {
                                                                        const CHECK: bool =
                                                                            {
                                                                                const fn check() -> bool {
                                                                                    let module_path =
                                                                                        "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                    if if 19usize > module_path.len() {
                                                                                                    false
                                                                                                } else {
                                                                                                   module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                           && module_path[2usize] == 97u8 &&
                                                                                                                                                                       module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                               && module_path[5usize] == 98u8 &&
                                                                                                                                                           module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                   && module_path[8usize] == 95u8 &&
                                                                                                                                               module_path[9usize] == 101u8 &&
                                                                                                                                           module_path[10usize] == 115u8 &&
                                                                                                                                       module_path[11usize] == 112u8 &&
                                                                                                                                   module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                           && module_path[14usize] == 99u8 &&
                                                                                                                       module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                               && module_path[17usize] == 118u8 &&
                                                                                                           module_path[18usize] == 50u8 &&
                                                                                                       if 19usize == module_path.len() {
                                                                                                               true
                                                                                                           } else { module_path[19usize] == b':' }
                                                                                               } {
                                                                                            return true;
                                                                                        }
                                                                                    false
                                                                                }
                                                                                check()
                                                                            };
                                                                        CHECK
                                                                    } {
                                                                    defmt::export::acquire_header_and_release(&{
                                                                                defmt::export::make_istr({
                                                                                        #[link_section =
                                                                                        ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b3 pressed\",\"disambiguator\":\"16145480872950347062\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        #[export_name =
                                                                                        "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b3 pressed\",\"disambiguator\":\"16145480872950347062\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                    })
                                                                            });
                                                                }
                                                        }
                                                    };
                                                    KIA_EVENTS.send(KiaEvent::Button(Action::Pressed(Button::B3))).await;
                                                    LCD_EVENTS.send(LcdEvent::Button(Action::Pressed(Button::B3))).await;
                                                } else {
                                                   match () {
                                                       () => {
                                                           if {
                                                                       const CHECK: bool =
                                                                           {
                                                                               const fn check() -> bool {
                                                                                   let module_path =
                                                                                       "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                   if if 19usize > module_path.len() {
                                                                                                   false
                                                                                               } else {
                                                                                                  module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                          && module_path[2usize] == 97u8 &&
                                                                                                                                                                      module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                              && module_path[5usize] == 98u8 &&
                                                                                                                                                          module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                  && module_path[8usize] == 95u8 &&
                                                                                                                                              module_path[9usize] == 101u8 &&
                                                                                                                                          module_path[10usize] == 115u8 &&
                                                                                                                                      module_path[11usize] == 112u8 &&
                                                                                                                                  module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                          && module_path[14usize] == 99u8 &&
                                                                                                                      module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                              && module_path[17usize] == 118u8 &&
                                                                                                          module_path[18usize] == 50u8 &&
                                                                                                      if 19usize == module_path.len() {
                                                                                                              true
                                                                                                          } else { module_path[19usize] == b':' }
                                                                                              } {
                                                                                           return true;
                                                                                       }
                                                                                   false
                                                                               }
                                                                               check()
                                                                           };
                                                                       CHECK
                                                                   } {
                                                                   defmt::export::acquire_header_and_release(&{
                                                                               defmt::export::make_istr({
                                                                                       #[link_section =
                                                                                       ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b3 released\",\"disambiguator\":\"2778908327972705652\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       #[export_name =
                                                                                       "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b3 released\",\"disambiguator\":\"2778908327972705652\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                       &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                   })
                                                                           });
                                                               }
                                                       }
                                                   };
                                                   KIA_EVENTS.send(KiaEvent::Button(Action::Released(Button::B3))).await;
                                                   LCD_EVENTS.send(LcdEvent::Button(Action::Released(Button::B3))).await;
                                               }
                                        }
                                    if new_touched.b4() != old_touched.b4() {
                                            if new_touched.b4() {
                                                    match () {
                                                        () => {
                                                            if {
                                                                        const CHECK: bool =
                                                                            {
                                                                                const fn check() -> bool {
                                                                                    let module_path =
                                                                                        "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                    if if 19usize > module_path.len() {
                                                                                                    false
                                                                                                } else {
                                                                                                   module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                           && module_path[2usize] == 97u8 &&
                                                                                                                                                                       module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                               && module_path[5usize] == 98u8 &&
                                                                                                                                                           module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                   && module_path[8usize] == 95u8 &&
                                                                                                                                               module_path[9usize] == 101u8 &&
                                                                                                                                           module_path[10usize] == 115u8 &&
                                                                                                                                       module_path[11usize] == 112u8 &&
                                                                                                                                   module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                           && module_path[14usize] == 99u8 &&
                                                                                                                       module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                               && module_path[17usize] == 118u8 &&
                                                                                                           module_path[18usize] == 50u8 &&
                                                                                                       if 19usize == module_path.len() {
                                                                                                               true
                                                                                                           } else { module_path[19usize] == b':' }
                                                                                               } {
                                                                                            return true;
                                                                                        }
                                                                                    false
                                                                                }
                                                                                check()
                                                                            };
                                                                        CHECK
                                                                    } {
                                                                    defmt::export::acquire_header_and_release(&{
                                                                                defmt::export::make_istr({
                                                                                        #[link_section =
                                                                                        ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b4 pressed\",\"disambiguator\":\"2053159253182837006\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        #[export_name =
                                                                                        "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b4 pressed\",\"disambiguator\":\"2053159253182837006\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                    })
                                                                            });
                                                                }
                                                        }
                                                    };
                                                    KIA_EVENTS.send(KiaEvent::Button(Action::Pressed(Button::B4))).await;
                                                    LCD_EVENTS.send(LcdEvent::Button(Action::Pressed(Button::B4))).await;
                                                } else {
                                                   match () {
                                                       () => {
                                                           if {
                                                                       const CHECK: bool =
                                                                           {
                                                                               const fn check() -> bool {
                                                                                   let module_path =
                                                                                       "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                   if if 19usize > module_path.len() {
                                                                                                   false
                                                                                               } else {
                                                                                                  module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                          && module_path[2usize] == 97u8 &&
                                                                                                                                                                      module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                              && module_path[5usize] == 98u8 &&
                                                                                                                                                          module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                  && module_path[8usize] == 95u8 &&
                                                                                                                                              module_path[9usize] == 101u8 &&
                                                                                                                                          module_path[10usize] == 115u8 &&
                                                                                                                                      module_path[11usize] == 112u8 &&
                                                                                                                                  module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                          && module_path[14usize] == 99u8 &&
                                                                                                                      module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                              && module_path[17usize] == 118u8 &&
                                                                                                          module_path[18usize] == 50u8 &&
                                                                                                      if 19usize == module_path.len() {
                                                                                                              true
                                                                                                          } else { module_path[19usize] == b':' }
                                                                                              } {
                                                                                           return true;
                                                                                       }
                                                                                   false
                                                                               }
                                                                               check()
                                                                           };
                                                                       CHECK
                                                                   } {
                                                                   defmt::export::acquire_header_and_release(&{
                                                                               defmt::export::make_istr({
                                                                                       #[link_section =
                                                                                       ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b4 released\",\"disambiguator\":\"778643237172078203\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       #[export_name =
                                                                                       "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b4 released\",\"disambiguator\":\"778643237172078203\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                       &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                   })
                                                                           });
                                                               }
                                                       }
                                                   };
                                                   KIA_EVENTS.send(KiaEvent::Button(Action::Released(Button::B4))).await;
                                                   LCD_EVENTS.send(LcdEvent::Button(Action::Released(Button::B4))).await;
                                               }
                                        }
                                    if new_touched.b5() != old_touched.b5() {
                                            if new_touched.b5() {
                                                    match () {
                                                        () => {
                                                            if {
                                                                        const CHECK: bool =
                                                                            {
                                                                                const fn check() -> bool {
                                                                                    let module_path =
                                                                                        "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                    if if 19usize > module_path.len() {
                                                                                                    false
                                                                                                } else {
                                                                                                   module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                           && module_path[2usize] == 97u8 &&
                                                                                                                                                                       module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                               && module_path[5usize] == 98u8 &&
                                                                                                                                                           module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                   && module_path[8usize] == 95u8 &&
                                                                                                                                               module_path[9usize] == 101u8 &&
                                                                                                                                           module_path[10usize] == 115u8 &&
                                                                                                                                       module_path[11usize] == 112u8 &&
                                                                                                                                   module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                           && module_path[14usize] == 99u8 &&
                                                                                                                       module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                               && module_path[17usize] == 118u8 &&
                                                                                                           module_path[18usize] == 50u8 &&
                                                                                                       if 19usize == module_path.len() {
                                                                                                               true
                                                                                                           } else { module_path[19usize] == b':' }
                                                                                               } {
                                                                                            return true;
                                                                                        }
                                                                                    false
                                                                                }
                                                                                check()
                                                                            };
                                                                        CHECK
                                                                    } {
                                                                    defmt::export::acquire_header_and_release(&{
                                                                                defmt::export::make_istr({
                                                                                        #[link_section =
                                                                                        ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b5 pressed\",\"disambiguator\":\"8163832670536814530\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        #[export_name =
                                                                                        "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b5 pressed\",\"disambiguator\":\"8163832670536814530\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                    })
                                                                            });
                                                                }
                                                        }
                                                    };
                                                    KIA_EVENTS.send(KiaEvent::Button(Action::Pressed(Button::B5))).await;
                                                    LCD_EVENTS.send(LcdEvent::Button(Action::Pressed(Button::B5))).await;
                                                } else {
                                                   match () {
                                                       () => {
                                                           if {
                                                                       const CHECK: bool =
                                                                           {
                                                                               const fn check() -> bool {
                                                                                   let module_path =
                                                                                       "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                   if if 19usize > module_path.len() {
                                                                                                   false
                                                                                               } else {
                                                                                                  module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                          && module_path[2usize] == 97u8 &&
                                                                                                                                                                      module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                              && module_path[5usize] == 98u8 &&
                                                                                                                                                          module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                  && module_path[8usize] == 95u8 &&
                                                                                                                                              module_path[9usize] == 101u8 &&
                                                                                                                                          module_path[10usize] == 115u8 &&
                                                                                                                                      module_path[11usize] == 112u8 &&
                                                                                                                                  module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                          && module_path[14usize] == 99u8 &&
                                                                                                                      module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                              && module_path[17usize] == 118u8 &&
                                                                                                          module_path[18usize] == 50u8 &&
                                                                                                      if 19usize == module_path.len() {
                                                                                                              true
                                                                                                          } else { module_path[19usize] == b':' }
                                                                                              } {
                                                                                           return true;
                                                                                       }
                                                                                   false
                                                                               }
                                                                               check()
                                                                           };
                                                                       CHECK
                                                                   } {
                                                                   defmt::export::acquire_header_and_release(&{
                                                                               defmt::export::make_istr({
                                                                                       #[link_section =
                                                                                       ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b5 released\",\"disambiguator\":\"9187890813999981782\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       #[export_name =
                                                                                       "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b5 released\",\"disambiguator\":\"9187890813999981782\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                       &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                   })
                                                                           });
                                                               }
                                                       }
                                                   };
                                                   KIA_EVENTS.send(KiaEvent::Button(Action::Released(Button::B5))).await;
                                                   LCD_EVENTS.send(LcdEvent::Button(Action::Released(Button::B5))).await;
                                               }
                                        }
                                    if new_touched.b6() != old_touched.b6() {
                                            if new_touched.b6() {
                                                    match () {
                                                        () => {
                                                            if {
                                                                        const CHECK: bool =
                                                                            {
                                                                                const fn check() -> bool {
                                                                                    let module_path =
                                                                                        "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                    if if 19usize > module_path.len() {
                                                                                                    false
                                                                                                } else {
                                                                                                   module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                           && module_path[2usize] == 97u8 &&
                                                                                                                                                                       module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                               && module_path[5usize] == 98u8 &&
                                                                                                                                                           module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                   && module_path[8usize] == 95u8 &&
                                                                                                                                               module_path[9usize] == 101u8 &&
                                                                                                                                           module_path[10usize] == 115u8 &&
                                                                                                                                       module_path[11usize] == 112u8 &&
                                                                                                                                   module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                           && module_path[14usize] == 99u8 &&
                                                                                                                       module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                               && module_path[17usize] == 118u8 &&
                                                                                                           module_path[18usize] == 50u8 &&
                                                                                                       if 19usize == module_path.len() {
                                                                                                               true
                                                                                                           } else { module_path[19usize] == b':' }
                                                                                               } {
                                                                                            return true;
                                                                                        }
                                                                                    false
                                                                                }
                                                                                check()
                                                                            };
                                                                        CHECK
                                                                    } {
                                                                    defmt::export::acquire_header_and_release(&{
                                                                                defmt::export::make_istr({
                                                                                        #[link_section =
                                                                                        ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b6 pressed\",\"disambiguator\":\"11036663506822557191\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        #[export_name =
                                                                                        "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b6 pressed\",\"disambiguator\":\"11036663506822557191\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                    })
                                                                            });
                                                                }
                                                        }
                                                    };
                                                    KIA_EVENTS.send(KiaEvent::Button(Action::Pressed(Button::B6))).await;
                                                    LCD_EVENTS.send(LcdEvent::Button(Action::Pressed(Button::B6))).await;
                                                } else {
                                                   match () {
                                                       () => {
                                                           if {
                                                                       const CHECK: bool =
                                                                           {
                                                                               const fn check() -> bool {
                                                                                   let module_path =
                                                                                       "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                   if if 19usize > module_path.len() {
                                                                                                   false
                                                                                               } else {
                                                                                                  module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                          && module_path[2usize] == 97u8 &&
                                                                                                                                                                      module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                              && module_path[5usize] == 98u8 &&
                                                                                                                                                          module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                  && module_path[8usize] == 95u8 &&
                                                                                                                                              module_path[9usize] == 101u8 &&
                                                                                                                                          module_path[10usize] == 115u8 &&
                                                                                                                                      module_path[11usize] == 112u8 &&
                                                                                                                                  module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                          && module_path[14usize] == 99u8 &&
                                                                                                                      module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                              && module_path[17usize] == 118u8 &&
                                                                                                          module_path[18usize] == 50u8 &&
                                                                                                      if 19usize == module_path.len() {
                                                                                                              true
                                                                                                          } else { module_path[19usize] == b':' }
                                                                                              } {
                                                                                           return true;
                                                                                       }
                                                                                   false
                                                                               }
                                                                               check()
                                                                           };
                                                                       CHECK
                                                                   } {
                                                                   defmt::export::acquire_header_and_release(&{
                                                                               defmt::export::make_istr({
                                                                                       #[link_section =
                                                                                       ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b6 released\",\"disambiguator\":\"13097174975878432108\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       #[export_name =
                                                                                       "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b6 released\",\"disambiguator\":\"13097174975878432108\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                       &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                   })
                                                                           });
                                                               }
                                                       }
                                                   };
                                                   KIA_EVENTS.send(KiaEvent::Button(Action::Released(Button::B6))).await;
                                                   LCD_EVENTS.send(LcdEvent::Button(Action::Released(Button::B6))).await;
                                               }
                                        }
                                    if new_touched.b7() != old_touched.b7() {
                                            if new_touched.b7() {
                                                    match () {
                                                        () => {
                                                            if {
                                                                        const CHECK: bool =
                                                                            {
                                                                                const fn check() -> bool {
                                                                                    let module_path =
                                                                                        "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                    if if 19usize > module_path.len() {
                                                                                                    false
                                                                                                } else {
                                                                                                   module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                           && module_path[2usize] == 97u8 &&
                                                                                                                                                                       module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                               && module_path[5usize] == 98u8 &&
                                                                                                                                                           module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                   && module_path[8usize] == 95u8 &&
                                                                                                                                               module_path[9usize] == 101u8 &&
                                                                                                                                           module_path[10usize] == 115u8 &&
                                                                                                                                       module_path[11usize] == 112u8 &&
                                                                                                                                   module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                           && module_path[14usize] == 99u8 &&
                                                                                                                       module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                               && module_path[17usize] == 118u8 &&
                                                                                                           module_path[18usize] == 50u8 &&
                                                                                                       if 19usize == module_path.len() {
                                                                                                               true
                                                                                                           } else { module_path[19usize] == b':' }
                                                                                               } {
                                                                                            return true;
                                                                                        }
                                                                                    false
                                                                                }
                                                                                check()
                                                                            };
                                                                        CHECK
                                                                    } {
                                                                    defmt::export::acquire_header_and_release(&{
                                                                                defmt::export::make_istr({
                                                                                        #[link_section =
                                                                                        ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b7 pressed\",\"disambiguator\":\"7385704043632014317\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        #[export_name =
                                                                                        "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b7 pressed\",\"disambiguator\":\"7385704043632014317\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                    })
                                                                            });
                                                                }
                                                        }
                                                    };
                                                    KIA_EVENTS.send(KiaEvent::Button(Action::Pressed(Button::B7))).await;
                                                    LCD_EVENTS.send(LcdEvent::Button(Action::Pressed(Button::B7))).await;
                                                } else {
                                                   match () {
                                                       () => {
                                                           if {
                                                                       const CHECK: bool =
                                                                           {
                                                                               const fn check() -> bool {
                                                                                   let module_path =
                                                                                       "kia_obd2_esp32c3_v2::tasks::buttons".as_bytes();
                                                                                   if if 19usize > module_path.len() {
                                                                                                   false
                                                                                               } else {
                                                                                                  module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                          && module_path[2usize] == 97u8 &&
                                                                                                                                                                      module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                              && module_path[5usize] == 98u8 &&
                                                                                                                                                          module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                  && module_path[8usize] == 95u8 &&
                                                                                                                                              module_path[9usize] == 101u8 &&
                                                                                                                                          module_path[10usize] == 115u8 &&
                                                                                                                                      module_path[11usize] == 112u8 &&
                                                                                                                                  module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                          && module_path[14usize] == 99u8 &&
                                                                                                                      module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                              && module_path[17usize] == 118u8 &&
                                                                                                          module_path[18usize] == 50u8 &&
                                                                                                      if 19usize == module_path.len() {
                                                                                                              true
                                                                                                          } else { module_path[19usize] == b':' }
                                                                                              } {
                                                                                           return true;
                                                                                       }
                                                                                   false
                                                                               }
                                                                               check()
                                                                           };
                                                                       CHECK
                                                                   } {
                                                                   defmt::export::acquire_header_and_release(&{
                                                                               defmt::export::make_istr({
                                                                                       #[link_section =
                                                                                       ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b7 released\",\"disambiguator\":\"2946239640227013544\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       #[export_name =
                                                                                       "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button b7 released\",\"disambiguator\":\"2946239640227013544\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                       static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                       &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                   })
                                                                           });
                                                               }
                                                       }
                                                   };
                                                   KIA_EVENTS.send(KiaEvent::Button(Action::Released(Button::B7))).await;
                                                   LCD_EVENTS.send(LcdEvent::Button(Action::Released(Button::B7))).await;
                                               }
                                        }
                                }
                            old_touched = new_touched;
                            old_touched_bytes = new_touched_bytes;
                            if last_touched.elapsed() <
                                        embassy_time::Duration::from_millis(50) {
                                    embassy_time::Timer::after(embassy_time::Duration::from_millis(200)).await;
                                    fast_loops += 1;
                                    if fast_loops > 10 {
                                            embassy_time::with_timeout(embassy_time::Duration::from_secs(1),
                                                        cap1188.wait_for_released()).await.ok();
                                            fast_loops = 0;
                                        }
                                }
                            last_touched = embassy_time::Instant::now();
                        }
                    },
                    async {
                        if !shutdown_on_init {
                                get_shutdown_signal().next_message_pure().await
                            }
                    }).await;
            cap1188.shutdown().await.ok();
        }
        pub fn run(cap1188: Cap1188) -> ::embassy_executor::SpawnToken<impl Sized> {
            trait _EmbassyInternalTaskTrait {
                type Fut: ::core::future::Future + 'static;
                fn construct(cap1188: Cap1188) -> Self::Fut;
            }
            impl _EmbassyInternalTaskTrait for () {
                type Fut = impl core::future::Future + 'static;
                fn construct(cap1188: Cap1188) -> Self::Fut {
                    __run_task(cap1188)
                }
            }
            const POOL_SIZE: usize = 1;
            static POOL: ::embassy_executor::raw::TaskPool<
                <() as _EmbassyInternalTaskTrait>::Fut,
                POOL_SIZE,
            > = ::embassy_executor::raw::TaskPool::new();
            unsafe {
                POOL._spawn_async_fn(move || <() as _EmbassyInternalTaskTrait>::construct(cap1188))
            }
        }
        pub fn init() {
            INIT_BUTTONS.signal(());
        }
    }
    pub mod can_listen {
        use core::sync::atomic::{AtomicUsize, Ordering};
        use defmt::{error, info, Format};
        use embassy_futures::select::select;
        use embassy_sync::{blocking_mutex::raw::CriticalSectionRawMutex, mutex::Mutex, signal::Signal};
        use embassy_time::{with_timeout, Duration};
        use serde::{Deserialize, Serialize};
        pub use types::{Pid as Obd2Event, PidError as Obd2Error};
        use crate::{
            mcp2515::{clock_16mhz, OperationMode, CANINTE, CLKPRE, RXB0CTRL, RXB1CTRL, RXM},
            tasks::power::ShutdownGuard,
            types::Mcp2515,
        };
        #[doc(hidden)]
        async fn __run_task(mut can_listen: Mcp2515) {
            return;
            embassy_time::Timer::after(Duration::from_secs(10)).await;
            let _shutdown_guard = ShutdownGuard::new();
            let config = crate::mcp2515::Config::default()
                .mode(OperationMode::NormalOperation)
                .bitrate(clock_16mhz::CNF_500K_BPS)
                .set_clk_prescaler(CLKPRE::SystemClockDiv2)
                .receive_buffer_0(
                    RXB0CTRL::default()
                        .with_rxm(RXM::ReceiveAny)
                        .with_bukt(true),
                )
                .receive_buffer_1(RXB1CTRL::default().with_rxm(RXM::ReceiveAny));
            can_listen.apply_config(&config, false).await.ok();
            let interputs_config = CANINTE::default().with_rx0ie(true).with_rx1ie(true);
            can_listen
                .apply_interrupts_config(interputs_config)
                .await
                .ok();
            with_timeout(Duration::from_secs(120), can_listen.shutdown())
                .await
                .ok();
        }
        pub fn run(can_listen: Mcp2515) -> ::embassy_executor::SpawnToken<impl Sized> {
            trait _EmbassyInternalTaskTrait {
                type Fut: ::core::future::Future + 'static;
                fn construct(can_listen: Mcp2515) -> Self::Fut;
            }
            impl _EmbassyInternalTaskTrait for () {
                type Fut = impl core::future::Future + 'static;
                fn construct(can_listen: Mcp2515) -> Self::Fut {
                    __run_task(can_listen)
                }
            }
            const POOL_SIZE: usize = 1;
            static POOL: ::embassy_executor::raw::TaskPool<
                <() as _EmbassyInternalTaskTrait>::Fut,
                POOL_SIZE,
            > = ::embassy_executor::raw::TaskPool::new();
            unsafe {
                POOL._spawn_async_fn(move || {
                    <() as _EmbassyInternalTaskTrait>::construct(can_listen)
                })
            }
        }
    }
    pub mod ieee802154 {
        use defmt::{error, info, unwrap, warn, Format};
        use embassy_executor::Spawner;
        use embassy_futures::select::{select, select4, Either4::*};
        use embassy_sync::{
            blocking_mutex::raw::CriticalSectionRawMutex,
            channel::Channel,
            mutex::Mutex,
            pubsub::{DynPublisher, PubSubChannel},
            signal::Signal,
        };
        use embassy_time::{with_timeout, Duration, Instant, Ticker, Timer};
        use esp_hal::aes::{dma::AesDma, Aes, Mode};
        use esp_ieee802154::{Config, Frame, Ieee802154, ReceivedFrame};
        use ieee802154::mac::{
            Address, FrameContent, FrameType, FrameVersion, Header, PanId, ShortAddress,
        };
        use serde::{Deserialize, Serialize};
        use serde_encrypt::{
            serialize::impls::PostcardSerializer, shared_key::SharedKey,
            traits::SerdeEncryptSharedKey,
        };
        use static_cell::StaticCell;
        use types::{MessageId, Pid, RxFrame, RxMessage, TxFrame, TxMessage};
        use super::power::ShutdownGuard;
        use crate::{
            event::{event_bus_sub, Event, KiaEvent},
            tasks::{obd2, power::get_shutdown_signal},
        };
        static SEND_NOW_SIGNAL: Signal<CriticalSectionRawMutex, ()> = Signal::new();
        static EXTRA_SEND: PubSubChannel<CriticalSectionRawMutex, types::TxFrame, 64, 1, 32> =
            PubSubChannel::new();
        static PIDS_SEND: Mutex<CriticalSectionRawMutex, heapless::FnvIndexSet<Pid, 64>> =
            Mutex::new(heapless::FnvIndexSet::new());
        static PID_ERRORS_SEND: Mutex<
            CriticalSectionRawMutex,
            heapless::FnvIndexSet<types::PidError, 64>,
        > = Mutex::new(heapless::FnvIndexSet::new());
        static LAST_SEND: Mutex<CriticalSectionRawMutex, Instant> =
            Mutex::new(Instant::from_ticks(0));
        static LAST_RECEIVE: Mutex<CriticalSectionRawMutex, Instant> =
            Mutex::new(Instant::from_ticks(0));
        static LAST_POSITION: Mutex<CriticalSectionRawMutex, Instant> =
            Mutex::new(Instant::from_ticks(0));
        #[doc(hidden)]
        async fn __run_task(ieee802154: Ieee802154<'static>, spawner: Spawner) {
            spawner.must_spawn(ieee802154_run(ieee802154));
            let send_ticker_duration = Duration::from_secs(15);
            let mut send_ticker = Ticker::every(send_ticker_duration);
            let _shutdown_guard = ShutdownGuard::new();
            let mut shutdown_signal = get_shutdown_signal();
            let mut extra_send_sub = match defmt::export::into_result(EXTRA_SEND.subscriber()) {
                ::core::result::Result::Ok(res) => res,
                ::core::result::Result::Err(_unwrap_err) => {
                    match (&(_unwrap_err)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: EXTRA_SEND.subscriber()'\\nerror: `{:?}`\",\"disambiguator\":\"17645953318716405144\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: EXTRA_SEND.subscriber()'\\nerror: `{:?}`\",\"disambiguator\":\"17645953318716405144\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    defmt::export::panic()
                }
            };
            let txmessage_pub = IEEE802154_SEND.sender();
            let rxmessage_sub = IEEE802154_RECEIVE.receiver();
            {
                let bootup_start = Instant::now();
                loop {
                    txmessage_pub
                        .send(TxFrame::Modem(types::Modem::Ping).into())
                        .await;
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"ping sent\",\"disambiguator\":\"2977532551053940757\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"ping sent\",\"disambiguator\":\"2977532551053940757\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    match with_timeout(Duration::from_secs(10), rxmessage_sub.receive()).await {
                        Ok(rxmessage) => {
                            match rxmessage.frame {
                                RxFrame::Modem(types::Modem::Boot) => {
                                    match () {
                                        () => {
                                            if {
                                                const CHECK: bool = {
                                                    const fn check() -> bool {
                                                        let module_path =
                                                                        "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                        if if 19usize > module_path.len() {
                                                            false
                                                        } else {
                                                            module_path[0usize] == 107u8
                                                                && module_path[1usize] == 105u8
                                                                && module_path[2usize] == 97u8
                                                                && module_path[3usize] == 95u8
                                                                && module_path[4usize] == 111u8
                                                                && module_path[5usize] == 98u8
                                                                && module_path[6usize] == 100u8
                                                                && module_path[7usize] == 50u8
                                                                && module_path[8usize] == 95u8
                                                                && module_path[9usize] == 101u8
                                                                && module_path[10usize] == 115u8
                                                                && module_path[11usize] == 112u8
                                                                && module_path[12usize] == 51u8
                                                                && module_path[13usize] == 50u8
                                                                && module_path[14usize] == 99u8
                                                                && module_path[15usize] == 51u8
                                                                && module_path[16usize] == 95u8
                                                                && module_path[17usize] == 118u8
                                                                && module_path[18usize] == 50u8
                                                                && if 19usize == module_path.len() {
                                                                    true
                                                                } else {
                                                                    module_path[19usize] == b':'
                                                                }
                                                        } {
                                                            return true;
                                                        }
                                                        false
                                                    }
                                                    check()
                                                };
                                                CHECK
                                            } {
                                                defmt::export::acquire_header_and_release(&{
                                                    defmt::export::make_istr({
                                                        #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem boot received\",\"disambiguator\":\"9445469121399806108\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem boot received\",\"disambiguator\":\"9445469121399806108\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                    })
                                                });
                                            }
                                        }
                                    };
                                    break;
                                }
                                RxFrame::Modem(types::Modem::Pong) => {
                                    match () {
                                        () => {
                                            if {
                                                const CHECK: bool = {
                                                    const fn check() -> bool {
                                                        let module_path =
                                                                        "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                        if if 19usize > module_path.len() {
                                                            false
                                                        } else {
                                                            module_path[0usize] == 107u8
                                                                && module_path[1usize] == 105u8
                                                                && module_path[2usize] == 97u8
                                                                && module_path[3usize] == 95u8
                                                                && module_path[4usize] == 111u8
                                                                && module_path[5usize] == 98u8
                                                                && module_path[6usize] == 100u8
                                                                && module_path[7usize] == 50u8
                                                                && module_path[8usize] == 95u8
                                                                && module_path[9usize] == 101u8
                                                                && module_path[10usize] == 115u8
                                                                && module_path[11usize] == 112u8
                                                                && module_path[12usize] == 51u8
                                                                && module_path[13usize] == 50u8
                                                                && module_path[14usize] == 99u8
                                                                && module_path[15usize] == 51u8
                                                                && module_path[16usize] == 95u8
                                                                && module_path[17usize] == 118u8
                                                                && module_path[18usize] == 50u8
                                                                && if 19usize == module_path.len() {
                                                                    true
                                                                } else {
                                                                    module_path[19usize] == b':'
                                                                }
                                                        } {
                                                            return true;
                                                        }
                                                        false
                                                    }
                                                    check()
                                                };
                                                CHECK
                                            } {
                                                defmt::export::acquire_header_and_release(&{
                                                    defmt::export::make_istr({
                                                        #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem pong received\",\"disambiguator\":\"1756326109354869480\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem pong received\",\"disambiguator\":\"1756326109354869480\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                    })
                                                });
                                            }
                                        }
                                    };
                                    break;
                                }
                                rxmessage => {
                                    match (&(rxmessage)) {
                                        (arg0) => {
                                            if {
                                                const CHECK: bool = {
                                                    const fn check() -> bool {
                                                        let module_path =
                                                                        "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                        if if 19usize > module_path.len() {
                                                            false
                                                        } else {
                                                            module_path[0usize] == 107u8
                                                                && module_path[1usize] == 105u8
                                                                && module_path[2usize] == 97u8
                                                                && module_path[3usize] == 95u8
                                                                && module_path[4usize] == 111u8
                                                                && module_path[5usize] == 98u8
                                                                && module_path[6usize] == 100u8
                                                                && module_path[7usize] == 50u8
                                                                && module_path[8usize] == 95u8
                                                                && module_path[9usize] == 101u8
                                                                && module_path[10usize] == 115u8
                                                                && module_path[11usize] == 112u8
                                                                && module_path[12usize] == 51u8
                                                                && module_path[13usize] == 50u8
                                                                && module_path[14usize] == 99u8
                                                                && module_path[15usize] == 51u8
                                                                && module_path[16usize] == 95u8
                                                                && module_path[17usize] == 118u8
                                                                && module_path[18usize] == 50u8
                                                                && if 19usize == module_path.len() {
                                                                    true
                                                                } else {
                                                                    module_path[19usize] == b':'
                                                                }
                                                        } {
                                                            return true;
                                                        }
                                                        false
                                                    }
                                                    check()
                                                };
                                                CHECK
                                            } {
                                                unsafe {
                                                    defmt::export::acquire_and_header(&{
                                                        defmt::export::make_istr({
                                                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"no modem bootup message received, got: {:?}\",\"disambiguator\":\"2442979295870534030\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"no modem bootup message received, got: {:?}\",\"disambiguator\":\"2442979295870534030\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                        })
                                                    });
                                                };
                                                defmt::export::fmt(arg0);
                                                unsafe { defmt::export::release() }
                                            }
                                        }
                                    };
                                }
                            }
                        }
                        Err(_err) => {
                            match () {
                                () => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::ieee802154"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        defmt::export::acquire_header_and_release(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"ieee802154.receive() timeout\",\"disambiguator\":\"10167668064551207500\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"ieee802154.receive() timeout\",\"disambiguator\":\"10167668064551207500\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    }
                                }
                            };
                        }
                    }
                    if bootup_start.elapsed() > Duration::from_secs(60) {
                        match () {
                            () => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    defmt::export::acquire_header_and_release(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"modem bootup timeout\",\"disambiguator\":\"4229727137357424473\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"modem bootup timeout\",\"disambiguator\":\"4229727137357424473\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                }
                            }
                        };
                        break;
                    }
                }
            }
            let mut state: Option<types::State> = None;
            let mut last_send = Instant::now();
            loop {
                match select4(async {
                                match select(send_ticker.next(),
                                            SEND_NOW_SIGNAL.wait()).await {
                                    embassy_futures::select::Either::First(_) =>
                                        match () {
                                            () => {
                                                if {
                                                            const CHECK: bool =
                                                                {
                                                                    const fn check() -> bool {
                                                                        let module_path =
                                                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                                        if if 19usize > module_path.len() {
                                                                                        false
                                                                                    } else {
                                                                                       module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                               && module_path[2usize] == 97u8 &&
                                                                                                                                                           module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                   && module_path[5usize] == 98u8 &&
                                                                                                                                               module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                       && module_path[8usize] == 95u8 &&
                                                                                                                                   module_path[9usize] == 101u8 &&
                                                                                                                               module_path[10usize] == 115u8 &&
                                                                                                                           module_path[11usize] == 112u8 &&
                                                                                                                       module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                               && module_path[14usize] == 99u8 &&
                                                                                                           module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                   && module_path[17usize] == 118u8 &&
                                                                                               module_path[18usize] == 50u8 &&
                                                                                           if 19usize == module_path.len() {
                                                                                                   true
                                                                                               } else { module_path[19usize] == b':' }
                                                                                   } {
                                                                                return true;
                                                                            }
                                                                        false
                                                                    }
                                                                    check()
                                                                };
                                                            CHECK
                                                        } {
                                                        defmt::export::acquire_header_and_release(&{
                                                                    defmt::export::make_istr({
                                                                            #[link_section =
                                                                            ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"send ticker\",\"disambiguator\":\"2784703190016212856\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            #[export_name =
                                                                            "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"send ticker\",\"disambiguator\":\"2784703190016212856\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                        })
                                                                });
                                                    }
                                            }
                                        },
                                    embassy_futures::select::Either::Second(_) =>
                                        match () {
                                            () => {
                                                if {
                                                            const CHECK: bool =
                                                                {
                                                                    const fn check() -> bool {
                                                                        let module_path =
                                                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                                        if if 19usize > module_path.len() {
                                                                                        false
                                                                                    } else {
                                                                                       module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                               && module_path[2usize] == 97u8 &&
                                                                                                                                                           module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                   && module_path[5usize] == 98u8 &&
                                                                                                                                               module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                       && module_path[8usize] == 95u8 &&
                                                                                                                                   module_path[9usize] == 101u8 &&
                                                                                                                               module_path[10usize] == 115u8 &&
                                                                                                                           module_path[11usize] == 112u8 &&
                                                                                                                       module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                               && module_path[14usize] == 99u8 &&
                                                                                                           module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                   && module_path[17usize] == 118u8 &&
                                                                                               module_path[18usize] == 50u8 &&
                                                                                           if 19usize == module_path.len() {
                                                                                                   true
                                                                                               } else { module_path[19usize] == b':' }
                                                                                   } {
                                                                                return true;
                                                                            }
                                                                        false
                                                                    }
                                                                    check()
                                                                };
                                                            CHECK
                                                        } {
                                                        defmt::export::acquire_header_and_release(&{
                                                                    defmt::export::make_istr({
                                                                            #[link_section =
                                                                            ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"send now\",\"disambiguator\":\"577395289791037200\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            #[export_name =
                                                                            "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"send now\",\"disambiguator\":\"577395289791037200\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                        })
                                                                });
                                                    }
                                            }
                                        },
                                }
                                if last_send.elapsed().as_secs() < 15 {
                                        Timer::after_secs(1).await;
                                    }
                                last_send = Instant::now();
                            }, shutdown_signal.next_message_pure(),
                            extra_send_sub.next_message_pure(),
                            rxmessage_sub.receive()).await {
                    First(_) => {
                        let now = embassy_time::Instant::now();
                        let obd2_pids;
                        {
                            let mut obd2_pids_lock = PIDS_SEND.lock().await;
                            obd2_pids = obd2_pids_lock.clone();
                            obd2_pids_lock.clear();
                        }
                        let mut pids_send = false;
                        for pid in obd2_pids.iter() {
                            txmessage_pub.send(TxFrame::Obd2Pid(pid.clone()).into()).await;
                            embassy_time::Timer::after(embassy_time::Duration::from_millis(25)).await;
                            pids_send = true;
                        }
                        let mut pid_errors_send = PID_ERRORS_SEND.lock().await;
                        for pid_error in pid_errors_send.iter() {
                            txmessage_pub.send(TxFrame::Obd2PidError(pid_error.clone()).into()).await;
                            embassy_time::Timer::after(embassy_time::Duration::from_millis(25)).await;
                        }
                        pid_errors_send.clear();
                        if let Some(state) = &state {
                                match (&(state)) {
                                    (arg0) => {
                                        if {
                                                    const CHECK: bool =
                                                        {
                                                            const fn check() -> bool {
                                                                let module_path =
                                                                    "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                                if if 19usize > module_path.len() {
                                                                                false
                                                                            } else {
                                                                               module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                       && module_path[2usize] == 97u8 &&
                                                                                                                                                   module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                           && module_path[5usize] == 98u8 &&
                                                                                                                                       module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                               && module_path[8usize] == 95u8 &&
                                                                                                                           module_path[9usize] == 101u8 &&
                                                                                                                       module_path[10usize] == 115u8 &&
                                                                                                                   module_path[11usize] == 112u8 &&
                                                                                                               module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                       && module_path[14usize] == 99u8 &&
                                                                                                   module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                           && module_path[17usize] == 118u8 &&
                                                                                       module_path[18usize] == 50u8 &&
                                                                                   if 19usize == module_path.len() {
                                                                                           true
                                                                                       } else { module_path[19usize] == b':' }
                                                                           } {
                                                                        return true;
                                                                    }
                                                                false
                                                            }
                                                            check()
                                                        };
                                                    CHECK
                                                } {
                                                unsafe {
                                                    defmt::export::acquire_and_header(&{
                                                                defmt::export::make_istr({
                                                                        #[link_section =
                                                                        ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"sending extra state: {:?}\",\"disambiguator\":\"3191723301754109953\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                        #[export_name =
                                                                        "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"sending extra state: {:?}\",\"disambiguator\":\"3191723301754109953\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                    })
                                                            });
                                                };
                                                defmt::export::fmt(arg0);
                                                unsafe { defmt::export::release() }
                                            }
                                    }
                                };
                                if pids_send {
                                        txmessage_pub.send(TxFrame::State(state.clone()).into()).await;
                                    }
                            }
                        txmessage_pub.send(TxFrame::Temperature(crate::tasks::temperature::get_temperature()).into()).await;
                        match (&(now.elapsed().as_millis())) {
                            (arg0) => {
                                if {
                                            const CHECK: bool =
                                                {
                                                    const fn check() -> bool {
                                                        let module_path =
                                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                        if if 19usize > module_path.len() {
                                                                        false
                                                                    } else {
                                                                       module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                               && module_path[2usize] == 97u8 &&
                                                                                                                                           module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                   && module_path[5usize] == 98u8 &&
                                                                                                                               module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                       && module_path[8usize] == 95u8 &&
                                                                                                                   module_path[9usize] == 101u8 &&
                                                                                                               module_path[10usize] == 115u8 &&
                                                                                                           module_path[11usize] == 112u8 &&
                                                                                                       module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                               && module_path[14usize] == 99u8 &&
                                                                                           module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                   && module_path[17usize] == 118u8 &&
                                                                               module_path[18usize] == 50u8 &&
                                                                           if 19usize == module_path.len() {
                                                                                   true
                                                                               } else { module_path[19usize] == b':' }
                                                                   } {
                                                                return true;
                                                            }
                                                        false
                                                    }
                                                    check()
                                                };
                                            CHECK
                                        } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                        defmt::export::make_istr({
                                                                #[link_section =
                                                                ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"send_ticker elapsed: {:?}ms\",\"disambiguator\":\"7227057446357760912\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                #[export_name =
                                                                "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"send_ticker elapsed: {:?}ms\",\"disambiguator\":\"7227057446357760912\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                            })
                                                    });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                            }
                        };
                        send_ticker.reset();
                    }
                    Second(_) => {
                        match () {
                            () => {
                                if {
                                            const CHECK: bool =
                                                {
                                                    const fn check() -> bool {
                                                        let module_path =
                                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                        if if 19usize > module_path.len() {
                                                                        false
                                                                    } else {
                                                                       module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                               && module_path[2usize] == 97u8 &&
                                                                                                                                           module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                   && module_path[5usize] == 98u8 &&
                                                                                                                               module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                       && module_path[8usize] == 95u8 &&
                                                                                                                   module_path[9usize] == 101u8 &&
                                                                                                               module_path[10usize] == 115u8 &&
                                                                                                           module_path[11usize] == 112u8 &&
                                                                                                       module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                               && module_path[14usize] == 99u8 &&
                                                                                           module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                   && module_path[17usize] == 118u8 &&
                                                                               module_path[18usize] == 50u8 &&
                                                                           if 19usize == module_path.len() {
                                                                                   true
                                                                               } else { module_path[19usize] == b':' }
                                                                   } {
                                                                return true;
                                                            }
                                                        false
                                                    }
                                                    check()
                                                };
                                            CHECK
                                        } {
                                        defmt::export::acquire_header_and_release(&{
                                                    defmt::export::make_istr({
                                                            #[link_section =
                                                            ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"ieee802154 shutdown\",\"disambiguator\":\"1843482281388688112\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                            #[export_name =
                                                            "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"ieee802154 shutdown\",\"disambiguator\":\"1843482281388688112\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                        })
                                                });
                                    }
                            }
                        };
                        txmessage_pub.send(types::TxFrame::Shutdown.into()).await;
                        break;
                    }
                    Third(extra_txframe) => {
                        match &extra_txframe {
                            types::TxFrame::State(new_state) => {
                                state = Some(new_state.clone());
                            }
                            _ => {}
                        }
                        txmessage_pub.send(extra_txframe.into()).await;
                    }
                    Fourth(received_frame) =>
                        match received_frame.frame {
                            types::RxFrame::Modem(modem) =>
                                match modem {
                                    types::Modem::Reset =>
                                        match () {
                                            () => {
                                                if {
                                                            const CHECK: bool =
                                                                {
                                                                    const fn check() -> bool {
                                                                        let module_path =
                                                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                                        if if 19usize > module_path.len() {
                                                                                        false
                                                                                    } else {
                                                                                       module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                               && module_path[2usize] == 97u8 &&
                                                                                                                                                           module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                   && module_path[5usize] == 98u8 &&
                                                                                                                                               module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                       && module_path[8usize] == 95u8 &&
                                                                                                                                   module_path[9usize] == 101u8 &&
                                                                                                                               module_path[10usize] == 115u8 &&
                                                                                                                           module_path[11usize] == 112u8 &&
                                                                                                                       module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                               && module_path[14usize] == 99u8 &&
                                                                                                           module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                   && module_path[17usize] == 118u8 &&
                                                                                               module_path[18usize] == 50u8 &&
                                                                                           if 19usize == module_path.len() {
                                                                                                   true
                                                                                               } else { module_path[19usize] == b':' }
                                                                                   } {
                                                                                return true;
                                                                            }
                                                                        false
                                                                    }
                                                                    check()
                                                                };
                                                            CHECK
                                                        } {
                                                        defmt::export::acquire_header_and_release(&{
                                                                    defmt::export::make_istr({
                                                                            #[link_section =
                                                                            ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem reset\",\"disambiguator\":\"1867990215436527883\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            #[export_name =
                                                                            "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem reset\",\"disambiguator\":\"1867990215436527883\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                        })
                                                                });
                                                    }
                                            }
                                        },
                                    types::Modem::GnssState(gnss_state) =>
                                        match (&(gnss_state)) {
                                            (arg0) => {
                                                if {
                                                            const CHECK: bool =
                                                                {
                                                                    const fn check() -> bool {
                                                                        let module_path =
                                                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                                        if if 19usize > module_path.len() {
                                                                                        false
                                                                                    } else {
                                                                                       module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                               && module_path[2usize] == 97u8 &&
                                                                                                                                                           module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                   && module_path[5usize] == 98u8 &&
                                                                                                                                               module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                       && module_path[8usize] == 95u8 &&
                                                                                                                                   module_path[9usize] == 101u8 &&
                                                                                                                               module_path[10usize] == 115u8 &&
                                                                                                                           module_path[11usize] == 112u8 &&
                                                                                                                       module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                               && module_path[14usize] == 99u8 &&
                                                                                                           module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                   && module_path[17usize] == 118u8 &&
                                                                                               module_path[18usize] == 50u8 &&
                                                                                           if 19usize == module_path.len() {
                                                                                                   true
                                                                                               } else { module_path[19usize] == b':' }
                                                                                   } {
                                                                                return true;
                                                                            }
                                                                        false
                                                                    }
                                                                    check()
                                                                };
                                                            CHECK
                                                        } {
                                                        unsafe {
                                                            defmt::export::acquire_and_header(&{
                                                                        defmt::export::make_istr({
                                                                                #[link_section =
                                                                                ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"gnss_state: {:?}\",\"disambiguator\":\"8853030352871624323\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                #[export_name =
                                                                                "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"gnss_state: {:?}\",\"disambiguator\":\"8853030352871624323\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                            })
                                                                    });
                                                        };
                                                        defmt::export::fmt(arg0);
                                                        unsafe { defmt::export::release() }
                                                    }
                                            }
                                        },
                                    types::Modem::GnssFix(gnss_fix) => {
                                        *LAST_POSITION.lock().await = Instant::now();
                                    }
                                    types::Modem::Connected =>
                                        match () {
                                            () => {
                                                if {
                                                            const CHECK: bool =
                                                                {
                                                                    const fn check() -> bool {
                                                                        let module_path =
                                                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                                        if if 19usize > module_path.len() {
                                                                                        false
                                                                                    } else {
                                                                                       module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                               && module_path[2usize] == 97u8 &&
                                                                                                                                                           module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                   && module_path[5usize] == 98u8 &&
                                                                                                                                               module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                       && module_path[8usize] == 95u8 &&
                                                                                                                                   module_path[9usize] == 101u8 &&
                                                                                                                               module_path[10usize] == 115u8 &&
                                                                                                                           module_path[11usize] == 112u8 &&
                                                                                                                       module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                               && module_path[14usize] == 99u8 &&
                                                                                                           module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                   && module_path[17usize] == 118u8 &&
                                                                                               module_path[18usize] == 50u8 &&
                                                                                           if 19usize == module_path.len() {
                                                                                                   true
                                                                                               } else { module_path[19usize] == b':' }
                                                                                   } {
                                                                                return true;
                                                                            }
                                                                        false
                                                                    }
                                                                    check()
                                                                };
                                                            CHECK
                                                        } {
                                                        defmt::export::acquire_header_and_release(&{
                                                                    defmt::export::make_istr({
                                                                            #[link_section =
                                                                            ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem connected\",\"disambiguator\":\"11636333868633116521\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            #[export_name =
                                                                            "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem connected\",\"disambiguator\":\"11636333868633116521\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                        })
                                                                });
                                                    }
                                            }
                                        },
                                    types::Modem::Disconnected =>
                                        match () {
                                            () => {
                                                if {
                                                            const CHECK: bool =
                                                                {
                                                                    const fn check() -> bool {
                                                                        let module_path =
                                                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                                        if if 19usize > module_path.len() {
                                                                                        false
                                                                                    } else {
                                                                                       module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                               && module_path[2usize] == 97u8 &&
                                                                                                                                                           module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                   && module_path[5usize] == 98u8 &&
                                                                                                                                               module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                       && module_path[8usize] == 95u8 &&
                                                                                                                                   module_path[9usize] == 101u8 &&
                                                                                                                               module_path[10usize] == 115u8 &&
                                                                                                                           module_path[11usize] == 112u8 &&
                                                                                                                       module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                               && module_path[14usize] == 99u8 &&
                                                                                                           module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                   && module_path[17usize] == 118u8 &&
                                                                                               module_path[18usize] == 50u8 &&
                                                                                           if 19usize == module_path.len() {
                                                                                                   true
                                                                                               } else { module_path[19usize] == b':' }
                                                                                   } {
                                                                                return true;
                                                                            }
                                                                        false
                                                                    }
                                                                    check()
                                                                };
                                                            CHECK
                                                        } {
                                                        defmt::export::acquire_header_and_release(&{
                                                                    defmt::export::make_istr({
                                                                            #[link_section =
                                                                            ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem disconnected\",\"disambiguator\":\"2933485167378521820\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            #[export_name =
                                                                            "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem disconnected\",\"disambiguator\":\"2933485167378521820\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                        })
                                                                });
                                                    }
                                            }
                                        },
                                    types::Modem::Battery { voltage, low_voltage, soc, charging
                                        } =>
                                        match (&(voltage), &(low_voltage), &(soc), &(charging)) {
                                            (arg0, arg1, arg2, arg3) => {
                                                if {
                                                            const CHECK: bool =
                                                                {
                                                                    const fn check() -> bool {
                                                                        let module_path =
                                                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                                        if if 19usize > module_path.len() {
                                                                                        false
                                                                                    } else {
                                                                                       module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                               && module_path[2usize] == 97u8 &&
                                                                                                                                                           module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                   && module_path[5usize] == 98u8 &&
                                                                                                                                               module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                       && module_path[8usize] == 95u8 &&
                                                                                                                                   module_path[9usize] == 101u8 &&
                                                                                                                               module_path[10usize] == 115u8 &&
                                                                                                                           module_path[11usize] == 112u8 &&
                                                                                                                       module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                               && module_path[14usize] == 99u8 &&
                                                                                                           module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                   && module_path[17usize] == 118u8 &&
                                                                                               module_path[18usize] == 50u8 &&
                                                                                           if 19usize == module_path.len() {
                                                                                                   true
                                                                                               } else { module_path[19usize] == b':' }
                                                                                   } {
                                                                                return true;
                                                                            }
                                                                        false
                                                                    }
                                                                    check()
                                                                };
                                                            CHECK
                                                        } {
                                                        unsafe {
                                                            defmt::export::acquire_and_header(&{
                                                                        defmt::export::make_istr({
                                                                                #[link_section =
                                                                                ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"battery: voltage: {:?} low_voltage: {:?} soc: {:?} charging: {:?}\",\"disambiguator\":\"12583721214296329441\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                #[export_name =
                                                                                "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"battery: voltage: {:?} low_voltage: {:?} soc: {:?} charging: {:?}\",\"disambiguator\":\"12583721214296329441\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                            })
                                                                    });
                                                        };
                                                        defmt::export::fmt(arg0);
                                                        defmt::export::fmt(arg1);
                                                        defmt::export::fmt(arg2);
                                                        defmt::export::fmt(arg3);
                                                        unsafe { defmt::export::release() }
                                                    }
                                            }
                                        },
                                    types::Modem::Boot =>
                                        match () {
                                            () => {
                                                if {
                                                            const CHECK: bool =
                                                                {
                                                                    const fn check() -> bool {
                                                                        let module_path =
                                                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                                        if if 19usize > module_path.len() {
                                                                                        false
                                                                                    } else {
                                                                                       module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                               && module_path[2usize] == 97u8 &&
                                                                                                                                                           module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                   && module_path[5usize] == 98u8 &&
                                                                                                                                               module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                       && module_path[8usize] == 95u8 &&
                                                                                                                                   module_path[9usize] == 101u8 &&
                                                                                                                               module_path[10usize] == 115u8 &&
                                                                                                                           module_path[11usize] == 112u8 &&
                                                                                                                       module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                               && module_path[14usize] == 99u8 &&
                                                                                                           module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                   && module_path[17usize] == 118u8 &&
                                                                                               module_path[18usize] == 50u8 &&
                                                                                           if 19usize == module_path.len() {
                                                                                                   true
                                                                                               } else { module_path[19usize] == b':' }
                                                                                   } {
                                                                                return true;
                                                                            }
                                                                        false
                                                                    }
                                                                    check()
                                                                };
                                                            CHECK
                                                        } {
                                                        defmt::export::acquire_header_and_release(&{
                                                                    defmt::export::make_istr({
                                                                            #[link_section =
                                                                            ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem boot\",\"disambiguator\":\"12917620190796829298\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            #[export_name =
                                                                            "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem boot\",\"disambiguator\":\"12917620190796829298\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                        })
                                                                });
                                                    }
                                            }
                                        },
                                    types::Modem::Ping =>
                                        match () {
                                            () => {
                                                if {
                                                            const CHECK: bool =
                                                                {
                                                                    const fn check() -> bool {
                                                                        let module_path =
                                                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                                        if if 19usize > module_path.len() {
                                                                                        false
                                                                                    } else {
                                                                                       module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                               && module_path[2usize] == 97u8 &&
                                                                                                                                                           module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                   && module_path[5usize] == 98u8 &&
                                                                                                                                               module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                       && module_path[8usize] == 95u8 &&
                                                                                                                                   module_path[9usize] == 101u8 &&
                                                                                                                               module_path[10usize] == 115u8 &&
                                                                                                                           module_path[11usize] == 112u8 &&
                                                                                                                       module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                               && module_path[14usize] == 99u8 &&
                                                                                                           module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                   && module_path[17usize] == 118u8 &&
                                                                                               module_path[18usize] == 50u8 &&
                                                                                           if 19usize == module_path.len() {
                                                                                                   true
                                                                                               } else { module_path[19usize] == b':' }
                                                                                   } {
                                                                                return true;
                                                                            }
                                                                        false
                                                                    }
                                                                    check()
                                                                };
                                                            CHECK
                                                        } {
                                                        defmt::export::acquire_header_and_release(&{
                                                                    defmt::export::make_istr({
                                                                            #[link_section =
                                                                            ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem ping\",\"disambiguator\":\"15671761088068414811\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            #[export_name =
                                                                            "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem ping\",\"disambiguator\":\"15671761088068414811\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                        })
                                                                });
                                                    }
                                            }
                                        },
                                    types::Modem::Pong =>
                                        match () {
                                            () => {
                                                if {
                                                            const CHECK: bool =
                                                                {
                                                                    const fn check() -> bool {
                                                                        let module_path =
                                                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                                        if if 19usize > module_path.len() {
                                                                                        false
                                                                                    } else {
                                                                                       module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                               && module_path[2usize] == 97u8 &&
                                                                                                                                                           module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                   && module_path[5usize] == 98u8 &&
                                                                                                                                               module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                       && module_path[8usize] == 95u8 &&
                                                                                                                                   module_path[9usize] == 101u8 &&
                                                                                                                               module_path[10usize] == 115u8 &&
                                                                                                                           module_path[11usize] == 112u8 &&
                                                                                                                       module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                               && module_path[14usize] == 99u8 &&
                                                                                                           module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                   && module_path[17usize] == 118u8 &&
                                                                                               module_path[18usize] == 50u8 &&
                                                                                           if 19usize == module_path.len() {
                                                                                                   true
                                                                                               } else { module_path[19usize] == b':' }
                                                                                   } {
                                                                                return true;
                                                                            }
                                                                        false
                                                                    }
                                                                    check()
                                                                };
                                                            CHECK
                                                        } {
                                                        defmt::export::acquire_header_and_release(&{
                                                                    defmt::export::make_istr({
                                                                            #[link_section =
                                                                            ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem pong\",\"disambiguator\":\"8548627572230974370\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            #[export_name =
                                                                            "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"modem pong\",\"disambiguator\":\"8548627572230974370\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                        })
                                                                });
                                                    }
                                            }
                                        },
                                },
                            RxFrame::Obd2Frame(obd2_frame) => {
                                obd2::send_custom_frame(obd2_frame).await;
                            }
                            _ => {}
                        },
                }
            }
        }
        pub fn run(
            ieee802154: Ieee802154<'static>,
            spawner: Spawner,
        ) -> ::embassy_executor::SpawnToken<impl Sized> {
            trait _EmbassyInternalTaskTrait {
                type Fut: ::core::future::Future + 'static;
                fn construct(ieee802154: Ieee802154<'static>, spawner: Spawner) -> Self::Fut;
            }
            impl _EmbassyInternalTaskTrait for () {
                type Fut = impl core::future::Future + 'static;
                fn construct(ieee802154: Ieee802154<'static>, spawner: Spawner) -> Self::Fut {
                    __run_task(ieee802154, spawner)
                }
            }
            const POOL_SIZE: usize = 1;
            static POOL: ::embassy_executor::raw::TaskPool<
                <() as _EmbassyInternalTaskTrait>::Fut,
                POOL_SIZE,
            > = ::embassy_executor::raw::TaskPool::new();
            unsafe {
                POOL._spawn_async_fn(move || {
                    <() as _EmbassyInternalTaskTrait>::construct(ieee802154, spawner)
                })
            }
        }
        static IEEE802154_SEND: Channel<CriticalSectionRawMutex, TxMessage, 64> = Channel::new();
        static IEEE802154_RECEIVE: Channel<CriticalSectionRawMutex, RxMessage, 64> = Channel::new();
        #[doc(hidden)]
        async fn __ieee802154_run_task(mut ieee802154: Ieee802154<'static>) {
            use embassy_futures::select::{select3, Either3::*};
            ieee802154.set_config(Config {
                channel: 15,
                promiscuous: true,
                pan_id: Some(0x4242),
                short_addr: Some(0x2222),
                cca_mode: esp_ieee802154::CcaMode::Carrier,
                txpower: 20,
                rx_when_idle: true,
                auto_ack_tx: false,
                auto_ack_rx: false,
                ..Default::default()
            });
            let local_timeout = Duration::from_millis(50);
            let remote_timeout = Duration::from_secs(4);
            let mut ieee802154 = AsyncIeee802154::new(ieee802154);
            let _shutdown_guard = ShutdownGuard::new();
            let mut shutdown_signal = get_shutdown_signal();
            let ieee802154_send_sub = IEEE802154_SEND.receiver();
            let ieee802154_receive_pub = IEEE802154_RECEIVE.sender();
            loop {
                match select3(
                    ieee802154.receive(),
                    ieee802154_send_sub.receive(),
                    shutdown_signal.next_message_pure(),
                )
                .await
                {
                    First(rxmessage) => {
                        if let RxFrame::Modem(types::Modem::GnssFix(_)) = rxmessage.frame {
                        } else {
                            *LAST_RECEIVE.lock().await = Instant::now();
                        }
                        if ieee802154_receive_pub.is_full() {
                            match () {
                                () => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::ieee802154"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        defmt::export::acquire_header_and_release(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"ieee802154_receive_pub is full\",\"disambiguator\":\"10792710260314418818\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"ieee802154_receive_pub is full\",\"disambiguator\":\"10792710260314418818\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    }
                                }
                            };
                            ieee802154_receive_pub.clear();
                        }
                        ieee802154_receive_pub.send(rxmessage).await;
                    }
                    Second(txmessage) => {
                        let needs_ack = txmessage.needs_ack();
                        if let Err(err) = ieee802154
                            .transmit_txmessage(
                                txmessage,
                                5,
                                if needs_ack {
                                    remote_timeout
                                } else {
                                    local_timeout
                                },
                            )
                            .await
                        {
                            match (&(err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::ieee802154"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"ieee802154.transmit_txmessage failed: {:?}\",\"disambiguator\":\"17323281681194240065\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"ieee802154.transmit_txmessage failed: {:?}\",\"disambiguator\":\"17323281681194240065\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                        }
                    }
                    Third(_) => {
                        match () {
                            () => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    defmt::export::acquire_header_and_release(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"ieee802154 shutdown\",\"disambiguator\":\"152464914413044364\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"ieee802154 shutdown\",\"disambiguator\":\"152464914413044364\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                }
                            }
                        };
                        while let Ok(txmessage) = ieee802154_send_sub.try_receive() {
                            let needs_ack = txmessage.needs_ack();
                            if let Err(err) = ieee802154
                                .transmit_txmessage(
                                    txmessage,
                                    5,
                                    if needs_ack {
                                        remote_timeout
                                    } else {
                                        local_timeout
                                    },
                                )
                                .await
                            {
                                match (&(err)) {
                                    (arg0) => {
                                        if {
                                            const CHECK: bool = {
                                                const fn check() -> bool {
                                                    let module_path =
                                                        "kia_obd2_esp32c3_v2::tasks::ieee802154"
                                                            .as_bytes();
                                                    if if 19usize > module_path.len() {
                                                        false
                                                    } else {
                                                        module_path[0usize] == 107u8
                                                            && module_path[1usize] == 105u8
                                                            && module_path[2usize] == 97u8
                                                            && module_path[3usize] == 95u8
                                                            && module_path[4usize] == 111u8
                                                            && module_path[5usize] == 98u8
                                                            && module_path[6usize] == 100u8
                                                            && module_path[7usize] == 50u8
                                                            && module_path[8usize] == 95u8
                                                            && module_path[9usize] == 101u8
                                                            && module_path[10usize] == 115u8
                                                            && module_path[11usize] == 112u8
                                                            && module_path[12usize] == 51u8
                                                            && module_path[13usize] == 50u8
                                                            && module_path[14usize] == 99u8
                                                            && module_path[15usize] == 51u8
                                                            && module_path[16usize] == 95u8
                                                            && module_path[17usize] == 118u8
                                                            && module_path[18usize] == 50u8
                                                            && if 19usize == module_path.len() {
                                                                true
                                                            } else {
                                                                module_path[19usize] == b':'
                                                            }
                                                    } {
                                                        return true;
                                                    }
                                                    false
                                                }
                                                check()
                                            };
                                            CHECK
                                        } {
                                            unsafe {
                                                defmt::export::acquire_and_header(&{
                                                    defmt::export::make_istr({
                                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"ieee802154.transmit_txmessage failed: {:?}\",\"disambiguator\":\"16328538906594815621\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"ieee802154.transmit_txmessage failed: {:?}\",\"disambiguator\":\"16328538906594815621\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                    })
                                                });
                                            };
                                            defmt::export::fmt(arg0);
                                            unsafe { defmt::export::release() }
                                        }
                                    }
                                };
                            }
                        }
                        break;
                    }
                }
            }
        }
        fn ieee802154_run(
            ieee802154: Ieee802154<'static>,
        ) -> ::embassy_executor::SpawnToken<impl Sized> {
            trait _EmbassyInternalTaskTrait {
                type Fut: ::core::future::Future + 'static;
                fn construct(ieee802154: Ieee802154<'static>) -> Self::Fut;
            }
            impl _EmbassyInternalTaskTrait for () {
                type Fut = impl core::future::Future + 'static;
                fn construct(ieee802154: Ieee802154<'static>) -> Self::Fut {
                    __ieee802154_run_task(ieee802154)
                }
            }
            const POOL_SIZE: usize = 1;
            static POOL: ::embassy_executor::raw::TaskPool<
                <() as _EmbassyInternalTaskTrait>::Fut,
                POOL_SIZE,
            > = ::embassy_executor::raw::TaskPool::new();
            unsafe {
                POOL._spawn_async_fn(move || {
                    <() as _EmbassyInternalTaskTrait>::construct(ieee802154)
                })
            }
        }
        pub enum AsyncIeee802154Error {
            Timeout,
            Ieee802154(esp_ieee802154::Error),
            SerdeEncrypt,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AsyncIeee802154Error {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    AsyncIeee802154Error::Timeout => {
                        ::core::fmt::Formatter::write_str(f, "Timeout")
                    }
                    AsyncIeee802154Error::Ieee802154(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Ieee802154",
                            &__self_0,
                        )
                    }
                    AsyncIeee802154Error::SerdeEncrypt => {
                        ::core::fmt::Formatter::write_str(f, "SerdeEncrypt")
                    }
                }
            }
        }
        impl defmt::Format for AsyncIeee802154Error {
            fn format(&self, f: defmt::Formatter) {
                match self {
                    Self::Timeout => {
                        let _typecheck_formatter: defmt::Formatter<'_> = f;
                        match () {
                            () => {
                                defmt::export::istr(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_write\",\"data\":\"Timeout\",\"disambiguator\":\"1568222288829805112\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_write\",\"data\":\"Timeout\",\"disambiguator\":\"1568222288829805112\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static S: u8 = 0;
                                        &S as *const u8 as u16
                                    })
                                });
                            }
                        }
                    }
                    Self::Ieee802154(err) => {
                        let _typecheck_formatter: defmt::Formatter<'_> = f;
                        match (&(defmt::Debug2Format(err))) {
                            (arg0) => {
                                defmt::export::istr(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_write\",\"data\":\"Ieee802154({:?})\",\"disambiguator\":\"2117703745246903958\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_write\",\"data\":\"Ieee802154({:?})\",\"disambiguator\":\"2117703745246903958\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static S: u8 = 0;
                                        &S as *const u8 as u16
                                    })
                                });
                                defmt::export::fmt(arg0);
                            }
                        }
                    }
                    Self::SerdeEncrypt => {
                        let _typecheck_formatter: defmt::Formatter<'_> = f;
                        match () {
                            () => {
                                defmt::export::istr(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_write\",\"data\":\"SerdeEncrypt\",\"disambiguator\":\"1558335574299860309\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_write\",\"data\":\"SerdeEncrypt\",\"disambiguator\":\"1558335574299860309\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static S: u8 = 0;
                                        &S as *const u8 as u16
                                    })
                                });
                            }
                        }
                    }
                }
            }
        }
        impl From<esp_ieee802154::Error> for AsyncIeee802154Error {
            fn from(err: esp_ieee802154::Error) -> Self {
                Self::Ieee802154(err)
            }
        }
        impl From<serde_encrypt::Error> for AsyncIeee802154Error {
            fn from(_err: serde_encrypt::Error) -> Self {
                Self::SerdeEncrypt
            }
        }
        pub struct AsyncIeee802154 {
            ieee802154: Ieee802154<'static>,
            tx_done_signal: &'static Signal<CriticalSectionRawMutex, ()>,
            rx_available_signal: &'static Signal<CriticalSectionRawMutex, ()>,
            rxmessage_buffer: heapless::Vec<RxMessage, 16>,
            tx_seq_number: u8,
            rx_seq_number: u8,
        }
        impl AsyncIeee802154 {
            pub fn new(mut ieee802154: Ieee802154<'static>) -> Self {
                static TX_DONE_SIGNAL: embassy_sync::signal::Signal<
                    embassy_sync::blocking_mutex::raw::CriticalSectionRawMutex,
                    (),
                > = embassy_sync::signal::Signal::new();
                static RX_AVAILABLE_SIGNAL: Signal<CriticalSectionRawMutex, ()> = Signal::new();
                ieee802154.set_rx_available_callback_fn(|| {
                    RX_AVAILABLE_SIGNAL.signal(());
                });
                ieee802154.set_tx_done_callback_fn(|| {
                    TX_DONE_SIGNAL.signal(());
                });
                ieee802154.start_receive();
                Self {
                    ieee802154,
                    tx_done_signal: &TX_DONE_SIGNAL,
                    rx_available_signal: &RX_AVAILABLE_SIGNAL,
                    tx_seq_number: 0,
                    rx_seq_number: 0,
                    rxmessage_buffer: heapless::Vec::new(),
                }
            }
            pub async fn transmit_txmessage(
                &mut self,
                txmessage: TxMessage,
                retry: u8,
                timeout: Duration,
            ) -> Result<(), AsyncIeee802154Error> {
                let elapsed = Instant::now();
                let txmessage_id = txmessage.id;
                let buffer = txmessage.to_vec_encrypted()?;
                for current_retry in 0..retry {
                    let chunks = buffer.chunks(100);
                    let chunks_count = chunks.len();
                    for (c, chunk) in chunks.enumerate() {
                        let frame = Frame {
                            header: Header {
                                frame_type: FrameType::Data,
                                frame_pending: c == 0,
                                ack_request: true,
                                pan_id_compress: false,
                                seq_no_suppress: false,
                                ie_present: false,
                                version: FrameVersion::Ieee802154_2003,
                                seq: self.tx_seq_number,
                                destination: Some(Address::Short(
                                    PanId(chunks_count as u16),
                                    ShortAddress(c as u16),
                                )),
                                source: Some(Address::Short(PanId(0x2222), ShortAddress(0x2222))),
                                auxiliary_security_header: None,
                            },
                            content: FrameContent::Data,
                            payload: match defmt::export::into_result(heapless::Vec::from_slice(
                                chunk,
                            )) {
                                ::core::result::Result::Ok(res) => res,
                                ::core::result::Result::Err(_unwrap_err) => {
                                    match (&(_unwrap_err)) {
                                        (arg0) => {
                                            if {
                                                const CHECK: bool = {
                                                    const fn check() -> bool {
                                                        let module_path =
                                                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                        if if 19usize > module_path.len() {
                                                            false
                                                        } else {
                                                            module_path[0usize] == 107u8
                                                                && module_path[1usize] == 105u8
                                                                && module_path[2usize] == 97u8
                                                                && module_path[3usize] == 95u8
                                                                && module_path[4usize] == 111u8
                                                                && module_path[5usize] == 98u8
                                                                && module_path[6usize] == 100u8
                                                                && module_path[7usize] == 50u8
                                                                && module_path[8usize] == 95u8
                                                                && module_path[9usize] == 101u8
                                                                && module_path[10usize] == 115u8
                                                                && module_path[11usize] == 112u8
                                                                && module_path[12usize] == 51u8
                                                                && module_path[13usize] == 50u8
                                                                && module_path[14usize] == 99u8
                                                                && module_path[15usize] == 51u8
                                                                && module_path[16usize] == 95u8
                                                                && module_path[17usize] == 118u8
                                                                && module_path[18usize] == 50u8
                                                                && if 19usize == module_path.len() {
                                                                    true
                                                                } else {
                                                                    module_path[19usize] == b':'
                                                                }
                                                        } {
                                                            return true;
                                                        }
                                                        false
                                                    }
                                                    check()
                                                };
                                                CHECK
                                            } {
                                                unsafe {
                                                    defmt::export::acquire_and_header(&{
                                                        defmt::export::make_istr({
                                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: heapless :: Vec :: from_slice(chunk)'\\nerror: `{:?}`\",\"disambiguator\":\"16662366645540927109\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: heapless :: Vec :: from_slice(chunk)'\\nerror: `{:?}`\",\"disambiguator\":\"16662366645540927109\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                        })
                                                    });
                                                };
                                                defmt::export::fmt(arg0);
                                                unsafe { defmt::export::release() }
                                            }
                                        }
                                    };
                                    defmt::export::panic()
                                }
                            },
                            footer: [0, 0],
                        };
                        if self
                            .transmit_raw(&frame, Duration::from_millis(100))
                            .await
                            .is_err()
                        {
                            match () {
                                () => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::ieee802154"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        defmt::export::acquire_header_and_release(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"transmit_raw failed\",\"disambiguator\":\"7510212944223445245\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"transmit_raw failed\",\"disambiguator\":\"7510212944223445245\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    }
                                }
                            };
                        }
                        self.tx_seq_number = self.tx_seq_number.wrapping_add(1);
                    }
                    match with_timeout(timeout,
                                async {
                                    loop {
                                        let ack = self.receive_ack(txmessage_id).await;
                                        if ack == txmessage_id {
                                                if current_retry > 0 {
                                                        match (&(current_retry)) {
                                                            (arg0) => {
                                                                if {
                                                                            const CHECK: bool =
                                                                                {
                                                                                    const fn check() -> bool {
                                                                                        let module_path =
                                                                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                                                        if if 19usize > module_path.len() {
                                                                                                        false
                                                                                                    } else {
                                                                                                       module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                               && module_path[2usize] == 97u8 &&
                                                                                                                                                                           module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                                   && module_path[5usize] == 98u8 &&
                                                                                                                                                               module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                                       && module_path[8usize] == 95u8 &&
                                                                                                                                                   module_path[9usize] == 101u8 &&
                                                                                                                                               module_path[10usize] == 115u8 &&
                                                                                                                                           module_path[11usize] == 112u8 &&
                                                                                                                                       module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                               && module_path[14usize] == 99u8 &&
                                                                                                                           module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                                   && module_path[17usize] == 118u8 &&
                                                                                                               module_path[18usize] == 50u8 &&
                                                                                                           if 19usize == module_path.len() {
                                                                                                                   true
                                                                                                               } else { module_path[19usize] == b':' }
                                                                                                   } {
                                                                                                return true;
                                                                                            }
                                                                                        false
                                                                                    }
                                                                                    check()
                                                                                };
                                                                            CHECK
                                                                        } {
                                                                        unsafe {
                                                                            defmt::export::acquire_and_header(&{
                                                                                        defmt::export::make_istr({
                                                                                                #[link_section =
                                                                                                ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"ack received after retry: {}\",\"disambiguator\":\"16378459237157533822\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                                #[export_name =
                                                                                                "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"ack received after retry: {}\",\"disambiguator\":\"16378459237157533822\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                            })
                                                                                    });
                                                                        };
                                                                        defmt::export::fmt(arg0);
                                                                        unsafe { defmt::export::release() }
                                                                    }
                                                            }
                                                        };
                                                    }
                                                break;
                                            } else {
                                               match () {
                                                   () => {
                                                       if {
                                                                   const CHECK: bool =
                                                                       {
                                                                           const fn check() -> bool {
                                                                               let module_path =
                                                                                   "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                                               if if 19usize > module_path.len() {
                                                                                               false
                                                                                           } else {
                                                                                              module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                      && module_path[2usize] == 97u8 &&
                                                                                                                                                                  module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                          && module_path[5usize] == 98u8 &&
                                                                                                                                                      module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                              && module_path[8usize] == 95u8 &&
                                                                                                                                          module_path[9usize] == 101u8 &&
                                                                                                                                      module_path[10usize] == 115u8 &&
                                                                                                                                  module_path[11usize] == 112u8 &&
                                                                                                                              module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                      && module_path[14usize] == 99u8 &&
                                                                                                                  module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                          && module_path[17usize] == 118u8 &&
                                                                                                      module_path[18usize] == 50u8 &&
                                                                                                  if 19usize == module_path.len() {
                                                                                                          true
                                                                                                      } else { module_path[19usize] == b':' }
                                                                                          } {
                                                                                       return true;
                                                                                   }
                                                                               false
                                                                           }
                                                                           check()
                                                                       };
                                                                   CHECK
                                                               } {
                                                               defmt::export::acquire_header_and_release(&{
                                                                           defmt::export::make_istr({
                                                                                   #[link_section =
                                                                                   ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"ack != txmessage_id\",\"disambiguator\":\"5868458747468457862\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                   #[export_name =
                                                                                   "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"ack != txmessage_id\",\"disambiguator\":\"5868458747468457862\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                   static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                   &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                               })
                                                                       });
                                                           }
                                                   }
                                               };
                                           }
                                    }
                                }).await {
                        Ok(ack) => {
                            match (&(elapsed.elapsed().as_millis())) {
                                (arg0) => {
                                    if {
                                                const CHECK: bool =
                                                    {
                                                        const fn check() -> bool {
                                                            let module_path =
                                                                "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                            if if 19usize > module_path.len() {
                                                                            false
                                                                        } else {
                                                                           module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                   && module_path[2usize] == 97u8 &&
                                                                                                                                               module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                       && module_path[5usize] == 98u8 &&
                                                                                                                                   module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                           && module_path[8usize] == 95u8 &&
                                                                                                                       module_path[9usize] == 101u8 &&
                                                                                                                   module_path[10usize] == 115u8 &&
                                                                                                               module_path[11usize] == 112u8 &&
                                                                                                           module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                   && module_path[14usize] == 99u8 &&
                                                                                               module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                       && module_path[17usize] == 118u8 &&
                                                                                   module_path[18usize] == 50u8 &&
                                                                               if 19usize == module_path.len() {
                                                                                       true
                                                                                   } else { module_path[19usize] == b':' }
                                                                       } {
                                                                    return true;
                                                                }
                                                            false
                                                        }
                                                        check()
                                                    };
                                                CHECK
                                            } {
                                            unsafe {
                                                defmt::export::acquire_and_header(&{
                                                            defmt::export::make_istr({
                                                                    #[link_section =
                                                                    ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"transmit_tx message ok, elapsed: {}ms\",\"disambiguator\":\"4534927620332448938\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                    #[export_name =
                                                                    "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"transmit_tx message ok, elapsed: {}ms\",\"disambiguator\":\"4534927620332448938\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                })
                                                        });
                                            };
                                            defmt::export::fmt(arg0);
                                            unsafe { defmt::export::release() }
                                        }
                                }
                            };
                            return Ok(());
                        }
                        Err(_) => {
                            match (&(timeout.as_millis())) {
                                (arg0) => {
                                    if {
                                                const CHECK: bool =
                                                    {
                                                        const fn check() -> bool {
                                                            let module_path =
                                                                "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                                            if if 19usize > module_path.len() {
                                                                            false
                                                                        } else {
                                                                           module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                   && module_path[2usize] == 97u8 &&
                                                                                                                                               module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                       && module_path[5usize] == 98u8 &&
                                                                                                                                   module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                           && module_path[8usize] == 95u8 &&
                                                                                                                       module_path[9usize] == 101u8 &&
                                                                                                                   module_path[10usize] == 115u8 &&
                                                                                                               module_path[11usize] == 112u8 &&
                                                                                                           module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                   && module_path[14usize] == 99u8 &&
                                                                                               module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                       && module_path[17usize] == 118u8 &&
                                                                                   module_path[18usize] == 50u8 &&
                                                                               if 19usize == module_path.len() {
                                                                                       true
                                                                                   } else { module_path[19usize] == b':' }
                                                                       } {
                                                                    return true;
                                                                }
                                                            false
                                                        }
                                                        check()
                                                    };
                                                CHECK
                                            } {
                                            unsafe {
                                                defmt::export::acquire_and_header(&{
                                                            defmt::export::make_istr({
                                                                    #[link_section =
                                                                    ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"receive_ack timeout for txmessage: {}ms\",\"disambiguator\":\"2831061184297537325\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                    #[export_name =
                                                                    "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"receive_ack timeout for txmessage: {}ms\",\"disambiguator\":\"2831061184297537325\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                })
                                                        });
                                            };
                                            defmt::export::fmt(arg0);
                                            unsafe { defmt::export::release() }
                                        }
                                }
                            };
                        }
                    }
                }
                match (&(elapsed.elapsed().as_millis())) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path =
                                        "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe {
                                defmt::export::acquire_and_header(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"transmit_buffer elapsed: {}ms\",\"disambiguator\":\"8474160651387941907\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"transmit_buffer elapsed: {}ms\",\"disambiguator\":\"8474160651387941907\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            };
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                Err(AsyncIeee802154Error::Timeout)
            }
            async fn transmit_raw(
                &mut self,
                frame: &Frame,
                timeout: Duration,
            ) -> Result<(), AsyncIeee802154Error> {
                *LAST_SEND.lock().await = Instant::now();
                self.tx_done_signal.reset();
                self.ieee802154.transmit(frame)?;
                if with_timeout(timeout, self.tx_done_signal.wait())
                    .await
                    .is_err()
                {
                    match (&(timeout.as_millis())) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"timeout waiting for tx_done_signal, timeout was: {}ms\",\"disambiguator\":\"10475707683146672936\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"timeout waiting for tx_done_signal, timeout was: {}ms\",\"disambiguator\":\"10475707683146672936\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                }
                Ok(())
            }
            fn frame_seq_number_check(&mut self, frame: &ReceivedFrame) -> bool {
                let new_rx_seq_number = frame.frame.header.seq;
                if new_rx_seq_number == self.rx_seq_number {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"frame with same seq number received\",\"disambiguator\":\"1083634005039064221\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"frame with same seq number received\",\"disambiguator\":\"1083634005039064221\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    false
                } else if new_rx_seq_number == self.rx_seq_number.wrapping_add(1) {
                    self.rx_seq_number = new_rx_seq_number;
                    true
                } else if new_rx_seq_number == 0 && self.rx_seq_number == 0 {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"frame seq number both 0\",\"disambiguator\":\"16356319863794423030\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"frame seq number both 0\",\"disambiguator\":\"16356319863794423030\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    true
                } else {
                    match (&(self.rx_seq_number), &(new_rx_seq_number)) {
                        (arg0, arg1) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"frame seq number out of order, expected: {}, got: {}\",\"disambiguator\":\"5565225133632113707\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"frame seq number out of order, expected: {}, got: {}\",\"disambiguator\":\"5565225133632113707\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                defmt::export::fmt(arg1);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    self.rx_seq_number = new_rx_seq_number;
                    true
                }
            }
            pub async fn receive_raw(&mut self) -> ReceivedFrame {
                let msg = self.ieee802154.received();
                if let Some(Ok(frame)) = msg {
                    if self.frame_seq_number_check(&frame) {
                        match () {
                            () => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    defmt::export::acquire_header_and_release(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"early frame return\",\"disambiguator\":\"3079362076969326882\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"early frame return\",\"disambiguator\":\"3079362076969326882\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                }
                            }
                        };
                        return frame;
                    }
                }
                loop {
                    self.rx_available_signal.wait().await;
                    if let Some(Ok(frame)) = self.ieee802154.received() {
                        if self.frame_seq_number_check(&frame) {
                            return frame;
                        }
                    } else {
                    }
                }
            }
            pub async fn receive_ack(&mut self, txmessage_id: MessageId) -> types::MessageId {
                loop {
                    let rxmessage = self.internal_receive().await;
                    if let types::RxFrame::TxFrameAck(ack) = rxmessage.frame {
                        if ack == txmessage_id {
                            return ack;
                        } else {
                            match (&(ack), &(txmessage_id)) {
                                (arg0, arg1) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::ieee802154"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"ack != txmessage_id got: ack: {:?} txmessage_id: {:?}\",\"disambiguator\":\"2913413104033488432\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"ack != txmessage_id got: ack: {:?} txmessage_id: {:?}\",\"disambiguator\":\"2913413104033488432\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        defmt::export::fmt(arg1);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            self.rxmessage_buffer.push(rxmessage).ok();
                        }
                    } else {
                        match (&(rxmessage)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"no ack received_frame: {:?}\",\"disambiguator\":\"236181663132775240\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"no ack received_frame: {:?}\",\"disambiguator\":\"236181663132775240\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        self.rxmessage_buffer.push(rxmessage).ok();
                    }
                }
            }
            async fn internal_receive(&mut self) -> RxMessage {
                loop {
                    let received_frame = self.receive_raw().await;
                    if received_frame.frame.payload.len() < 2 {
                        match () {
                            () => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    defmt::export::acquire_header_and_release(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"received_frame.frame.payload.len() < 2\",\"disambiguator\":\"213768609061182086\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"received_frame.frame.payload.len() < 2\",\"disambiguator\":\"213768609061182086\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                }
                            }
                        };
                    } else {
                        match types::RxMessage::from_bytes_encrypted(
                            &received_frame.frame.payload
                                [0..received_frame.frame.payload.len() - 2],
                        ) {
                            Ok(rxmessage) => return rxmessage,
                            Err(err) => match (&(defmt::Debug2Format(&err))) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::ieee802154"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"RxMessage::from_bytes_encrypted failed: {:?}\",\"disambiguator\":\"7133597341470692547\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"RxMessage::from_bytes_encrypted failed: {:?}\",\"disambiguator\":\"7133597341470692547\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            },
                        }
                    }
                }
            }
            pub async fn receive(&mut self) -> RxMessage {
                loop {
                    if let Some(rxmessage) = self.rxmessage_buffer.pop() {
                        match (&(rxmessage)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"message from buffer: {:?}\",\"disambiguator\":\"5767184445236814372\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"message from buffer: {:?}\",\"disambiguator\":\"5767184445236814372\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        return rxmessage;
                    }
                    return self.internal_receive().await;
                }
            }
        }
        pub fn send_now() {
            SEND_NOW_SIGNAL.signal(());
        }
        pub type TxFramePub = DynPublisher<'static, types::TxFrame>;
        pub fn extra_txframes_pub() -> TxFramePub {
            match defmt::export::into_result(EXTRA_SEND.dyn_publisher()) {
                ::core::result::Result::Ok(res) => res,
                ::core::result::Result::Err(_unwrap_err) => {
                    match (&(_unwrap_err)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: EXTRA_SEND.dyn_publisher()'\\nerror: `{:?}`\",\"disambiguator\":\"11752366257041583297\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: EXTRA_SEND.dyn_publisher()'\\nerror: `{:?}`\",\"disambiguator\":\"11752366257041583297\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
        }
        pub async fn insert_send_pid(pid: &Pid) {
            let mut pids_send = PIDS_SEND.lock().await;
            pids_send.remove(pid);
            pids_send.insert(pid.clone()).ok();
        }
        pub async fn insert_send_pid_error(pid_error: &types::PidError) {
            match (&(pid_error)) {
                (arg0) => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path =
                                    "kia_obd2_esp32c3_v2::tasks::ieee802154".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe {
                            defmt::export::acquire_and_header(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"new pid error: {:?}\",\"disambiguator\":\"8313723143197904665\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"new pid error: {:?}\",\"disambiguator\":\"8313723143197904665\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        };
                        defmt::export::fmt(arg0);
                        unsafe { defmt::export::release() }
                    }
                }
            };
            let mut pid_errors_send = PID_ERRORS_SEND.lock().await;
            pid_errors_send.remove(pid_error);
            pid_errors_send.insert(pid_error.clone()).ok();
        }
        pub async fn clear_pids(pid: &Pid) {
            PIDS_SEND.lock().await.clear();
        }
        pub fn last_send() -> Option<Instant> {
            LAST_SEND.try_lock().ok().map(|lock| *lock)
        }
        pub fn last_receive() -> Option<Instant> {
            LAST_RECEIVE.try_lock().ok().map(|lock| *lock)
        }
        pub fn last_position() -> Option<Instant> {
            LAST_POSITION.try_lock().ok().map(|lock| *lock)
        }
    }
    pub mod lcd {
        use defmt::*;
        use embassy_futures::select::{select, Either::*};
        use embassy_sync::{
            blocking_mutex::raw::CriticalSectionRawMutex, channel::Channel, signal::Signal,
        };
        use embassy_time::{with_timeout, Duration, Timer};
        use embedded_graphics::geometry::{Point, Size};
        use heapless::String;
        use statig::prelude::*;
        use types::Pid as Obd2Event;
        use crate::{
            debug::DEBUG_STRING_LEN,
            display::widgets::{Battery, BatteryOrientation, DebugScroll},
            tasks::obd2::{obd2_init_wait, Obd2Debug},
            types::{Display1, Display2},
        };
        mod boot {
            use defmt::{info, unwrap};
            use embassy_sync::{
                blocking_mutex::raw::CriticalSectionRawMutex, mutex::Mutex, signal::Signal,
            };
            use embassy_time::Instant;
            use heapless::FnvIndexMap;
            use crate::{
                display::widgets::DebugScroll,
                types::{Display1, Display2},
            };
            pub enum BootUp {
                Buttons,
                Obd2,
                CanListen,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for BootUp {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            BootUp::Buttons => "Buttons",
                            BootUp::Obd2 => "Obd2",
                            BootUp::CanListen => "CanListen",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for BootUp {
                #[inline]
                fn clone(&self) -> BootUp {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for BootUp {}
            pub struct LcdBootState {
                bootup_state: FnvIndexMap<BootUp, bool, 3>,
            }
            #[automatically_derived]
            impl ::core::default::Default for LcdBootState {
                #[inline]
                fn default() -> LcdBootState {
                    LcdBootState {
                        bootup_state: ::core::default::Default::default(),
                    }
                }
            }
            impl LcdBootState {
                pub fn new() -> Self {
                    Self {
                        bootup_state: FnvIndexMap::new(),
                    }
                }
                pub async fn draw(&mut self, display1: &mut Display1, display2: &mut Display2) {
                    match defmt::export::into_result(display1.flush().await) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::boot"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display1.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"1627709053263600974\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display1.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"1627709053263600974\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                    match defmt::export::into_result(display2.flush().await) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::boot"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display2.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"15629852913498762705\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display2.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"15629852913498762705\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                }
            }
        }
        mod debug {
            use defmt::{info, unwrap};
            use crate::{
                display::widgets::DebugScroll,
                types::{Display1, Display2},
            };
            pub struct LcdDebugState {
                debug: DebugScroll,
            }
            #[automatically_derived]
            impl ::core::default::Default for LcdDebugState {
                #[inline]
                fn default() -> LcdDebugState {
                    LcdDebugState {
                        debug: ::core::default::Default::default(),
                    }
                }
            }
            impl LcdDebugState {
                pub fn new() -> Self {
                    Self {
                        debug: DebugScroll::new(),
                    }
                }
                pub fn add_line(&mut self, line: &str) {
                    self.debug.add_line(line);
                }
                pub async fn draw(&mut self, display1: &mut Display1, display2: &mut Display2) {
                    self.debug.draw(display1, display2);
                    match defmt::export::into_result(display1.flush().await) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::debug"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display1.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"5662091230408197658\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display1.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"5662091230408197658\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                    match defmt::export::into_result(display2.flush().await) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::debug"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display2.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"7982533331762864478\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display2.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"7982533331762864478\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                }
            }
        }
        mod main {
            use defmt::{info, unwrap, warn};
            use embedded_graphics::geometry::{Point, Size};
            use types::{BmsPid, IceTemperaturePid, Pid as Obd2Event};
            use crate::{
                display::widgets::{
                    Arrow, ArrowDirection, Battery, Battery12V, BatteryOrientation, Connection,
                    GearboxGear, IceFuelRate, Icon, MotorElectric, MotorIce, Position, Power,
                    Temperature, Value,
                },
                tasks::ieee802154::{last_position, last_receive, last_send},
                types::{Display1, Display2},
            };
            pub struct LcdMainState {
                hv_battery: Battery,
                aux_battery: Battery12V,
                ice_temperature: Temperature,
                ice_fuel_rate: IceFuelRate,
                electric_power: Power,
                electric_power_arrow: Arrow,
                motor_electric: MotorElectric,
                motor_electric_rpm: Value,
                motor_ice: MotorIce,
                gearbox_gear: GearboxGear,
                vehicle_speed: Value,
                connection: Connection,
                position: Position,
                ac_compressor: Icon<embedded_iconoir::icons::size18px::weather::SnowFlake>,
                ice_fuel_rate_value: f32,
                hv_battery_current: f32,
                vehicle_speed_value: f32,
            }
            #[automatically_derived]
            impl ::core::default::Default for LcdMainState {
                #[inline]
                fn default() -> LcdMainState {
                    LcdMainState {
                        hv_battery: ::core::default::Default::default(),
                        aux_battery: ::core::default::Default::default(),
                        ice_temperature: ::core::default::Default::default(),
                        ice_fuel_rate: ::core::default::Default::default(),
                        electric_power: ::core::default::Default::default(),
                        electric_power_arrow: ::core::default::Default::default(),
                        motor_electric: ::core::default::Default::default(),
                        motor_electric_rpm: ::core::default::Default::default(),
                        motor_ice: ::core::default::Default::default(),
                        gearbox_gear: ::core::default::Default::default(),
                        vehicle_speed: ::core::default::Default::default(),
                        connection: ::core::default::Default::default(),
                        position: ::core::default::Default::default(),
                        ac_compressor: ::core::default::Default::default(),
                        ice_fuel_rate_value: ::core::default::Default::default(),
                        hv_battery_current: ::core::default::Default::default(),
                        vehicle_speed_value: ::core::default::Default::default(),
                    }
                }
            }
            impl LcdMainState {
                pub fn new() -> Self {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::lcd::main".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"LcdMainState::new()\",\"disambiguator\":\"7521506094683490260\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"LcdMainState::new()\",\"disambiguator\":\"7521506094683490260\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    Self {
                        hv_battery: Battery::new(
                            Point::new(9, 1),
                            Size::new(128, 62),
                            BatteryOrientation::HorizontalRight,
                            Some(Size::new(8, 32)),
                            4,
                            true,
                        ),
                        aux_battery: Battery12V::new(Point::new(256 - 18 * 2 - 16 * 2 - 6, 31)),
                        ice_temperature: Temperature::new(
                            Point::new(256 - 18 * 2 - 4, 0),
                            Size::new(16, 64),
                            0.0,
                            130.0,
                            4,
                        ),
                        electric_power: Power::new(Point::new(128 + 36, 14)),
                        electric_power_arrow: Arrow::new(
                            Point {
                                x: 9 + 128,
                                y: 64 / 2 - 9,
                            },
                            Size {
                                width: 54,
                                height: 16,
                            },
                            14,
                            ArrowDirection::Reverse,
                        ),
                        motor_electric: MotorElectric::new(Point::new(256 - 60, 0)),
                        motor_electric_rpm: Value::new(
                            Point::new(128 + 12, 55),
                            &profont::PROFONT_10_POINT,
                            "rpm",
                            0,
                        ),
                        motor_ice: MotorIce::new(Point::new(0, 0)),
                        gearbox_gear: GearboxGear::new(Point::new(40, 14)),
                        vehicle_speed: Value::new(
                            Point::new(58, 12),
                            &profont::PROFONT_14_POINT,
                            "km/h",
                            0,
                        ),
                        ice_fuel_rate: IceFuelRate::new(Point::new(60, 24)),
                        connection: Connection::new(Point::new(256 - 18, 0)),
                        position: Position::new(Point::new(256 - 18, 18)),
                        ac_compressor: Icon::new(Point::new(256 - 18, 18 + 18), false),
                        ice_fuel_rate_value: 0.0,
                        hv_battery_current: 0.0,
                        vehicle_speed_value: 0.0,
                    }
                }
                pub fn handle_obd2_event(&mut self, event: &Obd2Event) {
                    match event {
                        Obd2Event::BmsPid(bms_pid) => {
                            self.update_bms_pid(bms_pid);
                        }
                        Obd2Event::IceTemperaturePid(ice_temperature_pid) => {
                            self.ice_temperature
                                .update_temp(ice_temperature_pid.temperature);
                        }
                        Obd2Event::IceFuelRatePid(ice_fuel_rate_pid) => {
                            self.ice_fuel_rate_value = ice_fuel_rate_pid.fuel_rate;
                            self.ice_fuel_rate
                                .update_ice_fuel_rate(ice_fuel_rate_pid.fuel_rate);
                        }
                        Obd2Event::VehicleSpeedPid(vehicle_speed_pid) => {
                            let speed = vehicle_speed_pid.vehicle_speed as f32;
                            self.vehicle_speed.update_value(speed + speed * 0.1);
                            self.ice_fuel_rate.update_vehicle_speed(speed);
                            self.vehicle_speed_value = speed;
                        }
                        Obd2Event::TransaxlePid(transaxle_pid) => {
                            self.gearbox_gear.update_gear(transaxle_pid.gear.into());
                        }
                        Obd2Event::AcPid(ac_pid) => {
                            self.ac_compressor.enabled(ac_pid.compressor_on);
                        }
                        _ => {}
                    }
                }
                pub fn update_bms_pid(&mut self, bms_pid: &BmsPid) {
                    self.hv_battery.update_percentage(bms_pid.hv_soc);
                    self.hv_battery.update_voltage(bms_pid.hv_dc_voltage);
                    self.hv_battery.update_max_temp(bms_pid.hv_max_temp);
                    self.hv_battery.update_min_temp(bms_pid.hv_min_temp);
                    self.hv_battery.update_cell_voltage(
                        (bms_pid.hv_max_cell_voltage + bms_pid.hv_min_cell_voltage) / 2.0,
                    );
                    self.hv_battery.update_cell_voltage_deviation(
                        (bms_pid.hv_max_cell_voltage - bms_pid.hv_min_cell_voltage) * 100.0,
                    );
                    self.aux_battery.update_voltage(bms_pid.aux_dc_voltage);
                    self.electric_power_arrow.update_speed(50.0);
                    self.electric_power
                        .update_power(bms_pid.hv_battery_current * bms_pid.hv_dc_voltage);
                    self.electric_power
                        .update_current(bms_pid.hv_battery_current);
                    if bms_pid.hv_battery_current > 0.0 {
                        self.electric_power_arrow
                            .update_direction(ArrowDirection::Forward);
                    } else {
                        self.electric_power_arrow
                            .update_direction(ArrowDirection::Reverse);
                    }
                    self.hv_battery_current = bms_pid.hv_battery_current;
                    self.motor_electric_rpm
                        .update_value(bms_pid.motor_electric_rpm);
                }
                pub async fn draw(&mut self, display1: &mut Display1, display2: &mut Display2) {
                    if let Some(last_send) = last_send() {
                        self.connection
                            .update_last_send(last_send.elapsed().as_millis() < 250);
                    }
                    if let Some(last_receive) = last_receive() {
                        self.connection
                            .update_last_receive(last_receive.elapsed().as_millis() < 250);
                    }
                    if let Some(last_position) = last_position() {
                        self.position
                            .update_last_position(last_position.elapsed().as_millis() < 250);
                    }
                    if self.motor_ice.update_on(self.ice_fuel_rate_value > 0.0) {
                        self.gearbox_gear.force_redraw();
                    }
                    self.motor_electric
                        .update_on(if self.ice_fuel_rate_value == 0.0 {
                            true
                        } else {
                            self.hv_battery_current > 0.0
                        });
                    self.hv_battery.draw(display1).ok();
                    self.aux_battery.draw(display2).ok();
                    self.ice_temperature.draw(display2).ok();
                    self.motor_electric.draw(display1).ok();
                    self.motor_ice.draw(display2).ok();
                    self.electric_power.draw(display1).ok();
                    self.electric_power_arrow.draw(display1).ok();
                    self.gearbox_gear.draw(display2).ok();
                    self.ice_fuel_rate.draw(display2).ok();
                    self.vehicle_speed.draw(display2).ok();
                    self.motor_electric_rpm.draw(display1).ok();
                    self.connection.draw(display2).ok();
                    self.position.draw(display2).ok();
                    self.ac_compressor.draw(display2).ok();
                    match defmt::export::into_result(display1.flush().await) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::main"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display1.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"6750271096309968237\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display1.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"6750271096309968237\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                    match defmt::export::into_result(display2.flush().await) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::main"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display2.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"646645915183645854\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display2.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"646645915183645854\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                }
            }
        }
        mod menu {
            use defmt::{info, unwrap};
            use embedded_graphics::{image::Image, pixelcolor::BinaryColor, prelude::*};
            use embedded_iconoir::prelude::*;
            use statig::Response::{self, Transition};
            use super::State;
            use crate::{
                display::widgets::DebugScroll,
                tasks::{
                    buttons::{Action, Button},
                    lcd::{
                        debug::LcdDebugState, main::LcdMainState, obd2_pids::LcdObd2Pids,
                        settings::LcdSettingsState,
                    },
                },
                types::{Display1, Display2},
            };
            pub struct LcdMenuState {}
            #[automatically_derived]
            impl ::core::default::Default for LcdMenuState {
                #[inline]
                fn default() -> LcdMenuState {
                    LcdMenuState {}
                }
            }
            impl LcdMenuState {
                pub fn new() -> Self {
                    Self {}
                }
                pub fn handle_button(&mut self, button: &Action) -> Option<Response<State>> {
                    match (&(button)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::lcd::menu".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"menu button: {:?}\",\"disambiguator\":\"16249751124091226133\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"menu button: {:?}\",\"disambiguator\":\"16249751124091226133\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    match button {
                        Action::Pressed(Button::B4) => {
                            Some(Transition(State::main(LcdMainState::new())))
                        }
                        Action::Pressed(Button::B2) => {
                            Some(Transition(State::debug(LcdDebugState::new())))
                        }
                        Action::Pressed(Button::B1) => {
                            Some(Transition(State::obd2_pids(LcdObd2Pids::new())))
                        }
                        Action::Pressed(Button::B0) => {
                            Some(Transition(State::settings(LcdSettingsState::new())))
                        }
                        Action::Pressed(Button::B3) => {
                            crate::hal::reset();
                            None
                        }
                        _ => None,
                    }
                }
                pub async fn draw(&mut self, display1: &mut Display1, display2: &mut Display2) {
                    let icon =
                        embedded_iconoir::icons::size48px::devices::Computer::new(GrayColor::WHITE);
                    let image = Image::new(&icon, Point::zero());
                    match defmt::export::into_result(image.draw(display1)) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::menu"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: image.draw(display1)'\\nerror: `{:?}`\",\"disambiguator\":\"15069326298687591817\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: image.draw(display1)'\\nerror: `{:?}`\",\"disambiguator\":\"15069326298687591817\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                    let icon = embedded_iconoir::icons::size48px::weather::SnowFlake::new(
                        GrayColor::WHITE,
                    );
                    let image = Image::new(&icon, Point { x: 52, y: 0 });
                    match defmt::export::into_result(image.draw(display1)) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::menu"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: image.draw(display1)'\\nerror: `{:?}`\",\"disambiguator\":\"12225736580305293299\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: image.draw(display1)'\\nerror: `{:?}`\",\"disambiguator\":\"12225736580305293299\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                    let icon =
                        embedded_iconoir::icons::size48px::system::Settings::new(GrayColor::WHITE);
                    let image = Image::new(&icon, Point { x: 52 * 1, y: 0 });
                    match defmt::export::into_result(image.draw(display2)) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::menu"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: image.draw(display2)'\\nerror: `{:?}`\",\"disambiguator\":\"887548173854985763\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: image.draw(display2)'\\nerror: `{:?}`\",\"disambiguator\":\"887548173854985763\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                    let icon =
                        embedded_iconoir::icons::size48px::editor::List::new(GrayColor::WHITE);
                    let image = Image::new(&icon, Point { x: 52 * 2, y: 0 });
                    match defmt::export::into_result(image.draw(display2)) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::menu"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: image.draw(display2)'\\nerror: `{:?}`\",\"disambiguator\":\"12944604767291369598\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: image.draw(display2)'\\nerror: `{:?}`\",\"disambiguator\":\"12944604767291369598\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                    let icon = embedded_iconoir::icons::size48px::development::CodeBrackets::new(
                        GrayColor::WHITE,
                    );
                    let image = Image::new(&icon, Point { x: 52 * 3, y: 0 });
                    match defmt::export::into_result(image.draw(display2)) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::menu"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: image.draw(display2)'\\nerror: `{:?}`\",\"disambiguator\":\"813274571643776018\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: image.draw(display2)'\\nerror: `{:?}`\",\"disambiguator\":\"813274571643776018\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                    let icon =
                        embedded_iconoir::icons::size48px::actions::Restart::new(GrayColor::WHITE);
                    let image = Image::new(&icon, Point { x: 52 * 4, y: 0 });
                    match defmt::export::into_result(image.draw(display2)) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::menu"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: image.draw(display2)'\\nerror: `{:?}`\",\"disambiguator\":\"9104751361003295036\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: image.draw(display2)'\\nerror: `{:?}`\",\"disambiguator\":\"9104751361003295036\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                    match defmt::export::into_result(display1.flush().await) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::menu"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display1.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"14805184392860820395\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display1.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"14805184392860820395\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                    match defmt::export::into_result(display2.flush().await) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::menu"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display2.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"7499819469087491256\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display2.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"7499819469087491256\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                }
            }
        }
        mod obd2_pids {
            use core::sync::atomic::AtomicBool;
            use defmt::*;
            use crate::{
                display::widgets::{DebugScroll, Obd2DebugSelector},
                tasks::obd2::Obd2Debug,
                types::{Display1, Display2},
            };
            static OBD2_DEBUG_PIDS_ENABLED: AtomicBool = AtomicBool::new(false);
            pub struct LcdObd2Pids {
                debug: Obd2DebugSelector,
            }
            #[automatically_derived]
            impl ::core::default::Default for LcdObd2Pids {
                #[inline]
                fn default() -> LcdObd2Pids {
                    LcdObd2Pids {
                        debug: ::core::default::Default::default(),
                    }
                }
            }
            impl LcdObd2Pids {
                pub fn new() -> Self {
                    OBD2_DEBUG_PIDS_ENABLED.store(true, core::sync::atomic::Ordering::Relaxed);
                    Self {
                        debug: Obd2DebugSelector::new(),
                    }
                }
                pub fn handle_obd2_debug(&mut self, event: &Obd2Debug) {
                    self.debug.handle_obd2_debug(event);
                }
                pub async fn draw(&mut self, display1: &mut Display1, display2: &mut Display2) {
                    self.debug.draw(display1, display2);
                    match defmt::export::into_result(display1.flush().await) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::obd2_pids"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display1.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"1865902310925450026\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display1.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"1865902310925450026\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                    match defmt::export::into_result(display2.flush().await) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::obd2_pids"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display2.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"490469125293239141\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display2.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"490469125293239141\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                }
            }
            impl Drop for LcdObd2Pids {
                fn drop(&mut self) {
                    OBD2_DEBUG_PIDS_ENABLED.store(false, core::sync::atomic::Ordering::Relaxed);
                }
            }
            pub fn obd2_debug_pids_enabled() -> bool {
                OBD2_DEBUG_PIDS_ENABLED.load(core::sync::atomic::Ordering::Relaxed)
            }
        }
        mod settings {
            use core::sync::atomic::AtomicBool;
            use defmt::*;
            use embedded_graphics::prelude::*;
            use statig::Response::{self, Handled, Transition};
            use super::State;
            use crate::{
                display::widgets::{DebugScroll, Obd2DebugSelector, Slider, Text},
                tasks::{buttons::Action, lcd::menu::LcdMenuState, obd2::Obd2Debug},
                types::{Display1, Display2},
            };
            pub enum LcdSettingsEdit {
                #[default]
                Contrast,
            }
            impl defmt::Format for LcdSettingsEdit {
                fn format(&self, f: defmt::Formatter) {
                    {
                        match () {
                            () => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::lcd::settings"
                                                    .as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    defmt::export::acquire_header_and_release(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"16834518633868059856\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"16834518633868059856\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                }
                fn _format_tag() -> defmt::Str {
                    {
                        defmt::export::make_istr({
                            #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"Contrast\",\"disambiguator\":\"5204787192810741207\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"Contrast\",\"disambiguator\":\"5204787192810741207\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                            static S: u8 = 0;
                            &S as *const u8 as u16
                        })
                    }
                }
                fn _format_data(&self) {
                    match self {
                        LcdSettingsEdit::Contrast {} => {}
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for LcdSettingsEdit {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for LcdSettingsEdit {
                #[inline]
                fn eq(&self, other: &LcdSettingsEdit) -> bool {
                    true
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for LcdSettingsEdit {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::clone::Clone for LcdSettingsEdit {
                #[inline]
                fn clone(&self) -> LcdSettingsEdit {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for LcdSettingsEdit {}
            #[automatically_derived]
            impl ::core::default::Default for LcdSettingsEdit {
                #[inline]
                fn default() -> LcdSettingsEdit {
                    Self::Contrast
                }
            }
            pub struct LcdSettingsState {
                contrast: u8,
                contrast_text: Text,
                contrast_slider: Slider,
                current_contrast: u8,
                init: bool,
                edit: LcdSettingsEdit,
            }
            #[automatically_derived]
            impl ::core::default::Default for LcdSettingsState {
                #[inline]
                fn default() -> LcdSettingsState {
                    LcdSettingsState {
                        contrast: ::core::default::Default::default(),
                        contrast_text: ::core::default::Default::default(),
                        contrast_slider: ::core::default::Default::default(),
                        current_contrast: ::core::default::Default::default(),
                        init: ::core::default::Default::default(),
                        edit: ::core::default::Default::default(),
                    }
                }
            }
            impl LcdSettingsState {
                pub fn new() -> Self {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::lcd::settings".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"LcdSettingsState::new()\",\"disambiguator\":\"8646584021452975747\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"LcdSettingsState::new()\",\"disambiguator\":\"8646584021452975747\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    let mut ret = Self {
                        contrast: 128,
                        current_contrast: 128,
                        contrast_slider: Slider::new(Point::new(128, 0), Size::new(128, 10)),
                        contrast_text: Text::new(
                            Point::new(30, 7),
                            &embedded_graphics::mono_font::ascii::FONT_6X10,
                            Some("Contrast: "),
                        ),
                        init: true,
                        edit: LcdSettingsEdit::Contrast,
                    };
                    ret.contrast_text.update_selected(true);
                    ret
                }
                pub fn handle_button(&mut self, button: &Action) -> Option<Response<State>> {
                    use crate::tasks::buttons::{Action::*, Button::*};
                    match (&(button)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::lcd::settings".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"settings button: {:?}\",\"disambiguator\":\"10515263008145504677\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"settings button: {:?}\",\"disambiguator\":\"10515263008145504677\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    match button {
                        Pressed(B0) => {
                            self.edit = LcdSettingsEdit::Contrast;
                            None
                        }
                        Pressed(B1) => {
                            self.edit = LcdSettingsEdit::Contrast;
                            None
                        }
                        Pressed(B4) => {
                            return Some(Transition(State::menu(LcdMenuState::new())));
                            None
                        }
                        Pressed(_) => {
                            self.handle_edit_contrast(button);
                            None
                        }
                        _ => Some(0),
                    };
                    None
                }
                fn handle_edit_contrast(&mut self, button: &Action) {
                    use crate::tasks::buttons::{Action::*, Button::*};
                    match button {
                        Pressed(B6) => {
                            self.contrast = self.contrast.saturating_sub(5);
                            self.contrast_slider
                                .update_percentage(self.contrast as f64 / 255.0 * 100.0);
                        }
                        Pressed(B7) => {
                            self.contrast = self.contrast.saturating_add(5);
                            self.contrast_slider
                                .update_percentage(self.contrast as f64 / 255.0 * 100.0);
                        }
                        _ => {}
                    }
                    match (&(self.contrast)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::lcd::settings".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"contrast: {}\",\"disambiguator\":\"12806199466907288919\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"contrast: {}\",\"disambiguator\":\"12806199466907288919\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                }
                pub async fn draw(&mut self, display1: &mut Display1, display2: &mut Display2) {
                    if self.init {
                        self.contrast = display1.get_contrast();
                        self.contrast_slider
                            .update_percentage(self.contrast as f64 / 255.0 * 100.0);
                        self.init = false;
                    }
                    if self.current_contrast != self.contrast {
                        display1.set_contrast(self.contrast).await;
                        display2.set_contrast(self.contrast).await;
                        self.current_contrast = self.contrast;
                    }
                    self.contrast_text.draw(display1).ok();
                    self.contrast_slider.draw(display1).ok();
                    match defmt::export::into_result(display1.flush().await) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::settings"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display1.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"4087284997075561312\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display1.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"4087284997075561312\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                    match defmt::export::into_result(display2.flush().await) {
                        ::core::result::Result::Ok(res) => res,
                        ::core::result::Result::Err(_unwrap_err) => {
                            match (&(_unwrap_err)) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::lcd::settings"
                                                        .as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display2.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"6063811021659320749\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display2.flush().await'\\nerror: `{:?}`\",\"disambiguator\":\"6063811021659320749\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            defmt::export::panic()
                        }
                    };
                }
            }
        }
        use debug::LcdDebugState;
        use main::LcdMainState;
        use menu::LcdMenuState;
        use obd2_pids::LcdObd2Pids;
        use settings::LcdSettingsState;
        use crate::tasks::buttons::{Action, Button};
        pub static EVENTS: Channel<CriticalSectionRawMutex, LcdEvent, 128> = Channel::new();
        pub use obd2_pids::obd2_debug_pids_enabled;
        pub struct LcdContext {
            panic: Option<&'static str>,
        }
        pub enum LcdEvent {
            PowerOff,
            Main,
            Debug,
            Menu,
            Render,
            DebugLine(String<DEBUG_STRING_LEN>),
            Obd2Event(Obd2Event),
            Obd2Debug(Obd2Debug),
            Button(Action),
        }
        impl defmt::Format for LcdEvent
        where
            String<DEBUG_STRING_LEN>: defmt::Format,
            Obd2Event: defmt::Format,
            Obd2Debug: defmt::Format,
            Action: defmt::Format,
        {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"802730124069978044\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"802730124069978044\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"PowerOff|Main|Debug|Menu|Render|DebugLine({=?})|Obd2Event({=?})|Obd2Debug({=?})|Button({=?})\",\"disambiguator\":\"6605357485751221676\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"PowerOff|Main|Debug|Menu|Render|DebugLine({=?})|Obd2Event({=?})|Obd2Debug({=?})|Button({=?})\",\"disambiguator\":\"6605357485751221676\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    LcdEvent::PowerOff {} => {
                        defmt::export::u8(&0u8);
                    }
                    LcdEvent::Main {} => {
                        defmt::export::u8(&1u8);
                    }
                    LcdEvent::Debug {} => {
                        defmt::export::u8(&2u8);
                    }
                    LcdEvent::Menu {} => {
                        defmt::export::u8(&3u8);
                    }
                    LcdEvent::Render {} => {
                        defmt::export::u8(&4u8);
                    }
                    LcdEvent::DebugLine { 0: arg0 } => {
                        defmt::export::u8(&5u8);
                        defmt::export::fmt(arg0);
                    }
                    LcdEvent::Obd2Event { 0: arg0 } => {
                        defmt::export::u8(&6u8);
                        defmt::export::fmt(arg0);
                    }
                    LcdEvent::Obd2Debug { 0: arg0 } => {
                        defmt::export::u8(&7u8);
                        defmt::export::fmt(arg0);
                    }
                    LcdEvent::Button { 0: arg0 } => {
                        defmt::export::u8(&8u8);
                        defmt::export::fmt(arg0);
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for LcdEvent {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for LcdEvent {
            #[inline]
            fn eq(&self, other: &LcdEvent) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (LcdEvent::DebugLine(__self_0), LcdEvent::DebugLine(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (LcdEvent::Obd2Event(__self_0), LcdEvent::Obd2Event(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (LcdEvent::Obd2Debug(__self_0), LcdEvent::Obd2Debug(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (LcdEvent::Button(__self_0), LcdEvent::Button(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        _ => true,
                    }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for LcdEvent {
            #[inline]
            fn clone(&self) -> LcdEvent {
                match self {
                    LcdEvent::PowerOff => LcdEvent::PowerOff,
                    LcdEvent::Main => LcdEvent::Main,
                    LcdEvent::Debug => LcdEvent::Debug,
                    LcdEvent::Menu => LcdEvent::Menu,
                    LcdEvent::Render => LcdEvent::Render,
                    LcdEvent::DebugLine(__self_0) => {
                        LcdEvent::DebugLine(::core::clone::Clone::clone(__self_0))
                    }
                    LcdEvent::Obd2Event(__self_0) => {
                        LcdEvent::Obd2Event(::core::clone::Clone::clone(__self_0))
                    }
                    LcdEvent::Obd2Debug(__self_0) => {
                        LcdEvent::Obd2Debug(::core::clone::Clone::clone(__self_0))
                    }
                    LcdEvent::Button(__self_0) => {
                        LcdEvent::Button(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        pub struct LcdState {
            display1: Display1,
            display2: Display2,
            display_on: bool,
            is_debug: bool,
        }
        impl LcdState {
            pub fn new(display1: Display1, display2: Display2) -> Self {
                Self {
                    display1,
                    display2,
                    display_on: false,
                    is_debug: false,
                }
            }
            pub fn is_debug(&self) -> bool {
                self.is_debug
            }
        }
        use statig::{state, superstate, action};
        impl LcdState {
            async fn display_on(&mut self) {
                if self.display_on {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"display already on\",\"disambiguator\":\"14292695170962418442\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"display already on\",\"disambiguator\":\"14292695170962418442\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    return;
                }
                match () {
                    _ => {}
                };
                let lock = crate::locks::SPI_BUS.lock().await;
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"display on got spi lock\",\"disambiguator\":\"2044609919708381971\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"display on got spi lock\",\"disambiguator\":\"2044609919708381971\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                self.display1.clear();
                self.display2.clear();
                self.display1.flush().await.ok();
                self.display2.flush().await.ok();
                match defmt::export::into_result(self.display1.sleep(false).await) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: self.display1.sleep(false).await'\\nerror: `{:?}`\",\"disambiguator\":\"14156477930836168947\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: self.display1.sleep(false).await'\\nerror: `{:?}`\",\"disambiguator\":\"14156477930836168947\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(self.display2.sleep(false).await) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: self.display2.sleep(false).await'\\nerror: `{:?}`\",\"disambiguator\":\"13449943115633536395\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: self.display2.sleep(false).await'\\nerror: `{:?}`\",\"disambiguator\":\"13449943115633536395\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                crate::tasks::buttons::init();
                self.display_on = true;
                Timer::after(Duration::from_millis(100)).await;
            }
            async fn display_off(&mut self) {
                if !self.display_on {
                    return;
                }
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"display off\",\"disambiguator\":\"15903884933611522398\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"display off\",\"disambiguator\":\"15903884933611522398\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                let lock = crate::locks::SPI_BUS.lock().await;
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"display off got spi lock\",\"disambiguator\":\"12752011469260114229\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"display off got spi lock\",\"disambiguator\":\"12752011469260114229\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                self.display1.clear();
                self.display2.clear();
                self.display1.flush().await.ok();
                self.display2.flush().await.ok();
                match defmt::export::into_result(self.display1.sleep(true).await) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: self.display1.sleep(true).await'\\nerror: `{:?}`\",\"disambiguator\":\"9613702632358404927\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: self.display1.sleep(true).await'\\nerror: `{:?}`\",\"disambiguator\":\"9613702632358404927\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(self.display2.sleep(true).await) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: self.display2.sleep(true).await'\\nerror: `{:?}`\",\"disambiguator\":\"12088865990530733436\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: self.display2.sleep(true).await'\\nerror: `{:?}`\",\"disambiguator\":\"12088865990530733436\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                self.display_on = false;
            }
            async fn state_dispatch(&mut self, event: &LcdEvent) -> Response<State> {
                match event {
                    LcdEvent::Main => Transition(State::main(LcdMainState::new())),
                    LcdEvent::Debug => Transition(State::debug(LcdDebugState::new())),
                    LcdEvent::Button(Action::Pressed(pressed)) => {
                        if *pressed != Button::B3 {
                            Transition(State::menu(LcdMenuState::new()))
                        } else {
                            Handled
                        }
                    }
                    LcdEvent::Menu => Transition(State::menu(LcdMenuState::new())),
                    LcdEvent::PowerOff => Transition(State::init()),
                    _ => Handled,
                }
            }
            async fn enter_init(&mut self) {
                self.display_off().await;
            }
            async fn init(&mut self, event: &LcdEvent) -> Response<State> {
                match event {
                    LcdEvent::Main => Transition(State::main(LcdMainState::new())),
                    _ => Handled,
                }
            }
            async fn enter_main(&mut self, main: &mut LcdMainState) {
                self.display_on().await;
                let lock = crate::locks::SPI_BUS.lock().await;
                self.display1.clear();
                self.display2.clear();
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"enter_main\",\"disambiguator\":\"16976792765713523729\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"enter_main\",\"disambiguator\":\"16976792765713523729\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                main.draw(&mut self.display1, &mut self.display2).await;
            }
            async fn main(&mut self, main: &mut LcdMainState, event: &LcdEvent) -> Response<State> {
                let lock = crate::locks::SPI_BUS.lock().await;
                let ret = match event {
                    LcdEvent::Obd2Event(obd2_event) => {
                        main.handle_obd2_event(obd2_event);
                        Handled
                    }
                    LcdEvent::Render => {
                        main.draw(&mut self.display1, &mut self.display2).await;
                        Handled
                    }
                    _ => Super,
                };
                ret
            }
            async fn enter_debug(&mut self, debug: &mut LcdDebugState) {
                let lock = crate::locks::SPI_BUS.lock().await;
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"enter_debug\",\"disambiguator\":\"1876327958738097196\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"enter_debug\",\"disambiguator\":\"1876327958738097196\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                self.display_on().await;
                self.display1.clear();
                self.display2.clear();
                debug.draw(&mut self.display1, &mut self.display2).await;
            }
            async fn debug(
                &mut self,
                context: &mut LcdContext,
                debug: &mut LcdDebugState,
                event: &LcdEvent,
            ) -> Response<State> {
                let lock = crate::locks::SPI_BUS.lock().await;
                match event {
                    LcdEvent::DebugLine(line) => {
                        debug.add_line(line);
                        debug.draw(&mut self.display1, &mut self.display2).await;
                        Handled
                    }
                    _ => Super,
                }
            }
            async fn enter_menu(&mut self, menu: &mut LcdMenuState) {
                let lock = crate::locks::SPI_BUS.lock().await;
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"enter_debug\",\"disambiguator\":\"8192076298917332053\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"enter_debug\",\"disambiguator\":\"8192076298917332053\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                self.display_on().await;
                self.display1.clear();
                self.display2.clear();
                menu.draw(&mut self.display1, &mut self.display2).await;
            }
            async fn menu(
                &mut self,
                context: &mut LcdContext,
                menu: &mut LcdMenuState,
                event: &LcdEvent,
            ) -> Response<State> {
                let lock = crate::locks::SPI_BUS.lock().await;
                match event {
                    LcdEvent::Button(action) => {
                        if let Some(transition) = menu.handle_button(action) {
                            return transition;
                        }
                        menu.draw(&mut self.display1, &mut self.display2).await;
                        Handled
                    }
                    _ => Super,
                }
            }
            async fn enter_obd2_pids(&mut self, obd2_pids: &mut LcdObd2Pids) {
                let lock = crate::locks::SPI_BUS.lock().await;
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"enter_debug\",\"disambiguator\":\"4539996218562094361\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"enter_debug\",\"disambiguator\":\"4539996218562094361\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                self.display_on().await;
                self.display1.clear();
                self.display2.clear();
                obd2_pids.draw(&mut self.display1, &mut self.display2).await;
            }
            async fn obd2_pids(
                &mut self,
                context: &mut LcdContext,
                obd2_pids: &mut LcdObd2Pids,
                event: &LcdEvent,
            ) -> Response<State> {
                let lock = crate::locks::SPI_BUS.lock().await;
                match event {
                    LcdEvent::Obd2Debug(obd2_debug) => {
                        obd2_pids.handle_obd2_debug(obd2_debug);
                        obd2_pids.draw(&mut self.display1, &mut self.display2).await;
                        Handled
                    }
                    _ => Super,
                }
            }
            async fn enter_settings(&mut self, settings: &mut LcdSettingsState) {
                let lock = crate::locks::SPI_BUS.lock().await;
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"enter_debug\",\"disambiguator\":\"1014146968257961575\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"enter_debug\",\"disambiguator\":\"1014146968257961575\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                self.display_on().await;
                self.display1.clear();
                self.display2.clear();
                settings.draw(&mut self.display1, &mut self.display2).await;
            }
            async fn settings(
                &mut self,
                context: &mut LcdContext,
                settings: &mut LcdSettingsState,
                event: &LcdEvent,
            ) -> Response<State> {
                let lock = crate::locks::SPI_BUS.lock().await;
                match event {
                    LcdEvent::Button(action) => {
                        if let Some(transition) = settings.handle_button(action) {
                            return transition;
                        }
                        settings.draw(&mut self.display1, &mut self.display2).await;
                        Handled
                    }
                    _ => Super,
                }
            }
        }
        impl statig::awaitable::IntoStateMachine for LcdState {
            type Event<'event> = LcdEvent;
            type Context<'context> = LcdContext;
            type State = State;
            type Superstate<'sub> = Superstate;
            const INITIAL: State = State::init();
            const ON_TRANSITION: fn(&mut Self, &Self::State, &Self::State) = Self::on_transition;
            const ON_DISPATCH: fn(&mut Self, StateOrSuperstate<'_, '_, Self>, &Self::Event<'_>) =
                Self::on_dispatch;
        }
        pub enum State {
            Debug { debug: LcdDebugState },
            Settings { settings: LcdSettingsState },
            Init {},
            Obd2Pids { obd2_pids: LcdObd2Pids },
            Menu { menu: LcdMenuState },
            Main { main: LcdMainState },
        }
        impl State {
            const fn debug(debug: LcdDebugState) -> Self {
                Self::Debug { debug }
            }
            const fn settings(settings: LcdSettingsState) -> Self {
                Self::Settings { settings }
            }
            const fn init() -> Self {
                Self::Init {}
            }
            const fn obd2_pids(obd2_pids: LcdObd2Pids) -> Self {
                Self::Obd2Pids { obd2_pids }
            }
            const fn menu(menu: LcdMenuState) -> Self {
                Self::Menu { menu }
            }
            const fn main(main: LcdMainState) -> Self {
                Self::Main { main }
            }
        }
        #[allow(unused)]
        impl statig::awaitable::State<LcdState> for State {
            fn call_handler<'fut>(
                &'fut mut self,
                shared_storage: &'fut mut LcdState,
                event: &'fut <LcdState as statig::IntoStateMachine>::Event<'_>,
                context: &'fut mut <LcdState as statig::IntoStateMachine>::Context<'_>,
            ) -> core::pin::Pin<
                statig::Box<dyn core::future::Future<Output = statig::Response<Self>> + 'fut>,
            > {
                statig::Box::pin(async move {
                    match self {
                        State::Debug { debug } => {
                            LcdState::debug(shared_storage, context, debug, event).await
                        }
                        State::Settings { settings } => {
                            LcdState::settings(shared_storage, context, settings, event).await
                        }
                        State::Init {} => LcdState::init(shared_storage, event).await,
                        State::Obd2Pids { obd2_pids } => {
                            LcdState::obd2_pids(shared_storage, context, obd2_pids, event).await
                        }
                        State::Menu { menu } => {
                            LcdState::menu(shared_storage, context, menu, event).await
                        }
                        State::Main { main } => LcdState::main(shared_storage, main, event).await,
                        _ => statig::Response::Super,
                    }
                })
            }
            fn call_entry_action<'fut>(
                &'fut mut self,
                shared_storage: &'fut mut LcdState,
                context: &'fut mut <LcdState as statig::IntoStateMachine>::Context<'_>,
            ) -> core::pin::Pin<statig::Box<dyn core::future::Future<Output = ()> + 'fut>>
            {
                statig::Box::pin(async move {
                    match self {
                        State::Debug { debug } => {
                            LcdState::enter_debug(shared_storage, debug).await
                        }
                        State::Settings { settings } => {
                            LcdState::enter_settings(shared_storage, settings).await
                        }
                        State::Init {} => LcdState::enter_init(shared_storage).await,
                        State::Obd2Pids { obd2_pids } => {
                            LcdState::enter_obd2_pids(shared_storage, obd2_pids).await
                        }
                        State::Menu { menu } => LcdState::enter_menu(shared_storage, menu).await,
                        State::Main { main } => LcdState::enter_main(shared_storage, main).await,
                        _ => {}
                    }
                })
            }
            fn call_exit_action<'fut>(
                &'fut mut self,
                shared_storage: &'fut mut LcdState,
                context: &'fut mut <LcdState as statig::IntoStateMachine>::Context<'_>,
            ) -> core::pin::Pin<statig::Box<dyn core::future::Future<Output = ()> + 'fut>>
            {
                statig::Box::pin(async move {
                    match self {
                        State::Debug { debug } => {}
                        State::Settings { settings } => {}
                        State::Init {} => {}
                        State::Obd2Pids { obd2_pids } => {}
                        State::Menu { menu } => {}
                        State::Main { main } => {}
                        _ => {}
                    }
                })
            }
            fn superstate(
                &mut self,
            ) -> Option<<LcdState as statig::IntoStateMachine>::Superstate<'_>> {
                match self {
                    State::Debug { debug } => Some(Superstate::StateDispatch {}),
                    State::Settings { settings } => Some(Superstate::StateDispatch {}),
                    State::Init {} => None,
                    State::Obd2Pids { obd2_pids } => Some(Superstate::StateDispatch {}),
                    State::Menu { menu } => Some(Superstate::StateDispatch {}),
                    State::Main { main } => Some(Superstate::StateDispatch {}),
                    _ => None,
                }
            }
        }
        pub enum Superstate {
            StateDispatch {},
        }
        #[allow(unused)]
        impl<'sub> statig::awaitable::Superstate<LcdState> for Superstate
        where
            Self: 'sub,
        {
            fn call_handler<'fut>(
                &'fut mut self,
                shared_storage: &'fut mut LcdState,
                event: &'fut <LcdState as statig::IntoStateMachine>::Event<'_>,
                context: &'fut mut <LcdState as statig::IntoStateMachine>::Context<'_>,
            ) -> core::pin::Pin<
                statig::Box<
                    dyn core::future::Future<
                            Output = statig::Response<
                                <LcdState as statig::IntoStateMachine>::State,
                            >,
                        > + 'fut,
                >,
            > {
                statig::Box::pin(async move {
                    match self {
                        Superstate::StateDispatch {} => {
                            LcdState::state_dispatch(shared_storage, event).await
                        }
                        _ => statig::Response::Super,
                    }
                })
            }
            fn call_entry_action<'fut>(
                &'fut mut self,
                shared_storage: &'fut mut LcdState,
                context: &'fut mut <LcdState as statig::IntoStateMachine>::Context<'_>,
            ) -> core::pin::Pin<statig::Box<dyn core::future::Future<Output = ()> + 'fut>>
            {
                statig::Box::pin(async move {
                    match self {
                        Superstate::StateDispatch {} => {}
                        _ => {}
                    }
                })
            }
            fn call_exit_action<'fut>(
                &'fut mut self,
                shared_storage: &'fut mut LcdState,
                context: &'fut mut <LcdState as statig::IntoStateMachine>::Context<'_>,
            ) -> core::pin::Pin<statig::Box<dyn core::future::Future<Output = ()> + 'fut>>
            {
                statig::Box::pin(async move {
                    match self {
                        Superstate::StateDispatch {} => {}
                        _ => {}
                    }
                })
            }
            fn superstate(
                &mut self,
            ) -> Option<<LcdState as statig::IntoStateMachine>::Superstate<'_>> {
                match self {
                    Superstate::StateDispatch {} => None,
                    _ => None,
                }
            }
        }
        impl LcdState {
            fn on_transition(&mut self, source: &State, target: &State) {
                self.is_debug = false;
                match target {
                    State::Debug { debug: _ } => self.is_debug = true,
                    _ => {}
                }
            }
            fn on_dispatch(&mut self, state: StateOrSuperstate<Self>, event: &LcdEvent) {}
        }
        #[doc(hidden)]
        async fn __run_task(
            mut display1: Display1,
            mut display2: Display2,
            panic: Option<&'static str>,
        ) {
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        defmt::export::acquire_header_and_release(&{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"lcd init start\",\"disambiguator\":\"9651936819942830851\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"lcd init start\",\"disambiguator\":\"9651936819942830851\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        });
                    }
                }
            };
            with_timeout(Duration::from_secs(5 * 60), obd2_init_wait())
                .await
                .ok();
            {
                let _lock = crate::locks::SPI_BUS.lock().await;
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            defmt::export::acquire_header_and_release(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"display init\",\"disambiguator\":\"4500004884560820694\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"display init\",\"disambiguator\":\"4500004884560820694\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        }
                    }
                };
                match defmt::export::into_result(display1.init(None).await) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display1.init(None).await'\\nerror: `{:?}`\",\"disambiguator\":\"596554830984627005\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display1.init(None).await'\\nerror: `{:?}`\",\"disambiguator\":\"596554830984627005\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
                match defmt::export::into_result(display2.init(None).await) {
                    ::core::result::Result::Ok(res) => res,
                    ::core::result::Result::Err(_unwrap_err) => {
                        match (&(_unwrap_err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display2.init(None).await'\\nerror: `{:?}`\",\"disambiguator\":\"12099496455470074776\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: display2.init(None).await'\\nerror: `{:?}`\",\"disambiguator\":\"12099496455470074776\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        defmt::export::panic()
                    }
                };
            }
            display1.set_contrast(50).await.ok();
            display2.set_contrast(50).await.ok();
            display1.clear();
            display2.clear();
            display1.flush().await.ok();
            display2.flush().await.ok();
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        defmt::export::acquire_header_and_release(&{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"lcd init end\",\"disambiguator\":\"17397750396228633469\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"lcd init end\",\"disambiguator\":\"17397750396228633469\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        });
                    }
                }
            };
            let mut context = LcdContext { panic };
            let mut state = LcdState::new(display1, display2)
                .uninitialized_state_machine()
                .init_with_context(&mut context)
                .await;
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::tasks::lcd".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        defmt::export::acquire_header_and_release(&{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"lcd state machine initialized\",\"disambiguator\":\"11153574590287017570\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"lcd state machine initialized\",\"disambiguator\":\"11153574590287017570\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        });
                    }
                }
            };
            let mut render_ticker = embassy_time::Ticker::every(Duration::from_millis(1000 / 12));
            loop {
                match state.state() {
                    State::Debug { debug: _ } => {
                        match select(EVENTS.receive(), crate::debug::receive()).await {
                            First(event) => state.handle_with_context(&event, &mut context).await,
                            Second(line) => {
                                state
                                    .handle_with_context(&LcdEvent::DebugLine(line), &mut context)
                                    .await
                            }
                        }
                    }
                    _ => {
                        let event = match select(EVENTS.receive(), render_ticker.next()).await {
                            First(event) => event,
                            Second(_) => LcdEvent::Render,
                        };
                        state.handle_with_context(&event, &mut context).await;
                    }
                }
            }
        }
        pub fn run(
            display1: Display1,
            display2: Display2,
            panic: Option<&'static str>,
        ) -> ::embassy_executor::SpawnToken<impl Sized> {
            trait _EmbassyInternalTaskTrait {
                type Fut: ::core::future::Future + 'static;
                fn construct(
                    display1: Display1,
                    display2: Display2,
                    panic: Option<&'static str>,
                ) -> Self::Fut;
            }
            impl _EmbassyInternalTaskTrait for () {
                type Fut = impl core::future::Future + 'static;
                fn construct(
                    display1: Display1,
                    display2: Display2,
                    panic: Option<&'static str>,
                ) -> Self::Fut {
                    __run_task(display1, display2, panic)
                }
            }
            const POOL_SIZE: usize = 1;
            static POOL: ::embassy_executor::raw::TaskPool<
                <() as _EmbassyInternalTaskTrait>::Fut,
                POOL_SIZE,
            > = ::embassy_executor::raw::TaskPool::new();
            unsafe {
                POOL._spawn_async_fn(move || {
                    <() as _EmbassyInternalTaskTrait>::construct(display1, display2, panic)
                })
            }
        }
    }
    pub mod led {
        use embassy_futures::select::select;
        use super::{obd2::obd2_inited, power::get_shutdown_signal};
        #[doc(hidden)]
        async fn __run_task(mut led: crate::types::Led) {
            select(
                async {
                    loop {
                        led.set_low();
                        embassy_time::Timer::after(embassy_time::Duration::from_millis(10)).await;
                        led.set_high();
                        if obd2_inited() {
                            embassy_time::Timer::after(embassy_time::Duration::from_secs(2)).await;
                        } else {
                            embassy_time::Timer::after(embassy_time::Duration::from_millis(250))
                                .await;
                        }
                    }
                },
                get_shutdown_signal().next_message(),
            )
            .await;
            led.set_high();
        }
        pub fn run(led: crate::types::Led) -> ::embassy_executor::SpawnToken<impl Sized> {
            trait _EmbassyInternalTaskTrait {
                type Fut: ::core::future::Future + 'static;
                fn construct(led: crate::types::Led) -> Self::Fut;
            }
            impl _EmbassyInternalTaskTrait for () {
                type Fut = impl core::future::Future + 'static;
                fn construct(led: crate::types::Led) -> Self::Fut {
                    __run_task(led)
                }
            }
            const POOL_SIZE: usize = 1;
            static POOL: ::embassy_executor::raw::TaskPool<
                <() as _EmbassyInternalTaskTrait>::Fut,
                POOL_SIZE,
            > = ::embassy_executor::raw::TaskPool::new();
            unsafe {
                POOL._spawn_async_fn(move || <() as _EmbassyInternalTaskTrait>::construct(led))
            }
        }
    }
    pub mod obd2 {
        use core::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
        use defmt::*;
        use embassy_futures::select::{select, Either};
        pub use embassy_sync::watch::Watch;
        use embassy_sync::{
            blocking_mutex::raw::CriticalSectionRawMutex, channel::Channel, mutex::Mutex,
            signal::Signal,
        };
        use embassy_time::{with_timeout, Duration};
        use serde::{Deserialize, Serialize};
        pub use types::{Pid as Obd2Event, PidError as Obd2Error};
        static OBD2_SETS_CHANGED: Signal<CriticalSectionRawMutex, Obd2PidSets> = Signal::new();
        static OBD2_INITED: embassy_sync::watch::Watch<CriticalSectionRawMutex, bool, 10> =
            Watch::new_with(false);
        static OBD2_INIT: AtomicBool = AtomicBool::new(false);
        static OBD2_CUSTOM_FRAMES: Channel<CriticalSectionRawMutex, types::Obd2Frame, 8> =
            Channel::new();
        use crate::{
            debug::internal_debug,
            event::{KiaEvent, KIA_EVENTS},
            obd2::{Obd2, Pid},
            pid,
            tasks::{ieee802154::extra_txframes_pub, power::get_shutdown_signal},
        };
        pub struct Obd2Debug {
            pub type_id: &'static str,
            pub data: Option<alloc::vec::Vec<u8>>,
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Obd2Debug {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Obd2Debug {
            #[inline]
            fn eq(&self, other: &Obd2Debug) -> bool {
                self.type_id == other.type_id && self.data == other.data
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Obd2Debug {
            #[inline]
            fn clone(&self) -> Obd2Debug {
                Obd2Debug {
                    type_id: ::core::clone::Clone::clone(&self.type_id),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        impl Obd2Debug {
            pub fn new<PID: Pid + core::any::Any>(data: Option<alloc::vec::Vec<u8>>) -> Self {
                Self {
                    type_id: core::any::type_name::<PID>()
                        .split("::")
                        .last()
                        .unwrap_or_default(),
                    data,
                }
            }
        }
        impl defmt::Format for Obd2Debug {
            fn format(&self, f: defmt::Formatter) {
                {
                    let _typecheck_formatter: defmt::Formatter<'_> = f;
                    match (&(self.type_id)) {
                        (arg0) => {
                            defmt::export::istr(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_write\",\"data\":\"Obd2Debug {}\",\"disambiguator\":\"17910924409867512604\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_write\",\"data\":\"Obd2Debug {}\",\"disambiguator\":\"17910924409867512604\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static S: u8 = 0;
                                    &S as *const u8 as u16
                                })
                            });
                            defmt::export::fmt(arg0);
                        }
                    }
                };
            }
        }
        pub enum Obd2PidSets {
            IgnitionOn,
            IgnitionOff,
            Charging,
            None,
        }
        impl defmt::Format for Obd2PidSets {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::obd2".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"3530132726925811945\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"3530132726925811945\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"IgnitionOn|IgnitionOff|Charging|None\",\"disambiguator\":\"3099927664753075370\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"IgnitionOn|IgnitionOff|Charging|None\",\"disambiguator\":\"3099927664753075370\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    Obd2PidSets::IgnitionOn {} => {
                        defmt::export::u8(&0u8);
                    }
                    Obd2PidSets::IgnitionOff {} => {
                        defmt::export::u8(&1u8);
                    }
                    Obd2PidSets::Charging {} => {
                        defmt::export::u8(&2u8);
                    }
                    Obd2PidSets::None {} => {
                        defmt::export::u8(&3u8);
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Obd2PidSets {
            #[inline]
            fn clone(&self) -> Obd2PidSets {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Obd2PidSets {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Obd2PidSets {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Obd2PidSets {
            #[inline]
            fn eq(&self, other: &Obd2PidSets) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Obd2PidSets {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl Obd2PidSets {
            pub async fn handle(&self, obd2: &mut Obd2) -> bool {
                match self {
                    Self::IgnitionOn => Self::handle_ignition_on(obd2).await,
                    Self::IgnitionOff => Self::handle_ignition_off(obd2).await,
                    Self::Charging => Self::handle_charging(obd2).await,
                    Self::None => false,
                }
            }
            async fn handle_ignition_on(obd2: &mut Obd2) -> bool {
                let mut all_ok = true;
                let mut any_ok = false;
                obd2.enable_obd2_pid_periods();
                let ret = obd2.handle_pid::<pid::BmsPid>().await;
                all_ok = ret && all_ok;
                any_ok = ret || any_ok;
                let ret = obd2.handle_pid::<pid::TransaxlePid>().await;
                all_ok = ret && all_ok;
                any_ok = ret || any_ok;
                let ret = obd2.handle_pid::<pid::IceTemperaturePid>().await;
                all_ok = ret && all_ok;
                any_ok = ret || any_ok;
                let ret = obd2.handle_pid::<pid::IceFuelRatePid>().await;
                all_ok = ret && all_ok;
                any_ok = ret || any_ok;
                let ret = obd2.handle_pid::<pid::VehicleSpeedPid>().await;
                all_ok = ret && all_ok;
                any_ok = ret || any_ok;
                let ret = obd2.handle_pid::<pid::HybridDcDcPid>().await;
                all_ok = ret && all_ok;
                any_ok = ret || any_ok;
                let ret = obd2.handle_pid::<pid::IcuPid>().await;
                all_ok = ret && all_ok;
                any_ok = ret || any_ok;
                let ret = obd2.handle_pid::<pid::Icu2Pid>().await;
                all_ok = ret && all_ok;
                any_ok = ret || any_ok;
                let ret = obd2.handle_pid::<pid::Icu3Pid>().await;
                all_ok = ret && all_ok;
                any_ok = ret || any_ok;
                let ret = obd2.handle_pid::<pid::IceEnginePid>().await;
                all_ok = ret && all_ok;
                any_ok = ret || any_ok;
                let ret = obd2.handle_pid::<pid::OnBoardChargerPid>().await;
                all_ok = ret && all_ok;
                any_ok = ret || any_ok;
                let ret = obd2.handle_pid::<pid::Icu1Smk>().await;
                all_ok = ret && all_ok;
                any_ok = ret || any_ok;
                let ret = obd2.handle_pid::<pid::AcPid>().await;
                all_ok = ret && all_ok;
                any_ok = ret || any_ok;
                if !any_ok {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::obd2".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"obd2 pid error in handle_ignition_on\",\"disambiguator\":\"5317361940187185298\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"obd2 pid error in handle_ignition_on\",\"disambiguator\":\"5317361940187185298\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    obd2.reset().await;
                }
                all_ok
            }
            async fn handle_charging(obd2: &mut Obd2) -> bool {
                let mut ret = true;
                obd2.disable_obd2_pid_periods();
                ret = obd2.handle_pid::<pid::BmsPid>().await && ret;
                ret = obd2.handle_pid::<pid::IceTemperaturePid>().await && ret;
                ret = obd2.handle_pid::<pid::IcuPid>().await && ret;
                ret = obd2.handle_pid::<pid::Icu2Pid>().await && ret;
                ret = obd2.handle_pid::<pid::Icu3Pid>().await && ret;
                ret = obd2.handle_pid::<pid::OnBoardChargerPid>().await && ret;
                ret = obd2.handle_pid::<pid::Icu1Smk>().await && ret;
                ret
            }
            async fn handle_ignition_off(obd2: &mut Obd2) -> bool {
                let mut ret = true;
                obd2.disable_obd2_pid_periods();
                ret = obd2.handle_pid::<pid::IcuPid>().await && ret;
                ret = obd2.handle_pid::<pid::Icu2Pid>().await && ret;
                ret = obd2.handle_pid::<pid::Icu3Pid>().await && ret;
                ret = obd2.handle_pid::<pid::Icu1Smk>().await && ret;
                obd2.handle_pid::<pid::OnBoardChargerPid>().await;
                ret
            }
            pub async fn loop_delay(&self) {
                let delay = match self {
                    Self::Charging => embassy_time::Duration::from_secs(1),
                    Self::IgnitionOff => embassy_time::Duration::from_secs(1),
                    Self::IgnitionOn | Self::None => embassy_time::Duration::from_millis(100),
                };
                embassy_time::Timer::after(delay).await;
            }
        }
        #[doc(hidden)]
        async fn __run_task(mut obd2: Obd2) {
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::tasks::obd2".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        defmt::export::acquire_header_and_release(&{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"obd2 task started\",\"disambiguator\":\"3071956819413203233\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"obd2 task started\",\"disambiguator\":\"3071956819413203233\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        });
                    }
                }
            };
            let obd2_inited = OBD2_INITED.sender();
            let ieee802154_extra_txframes_pub = extra_txframes_pub();
            embassy_time::Timer::after(embassy_time::Duration::from_secs(1)).await;
            {
                with_timeout(Duration::from_secs(60), async {
                    loop {
                        if obd2.init().await.is_ok() {
                            break;
                        }
                        KIA_EVENTS.send(KiaEvent::Obd2Init(false)).await;
                    }
                })
                .await
                .ok();
            }
            obd2_inited.send(true);
            OBD2_INIT.store(true, Ordering::Relaxed);
            KIA_EVENTS.send(KiaEvent::Obd2Init(true)).await;
            embassy_time::Timer::after(Duration::from_millis(100)).await;
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::tasks::obd2".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        defmt::export::acquire_header_and_release(&{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"obd2 init done\",\"disambiguator\":\"9031836224298508679\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"obd2 init done\",\"disambiguator\":\"9031836224298508679\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        });
                    }
                }
            };
            let obd2_custom_frames_recv = OBD2_CUSTOM_FRAMES.receiver();
            let mut current_sets = OBD2_SETS_CHANGED.wait().await;
            select(async {
                        loop {
                            if let Some(new_sets) = OBD2_SETS_CHANGED.try_take() {
                                    match (&(new_sets)) {
                                        (arg0) => {
                                            if {
                                                        const CHECK: bool =
                                                            {
                                                                const fn check() -> bool {
                                                                    let module_path =
                                                                        "kia_obd2_esp32c3_v2::tasks::obd2".as_bytes();
                                                                    if if 19usize > module_path.len() {
                                                                                    false
                                                                                } else {
                                                                                   module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                           && module_path[2usize] == 97u8 &&
                                                                                                                                                       module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                               && module_path[5usize] == 98u8 &&
                                                                                                                                           module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                   && module_path[8usize] == 95u8 &&
                                                                                                                               module_path[9usize] == 101u8 &&
                                                                                                                           module_path[10usize] == 115u8 &&
                                                                                                                       module_path[11usize] == 112u8 &&
                                                                                                                   module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                           && module_path[14usize] == 99u8 &&
                                                                                                       module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                               && module_path[17usize] == 118u8 &&
                                                                                           module_path[18usize] == 50u8 &&
                                                                                       if 19usize == module_path.len() {
                                                                                               true
                                                                                           } else { module_path[19usize] == b':' }
                                                                               } {
                                                                            return true;
                                                                        }
                                                                    false
                                                                }
                                                                check()
                                                            };
                                                        CHECK
                                                    } {
                                                    unsafe {
                                                        defmt::export::acquire_and_header(&{
                                                                    defmt::export::make_istr({
                                                                            #[link_section =
                                                                            ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"obd2 sets changed: {:?}\",\"disambiguator\":\"18443401410493334445\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            #[export_name =
                                                                            "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"obd2 sets changed: {:?}\",\"disambiguator\":\"18443401410493334445\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                        })
                                                                });
                                                    };
                                                    defmt::export::fmt(arg0);
                                                    unsafe { defmt::export::release() }
                                                }
                                        }
                                    };
                                    if current_sets != new_sets {
                                            current_sets = new_sets;
                                            obd2.clear_pids_cache();
                                        }
                                }
                            let all = current_sets.handle(&mut obd2).await;
                            KIA_EVENTS.send(KiaEvent::Obd2LoopEnd(current_sets,
                                        all)).await;
                            match select(obd2_custom_frames_recv.receive(),
                                        current_sets.loop_delay()).await {
                                Either::First(obd2_custom_frame) => {
                                    crate::tasks::state::EVENTS.send(KiaEvent::IgnitionOffResetTimeout).await;
                                    match (&(obd2_custom_frame)) {
                                        (arg0) => {
                                            if {
                                                        const CHECK: bool =
                                                            {
                                                                const fn check() -> bool {
                                                                    let module_path =
                                                                        "kia_obd2_esp32c3_v2::tasks::obd2".as_bytes();
                                                                    if if 19usize > module_path.len() {
                                                                                    false
                                                                                } else {
                                                                                   module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                           && module_path[2usize] == 97u8 &&
                                                                                                                                                       module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                               && module_path[5usize] == 98u8 &&
                                                                                                                                           module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                   && module_path[8usize] == 95u8 &&
                                                                                                                               module_path[9usize] == 101u8 &&
                                                                                                                           module_path[10usize] == 115u8 &&
                                                                                                                       module_path[11usize] == 112u8 &&
                                                                                                                   module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                           && module_path[14usize] == 99u8 &&
                                                                                                       module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                               && module_path[17usize] == 118u8 &&
                                                                                           module_path[18usize] == 50u8 &&
                                                                                       if 19usize == module_path.len() {
                                                                                               true
                                                                                           } else { module_path[19usize] == b':' }
                                                                               } {
                                                                            return true;
                                                                        }
                                                                    false
                                                                }
                                                                check()
                                                            };
                                                        CHECK
                                                    } {
                                                    unsafe {
                                                        defmt::export::acquire_and_header(&{
                                                                    defmt::export::make_istr({
                                                                            #[link_section =
                                                                            ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"obd2 custom frame: {:?}\",\"disambiguator\":\"7343412781245524431\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            #[export_name =
                                                                            "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"obd2 custom frame: {:?}\",\"disambiguator\":\"7343412781245524431\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                        })
                                                                });
                                                    };
                                                    defmt::export::fmt(arg0);
                                                    unsafe { defmt::export::release() }
                                                }
                                        }
                                    };
                                    if let Ok(response) =
                                                obd2.send_custom_frame(obd2_custom_frame).await {
                                            ieee802154_extra_txframes_pub.publish(types::TxFrame::Obd2Frame(response)).await;
                                        }
                                }
                                Either::Second(_) => {}
                            }
                        }
                    }, get_shutdown_signal().next_message()).await;
            obd2.shutdown().await;
        }
        pub fn run(obd2: Obd2) -> ::embassy_executor::SpawnToken<impl Sized> {
            trait _EmbassyInternalTaskTrait {
                type Fut: ::core::future::Future + 'static;
                fn construct(obd2: Obd2) -> Self::Fut;
            }
            impl _EmbassyInternalTaskTrait for () {
                type Fut = impl core::future::Future + 'static;
                fn construct(obd2: Obd2) -> Self::Fut {
                    __run_task(obd2)
                }
            }
            const POOL_SIZE: usize = 1;
            static POOL: ::embassy_executor::raw::TaskPool<
                <() as _EmbassyInternalTaskTrait>::Fut,
                POOL_SIZE,
            > = ::embassy_executor::raw::TaskPool::new();
            unsafe {
                POOL._spawn_async_fn(move || <() as _EmbassyInternalTaskTrait>::construct(obd2))
            }
        }
        pub async fn set_obd2_sets(sets: Obd2PidSets) {
            match (&(sets)) {
                (arg0) => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::tasks::obd2".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe {
                            defmt::export::acquire_and_header(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"obd2 sets changed: {:?}\",\"disambiguator\":\"16040691510156211246\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"obd2 sets changed: {:?}\",\"disambiguator\":\"16040691510156211246\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        };
                        defmt::export::fmt(arg0);
                        unsafe { defmt::export::release() }
                    }
                }
            };
            OBD2_SETS_CHANGED.signal(sets);
        }
        pub async fn obd2_init_wait() {
            let mut obd2_inited_recv = match defmt::export::into_result(OBD2_INITED.receiver()) {
                ::core::result::Result::Ok(res) => res,
                ::core::result::Result::Err(_unwrap_err) => {
                    match (&(_unwrap_err)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::obd2".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: OBD2_INITED.receiver()'\\nerror: `{:?}`\",\"disambiguator\":\"13922733801398224703\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: OBD2_INITED.receiver()'\\nerror: `{:?}`\",\"disambiguator\":\"13922733801398224703\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    defmt::export::panic()
                }
            };
            while obd2_inited_recv.try_changed_and(|o| *o) != Some(true) {
                match with_timeout(Duration::from_millis(100), obd2_inited_recv.changed()).await {
                    Ok(true) => break,
                    Ok(false) => {}
                    Err(_) => {
                        if OBD2_INIT.load(Ordering::Relaxed) {
                            break;
                        }
                    }
                }
            }
        }
        pub fn obd2_inited() -> bool {
            OBD2_INIT.load(Ordering::Relaxed)
        }
        pub async fn send_custom_frame(frame: types::Obd2Frame) {
            OBD2_CUSTOM_FRAMES.send(frame).await;
        }
    }
    pub mod power {
        use core::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
        use defmt::*;
        use embassy_futures::select::{select3, Either3::*};
        use embassy_sync::{
            blocking_mutex::raw::CriticalSectionRawMutex, pubsub::PubSubChannel, signal::Signal,
        };
        use embassy_time::{Duration, Timer};
        use esp_hal::{debugger::debugger_connected, reset::SleepSource, Cpu};
        pub enum PowerEvent {
            Shutdown(embassy_time::Duration),
            RwdtFeed,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PowerEvent {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    PowerEvent::Shutdown(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Shutdown", &__self_0)
                    }
                    PowerEvent::RwdtFeed => ::core::fmt::Formatter::write_str(f, "RwdtFeed"),
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PowerEvent {
            #[inline]
            fn clone(&self) -> PowerEvent {
                match self {
                    PowerEvent::Shutdown(__self_0) => {
                        PowerEvent::Shutdown(::core::clone::Clone::clone(__self_0))
                    }
                    PowerEvent::RwdtFeed => PowerEvent::RwdtFeed,
                }
            }
        }
        static SHUTDOWN: PubSubChannel<CriticalSectionRawMutex, (), 1, 16, 1> =
            PubSubChannel::new();
        static SHUTDOWN_GUARD_DROP_SIGNAL: Signal<CriticalSectionRawMutex, ()> = Signal::new();
        static SHUTDOWN_GUARDS: AtomicUsize = AtomicUsize::new(0);
        static SHUTDOWN_REQUESTED: AtomicBool = AtomicBool::new(false);
        static POWER_EVENTS: PubSubChannel<CriticalSectionRawMutex, PowerEvent, 1, 1, 16> =
            PubSubChannel::new();
        use crate::{
            debug::internal_debug,
            event::*,
            power::{Ignition, Power},
        };
        #[doc(hidden)]
        async fn __run_task(mut power: Power) {
            if power.is_ignition_on() {
                KIA_EVENTS.send(KiaEvent::IgnitionOn).await;
            } else {
                KIA_EVENTS.send(KiaEvent::IgnitionOff).await;
            }
            let mut power_events_sub = match defmt::export::into_result(POWER_EVENTS.subscriber()) {
                ::core::result::Result::Ok(res) => res,
                ::core::result::Result::Err(_unwrap_err) => {
                    match (&(_unwrap_err)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::power".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: POWER_EVENTS.subscriber()'\\nerror: `{:?}`\",\"disambiguator\":\"7667481494471525345\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: POWER_EVENTS.subscriber()'\\nerror: `{:?}`\",\"disambiguator\":\"7667481494471525345\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    defmt::export::panic()
                }
            };
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2::tasks::power".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        defmt::export::acquire_header_and_release(&{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"power task select\",\"disambiguator\":\"8836666625184226384\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"power task select\",\"disambiguator\":\"8836666625184226384\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        });
                    }
                }
            };
            loop {
                match select3(
                    power.wait_for_ignition_change(),
                    power_events_sub.next_message_pure(),
                    Timer::after_secs(5),
                )
                .await
                {
                    First(ignition) => match ignition {
                        Ignition::On => {
                            KIA_EVENTS.send(KiaEvent::IgnitionOn).await;
                        }
                        Ignition::Off => {
                            KIA_EVENTS.send(KiaEvent::IgnitionOff).await;
                        }
                    },
                    Second(power_event) => match power_event {
                        PowerEvent::Shutdown(duration) => {
                            match (&(duration.as_secs())) {
                                (arg0) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::power".as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"shutdown event received for {:?}s\",\"disambiguator\":\"9767398967580859637\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"shutdown event received for {:?}s\",\"disambiguator\":\"9767398967580859637\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            match defmt::export::into_result(SHUTDOWN.publisher()) {
                                        ::core::result::Result::Ok(res) => res,
                                        ::core::result::Result::Err(_unwrap_err) => {
                                            match (&(_unwrap_err)) {
                                                (arg0) => {
                                                    if {
                                                                const CHECK: bool =
                                                                    {
                                                                        const fn check() -> bool {
                                                                            let module_path =
                                                                                "kia_obd2_esp32c3_v2::tasks::power".as_bytes();
                                                                            if if 19usize > module_path.len() {
                                                                                            false
                                                                                        } else {
                                                                                           module_path[0usize] == 107u8 && module_path[1usize] == 105u8
                                                                                                                                                                   && module_path[2usize] == 97u8 &&
                                                                                                                                                               module_path[3usize] == 95u8 && module_path[4usize] == 111u8
                                                                                                                                                       && module_path[5usize] == 98u8 &&
                                                                                                                                                   module_path[6usize] == 100u8 && module_path[7usize] == 50u8
                                                                                                                                           && module_path[8usize] == 95u8 &&
                                                                                                                                       module_path[9usize] == 101u8 &&
                                                                                                                                   module_path[10usize] == 115u8 &&
                                                                                                                               module_path[11usize] == 112u8 &&
                                                                                                                           module_path[12usize] == 51u8 && module_path[13usize] == 50u8
                                                                                                                   && module_path[14usize] == 99u8 &&
                                                                                                               module_path[15usize] == 51u8 && module_path[16usize] == 95u8
                                                                                                       && module_path[17usize] == 118u8 &&
                                                                                                   module_path[18usize] == 50u8 &&
                                                                                               if 19usize == module_path.len() {
                                                                                                       true
                                                                                                   } else { module_path[19usize] == b':' }
                                                                                       } {
                                                                                    return true;
                                                                                }
                                                                            false
                                                                        }
                                                                        check()
                                                                    };
                                                                CHECK
                                                            } {
                                                            unsafe {
                                                                defmt::export::acquire_and_header(&{
                                                                            defmt::export::make_istr({
                                                                                    #[link_section =
                                                                                    ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: SHUTDOWN.publisher()'\\nerror: `{:?}`\",\"disambiguator\":\"6441900794313166865\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                    #[export_name =
                                                                                    "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: SHUTDOWN.publisher()'\\nerror: `{:?}`\",\"disambiguator\":\"6441900794313166865\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                                                })
                                                                        });
                                                            };
                                                            defmt::export::fmt(arg0);
                                                            unsafe { defmt::export::release() }
                                                        }
                                                }
                                            };
                                            defmt::export::panic()
                                        }
                                    }.publish_immediate(());
                            let delay_duration = if debugger_connected() {
                                match () {
                                    () => {
                                        if {
                                            const CHECK: bool = {
                                                const fn check() -> bool {
                                                    let module_path =
                                                        "kia_obd2_esp32c3_v2::tasks::power"
                                                            .as_bytes();
                                                    if if 19usize > module_path.len() {
                                                        false
                                                    } else {
                                                        module_path[0usize] == 107u8
                                                            && module_path[1usize] == 105u8
                                                            && module_path[2usize] == 97u8
                                                            && module_path[3usize] == 95u8
                                                            && module_path[4usize] == 111u8
                                                            && module_path[5usize] == 98u8
                                                            && module_path[6usize] == 100u8
                                                            && module_path[7usize] == 50u8
                                                            && module_path[8usize] == 95u8
                                                            && module_path[9usize] == 101u8
                                                            && module_path[10usize] == 115u8
                                                            && module_path[11usize] == 112u8
                                                            && module_path[12usize] == 51u8
                                                            && module_path[13usize] == 50u8
                                                            && module_path[14usize] == 99u8
                                                            && module_path[15usize] == 51u8
                                                            && module_path[16usize] == 95u8
                                                            && module_path[17usize] == 118u8
                                                            && module_path[18usize] == 50u8
                                                            && if 19usize == module_path.len() {
                                                                true
                                                            } else {
                                                                module_path[19usize] == b':'
                                                            }
                                                    } {
                                                        return true;
                                                    }
                                                    false
                                                }
                                                check()
                                            };
                                            CHECK
                                        } {
                                            defmt::export::acquire_header_and_release(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"debugger connected, deep sleeping in 5s\",\"disambiguator\":\"7882051596432693517\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"debugger connected, deep sleeping in 5s\",\"disambiguator\":\"7882051596432693517\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        }
                                    }
                                };
                                Duration::from_secs(5)
                            } else {
                                match () {
                                    () => {
                                        if {
                                            const CHECK: bool = {
                                                const fn check() -> bool {
                                                    let module_path =
                                                        "kia_obd2_esp32c3_v2::tasks::power"
                                                            .as_bytes();
                                                    if if 19usize > module_path.len() {
                                                        false
                                                    } else {
                                                        module_path[0usize] == 107u8
                                                            && module_path[1usize] == 105u8
                                                            && module_path[2usize] == 97u8
                                                            && module_path[3usize] == 95u8
                                                            && module_path[4usize] == 111u8
                                                            && module_path[5usize] == 98u8
                                                            && module_path[6usize] == 100u8
                                                            && module_path[7usize] == 50u8
                                                            && module_path[8usize] == 95u8
                                                            && module_path[9usize] == 101u8
                                                            && module_path[10usize] == 115u8
                                                            && module_path[11usize] == 112u8
                                                            && module_path[12usize] == 51u8
                                                            && module_path[13usize] == 50u8
                                                            && module_path[14usize] == 99u8
                                                            && module_path[15usize] == 51u8
                                                            && module_path[16usize] == 95u8
                                                            && module_path[17usize] == 118u8
                                                            && module_path[18usize] == 50u8
                                                            && if 19usize == module_path.len() {
                                                                true
                                                            } else {
                                                                module_path[19usize] == b':'
                                                            }
                                                    } {
                                                        return true;
                                                    }
                                                    false
                                                }
                                                check()
                                            };
                                            CHECK
                                        } {
                                            defmt::export::acquire_header_and_release(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"debugger not connected, deep sleeping in 200ms\",\"disambiguator\":\"18308052368306762468\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"debugger not connected, deep sleeping in 200ms\",\"disambiguator\":\"18308052368306762468\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        }
                                    }
                                };
                                Duration::from_millis(200)
                            };
                            embassy_time::with_timeout(Duration::from_secs(120), async {
                                SHUTDOWN_REQUESTED.store(true, Ordering::Relaxed);
                                while SHUTDOWN_GUARDS.load(Ordering::Relaxed) != 0 {
                                    SHUTDOWN_GUARD_DROP_SIGNAL.wait().await;
                                }
                            })
                            .await
                            .ok();
                            Timer::after(delay_duration).await;
                            if power.is_ignition_on() {
                                match () {
                                    () => {
                                        if {
                                            const CHECK: bool = {
                                                const fn check() -> bool {
                                                    let module_path =
                                                        "kia_obd2_esp32c3_v2::tasks::power"
                                                            .as_bytes();
                                                    if if 19usize > module_path.len() {
                                                        false
                                                    } else {
                                                        module_path[0usize] == 107u8
                                                            && module_path[1usize] == 105u8
                                                            && module_path[2usize] == 97u8
                                                            && module_path[3usize] == 95u8
                                                            && module_path[4usize] == 111u8
                                                            && module_path[5usize] == 98u8
                                                            && module_path[6usize] == 100u8
                                                            && module_path[7usize] == 50u8
                                                            && module_path[8usize] == 95u8
                                                            && module_path[9usize] == 101u8
                                                            && module_path[10usize] == 115u8
                                                            && module_path[11usize] == 112u8
                                                            && module_path[12usize] == 51u8
                                                            && module_path[13usize] == 50u8
                                                            && module_path[14usize] == 99u8
                                                            && module_path[15usize] == 51u8
                                                            && module_path[16usize] == 95u8
                                                            && module_path[17usize] == 118u8
                                                            && module_path[18usize] == 50u8
                                                            && if 19usize == module_path.len() {
                                                                true
                                                            } else {
                                                                module_path[19usize] == b':'
                                                            }
                                                    } {
                                                        return true;
                                                    }
                                                    false
                                                }
                                                check()
                                            };
                                            CHECK
                                        } {
                                            defmt::export::acquire_header_and_release(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"ignition is on, not deep sleeping\",\"disambiguator\":\"11562690768005096200\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"ignition is on, not deep sleeping\",\"disambiguator\":\"11562690768005096200\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        }
                                    }
                                };
                                esp_hal::reset::software_reset();
                            } else {
                                match (&(duration)) {
                                    (arg0) => {
                                        if {
                                            const CHECK: bool = {
                                                const fn check() -> bool {
                                                    let module_path =
                                                        "kia_obd2_esp32c3_v2::tasks::power"
                                                            .as_bytes();
                                                    if if 19usize > module_path.len() {
                                                        false
                                                    } else {
                                                        module_path[0usize] == 107u8
                                                            && module_path[1usize] == 105u8
                                                            && module_path[2usize] == 97u8
                                                            && module_path[3usize] == 95u8
                                                            && module_path[4usize] == 111u8
                                                            && module_path[5usize] == 98u8
                                                            && module_path[6usize] == 100u8
                                                            && module_path[7usize] == 50u8
                                                            && module_path[8usize] == 95u8
                                                            && module_path[9usize] == 101u8
                                                            && module_path[10usize] == 115u8
                                                            && module_path[11usize] == 112u8
                                                            && module_path[12usize] == 51u8
                                                            && module_path[13usize] == 50u8
                                                            && module_path[14usize] == 99u8
                                                            && module_path[15usize] == 51u8
                                                            && module_path[16usize] == 95u8
                                                            && module_path[17usize] == 118u8
                                                            && module_path[18usize] == 50u8
                                                            && if 19usize == module_path.len() {
                                                                true
                                                            } else {
                                                                module_path[19usize] == b':'
                                                            }
                                                    } {
                                                        return true;
                                                    }
                                                    false
                                                }
                                                check()
                                            };
                                            CHECK
                                        } {
                                            unsafe {
                                                defmt::export::acquire_and_header(&{
                                                    defmt::export::make_istr({
                                                        #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"deep sleeping for {:?}\",\"disambiguator\":\"12997528559061860331\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"deep sleeping for {:?}\",\"disambiguator\":\"12997528559061860331\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                    })
                                                });
                                            };
                                            defmt::export::fmt(arg0);
                                            unsafe { defmt::export::release() }
                                        }
                                    }
                                };
                                power.deep_sleep(duration);
                            }
                        }
                        PowerEvent::RwdtFeed => {
                            power.rwdt_feed();
                        }
                    },
                    Third(_) => {
                        if power.is_ignition_on() {
                            KIA_EVENTS.send(KiaEvent::IgnitionOn).await;
                        } else {
                            KIA_EVENTS.send(KiaEvent::IgnitionOff).await;
                        }
                    }
                }
            }
        }
        pub fn run(power: Power) -> ::embassy_executor::SpawnToken<impl Sized> {
            trait _EmbassyInternalTaskTrait {
                type Fut: ::core::future::Future + 'static;
                fn construct(power: Power) -> Self::Fut;
            }
            impl _EmbassyInternalTaskTrait for () {
                type Fut = impl core::future::Future + 'static;
                fn construct(power: Power) -> Self::Fut {
                    __run_task(power)
                }
            }
            const POOL_SIZE: usize = 1;
            static POOL: ::embassy_executor::raw::TaskPool<
                <() as _EmbassyInternalTaskTrait>::Fut,
                POOL_SIZE,
            > = ::embassy_executor::raw::TaskPool::new();
            unsafe {
                POOL._spawn_async_fn(move || <() as _EmbassyInternalTaskTrait>::construct(power))
            }
        }
        pub fn get_shutdown_signal(
        ) -> embassy_sync::pubsub::Subscriber<'static, CriticalSectionRawMutex, (), 1, 16, 1>
        {
            match defmt::export::into_result(SHUTDOWN.subscriber()) {
                ::core::result::Result::Ok(res) => res,
                ::core::result::Result::Err(_unwrap_err) => {
                    match (&(_unwrap_err)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::power".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: SHUTDOWN.subscriber()'\\nerror: `{:?}`\",\"disambiguator\":\"8602959931760886249\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: SHUTDOWN.subscriber()'\\nerror: `{:?}`\",\"disambiguator\":\"8602959931760886249\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
        }
        pub type PowerEventPublisher = embassy_sync::pubsub::DynPublisher<'static, PowerEvent>;
        pub fn get_power_events_pub() -> PowerEventPublisher {
            match defmt::export::into_result(POWER_EVENTS.dyn_publisher()) {
                ::core::result::Result::Ok(res) => res,
                ::core::result::Result::Err(_unwrap_err) => {
                    match (&(_unwrap_err)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::power".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: POWER_EVENTS.dyn_publisher()'\\nerror: `{:?}`\",\"disambiguator\":\"8482675428668408459\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'unwrap failed: POWER_EVENTS.dyn_publisher()'\\nerror: `{:?}`\",\"disambiguator\":\"8482675428668408459\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
        }
        pub struct ShutdownGuard;
        impl ShutdownGuard {
            pub fn new() -> Self {
                SHUTDOWN_GUARDS.fetch_add(1, Ordering::Relaxed);
                Self
            }
        }
        impl Drop for ShutdownGuard {
            fn drop(&mut self) {
                SHUTDOWN_GUARDS.fetch_sub(1, Ordering::Relaxed);
                let requested = SHUTDOWN_REQUESTED.load(Ordering::Relaxed);
                if requested {
                    SHUTDOWN_GUARD_DROP_SIGNAL.signal(());
                }
            }
        }
    }
    pub mod state {
        use defmt::*;
        use embassy_futures::select::{select, Either::*};
        use embassy_sync::{blocking_mutex::raw::CriticalSectionRawMutex, channel::Channel};
        use embassy_time::{with_timeout, Duration, Instant};
        use esp_hal_procmacros::ram;
        use statig::prelude::*;
        use types::OnBoardChargerPid;
        use super::{
            ieee802154::{extra_txframes_pub, TxFramePub},
            obd2::{set_obd2_sets, Obd2Debug, Obd2PidSets},
            power::{get_power_events_pub, PowerEvent, PowerEventPublisher},
        };
        use crate::{
            event::{LcdEvent, Obd2Event, LCD_EVENTS},
            tasks::{
                buttons::{Action, Button},
                ieee802154,
            },
        };
        pub static EVENTS: Channel<CriticalSectionRawMutex, KiaEvent, 128> = Channel::new();
        pub enum KiaEvent {
            IgnitionOff,
            IgnitionOffResetTimeout,
            IgnitionOn,
            Button(crate::tasks::buttons::Action),
            Obd2Event(Obd2Event),
            Obd2Debug(Obd2Debug),
            Obd2LoopEnd(Obd2PidSets, bool),
            Obd2Init(bool),
            Ticker,
        }
        impl defmt::Format for KiaEvent
        where
            crate::tasks::buttons::Action: defmt::Format,
            Obd2Event: defmt::Format,
            Obd2Debug: defmt::Format,
            Obd2PidSets: defmt::Format,
        {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::state".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"14278182546970236923\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"14278182546970236923\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"IgnitionOff|IgnitionOffResetTimeout|IgnitionOn|Button({=?})|Obd2Event({=?})|Obd2Debug({=?})|Obd2LoopEnd({=?}, {=bool})|Obd2Init({=bool})|Ticker\",\"disambiguator\":\"1403866201056804048\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"IgnitionOff|IgnitionOffResetTimeout|IgnitionOn|Button({=?})|Obd2Event({=?})|Obd2Debug({=?})|Obd2LoopEnd({=?}, {=bool})|Obd2Init({=bool})|Ticker\",\"disambiguator\":\"1403866201056804048\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    KiaEvent::IgnitionOff {} => {
                        defmt::export::u8(&0u8);
                    }
                    KiaEvent::IgnitionOffResetTimeout {} => {
                        defmt::export::u8(&1u8);
                    }
                    KiaEvent::IgnitionOn {} => {
                        defmt::export::u8(&2u8);
                    }
                    KiaEvent::Button { 0: arg0 } => {
                        defmt::export::u8(&3u8);
                        defmt::export::fmt(arg0);
                    }
                    KiaEvent::Obd2Event { 0: arg0 } => {
                        defmt::export::u8(&4u8);
                        defmt::export::fmt(arg0);
                    }
                    KiaEvent::Obd2Debug { 0: arg0 } => {
                        defmt::export::u8(&5u8);
                        defmt::export::fmt(arg0);
                    }
                    KiaEvent::Obd2LoopEnd { 0: arg0, 1: arg1 } => {
                        defmt::export::u8(&6u8);
                        defmt::export::fmt(arg0);
                        defmt::export::bool(arg1);
                    }
                    KiaEvent::Obd2Init { 0: arg0 } => {
                        defmt::export::u8(&7u8);
                        defmt::export::bool(arg0);
                    }
                    KiaEvent::Ticker {} => {
                        defmt::export::u8(&8u8);
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for KiaEvent {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for KiaEvent {
            #[inline]
            fn eq(&self, other: &KiaEvent) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (KiaEvent::Button(__self_0), KiaEvent::Button(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (KiaEvent::Obd2Event(__self_0), KiaEvent::Obd2Event(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (KiaEvent::Obd2Debug(__self_0), KiaEvent::Obd2Debug(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (
                            KiaEvent::Obd2LoopEnd(__self_0, __self_1),
                            KiaEvent::Obd2LoopEnd(__arg1_0, __arg1_1),
                        ) => __self_0 == __arg1_0 && __self_1 == __arg1_1,
                        (KiaEvent::Obd2Init(__self_0), KiaEvent::Obd2Init(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        _ => true,
                    }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for KiaEvent {
            #[inline]
            fn clone(&self) -> KiaEvent {
                match self {
                    KiaEvent::IgnitionOff => KiaEvent::IgnitionOff,
                    KiaEvent::IgnitionOffResetTimeout => KiaEvent::IgnitionOffResetTimeout,
                    KiaEvent::IgnitionOn => KiaEvent::IgnitionOn,
                    KiaEvent::Button(__self_0) => {
                        KiaEvent::Button(::core::clone::Clone::clone(__self_0))
                    }
                    KiaEvent::Obd2Event(__self_0) => {
                        KiaEvent::Obd2Event(::core::clone::Clone::clone(__self_0))
                    }
                    KiaEvent::Obd2Debug(__self_0) => {
                        KiaEvent::Obd2Debug(::core::clone::Clone::clone(__self_0))
                    }
                    KiaEvent::Obd2LoopEnd(__self_0, __self_1) => KiaEvent::Obd2LoopEnd(
                        ::core::clone::Clone::clone(__self_0),
                        ::core::clone::Clone::clone(__self_1),
                    ),
                    KiaEvent::Obd2Init(__self_0) => {
                        KiaEvent::Obd2Init(::core::clone::Clone::clone(__self_0))
                    }
                    KiaEvent::Ticker => KiaEvent::Ticker,
                }
            }
        }
        #[link_section = ".rtc_fast.persistent"]
        static mut LAST_IGNITION_ON: i64 = 0;
        const _: () = esp_hal::__macro_implementation::assert_is_persistable::<i64>();
        pub struct KiaState {
            pub power_events_pub: PowerEventPublisher,
            pub tx_frame_pub: TxFramePub,
            pub rtc: crate::types::Rtc,
            pub obd2_init: bool,
        }
        use statig::{state, superstate, action};
        impl KiaState {
            async fn init(&mut self, event: &KiaEvent) -> Response<State> {
                match event {
                    KiaEvent::IgnitionOff => Transition(State::ignition_off(
                        Instant::now(),
                        Duration::from_secs(60),
                        false,
                        false,
                    )),
                    KiaEvent::IgnitionOn => Transition(State::ignition_on()),
                    _ => Handled,
                }
            }
            async fn enter_ignition_on(&mut self) {
                unsafe {
                    LAST_IGNITION_ON = self.rtc.lock().await.current_time().and_utc().timestamp();
                    match (&(LAST_IGNITION_ON)) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::state".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe {
                                    defmt::export::acquire_and_header(&{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"last ignition on: {}\",\"disambiguator\":\"520123669169073690\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"last ignition on: {}\",\"disambiguator\":\"520123669169073690\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    });
                                };
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                }
                ieee802154::send_now();
                LCD_EVENTS.send(LcdEvent::Main).await;
                set_obd2_sets(Obd2PidSets::IgnitionOn).await;
                self.tx_frame_pub
                    .publish_immediate(types::TxFrame::State(types::State::IgnitionOn));
            }
            async fn ignition_on(&mut self, event: &KiaEvent) -> Response<State> {
                match event {
                    KiaEvent::IgnitionOff => {
                        LCD_EVENTS.send(LcdEvent::PowerOff).await;
                        Transition(State::check_charging(Default::default(), Instant::now()))
                    }
                    KiaEvent::Obd2Event(obd2_event) => {
                        LCD_EVENTS
                            .send(LcdEvent::Obd2Event(obd2_event.clone()))
                            .await;
                        Handled
                    }
                    KiaEvent::Obd2Debug(obd2_debug) => {
                        LCD_EVENTS
                            .send(LcdEvent::Obd2Debug(obd2_debug.clone()))
                            .await;
                        Handled
                    }
                    KiaEvent::Obd2LoopEnd(set, _all) => {
                        LCD_EVENTS.send(LcdEvent::Render).await;
                        Handled
                    }
                    KiaEvent::Button(action) => {
                        match (&(action)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path =
                                                "kia_obd2_esp32c3_v2::tasks::state".as_bytes();
                                            if if 19usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 107u8
                                                    && module_path[1usize] == 105u8
                                                    && module_path[2usize] == 97u8
                                                    && module_path[3usize] == 95u8
                                                    && module_path[4usize] == 111u8
                                                    && module_path[5usize] == 98u8
                                                    && module_path[6usize] == 100u8
                                                    && module_path[7usize] == 50u8
                                                    && module_path[8usize] == 95u8
                                                    && module_path[9usize] == 101u8
                                                    && module_path[10usize] == 115u8
                                                    && module_path[11usize] == 112u8
                                                    && module_path[12usize] == 51u8
                                                    && module_path[13usize] == 50u8
                                                    && module_path[14usize] == 99u8
                                                    && module_path[15usize] == 51u8
                                                    && module_path[16usize] == 95u8
                                                    && module_path[17usize] == 118u8
                                                    && module_path[18usize] == 50u8
                                                    && if 19usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[19usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe {
                                        defmt::export::acquire_and_header(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button action: {:?}\",\"disambiguator\":\"16523790884801697234\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"button action: {:?}\",\"disambiguator\":\"16523790884801697234\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    };
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        match action {
                            _ => {
                                match (&(action)) {
                                    (arg0) => {
                                        if {
                                            const CHECK: bool = {
                                                const fn check() -> bool {
                                                    let module_path =
                                                        "kia_obd2_esp32c3_v2::tasks::state"
                                                            .as_bytes();
                                                    if if 19usize > module_path.len() {
                                                        false
                                                    } else {
                                                        module_path[0usize] == 107u8
                                                            && module_path[1usize] == 105u8
                                                            && module_path[2usize] == 97u8
                                                            && module_path[3usize] == 95u8
                                                            && module_path[4usize] == 111u8
                                                            && module_path[5usize] == 98u8
                                                            && module_path[6usize] == 100u8
                                                            && module_path[7usize] == 50u8
                                                            && module_path[8usize] == 95u8
                                                            && module_path[9usize] == 101u8
                                                            && module_path[10usize] == 115u8
                                                            && module_path[11usize] == 112u8
                                                            && module_path[12usize] == 51u8
                                                            && module_path[13usize] == 50u8
                                                            && module_path[14usize] == 99u8
                                                            && module_path[15usize] == 51u8
                                                            && module_path[16usize] == 95u8
                                                            && module_path[17usize] == 118u8
                                                            && module_path[18usize] == 50u8
                                                            && if 19usize == module_path.len() {
                                                                true
                                                            } else {
                                                                module_path[19usize] == b':'
                                                            }
                                                    } {
                                                        return true;
                                                    }
                                                    false
                                                }
                                                check()
                                            };
                                            CHECK
                                        } {
                                            unsafe {
                                                defmt::export::acquire_and_header(&{
                                                    defmt::export::make_istr({
                                                        #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"unhandled button action: {:?}\",\"disambiguator\":\"8750027619787502352\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"unhandled button action: {:?}\",\"disambiguator\":\"8750027619787502352\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                    })
                                                });
                                            };
                                            defmt::export::fmt(arg0);
                                            unsafe { defmt::export::release() }
                                        }
                                    }
                                };
                            }
                        }
                        Handled
                    }
                    _ => Handled,
                }
            }
            async fn enter_check_charging(&mut self) {
                ieee802154::send_now();
                set_obd2_sets(Obd2PidSets::Charging).await;
                self.tx_frame_pub
                    .publish_immediate(types::TxFrame::State(types::State::CheckCharging));
                embassy_time::Timer::after_secs(1).await;
            }
            async fn check_charging(
                &mut self,
                event: &KiaEvent,
                obc_pid: &mut Option<OnBoardChargerPid>,
                timeout: &Instant,
            ) -> Response<State> {
                match event {
                    KiaEvent::IgnitionOn => Transition(State::ignition_on()),
                    KiaEvent::Obd2Event(Obd2Event::OnBoardChargerPid(new_obc_pid)) => {
                        *obc_pid = Some(new_obc_pid.clone());
                        Handled
                    }
                    KiaEvent::Obd2LoopEnd(set, _all) => {
                        if let Some(obc_pid) = obc_pid {
                            if obc_pid.ac_input_current > 0.0 {
                                Transition(State::charging(None, 0))
                            } else {
                                if timeout.elapsed().as_secs() > 5 * 60 {
                                    Transition(State::ignition_off(
                                        Instant::now(),
                                        Duration::from_secs(60),
                                        false,
                                        false,
                                    ))
                                } else {
                                    Handled
                                }
                            }
                        } else {
                            if timeout.elapsed().as_secs() > 5 * 60 {
                                Transition(State::ignition_off(
                                    Instant::now(),
                                    Duration::from_secs(60),
                                    false,
                                    false,
                                ))
                            } else {
                                Handled
                            }
                        }
                    }
                    _ => Handled,
                }
            }
            async fn enter_charging(&mut self) {
                ieee802154::send_now();
                set_obd2_sets(Obd2PidSets::Charging).await;
                self.tx_frame_pub
                    .publish_immediate(types::TxFrame::State(types::State::Charging));
            }
            async fn charging(
                &mut self,
                event: &KiaEvent,
                obc_pid: &mut Option<OnBoardChargerPid>,
                obc_pid_wait: &mut u8,
            ) -> Response<State> {
                match event {
                    KiaEvent::Obd2Event(Obd2Event::OnBoardChargerPid(new_obc_pid)) => {
                        let ret = if new_obc_pid.ac_input_current == 0.0 {
                            match () {
                                () => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::state".as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        defmt::export::acquire_header_and_release(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"ac input current is zero\",\"disambiguator\":\"6201259165929820622\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"ac input current is zero\",\"disambiguator\":\"6201259165929820622\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    }
                                }
                            };
                            Transition(State::check_charging(None, Instant::now()))
                        } else {
                            Handled
                        };
                        *obc_pid = Some(new_obc_pid.clone());
                        ret
                    }
                    KiaEvent::IgnitionOn => Transition(State::ignition_on()),
                    KiaEvent::Obd2LoopEnd(set, _all) => {
                        if obc_pid.is_none() {
                            if *obc_pid_wait > 50 {
                                Transition(State::check_charging(None, Instant::now()))
                            } else {
                                *obc_pid_wait += 1;
                                Handled
                            }
                        } else {
                            *obc_pid = None;
                            Handled
                        }
                    }
                    _ => Handled,
                }
            }
            async fn enter_ignition_off(&mut self, shutdown_duration: &mut Duration) {
                ieee802154::send_now();
                LCD_EVENTS.send(LcdEvent::PowerOff).await;
                set_obd2_sets(Obd2PidSets::IgnitionOff).await;
                set_obd2_sets(Obd2PidSets::IgnitionOff).await;
                self.tx_frame_pub
                    .publish_immediate(types::TxFrame::State(types::State::IgnitionOff));
                let now = self.rtc.lock().await.current_time().and_utc().timestamp();
                let last_ignition_on = unsafe { LAST_IGNITION_ON };
                *shutdown_duration = if last_ignition_on != 0 && now - last_ignition_on > 60 * 60 {
                    Duration::from_secs(60 * 60)
                } else {
                    Duration::from_secs(15 * 60)
                };
                match (
                    &(shutdown_duration.as_secs() / 60),
                    &(last_ignition_on),
                    &(now),
                ) {
                    (arg0, arg1, arg2) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path =
                                        "kia_obd2_esp32c3_v2::tasks::state".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe {
                                defmt::export::acquire_and_header(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"shutdown duration: {}min: last_ignition_on:{}sec now: {}sec\",\"disambiguator\":\"18083601989447847235\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"shutdown duration: {}min: last_ignition_on:{}sec now: {}sec\",\"disambiguator\":\"18083601989447847235\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            };
                            defmt::export::fmt(arg0);
                            defmt::export::fmt(arg1);
                            defmt::export::fmt(arg2);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
            }
            async fn ignition_off(
                &mut self,
                event: &KiaEvent,
                timeout: &mut Instant,
                shutdown_duration: &mut Duration,
                got_any_timeout_reset: &mut bool,
                car_is_open: &mut bool,
            ) -> Response<State> {
                match event {
                    KiaEvent::IgnitionOffResetTimeout => {
                        *timeout = Instant::now();
                        *got_any_timeout_reset = true;
                        Handled
                    }
                    KiaEvent::Obd2Event(Obd2Event::Icu2Pid(icu2_pid)) => {
                        *car_is_open = icu2_pid.is_open();
                        Handled
                    }
                    KiaEvent::Obd2Event(Obd2Event::Icu3Pid(icu3_pid)) => {
                        if icu3_pid.on_board_charger_wakeup_output {
                            Transition(State::check_charging(None, Instant::now()))
                        } else {
                            Handled
                        }
                    }
                    KiaEvent::Obd2Event(Obd2Event::OnBoardChargerPid(obc_pid)) => {
                        if obc_pid.ac_input_current > 0.0 {
                            Transition(State::check_charging(None, Instant::now()))
                        } else {
                            Handled
                        }
                    }
                    KiaEvent::IgnitionOn => Transition(State::ignition_on()),
                    KiaEvent::Obd2LoopEnd(set, all) => {
                        let mut timeout_duration = if *car_is_open {
                            Duration::from_secs(30 * 60)
                        } else {
                            Duration::from_secs(2 * 60)
                        };
                        if *got_any_timeout_reset {
                            timeout_duration = Duration::from_secs(30 * 60);
                        }
                        if !all {
                            timeout_duration = Duration::from_secs(10 * 60);
                        }
                        if !self.obd2_init {
                            match () {
                                () => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::state".as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        defmt::export::acquire_header_and_release(&{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"obd2 not inited\",\"disambiguator\":\"1213401222476019384\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"obd2 not inited\",\"disambiguator\":\"1213401222476019384\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        });
                                    }
                                }
                            };
                            timeout_duration = Duration::from_secs(30 * 60);
                        }
                        if set != &Obd2PidSets::IgnitionOff {
                            set_obd2_sets(Obd2PidSets::IgnitionOff).await;
                        }
                        if timeout.elapsed() > timeout_duration {
                            Transition(State::shutdown(*shutdown_duration))
                        } else {
                            Handled
                        }
                    }
                    _ => {
                        if timeout.elapsed().as_secs() > 20 * 60 {
                            Transition(State::shutdown(*shutdown_duration))
                        } else {
                            Handled
                        }
                    }
                }
            }
            async fn enter_shutdown(&mut self, duration: &embassy_time::Duration) {
                match (&(duration)) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path =
                                        "kia_obd2_esp32c3_v2::tasks::state".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe {
                                defmt::export::acquire_and_header(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.warn.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"shutting down for {:?}\",\"disambiguator\":\"1564747876981365795\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_warn\",\"data\":\"shutting down for {:?}\",\"disambiguator\":\"1564747876981365795\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            };
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                ieee802154::send_now();
                self.tx_frame_pub
                    .publish_immediate(types::TxFrame::State(types::State::Shutdown(
                        (*duration).into(),
                    )));
                embassy_time::Timer::after_millis(200).await;
                self.power_events_pub
                    .publish_immediate(PowerEvent::Shutdown(*duration));
                ieee802154::send_now();
            }
            async fn shutdown(&mut self, duration: &Duration) -> Response<State> {
                Handled
            }
        }
        impl statig::awaitable::IntoStateMachine for KiaState {
            type Event<'event> = KiaEvent;
            type Context<'context> = ();
            type State = State;
            type Superstate<'sub> = Superstate;
            const INITIAL: State = State::init();
            const ON_TRANSITION: fn(&mut Self, &Self::State, &Self::State) = Self::on_transition;
            const ON_DISPATCH: fn(&mut Self, StateOrSuperstate<'_, '_, Self>, &Self::Event<'_>) =
                Self::on_dispatch;
        }
        pub enum State {
            IgnitionOn {},
            Shutdown {
                duration: Duration,
            },
            Init {},
            IgnitionOff {
                timeout: Instant,
                shutdown_duration: Duration,
                got_any_timeout_reset: bool,
                car_is_open: bool,
            },
            Charging {
                obc_pid: Option<OnBoardChargerPid>,
                obc_pid_wait: u8,
            },
            CheckCharging {
                obc_pid: Option<OnBoardChargerPid>,
                timeout: Instant,
            },
        }
        impl defmt::Format for State
        where
            Duration: defmt::Format,
            Instant: defmt::Format,
            Duration: defmt::Format,
            Option<OnBoardChargerPid>: defmt::Format,
            Instant: defmt::Format,
        {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::state".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"6833247907751727209\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"6833247907751727209\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"IgnitionOn|Shutdown {{ duration: {=?:?} }}|Init|IgnitionOff {{ timeout: {=?:?}, shutdown_duration: {=?:?}, got_any_timeout_reset: {=bool:?}, car_is_open: {=bool:?} }}|Charging {{ obc_pid: {=?:?}, obc_pid_wait: {=u8:?} }}|CheckCharging {{ obc_pid: {=?:?}, timeout: {=?:?} }}\",\"disambiguator\":\"17106348227848476817\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"IgnitionOn|Shutdown {{ duration: {=?:?} }}|Init|IgnitionOff {{ timeout: {=?:?}, shutdown_duration: {=?:?}, got_any_timeout_reset: {=bool:?}, car_is_open: {=bool:?} }}|Charging {{ obc_pid: {=?:?}, obc_pid_wait: {=u8:?} }}|CheckCharging {{ obc_pid: {=?:?}, timeout: {=?:?} }}\",\"disambiguator\":\"17106348227848476817\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    State::IgnitionOn {} => {
                        defmt::export::u8(&0u8);
                    }
                    State::Shutdown { duration } => {
                        defmt::export::u8(&1u8);
                        defmt::export::fmt(duration);
                    }
                    State::Init {} => {
                        defmt::export::u8(&2u8);
                    }
                    State::IgnitionOff {
                        timeout,
                        shutdown_duration,
                        got_any_timeout_reset,
                        car_is_open,
                    } => {
                        defmt::export::u8(&3u8);
                        defmt::export::fmt(timeout);
                        defmt::export::fmt(shutdown_duration);
                        defmt::export::bool(got_any_timeout_reset);
                        defmt::export::bool(car_is_open);
                    }
                    State::Charging {
                        obc_pid,
                        obc_pid_wait,
                    } => {
                        defmt::export::u8(&4u8);
                        defmt::export::fmt(obc_pid);
                        defmt::export::u8(obc_pid_wait);
                    }
                    State::CheckCharging { obc_pid, timeout } => {
                        defmt::export::u8(&5u8);
                        defmt::export::fmt(obc_pid);
                        defmt::export::fmt(timeout);
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for State {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    State::IgnitionOn {} => ::core::fmt::Formatter::write_str(f, "IgnitionOn"),
                    State::Shutdown { duration: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f, "Shutdown", "duration", &__self_0,
                        )
                    }
                    State::Init {} => ::core::fmt::Formatter::write_str(f, "Init"),
                    State::IgnitionOff {
                        timeout: __self_0,
                        shutdown_duration: __self_1,
                        got_any_timeout_reset: __self_2,
                        car_is_open: __self_3,
                    } => ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "IgnitionOff",
                        "timeout",
                        __self_0,
                        "shutdown_duration",
                        __self_1,
                        "got_any_timeout_reset",
                        __self_2,
                        "car_is_open",
                        &__self_3,
                    ),
                    State::Charging {
                        obc_pid: __self_0,
                        obc_pid_wait: __self_1,
                    } => ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Charging",
                        "obc_pid",
                        __self_0,
                        "obc_pid_wait",
                        &__self_1,
                    ),
                    State::CheckCharging {
                        obc_pid: __self_0,
                        timeout: __self_1,
                    } => ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "CheckCharging",
                        "obc_pid",
                        __self_0,
                        "timeout",
                        &__self_1,
                    ),
                }
            }
        }
        impl State {
            const fn ignition_on() -> Self {
                Self::IgnitionOn {}
            }
            const fn shutdown(duration: Duration) -> Self {
                Self::Shutdown { duration }
            }
            const fn init() -> Self {
                Self::Init {}
            }
            const fn ignition_off(
                timeout: Instant,
                shutdown_duration: Duration,
                got_any_timeout_reset: bool,
                car_is_open: bool,
            ) -> Self {
                Self::IgnitionOff {
                    timeout,
                    shutdown_duration,
                    got_any_timeout_reset,
                    car_is_open,
                }
            }
            const fn charging(obc_pid: Option<OnBoardChargerPid>, obc_pid_wait: u8) -> Self {
                Self::Charging {
                    obc_pid,
                    obc_pid_wait,
                }
            }
            const fn check_charging(obc_pid: Option<OnBoardChargerPid>, timeout: Instant) -> Self {
                Self::CheckCharging { obc_pid, timeout }
            }
        }
        #[allow(unused)]
        impl statig::awaitable::State<KiaState> for State {
            fn call_handler<'fut>(
                &'fut mut self,
                shared_storage: &'fut mut KiaState,
                event: &'fut <KiaState as statig::IntoStateMachine>::Event<'_>,
                context: &'fut mut <KiaState as statig::IntoStateMachine>::Context<'_>,
            ) -> core::pin::Pin<
                statig::Box<dyn core::future::Future<Output = statig::Response<Self>> + 'fut>,
            > {
                statig::Box::pin(async move {
                    match self {
                        State::IgnitionOn {} => KiaState::ignition_on(shared_storage, event).await,
                        State::Shutdown { duration } => {
                            KiaState::shutdown(shared_storage, duration).await
                        }
                        State::Init {} => KiaState::init(shared_storage, event).await,
                        State::IgnitionOff {
                            timeout,
                            shutdown_duration,
                            got_any_timeout_reset,
                            car_is_open,
                        } => {
                            KiaState::ignition_off(
                                shared_storage,
                                event,
                                timeout,
                                shutdown_duration,
                                got_any_timeout_reset,
                                car_is_open,
                            )
                            .await
                        }
                        State::Charging {
                            obc_pid,
                            obc_pid_wait,
                        } => KiaState::charging(shared_storage, event, obc_pid, obc_pid_wait).await,
                        State::CheckCharging { obc_pid, timeout } => {
                            KiaState::check_charging(shared_storage, event, obc_pid, timeout).await
                        }
                        _ => statig::Response::Super,
                    }
                })
            }
            fn call_entry_action<'fut>(
                &'fut mut self,
                shared_storage: &'fut mut KiaState,
                context: &'fut mut <KiaState as statig::IntoStateMachine>::Context<'_>,
            ) -> core::pin::Pin<statig::Box<dyn core::future::Future<Output = ()> + 'fut>>
            {
                statig::Box::pin(async move {
                    match self {
                        State::IgnitionOn {} => KiaState::enter_ignition_on(shared_storage).await,
                        State::Shutdown { duration } => {
                            KiaState::enter_shutdown(shared_storage, duration).await
                        }
                        State::Init {} => {}
                        State::IgnitionOff {
                            timeout,
                            shutdown_duration,
                            got_any_timeout_reset,
                            car_is_open,
                        } => KiaState::enter_ignition_off(shared_storage, shutdown_duration).await,
                        State::Charging {
                            obc_pid,
                            obc_pid_wait,
                        } => KiaState::enter_charging(shared_storage).await,
                        State::CheckCharging { obc_pid, timeout } => {
                            KiaState::enter_check_charging(shared_storage).await
                        }
                        _ => {}
                    }
                })
            }
            fn call_exit_action<'fut>(
                &'fut mut self,
                shared_storage: &'fut mut KiaState,
                context: &'fut mut <KiaState as statig::IntoStateMachine>::Context<'_>,
            ) -> core::pin::Pin<statig::Box<dyn core::future::Future<Output = ()> + 'fut>>
            {
                statig::Box::pin(async move {
                    match self {
                        State::IgnitionOn {} => {}
                        State::Shutdown { duration } => {}
                        State::Init {} => {}
                        State::IgnitionOff {
                            timeout,
                            shutdown_duration,
                            got_any_timeout_reset,
                            car_is_open,
                        } => {}
                        State::Charging {
                            obc_pid,
                            obc_pid_wait,
                        } => {}
                        State::CheckCharging { obc_pid, timeout } => {}
                        _ => {}
                    }
                })
            }
            fn superstate(
                &mut self,
            ) -> Option<<KiaState as statig::IntoStateMachine>::Superstate<'_>> {
                match self {
                    State::IgnitionOn {} => None,
                    State::Shutdown { duration } => None,
                    State::Init {} => None,
                    State::IgnitionOff {
                        timeout,
                        shutdown_duration,
                        got_any_timeout_reset,
                        car_is_open,
                    } => None,
                    State::Charging {
                        obc_pid,
                        obc_pid_wait,
                    } => None,
                    State::CheckCharging { obc_pid, timeout } => None,
                    _ => None,
                }
            }
        }
        pub enum Superstate {}
        impl defmt::Format for Superstate {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path =
                                            "kia_obd2_esp32c3_v2::tasks::state".as_bytes();
                                        if if 19usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 107u8
                                                && module_path[1usize] == 105u8
                                                && module_path[2usize] == 97u8
                                                && module_path[3usize] == 95u8
                                                && module_path[4usize] == 111u8
                                                && module_path[5usize] == 98u8
                                                && module_path[6usize] == 100u8
                                                && module_path[7usize] == 50u8
                                                && module_path[8usize] == 95u8
                                                && module_path[9usize] == 101u8
                                                && module_path[10usize] == 115u8
                                                && module_path[11usize] == 112u8
                                                && module_path[12usize] == 51u8
                                                && module_path[13usize] == 50u8
                                                && module_path[14usize] == 99u8
                                                && module_path[15usize] == 51u8
                                                && module_path[16usize] == 95u8
                                                && module_path[17usize] == 118u8
                                                && module_path[18usize] == 50u8
                                                && if 19usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[19usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                defmt::export::acquire_header_and_release(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"1341798317443735555\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"1341798317443735555\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"!\",\"disambiguator\":\"11278465174871194265\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_derived\",\"data\":\"!\",\"disambiguator\":\"11278465174871194265\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match *self {}
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Superstate {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {}
            }
        }
        #[allow(unused)]
        impl<'sub> statig::awaitable::Superstate<KiaState> for Superstate
        where
            Self: 'sub,
        {
            fn call_handler<'fut>(
                &'fut mut self,
                shared_storage: &'fut mut KiaState,
                event: &'fut <KiaState as statig::IntoStateMachine>::Event<'_>,
                context: &'fut mut <KiaState as statig::IntoStateMachine>::Context<'_>,
            ) -> core::pin::Pin<
                statig::Box<
                    dyn core::future::Future<
                            Output = statig::Response<
                                <KiaState as statig::IntoStateMachine>::State,
                            >,
                        > + 'fut,
                >,
            > {
                statig::Box::pin(async move {
                    match self {
                        _ => statig::Response::Super,
                    }
                })
            }
            fn call_entry_action<'fut>(
                &'fut mut self,
                shared_storage: &'fut mut KiaState,
                context: &'fut mut <KiaState as statig::IntoStateMachine>::Context<'_>,
            ) -> core::pin::Pin<statig::Box<dyn core::future::Future<Output = ()> + 'fut>>
            {
                statig::Box::pin(async move {
                    match self {
                        _ => {}
                    }
                })
            }
            fn call_exit_action<'fut>(
                &'fut mut self,
                shared_storage: &'fut mut KiaState,
                context: &'fut mut <KiaState as statig::IntoStateMachine>::Context<'_>,
            ) -> core::pin::Pin<statig::Box<dyn core::future::Future<Output = ()> + 'fut>>
            {
                statig::Box::pin(async move {
                    match self {
                        _ => {}
                    }
                })
            }
            fn superstate(
                &mut self,
            ) -> Option<<KiaState as statig::IntoStateMachine>::Superstate<'_>> {
                match self {
                    _ => None,
                }
            }
        }
        impl KiaState {
            fn on_transition(&mut self, source: &State, target: &State) {
                match (&(source), &(target)) {
                    (arg0, arg1) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path =
                                        "kia_obd2_esp32c3_v2::tasks::state".as_bytes();
                                    if if 19usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 107u8
                                            && module_path[1usize] == 105u8
                                            && module_path[2usize] == 97u8
                                            && module_path[3usize] == 95u8
                                            && module_path[4usize] == 111u8
                                            && module_path[5usize] == 98u8
                                            && module_path[6usize] == 100u8
                                            && module_path[7usize] == 50u8
                                            && module_path[8usize] == 95u8
                                            && module_path[9usize] == 101u8
                                            && module_path[10usize] == 115u8
                                            && module_path[11usize] == 112u8
                                            && module_path[12usize] == 51u8
                                            && module_path[13usize] == 50u8
                                            && module_path[14usize] == 99u8
                                            && module_path[15usize] == 51u8
                                            && module_path[16usize] == 95u8
                                            && module_path[17usize] == 118u8
                                            && module_path[18usize] == 50u8
                                            && if 19usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[19usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe {
                                defmt::export::acquire_and_header(&{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"kia transitioned from `{}` to `{}`\",\"disambiguator\":\"3062004094835346736\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"kia transitioned from `{}` to `{}`\",\"disambiguator\":\"3062004094835346736\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                });
                            };
                            defmt::export::fmt(arg0);
                            defmt::export::fmt(arg1);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
            }
            fn on_dispatch(&mut self, state: StateOrSuperstate<Self>, event: &KiaEvent) {
                self.power_events_pub
                    .publish_immediate(PowerEvent::RwdtFeed);
                if let KiaEvent::Obd2Event(_) = event {
                    match (&(event), &(defmt::Debug2Format(&state))) {
                        _ => {}
                    };
                } else if let &KiaEvent::Obd2Init(obd2_init) = event {
                    self.obd2_init = obd2_init;
                } else {
                    match event {
                        KiaEvent::Obd2Debug(_) | KiaEvent::Obd2LoopEnd(_, _) => {
                            match (&(event), &(defmt::Debug2Format(&state))) {
                                _ => {}
                            };
                        }
                        _ => {
                            match (&(event), &(defmt::Debug2Format(&state))) {
                                (arg0, arg1) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path =
                                                    "kia_obd2_esp32c3_v2::tasks::state".as_bytes();
                                                if if 19usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 107u8
                                                        && module_path[1usize] == 105u8
                                                        && module_path[2usize] == 97u8
                                                        && module_path[3usize] == 95u8
                                                        && module_path[4usize] == 111u8
                                                        && module_path[5usize] == 98u8
                                                        && module_path[6usize] == 100u8
                                                        && module_path[7usize] == 50u8
                                                        && module_path[8usize] == 95u8
                                                        && module_path[9usize] == 101u8
                                                        && module_path[10usize] == 115u8
                                                        && module_path[11usize] == 112u8
                                                        && module_path[12usize] == 51u8
                                                        && module_path[13usize] == 50u8
                                                        && module_path[14usize] == 99u8
                                                        && module_path[15usize] == 51u8
                                                        && module_path[16usize] == 95u8
                                                        && module_path[17usize] == 118u8
                                                        && module_path[18usize] == 50u8
                                                        && if 19usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[19usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe {
                                            defmt::export::acquire_and_header(&{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"kia dispatching `{}` to `{}`\",\"disambiguator\":\"4309257813243606479\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"kia dispatching `{}` to `{}`\",\"disambiguator\":\"4309257813243606479\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            });
                                        };
                                        defmt::export::fmt(arg0);
                                        defmt::export::fmt(arg1);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                        }
                    }
                }
            }
        }
        pub async fn run(rtc: crate::types::Rtc) {
            let mut state = KiaState {
                power_events_pub: get_power_events_pub(),
                tx_frame_pub: extra_txframes_pub(),
                rtc,
                obd2_init: false,
            }
            .uninitialized_state_machine()
            .init()
            .await;
            loop {
                match with_timeout(Duration::from_secs(5), EVENTS.receive()).await {
                    Ok(event) => {
                        state.handle(&event).await;
                    }
                    Err(_) => {
                        state.handle(&KiaEvent::Ticker).await;
                    }
                }
            }
        }
    }
    pub mod temperature {
        use core::sync::atomic::{AtomicI32, Ordering};
        use defmt::*;
        use embassy_time::{with_timeout, Duration};
        use embedded_io_async::Write as _;
        use heapless::Vec;
        static TEMPERATURE: AtomicI32 = AtomicI32::new(0);
        #[doc(hidden)]
        async fn __run_task(temperature: crate::types::TemperatureSensor) {
            loop {
                let temp = temperature.get_temperature().to_celsius();
                TEMPERATURE.store(temp as i32 * 1000, Ordering::Relaxed);
                embassy_time::Timer::after(Duration::from_secs(1)).await;
            }
        }
        pub fn run(
            temperature: crate::types::TemperatureSensor,
        ) -> ::embassy_executor::SpawnToken<impl Sized> {
            trait _EmbassyInternalTaskTrait {
                type Fut: ::core::future::Future + 'static;
                fn construct(temperature: crate::types::TemperatureSensor) -> Self::Fut;
            }
            impl _EmbassyInternalTaskTrait for () {
                type Fut = impl core::future::Future + 'static;
                fn construct(temperature: crate::types::TemperatureSensor) -> Self::Fut {
                    __run_task(temperature)
                }
            }
            const POOL_SIZE: usize = 1;
            static POOL: ::embassy_executor::raw::TaskPool<
                <() as _EmbassyInternalTaskTrait>::Fut,
                POOL_SIZE,
            > = ::embassy_executor::raw::TaskPool::new();
            unsafe {
                POOL._spawn_async_fn(move || {
                    <() as _EmbassyInternalTaskTrait>::construct(temperature)
                })
            }
        }
        pub fn get_temperature() -> f32 {
            TEMPERATURE.load(Ordering::Relaxed) as f32 / 1000.0
        }
    }
}
mod types {
    use embassy_embedded_hal::shared_bus::asynch::spi::SpiDeviceWithConfig;
    use embassy_sync::{blocking_mutex::raw::CriticalSectionRawMutex, mutex::Mutex};
    use esp_hal::{gpio::*, spi::AnySpi, Async};
    pub type Spi = Mutex<CriticalSectionRawMutex, esp_hal::spi::master::SpiDma<'static, Async>>;
    pub use crate::hal::SpiBus;
    pub type Mcp2515 = crate::mcp2515::Mcp2515<
        SpiDeviceWithConfig<'static, CriticalSectionRawMutex, SpiBus, Output<'static>>,
        Input<'static>,
    >;
    pub type Sh1122 = sh1122::AsyncDisplay<
        display_interface_spi::SPIInterface<
            SpiDeviceWithConfig<'static, CriticalSectionRawMutex, SpiBus, Output<'static>>,
            Output<'static>,
        >,
        sh1122::async_display::buffered_graphics::AsyncBufferedGraphicsMode,
    >;
    pub type Cap1188 = crate::cap1188::Cap1188<
        SpiDeviceWithConfig<'static, CriticalSectionRawMutex, SpiBus, Output<'static>>,
        Input<'static>,
    >;
    pub type UsbSerial = esp_hal::usb_serial_jtag::UsbSerialJtag<'static, esp_hal::Async>;
    pub type IngGpio = Input<'static>;
    pub type Display2 = Sh1122;
    pub type Display1 = Sh1122;
    pub type Led = Output<'static>;
    pub type Rs = Output<'static>;
    pub type Rtc = &'static Mutex<CriticalSectionRawMutex, esp_hal::rtc_cntl::Rtc<'static>>;
    pub type TemperatureSensor = esp_hal::tsens::TemperatureSensor<'static>;
}
fn init_heap() {
    const HEAP_SIZE: usize = 8 * 1024;
    static mut HEAP: MaybeUninit<[u8; HEAP_SIZE]> = MaybeUninit::uninit();
    unsafe {
        esp_alloc::HEAP.add_region(esp_alloc::HeapRegion::new(
            HEAP.as_mut_ptr() as *mut u8,
            HEAP_SIZE,
            esp_alloc::MemoryCapability::Internal.into(),
        ));
    }
}
#[doc(hidden)]
#[doc(hidden)]
async fn ____embassy_main_task(spawner: Spawner) {
    {
        match () {
            () => {
                if {
                    const CHECK: bool = {
                        const fn check() -> bool {
                            let module_path = "kia_obd2_esp32c3_v2".as_bytes();
                            if if 19usize > module_path.len() {
                                false
                            } else {
                                module_path[0usize] == 107u8
                                    && module_path[1usize] == 105u8
                                    && module_path[2usize] == 97u8
                                    && module_path[3usize] == 95u8
                                    && module_path[4usize] == 111u8
                                    && module_path[5usize] == 98u8
                                    && module_path[6usize] == 100u8
                                    && module_path[7usize] == 50u8
                                    && module_path[8usize] == 95u8
                                    && module_path[9usize] == 101u8
                                    && module_path[10usize] == 115u8
                                    && module_path[11usize] == 112u8
                                    && module_path[12usize] == 51u8
                                    && module_path[13usize] == 50u8
                                    && module_path[14usize] == 99u8
                                    && module_path[15usize] == 51u8
                                    && module_path[16usize] == 95u8
                                    && module_path[17usize] == 118u8
                                    && module_path[18usize] == 50u8
                                    && if 19usize == module_path.len() {
                                        true
                                    } else {
                                        module_path[19usize] == b':'
                                    }
                            } {
                                return true;
                            }
                            false
                        }
                        check()
                    };
                    CHECK
                } {
                    defmt::export::acquire_header_and_release(&{
                        defmt::export::make_istr({
                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"heap init\",\"disambiguator\":\"12692059259693759172\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"heap init\",\"disambiguator\":\"12692059259693759172\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                            static DEFMT_LOG_STATEMENT: u8 = 0;
                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                        })
                    });
                }
            }
        };
        init_heap();
        match () {
            () => {
                if {
                    const CHECK: bool = {
                        const fn check() -> bool {
                            let module_path = "kia_obd2_esp32c3_v2".as_bytes();
                            if if 19usize > module_path.len() {
                                false
                            } else {
                                module_path[0usize] == 107u8
                                    && module_path[1usize] == 105u8
                                    && module_path[2usize] == 97u8
                                    && module_path[3usize] == 95u8
                                    && module_path[4usize] == 111u8
                                    && module_path[5usize] == 98u8
                                    && module_path[6usize] == 100u8
                                    && module_path[7usize] == 50u8
                                    && module_path[8usize] == 95u8
                                    && module_path[9usize] == 101u8
                                    && module_path[10usize] == 115u8
                                    && module_path[11usize] == 112u8
                                    && module_path[12usize] == 51u8
                                    && module_path[13usize] == 50u8
                                    && module_path[14usize] == 99u8
                                    && module_path[15usize] == 51u8
                                    && module_path[16usize] == 95u8
                                    && module_path[17usize] == 118u8
                                    && module_path[18usize] == 50u8
                                    && if 19usize == module_path.len() {
                                        true
                                    } else {
                                        module_path[19usize] == b':'
                                    }
                            } {
                                return true;
                            }
                            false
                        }
                        check()
                    };
                    CHECK
                } {
                    defmt::export::acquire_header_and_release(&{
                        defmt::export::make_istr({
                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"hal init\",\"disambiguator\":\"3853871411560054160\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"hal init\",\"disambiguator\":\"3853871411560054160\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                            static DEFMT_LOG_STATEMENT: u8 = 0;
                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                        })
                    });
                }
            }
        };
        let mut hal = hal::init();
        let panic = get_panic_message_utf8();
        if let Some(msg) = panic {
            match (&(msg)) {
                (arg0) => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "kia_obd2_esp32c3_v2".as_bytes();
                                if if 19usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 107u8
                                        && module_path[1usize] == 105u8
                                        && module_path[2usize] == 97u8
                                        && module_path[3usize] == 95u8
                                        && module_path[4usize] == 111u8
                                        && module_path[5usize] == 98u8
                                        && module_path[6usize] == 100u8
                                        && module_path[7usize] == 50u8
                                        && module_path[8usize] == 95u8
                                        && module_path[9usize] == 101u8
                                        && module_path[10usize] == 115u8
                                        && module_path[11usize] == 112u8
                                        && module_path[12usize] == 51u8
                                        && module_path[13usize] == 50u8
                                        && module_path[14usize] == 99u8
                                        && module_path[15usize] == 51u8
                                        && module_path[16usize] == 95u8
                                        && module_path[17usize] == 118u8
                                        && module_path[18usize] == 50u8
                                        && if 19usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[19usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe {
                            defmt::export::acquire_and_header(&{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.error.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"Panic: {:?}\",\"disambiguator\":\"10606493372604871803\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_error\",\"data\":\"Panic: {:?}\",\"disambiguator\":\"10606493372604871803\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            });
                        };
                        defmt::export::fmt(arg0);
                        unsafe { defmt::export::release() }
                    }
                }
            };
            embassy_time::Timer::after(embassy_time::Duration::from_secs(1)).await;
        }
        embassy_time::Timer::after(embassy_time::Duration::from_secs(1)).await;
        match () {
            () => {
                if {
                    const CHECK: bool = {
                        const fn check() -> bool {
                            let module_path = "kia_obd2_esp32c3_v2".as_bytes();
                            if if 19usize > module_path.len() {
                                false
                            } else {
                                module_path[0usize] == 107u8
                                    && module_path[1usize] == 105u8
                                    && module_path[2usize] == 97u8
                                    && module_path[3usize] == 95u8
                                    && module_path[4usize] == 111u8
                                    && module_path[5usize] == 98u8
                                    && module_path[6usize] == 100u8
                                    && module_path[7usize] == 50u8
                                    && module_path[8usize] == 95u8
                                    && module_path[9usize] == 101u8
                                    && module_path[10usize] == 115u8
                                    && module_path[11usize] == 112u8
                                    && module_path[12usize] == 51u8
                                    && module_path[13usize] == 50u8
                                    && module_path[14usize] == 99u8
                                    && module_path[15usize] == 51u8
                                    && module_path[16usize] == 95u8
                                    && module_path[17usize] == 118u8
                                    && module_path[18usize] == 50u8
                                    && if 19usize == module_path.len() {
                                        true
                                    } else {
                                        module_path[19usize] == b':'
                                    }
                            } {
                                return true;
                            }
                            false
                        }
                        check()
                    };
                    CHECK
                } {
                    defmt::export::acquire_header_and_release(&{
                        defmt::export::make_istr({
                            #[link_section = ".defmt.info.{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"init\",\"disambiguator\":\"11363294709415244746\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                            #[export_name = "{\"package\":\"kia_obd2_esp32c3_v2\",\"tag\":\"defmt_info\",\"data\":\"init\",\"disambiguator\":\"11363294709415244746\",\"crate_name\":\"kia_obd2_esp32c3_v2\"}"]
                            static DEFMT_LOG_STATEMENT: u8 = 0;
                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                        })
                    });
                }
            }
        };
        hal.led.set_low();
        spawner.spawn(tasks::temperature::run(hal.temperature)).ok();
        spawner
            .spawn(tasks::lcd::run(hal.display1, hal.display2, panic))
            .ok();
        spawner.spawn(tasks::led::run(hal.led)).ok();
        spawner.spawn(tasks::buttons::run(hal.buttons)).ok();
        spawner.spawn(tasks::obd2::run(hal.obd2)).ok();
        spawner.spawn(tasks::can_listen::run(hal.can_listen)).ok();
        spawner.spawn(tasks::power::run(hal.power)).ok();
        spawner
            .spawn(tasks::ieee802154::run(hal.ieee802154, spawner))
            .ok();
        tasks::state::run(hal.rtc).await;
    }
}
#[doc(hidden)]
fn __embassy_main(spawner: Spawner) -> ::embassy_executor::SpawnToken<impl Sized> {
    trait _EmbassyInternalTaskTrait {
        type Fut: ::core::future::Future + 'static;
        fn construct(spawner: Spawner) -> Self::Fut;
    }
    impl _EmbassyInternalTaskTrait for () {
        type Fut = impl core::future::Future + 'static;
        fn construct(spawner: Spawner) -> Self::Fut {
            ____embassy_main_task(spawner)
        }
    }
    const POOL_SIZE: usize = 1;
    static POOL: ::embassy_executor::raw::TaskPool<
        <() as _EmbassyInternalTaskTrait>::Fut,
        POOL_SIZE,
    > = ::embassy_executor::raw::TaskPool::new();
    unsafe { POOL._spawn_async_fn(move || <() as _EmbassyInternalTaskTrait>::construct(spawner)) }
}
#[doc(hidden)]
unsafe fn __make_static<T>(t: &mut T) -> &'static mut T {
    ::core::mem::transmute(t)
}
#[allow(non_snake_case)]
#[export_name = "main"]
pub fn __risc_v_rt__main() -> ! {
    let mut executor = ::esp_hal_embassy::Executor::new();
    let executor = unsafe { __make_static(&mut executor) };
    executor.run(|spawner| {
        spawner.must_spawn(__embassy_main(spawner));
    })
}
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    riscv::interrupt::machine::disable();
    panic_persist::report_panic_info(info);
    unsafe { riscv::interrupt::machine::enable() };
    esp_hal::reset::software_reset();
    loop {}
}
#[no_mangle]
pub extern "Rust" fn custom_halt() -> ! {
    esp_hal::reset::software_reset();
    riscv::interrupt::machine::disable();
    loop {}
}
